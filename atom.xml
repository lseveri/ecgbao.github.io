<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>跳跳魔王的博客</title>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-22T01:08:31.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>跳跳魔王</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Using Swift with Cocoa and Objective-C (Swift 3.0.1)</title>
    <link href="http://yoursite.com/2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/"/>
    <id>http://yoursite.com/2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/</id>
    <published>2017-01-13T05:29:42.000Z</published>
    <updated>2017-01-22T01:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本构建"><a href="#基本构建" class="headerlink" title="基本构建"></a>基本构建</h1><p>Swift 被设计成可以与 Cocoa 和 Objective-C无缝兼容。你可以在 Swift 中使用 Objective-C APIs, 也可以在 Objective-C 中使用Swift APIs. 这让 Swift 可以方便容易的移植到你的开发流程里。</p>
<p>这个教程覆盖了 Swift 和 Objective-C 兼容性的三个主要方面, 你在开发Coca 应用时可以使用:</p>
<ul><br><li><em>互用性</em>: 让 Swift 和 Objective-C 的代码互动, 允许你在 Objective-C 中使用 Swift 的类。在写 Swift 代码时可以采用熟悉的 Cocoa 类, 模式, 和实践。</li><br><li><em>混合匹配</em>: 允许你创建包括 Swift 和 Objective-C 文件的混合语言的应用。</li><br><li><em>移植</em>: 从 Objective-C 代码到 Swift 很容易, 用最新的 Swift 特性替换你的 Objective-C 应用的部分代码成为可能。</li><br></ul>

<p>在你开始学习这些新特性之前, 你需要了解怎么建立一个 Swift 环境, 这个环境里你可以访问 Cocoa 系统框架。</p>
<h1 id="建立你的-Swift-环境"><a href="#建立你的-Swift-环境" class="headerlink" title="建立你的 Swift 环境"></a>建立你的 Swift 环境</h1><p>开始尝试用 Swift 开发 Cocoa 应用, 从Xcode提供的模板创建一个新的 Swift.</p>
<p class="para"><br>  <strong>在Xcode中创建一个 Swift 工程</strong><br></p><br><li>选择 File &gt; New &gt; Project &gt; (iOS, watchOS, tvOS, <em>或者</em> macOS) &gt; Application &gt; <em>你选择模板</em>。</li><br><li>点击 Language 弹出菜单选择 Swift.</li><br><br> <img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png" alt="" width="680" height="485"><br><br>一个 Swift 工程的结构和 Objective-C 工程的结构基本一样, 一个重要的区别是: Swift 没有头文件。在实现和接口之间, 没有显式的描述—所有关于类,函数,或者常量的信息都在一个单独的 .swift 文件里。<br><br>这里, 你现在可以开始在应用代理中写 Swift 代码,或者通过File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, or macOS) &gt; Source &gt; Swift 创建新的 Swift 源文件。<br><br># 要求<br>使用 Swift 3.0 创建应用要求 Xcode 8.0 或以上, 下面是基本SDK要求:<br><img src="http://a1.qpic.cn/psb?/V13UfvND3TZFZo/9jHnlruMgcZ3mMDBe1nUle9hmi4KluzHwU2gd8AKnLM!/b/dN4AAAAAAAAA&bo=qwKeAAAAAAADBxU!&rf=viewer_4" alt="" width="600" height="150"><br><br>Swift 编译器和 Xcode 要求部署目标最低是 iOS 7 或者 macOS 10.9. 设置更早的部署目标会导致构建失败。<br><p class="aside-title">备注<br>    </p><br>        <p class="para">命令行的可执行文件要在它们  <code class="code-voice">@rpath</code>下找到Swift库。 如果你打算用命令行输出一个 Swift 可执行文件, 你也要输送 Swift 动态库。来自Xcode 的 Swift 可执行文件有运行静态连接。<br>        </p><br># 了解 Swift 导入过程<br>建立好 Xcode 工程后, 你可以导入任意 Cocoa 或者 Cocoa Touch 的框架,然后在 Swift 中使用 Objective-C.<br><br>任何 Objective-C 框架或者 C 库支持的模块都可以导入 Swift. 这包括所有的 Objective-C 系统框架—例如 Foundation, UIKit, 和 SpriteKit—同样,一般 C 库也是支持的。例如, 为了使用 Foundation APIs, 在文件最上面添加下面的导入语句:<br> <pre><code><br>      <code> import Foundation </code><br> </code></pre><br><br>有了这个导入语句, 现在 Swift 文件可以访问所有的 Foundation 类,协议,方法,属性和常量。<br><br>导入过程很直接。 Objective-C 框架在头文件提供 APIs. 在 Swift 里, 这些头文件被编译成 Objective-C 模块, 它们被导入 Swift 作为 Swift APIs. 这个导入过程决定了 Objective-C 中声明的函数,类,方法和类型在 Swift中以什么样的代码显示。对于函数和方法来说, 这个过程影响它们的参数类型和返回值。对于类型来说, 导入过程有下面的影响:<br><br><li>重映射某种 Objective-C 类型到 Swift 中的同等类型, 例如 <code class="code-voice">id</code> to <code class="code-voice">Any</code></li><br><li>重映射某种 Objective-C 内置类型到 Swift 中的替代类型, 例如 <code class="code-voice">NSString</code> to <code class="code-voice">String</code></li><br><li>重映射某种 Objective-C 概念去匹配 Swift 中的概念, 例如指针变成可选项。</li><br><br><br><aside class="aside"><br>    <p class="aside-title">备注<br>    </p><br>        <p class="para">你不能向 Swift 直接导入 C++ 代码。替代方式是, 创建一个 Objective-C 或者 C 包装器。<br>        </p><br>  </aside><br>向Objective-C 中导入 Swift 和 向 Swift 中导入 Objective-C 很像。 Swift 提供它的 APIs—例如从一个框架—作为 Swift 模块。与这些 Swift 模块产生 Objective-C 头文件。这些头文件提供可以映射回Objective-C的 APIs. 有些 Swift APIs 不能映射回 Objective-C ,它们语言特性不适合 Objective-C.<br><br># 跟 Objective-C APIs 交互<br><br>互用性是指在 Swift 和 Objective-C 两个方向的能力, 让你在一种语言里访问和使用另外一种语言。当你把 Swift 迁移到你的开发流程时, 要先理解怎么利用互用性来重定义,改进写 Cocoa 应用的方法。<br><br>互用性一个重要部分是, 让你在写 Swift 代码时可以使用 Objective-C APIs. 在导入一个 Objective-C 框架后, 你可以用它来实例化类,然后用原生 Swift 语法与之交互。<br><br># 初始化<br>为了在Swift中实例化一个 Objective-C 类, 你可以调用一个 Swift 语法的构造器。<br><br>Objective-C 构造器以 init, 或者 initWith 开始: 如果构造器有一个或者更多的参数。当一个 Objective-C 构造器被 Swift 导入时, init 前缀变成一个 init 关键字,来表明这个方法是一个 Swift 构造器。如果这个构造器有一个参数, With 会被删除, 剩余部分会相应划分成命名参数。<br><br>看一下下面的 Objective-C 构造器声明:<br><pre><code><br>- (instancetype)init;<br>- (instancetype)initWithFrame:(CGRect)frame<br>                        style:(UITableViewStyle)style;<br></code></pre><br>下面是等价的 Swift 构造器声明:<br><pre><code><br>init() { /<em> … </em>/ }<br>init(frame: CGRect, style: UITableViewStyle) { /<em> … </em>/ }<br></code></pre><br>Objective-C 和 Swift 语法的不同之处是所有实例化对象更明显。<br><br>在 Objective-C 中, 你会这么做:<br><pre><code><br>UITableView <em>myTableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];<br></em></code></pre><br>在 Swift, 你可以这么做:<br><pre><code><br>let myTableView: UITableView = UITableView(frame: CGRectZero, style: .Grouped)<br></code></pre><br>你无需调用 alloc; Swift 替你处理了。同时可以看到, “init” 也没有出现。<br><br>在赋值给一个常量或者变量的时候,你可以指定一个显式的类型, 或者你可以忽略这个类型, 让 Swift 自己从构造器推断。<br><pre><code><br>let myTextField = UITextField(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 40.0))<br></code></pre><br>这些 UITableView 和 UITextField 你在 Objective-C 构造的对象, 在这里都是一样的。你可以像在 Objective-C 中一样使用它们, 访问各自类型中定义的属性和方法。<br><br># 类工厂方法和便利构造器<br>考虑到一致性和简单性, Objective-C 类工厂方法在 Swift 中会作为便利构造器使用。这让它们可以像构造器一样使用。<br><br>例如, 你在 Objective-C 中这样调用工厂方法:<br><pre><code><br>UIColor color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];<br></code></pre><br>而在 Swift 中, 可以这样调用:<br><pre><code><br>let color = UIColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0)<br></code></pre><br># 可失败的构造<br>在 Objective-C 中, 构造器直接返回它们构造的对象。为了告诉调用者构造失败, Objective-C 构造器会返回 nil. 在 Swift 中, 这个模式被构建成一个语言特性,叫可失败的构造。<br><br>许多系统框架的 Objective-C 构造器可以表示构造是否失败。你可以用nullability 注释表明这些构造器能否失败, 它们在 Nullability and Optionals 中描述。它们或者被导入成 init(…)—构造不会失败—或者 init?(…)—构造可以失败。因此, Objective-C 构造器被导入成 init!(…).<br><br>例如, 如果所提供的路径不存在一张图片的话, the UIImage(contentsOfFile:) 构造器就会失败。如果构造成功, 你可以用可选绑定来拆包一个可失败构造器的结果。<br><br><pre><code><br>if let image = UIImage(contentsOfFile: “MyImage.png”) {<br>    // loaded the image successfully<br>} else {<br>    // could not load the image<br>}<br></code></pre><br># 访问属性<br>用 @property语法声明的 Objective-C 属性用以下方式导入 Swift:<br><ul><br><li>带有非空属性的属性 (<code>nonnull</code>, <code>nullable</code>, 和 <code>null_resettable</code>) 以可选或者非可选类型导入 Swift, 它们在 Nullability and Optionals 中描述。</li><br><li>带有 <code>readonly</code> 的属性导入 Swift ,作为计算属性,有一个 getter ({ <code>get</code> }).</li><br><li>带有 <code>weak</code> 的属性导入 Swift,用 <code>weak</code> 关键字标记 (<code>weak var</code>).</li><br><li>带有自由属性的属性,而不是 <code>weak</code> (意思是, <code>assign</code>, <code>copy</code>, <code>strong</code>, 或者 <code>unsafe_unretained</code>) 以适当的存储属性导入 Swift.</li><br><li>带有 <code>class</code> 的属性作为类型属性导入 Swift.</li><br><li>原子属性 (<code>atomic</code> 和 <code>nonatomic</code>) 没有对应的 Swift 属性声明, 不过在Swift访问这些导入属性时, Objective-C 实现的原子性会保留。</li><br><li>访问器属性 (<code>getter=</code> 和 <code>setter=</code>) 在 Swift 中忽略。</li><br></ul><br><br>在 Swift 中访问 Objective-C 对象属性使用点语法, 使用属性名不带括号。<br><br>例如, 你可以用下面的代码设置一个 UITextField  对象的textColor 和 text 属性:<br><pre><code><br>myTextField.textColor = UIColor.darkGray<br>myTextField.text = “Hello world”<br></code></pre><br>返回一个值并且不带参数的 Objective-C 方法可以像 Objective-C 属性那样用点语法调用。不过, 它们导入 Swift 会变成实例方法, 因为只有 Objective-C @property 声明的会作为属性导入 Swift. 方法的导入和调用在 Working with Methods（使用方法） 中描述。<br><br># 使用方法<br>通过点语法在 Swift 中调用 Objective-C 方法。<br><br>当 Objective-C 方法导入 Swift 时, Objective-C 选择器的第一部分成为方法名,并且出现在括号前。第一个参数直接出现在括号内, 没有名字。选择器的剩余部分对应参数名,出现在括号内。所有选择器部分要求在调用位置。<br><br>例如, 鉴于在 Objective-C 中你这样做:<br><pre><code><br>[myTableView insertSubview:mySubview atIndex:2];<br></code></pre><br>在 Swift 中, 你可以这样做:<br><pre><code><br>myTableView.insertSubview(mySubview, at: 2)<br></code></pre><br>如果你调用无参数的方法, 你仍然需要带上括号。<br><pre><code><br>myTableView.layoutIfNeeded()<br></code></pre><br># id 兼容性<br>Objective-C 的 id 类型作为 Any 类型导入 Swift。 在编译和运行期, 当一个 Swift 值或者对象作为 id 参数传给Objective-C 时, 编译器会引入一个通用的桥接转换操作。当 id 值作为 Any 类型导入 Swift, 运行期自动处理桥接到类引用或者 Swift 值类型。<br><pre><code><br>var x: Any = “hello” as String<br>x as? String   // String with value “hello”<br>x as? NSString // NSString with value “hello”<br><br>x = “goodbye” as NSString<br>x as? String   // String with value “goodbye”<br>x as? NSString // NSString with value “goodbye”<br></code></pre><br><br># 向下转换 Any<br>当使用Any类型的对象时, 这里潜在的类型可以知道或者有理由确定, 通常把这些对象向下转换成更具体的类型。不过, 由于 Any 类型可以引用任意类型, 向下转换不能保证一定成功。<br><br>你可以使用条件类型转换运算符 (as?), 它可以返回一个你想转换类型的的可选值:<br><pre><code><br>let userDefaults = UserDefaults.standard<br>let lastRefreshDate = userDefaults.object(forKey: “LastRefreshDate”) // lastRefreshDate is of type Any?<br>if let date = lastRefreshDate as? Date {<br>    print(“(date.timeIntervalSinceReferenceDate)”)<br>}<br></code></pre><br>如果你确定对象的类型, 你可以用强制转换运算符 (as!).<br><pre><code><br>let myDate = lastRefreshDate as! Date<br>let timeInterval = myDate.timeIntervalSinceReferenceDate<br></code></pre><br>不过, 如果强制转换失败了, 会触发一个运行时的错误:<br><pre><code><br>let myDate = lastRefreshDate as! String // Error<br></code></pre><br><br># 动态方法查找<br>Swift 也有一个 <code>AnyObject</code> 类型, 它代表某种类型的对象,这个对象拥有动态查找任意 <code>@objc</code> 方法的能力。 这样你就可以写出灵活的无类型访问 Objective-C APIs, 这些APIs 返回 id 值。<br><br>例如, 你可以把任意类类型的对象赋值给一个 <code>AnyObject</code> 类型的常量或者变量, 再把一个变量赋值给一个不同类型的变量。你也可以调用任意 Objective-C 方法, 访问一个 <code>AnyObject</code> 值的一个属性,而不用转换成更具体的类类型。<br><pre><code><br>var myObject: AnyObject = UITableViewCell()<br>myObject = NSDate()<br>let futureDate = myObject.addingTimeInterval(10)<br>let timeSinceNow = myObject.timeIntervalSinceNow<br></code></pre><br><br># 无法辨识的选择器和可选链<br>因为一个 <code>AnyObject</code> 的具体值直到运行时才知晓, 因此可能无意中写出不安全的代码。在 Swift 中,同 Objective-C 一样, 尝试调用一个不存在的方法, 也会触发一个无法辨识的选择器的错误。<br><br>例如, 下面的代码没有编译警告, 但是会触发运行时错误:<br><pre><code><br>myObject.character(at: 5)<br>// crash, myObject doesn’t respond to that method<br></code></pre><br>Swift 使用可选项来防范这种不安全的行为。当你在 AnyObject 类型值上调用方法的时候, 这个方法的调用行为就像是一个隐式拆包可选项。 你可以使用相同的可选链接语法, 你会在协议中的可选方法里使用, 调用 <code>AnyObject</code> 的方法。<br><br>例如, 下面的代码, 第一行和第二行代码不会执行, 因为 <code>count</code> 熟悉和 <code>character(at:)</code> 方法在 <code>NSDate</code> 对象中不存在。<code>myCount</code> 常量可以推断出是一个可选的整型, 并且值为 <code>nil</code>. 你也可以使用 <code>if–let</code> 语句去有条件拆包一个方法的结果, 这个方法对象可能不会响应, 下面三行显示。<br><pre><code><br>// myObject has AnyObject type and NSDate value<br>let myCount = myObject.count<br>// myCount has Int? type and nil value<br>let myChar = myObject.character?(at: 5)<br>// myChar has unichar? type and nil value<br>if let fifthCharacter = myObject.character?(at: 5) {<br>    print(“Found (fifthCharacter) at index 5”)<br>}<br>// 条件分支没有执行<br></code></pre><br>备注<br><br>尽管,在调用 <code>AnyObject</code> 类型的方法时, Swift 没有要求强制拆包, 它可以作为一个防范非预期行为的手段。<br># 为空性和可选项<br>在 Objective-C 里面, 使用原始指针调用对象有可能是 <code>NULL</code> (在 Objective-C 中是<code>nil</code>). 在 Swift 中, 所有的值—包括结构体和对象引用—都是保证非空的。表达一个值可以缺失的方法是, 把这个值的类型包进一个可选项类型。当你需要表示这个值缺失的时候, 你可以使用<code>nil</code>.<br><br>Objective-C 可以用为空性注释来指定一个参数类型, 属性类型, 或者返回值, 是一个 <code>NULL</code> 或者 <code>nil</code> 值。单个类型声明可以使用 <code>_Nullable</code> 和 <code>_Nonnull</code> 注释, 单个属性声明可以用 <code>nullable</code>, <code>nonnull</code> 和 <code>null_resettable</code>, 或者整个区域都可以用 <code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code> 宏标记为空性。如果一个类型没有提供为空性, Swift 无法区分可选项和非可选项的引用, 然后会以一个隐式拆包可选项来导入。<br><br><ul><br><li>类型声明成可以为空, 或者用一个 <code>_Nonnull</code> 注释或者在一个授权区域, 作为一个非可选项导入 Swift.</li><br><li>使用一个 <code>_Nullable</code> 注释声明类型成可以为空, 作为一个可选项导入 Swift.</li><br><li>没有为空性注释的类型,作为一个隐式拆包可选项导入 Swift.</li><br></ul><br><br>例如, 下面的 Objective-C 声明:<br><pre><code><br>@property (nullable) id nullableProperty;<br>@property (nonnull) id nonNullProperty;<br>@property id unannotatedProperty;<br>NS_ASSUME_NONNULL_BEGIN<br>- (id)returnsNonNullValue;<br>- (void)takesNonNullParameter:(id)value;<br>NS_ASSUME_NONNULL_END<br>- (nullable id)returnsNullableValue;<br>- (void)takesNullableParameter:(nullable id)value;<br>- (id)returnsUnannotatedValue;<br>- (void)takesUnannotatedParameter:(id)value;<br></code></pre><br><br>这里是导入 Swift后的样子:<br><pre><code><br>var nullableProperty: Any?<br>var nonNullProperty: Any<br>var unannotatedProperty: Any!<br>func returnsNonNullValue() -&gt; Any<br>func takesNonNullParameter(value: Any)<br>func returnsNullableValue() -&gt; Any?<br>func takesNullableParameter(value: Any?)<br>func returnsUnannotatedValue() -&gt; Any!<br>func takesUnannotatedParameter(value: Any!)<br></code></pre><br>大多数的 Objective-C 系统框架, 包括 Foundation, 已经提供了为空性的注释, 允许你以一个惯用和类型安全的方式使用值。<br><br># 非空对象的桥接可选项<br>Swift 向非空 Objective-C 对象的桥接可选值, 根据可选项是否包含一个潜在值来决定。如果可选项为 nil, Swift 把这个nil值桥接成NSNull 实例。因此, Swift 用拆包值来桥接可选项。<br><br>下面的代码展示了 String? 实例怎么怎么根据它们的值桥接到 Objective-C.<br><pre><code><br>@implementation OptionalBridging<br>+ (void)logSomeValue:(nonnull id)valueFromSwift {<br>    if ([valueFromSwift isKindOfClass: [NSNull class]]) {<br>        os_log(OS_LOG_DEFAULT, “Received an NSNull value.”);<br>    } else {<br>        os_log(OS_LOG<em>DEFAULT, “%s”, [valueFromSwift UTF8String]);<br>    }<br>}<br>@end<br></em></code></pre><br>因为 valueFromSwift 参数类型是 id, 它导入 Swift 会作为 Any类型。不过, 因为在 Any 不常用时, 传入一个可选项。传入 logSomeValue(:) 类方法的可选项显式转换为 Any 类型, 这个会去掉编译器的警告。<br><pre><code><br>let someValue: String? = “Bridge me, please.”<br>let nilValue: String? = nil<br>OptionalBridging.logSomeValue(someValue as Any)  // Bridge me, please.<br>OptionalBridging.logSomeValue(nilValue as Any)   // Received an NSNull value.<br></code></pre><br># 协议资格的类<br>Objective-C 的协议资格的类作为类型值导入 Swift. 例如, 给出下面的 Objective-C 方法,在一个特定类执行一个操作:<br><pre><code><br>- (void)doSomethingForClass:(Class\<nscoding>)codingClass;<br></nscoding></code></pre><br>这里是 Swift 怎么导入它:<br><pre><code><br>func doSomething(for codingClass: NSCoding.Type)<br></code></pre><br><br># 轻量级泛型<br>使用轻量级泛型参数化的 Objective-C 类型,带有保留内容类型的信息导入 Swift. 例如, 下面的 Objective-C 属性声明:<br><pre><code><br>@property NSArray\<nsdate *=""> <em>dates;<br>@property NSCache\&lt;NSObject </em>, id\<nsdiscardablecontent>&gt; <em>cachedData;<br>@property NSDictionary \&lt;NSString </em>, NSArray\<nslocale *="">&gt; <em>supportedLocales;<br></em></nslocale></nsdiscardablecontent></nsdate></code></pre><br>导入 Swift 后:<br><pre><code><br>var dates: [Date]<br>var cachedData: NSCache<anyobject, nsdiscardablecontent=""><br>var supportedLocales: [String: [Locale]]<br></anyobject,></code></pre><br>用 Objective-C 写的参数化的类, 作为一个带有相同数量类型参数的泛型类导入 Swift. 所有 Swift导入后的 Objective-C 泛型参数都有一个类型限制, 要求这个类型是一个 class (T: Any). 如果 Objective-C 泛型参数化指定了一个类的资质, 那么导入到 Swift 类有一个限制, 那就是要求这个类型是这个指定类的子类。 如果 Objective-C 泛型参数化指定了一个协议资质, 那么导入到 Swift 的类有一个限制, 那就是要求这个类型符合这个协议。对于一个未指定的 Objective-C 类型, Swift 为导入的类类型限制推断泛型参数。例如, 下面给出的 Objective-C 类和分类声明:<br><pre><code><br>@interface List\<t: id\<nscopying="">&gt; : NSObject<br>- (List\<t> )listByAppendingItemsInList:(List\<t> <em>)otherList;<br>@end<br>@interface ListContainer : NSObject<br>- (List\&lt;NSValue </em>&gt; <em>)listOfValues;<br>@end<br>@interface ListContainer (ObjectList)<br>- (List </em>)listOfObjects;<br>@end<br></t></t></t:></code></pre><br>下面的导入 Swift后的:<br><pre><code><br>class List\<t: nscopying=""> : NSObject {<br>    func listByAppendingItemsInList(otherList: List\<t>) -&gt; List\<t><br>}<br>class ListContainer : NSObject {<br>    func listOfValues() -&gt; List\<nsvalue><br>}<br>extension ListContainer {<br>    func listOfObjects() -&gt; List\<nscopying><br>}<br></nscopying></nsvalue></t></t></t:></code></pre><br><br># 扩展<br>Swift 的扩展和 Objective-C 的分类很像。扩展是增加现有类,结构体和枚举的行为, Objective-C 也包括这些。你可以给系统框架类型或者自定义类型定义扩展。简单导入对应模块, 然后像在 Objective-C 中一样, 用相同的名字调用类,结构体和枚举。<br><br>例如, 你可以扩展 UIBezierPath 类, 基于一个提供的边长和起始点, 然后用等边三角形创建一个贝塞尔路径。<br><pre><code><br>extension UIBezierPath {<br>    convenience init(triangleSideLength: CGFloat, origin: CGPoint) {<br>        self.init()<br>        let squareRoot = CGFloat(sqrt(3.0))<br>        let altitude = (squareRoot <em> triangleSideLength) / 2<br>        move(to: origin)<br>        addLine(to: CGPoint(x: origin.x + triangleSideLength, y: origin.y))<br>        addLine(to: CGPoint(x: origin.x + triangleSideLength / 2, y: origin.y + altitude))<br>        close()<br>    }<br>}<br></em></code></pre><br>你可以用扩展添加属性 (包括类和静态属性)。不过, 这些属性必须可以计算; 扩展不能给类,结构体或者枚举添加存储属性。<br><br>下面的例子给 CGRect 扩展了一个 area 计算属性:<br><pre><code><br>extension CGRect {<br>    var area: CGFloat {<br>        return width  height<br>    }<br>}<br>let rect = CGRect(x: 0.0, y: 0.0, width: 10.0, height: 50.0)<br>let area = rect.area<br></code></pre><br>你可以给一个类扩展协议,而不用子类化。如果协议定义在 Swift 中, 你还可以向结构体或者枚举添加。<br><br>你不可以用扩展来覆盖 Objective-C 类型已有的方法和属性。<br><br># 闭包<br>Objective-C 块作为闭包自动导入 Swift, 用 Objective-C 块的调用约定, 标记为 <code>@convention(block)</code> 属性。例如, 下面是一个 Objective-C 块变量:<br><pre><code><br>void (^completionBlock)(NSData <em>) = ^(NSData </em>data) {<br>   // …<br>}<br></code></pre><br>下面是 Swift 的版本:<br><pre><code><br>let completionBlock: (Data) -&gt; Void = { data in<br>    // …<br>}<br></code></pre><br>Swift 闭包和 Objective-C 块是兼容的, 所以你向需要块的 Objective-C 方法传入 Swift 的闭包。Swift 闭包和函数有相同的类型, 所以你甚至可以传入一个 Swift 函数名。<br><br>闭包和块一样有相似的捕获语义, 只是有一个关键地方不一样: 变量是可变的而不是拷贝的。换句话说, Objective-C 中 <code><strong>block</strong></code> 的行为是 Swift 变量的默认行为。<br><br># 捕获 self 时避免强引用循环<br>在 Objective-C 里, 如果你需要在一个块中捕获 self, 有必要去考虑内存管理的实现。<br><br>块维持对所有捕获对象的强引用, 包括 self. 如果 self 维持对块的强引用, 比如一个拷贝属性, 这会产生一个强引用循环。为了避免这个, 你可以用一个弱引用 self 来替换:<br><pre><code>
weak typeof(self) weakSelf = self;<br>self.block = ^{<br>   <strong>strong typeof(self) strongSelf = weakSelf;<br>   [strongSelf doSomething];<br>};<br></strong></code></pre><br>如同在 Objective-C 中的块, Swift 中的闭包也维持对所有捕获对象的强引用, 包括 self. 为了防止强引用循环, 你可以在闭包捕获列表里, 指定 self 为无主的:<br><pre><code><br>self.closure = { [unowned self] in<br>    self.doSomething()<br>}<br></code></pre><br><br># 对象比较<br>在 Swift 中你可以在两个对象中进行不同类型的比较。第一个, 等于 (==), 比较两个对象的内容。 第二个, 恒等于 (===), 判断常量或者变量是否引用了相同的对象实例。<br><br>Swift 提供了 == 和 === 运算符的默认实现, 对源于 NSObject 类的对象采用 Equatable 协议。== 运算符的默认实现调用了 isEqual: 方法, === 运算符的默认实现是判断指针是否相等。你不能重写来自 Objective-C 的等式运算符。<br><br>isEqual 的基本实现: NSObject 类提供, 等于判断指针的相等性。你可以重写 isEqual: 在一个子类里, 基于对象的内容而不是本身, 让 Swift 和 Objective-C APIs 决定是否相等。<br><br>备注<br><br>Swift 自动提供等式运算符的补充部分 (!= and !==). 这些不能重写。<br><br># 哈希<br>Swift 导入NSDictionary 声明, 没有为键类型指定一个类的资质, 只是作为带有键类型是 AnyHashable 的字典。类似的, 没有一个类资质对象类型声明的 NSSet, 值作为一个带有元素类型是 AnyHashable 的集合导入 Swift. 如果一个 NSDictionary 或者 NSSet 声明参数化它的键或者对象类型, 就分别用类型代替。例如, 下面是 Objective-C 的声明:<br><pre><code><br>@property NSDictionary <em>unqualifiedDictionary;<br>@property NSDictionary\&lt;NSString </em>, NSDate <em>&gt; </em>qualifiedDictionary;<br>@property NSSet <em>unqualifiedSet;<br>@property NSSet\&lt;NSString </em>&gt; *qualifiedSet;<br></code></pre><br>这里是 Swift 导入后的:<br><pre><code><br>var unqualifiedDictionary: [AnyHashable: Any]<br>var qualifiedDictionary: [String: Date]<br>var unqualifiedSet: Set\<anyhashable><br>var qualifiedSet: Set\<string><br></string></anyhashable></code></pre><br>用未指定或者id类型导入 Objective-C 声明时, Swift 会使用 AnyHashable 类型, 如果不是就作为 Any类型, 因为类型需要符合哈希协议。AnyHashable 类型从任意哈希类型隐式转换, 你可以使用 as? 和 as! 运算符, 从 AnyHashable 转换为一个更具体的类型。<br><br># Swift 类型兼容性<br>当你创建一个来自 Objective-C 类的 Swift 类, 这个类和它的成员属性,方法,下标和构造器—从 Objective-C 自动可用。它不包括 Swift-特有的特性, 列举如下:<br><ul><br><li>泛型 </li><br><li>元组 </li><br><li>没有整数原始值的枚举</li><br><li>结构体</li><br><li>顶层函数</li><br><li>全局变量</li><br><li>类型别名</li><br><li>可变类型</li><br><li>内嵌类型</li><br><li>柯里化函数</li><br></ul><br><br>Swift APIs 和 Objective-C APIs 转换规则:<br><ul><br><li>Swift 可选类型解释为 nullable.</li><br><li>Swift 非可选类型解释为 <strong>nonnull.</strong></li><br><li>Swift 常量存储属性和计算属性变成只读 Objective-C 属性。</li><br><li>Swift 变量存储属性变成读写 Objective-C 属性。</li><br><li>Swift 类型属性变成带有类属性的 Objective-C 属性。</li><br><li>Swift 类型方法变成 Objective-C 类方法。</li><br><li>Swift 构造器和实例方法变成 Objective-C 的实例方法。</li><br><li>Swift 抛出错误的方法变成带有NSError <em>*参数的 Objective-C 方法。如果 Swift 方法没有参数, AndReturnError: 添加在 Objective-C 方法名的后面, 否则添加 error:. 如果 Swift 方法没有指定返回值, 对应的 Objective-C 方法有一个布尔返回类型。如果Swift 方法返回一个非可选类型, 对应的 Objective-C 有一个可选的返回类型。</em></li><br></ul><br><br>例如, 下面是 Swift 声明:<br><br><pre><code><br>class Jukebox: NSObject {<br>    var library: Set<string><br><br>    var nowPlaying: String?<br><br>    var isCurrentlyPlaying: Bool {<br>        return nowPlaying != nil<br>    }<br><br>    class var favoritesPlaylist: [String] {<br>        // return an array of song names<br>    }<br><br>    init(songs: String…) {<br>        self.library = Set<string>(songs)<br>    }<br><br>    func playSong(named name: String) throws {<br>        // play song or throw an error if unavailable<br>    }<br>}<br></string></string></code></pre><br>下面是导入 Objective-C 后的样子:<br><pre><code><br>@interface Jukebox : NSObject<br>@property (nonatomic, strong, nonnull) NSSet&lt;NSString &gt; <em>library;<br>@property (nonatomic, copy, nullable) NSString </em>nowPlaying;<br>@property (nonatomic, readonly, getter=isCurrentlyPlaying) BOOL currentlyPlaying;<br>@property (nonatomic, class, readonly, nonnull) NSArray<nsstring *=""> <em> favoritesPlaylist;<br>- (nonnull instancetype)initWithSongs:(NSArray&lt;NSString </em>&gt; * nonnull)songs OBJC_DESIGNATED_INITIALIZER;<br>- (BOOL)playSong:(NSString <em> __nonnull)name error:(NSError </em> <strong>nullable * </strong>null_unspecified)error;<br>@end<br></nsstring></code></pre><br><br>备注:你不能在 Objective-C 里子类化 Swift 的类。<br><br># 在 Objective-C 里配置 Swift 接口<br><br>在一些情况下, 你需要仔细控制怎么把 Swift API 暴露给 Objective-C. 你可以用 @objc(name) 特性来改变一个类,属性,方法,枚举类型或者枚举分支声明的名字。<br><br>例如, 如果你的 Swift 类名包含了 Objective-C 不支持的字符, 你可以提供一个替代的名字。如果你为一个 Swift 函数提供一个 Objective-C 名, 就使用 Objective-C 选择器语法。记住在选择器部分后面的参数加上冒号 (:).<br><br><pre><code><br>@objc(Color)<br>enum Цвет: Int {<br>    @objc(Red)<br>    case Красный<br><br>    @objc(Black)<br>    case Черный<br>}<br><br>@objc(Squirrel)<br>class Белка: NSObject {<br>    @objc(color)<br>    var цвет: Цвет = .Красный<br><br>    @objc(initWithName:)<br>    init (имя: String) {<br>        // …<br>    }<br>    @objc(hideNuts:inTree:)<br>    func прячьОрехи(количество: Int, вДереве дерево: Дерево) {<br>        // …<br>    }<br>}<br></code></pre><br>在一个 Swift 类上使用 @objc(name)时, 这个类可以在 Objective-C 中使用, 没有任何命名空间。结果就是, 把一个可归档的 Objective-C 类移植到 Swift 时, 这个特性很有用。 因为归档对象在归档中存储它们的类名, 你应该使用 @objc(name) 特性来指定相同的名字作为你的 Objective-C 类, 这样的话, 老的归档可以被新的 Swift 类反归档。<br><br><p><br>备注:相反, Swift 也提供了 @nonobjc 特性, 它可以让一个 Swift 声明在 Objective-C 中无效。你可以用它来解决桥接方法的循环问题, 同时允许对被 Objective-C 导入的类的方法进行重载。如果一个 Objective-C 方法被无法在 Objective-C 里表示的 Swift 方法重写, 例如指定一个参数是变量, 这个方法必须标记为 @nonobjc.<br></p>

<h1 id="Requiring-Dynamic-Dispatch"><a href="#Requiring-Dynamic-Dispatch" class="headerlink" title="Requiring Dynamic Dispatch"></a>Requiring Dynamic Dispatch</h1><p>在 Swift APIs 被 Objective-C 运行期导入时, 不能保证属性,方法,下标或者构造器的动态调度。Swift 编译器可能仍然要去虚拟化或者内联成员访问来优化你的代码性能, 绕过 Objective-C 运行期。</p>
<p>你可以用 dynamic 修饰符来要求整个运行期的访问是动态调度的。要求动态调度很少用到。不过, 在使用例如键值观察或者 method_exchangeImplementations 运行期函数是就很有必要。它们会在运行期动态替换掉一个方法的实现。如果 Swift 编译器内部实现这个方法或者去虚拟化访问它, 这个新的实现就用不到了。</p>
<p>备注: 用 dynamic 修饰符标记的声明不能同时用 @nonobjc 特性标记。</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>在 Objective-C 中, 一个选择器是一个调用 Objective-C 方法名的类型。在 Swift 中, Objective-C 选择器用 Selector 结构体表示, 可以用 #selector 表达式构造。 要创建可以被 Objective-C 调用的方法选择器, 传入一个方法名, 例如 #selector(MyViewController.tappedButton(sender:)). 要创建一个属性的 getter 或者 setter 方法选择器, 传入属性名, 前面加上 getter: 或者 setter: 标签, 例如 #selector(getter: MyViewController.myButton).</p>
<pre><code>
import UIKit
class MyViewController: UIViewController {
    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))

    override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        let action = #selector(MyViewController.tappedButton)
        myButton.addTarget(self, action: action, forControlEvents: .touchUpInside)
    }

    func tappedButton(sender: UIButton?) {
        print("tapped button")
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
}
</code></pre>

<p>备注</p>
<p>Objective-C 方法调用可以用括号括起来, 它可以用作消除重载函数歧义的运算符, 例如 #selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void)).</p>
<h1 id="不安全的-Objective-C-方法调用"><a href="#不安全的-Objective-C-方法调用" class="headerlink" title="不安全的 Objective-C 方法调用"></a>不安全的 Objective-C 方法调用</h1><p>你可以在一个兼容的 Objective-C 对象上调用一个 Objective-C 方法, 通过一个 perform(<em>:) 方法选择器或者是它的变种。通过选择器调用方法本质上是不安全的, 因为编译器不能对结果有任何保证, 甚至不能保证对象是否可以响应这个选择器。因此, 使用这些 APIs 是强烈不鼓励的, 除非你的代码很依赖动态实现。例如, 如果你需要在接口里使用 target-action 模式来实现, 使用这些 APIs 还比较合适, 就像 NSResponder 做的那样。在大多数情况下, 把对象转换成 AnyObject, 然后使用函数调用可选链, 才更安全和方便。<br>这些方法同步执行一个选择器, 例如 perform(</em>:), 返回一个隐式拆包的可选的非托管指针, 指向一个 AnyObject 实例 (Unmanaged<anyobject>!), 因为执行选择器返回值的类型和所有权不是在编译期决定的。相反, 特别线程或者延迟执行的选择器, 例如 perform(<em>:on:with:waitUntilDone:modes:) 和 perform(</em>:with:afterDelay:), 不会返回值。</anyobject></p>
<pre><code>
let string: NSString = "Hello, Cocoa!"
let selector = #selector(NSString.lowercased(with:))
let locale = Locale.current
if let result = string.perform(selector, with: locale) {
    print(result.takeUnretainedValue())
}
// Prints "hello, cocoa!"
</code></pre>
调用一个没有指定的选择器会导致 doesNotRecognizeSelector(_:)的调用, 它默认抛出一个 NSInvalidArgumentException 的异常。

<pre><code>
let array: NSArray = ["delta", "alpha", "zulu"]

// Not a compile-time error because NSDictionary has this selector.
let selector = #selector(NSDictionary.allKeysForObject)

// Raises an exception because NSArray does not respond to this selector.
array.perform(selector)
</code></pre>

<h1 id="键和键的路径"><a href="#键和键的路径" class="headerlink" title="键和键的路径"></a>键和键的路径</h1><p>在 Objective-C 中, 一个键就是一个标示特定对象属性的字符串; 一个键路径是一个用点分开的多个键的字符串, 它指定了对象属性遍历的顺序。键和键路径经常用于键值编码 (KVC), 它是一个用字符串标识符间接访问一个对象属性和关系的机制。它们也经常用于键值观察 (KVO), 它是一种通知机制, 当其他对象的属性发生变化时, 一个对象可以获得通知。</p>
<p>在 Swift 中, 你可以用 #keyPath 表达式来产生一个编译器判断的键和键路径, 可以用于 KVC 方法,比如 value(forKey:) 和 value(forKeyPath:), 也可以用于 KVO 方法,比如 addObserver(_:forKeyPath:options:context:). #keyPath 接受链式的方法和属性调用, 例如 #keyPath(Person.bestFriend.name).</p>
<p>备注</p>
<p>#keyPath 表达式的语法和 #selector 表达式语法相似。</p>
<pre><code>
class Person: NSObject {
    var name: String
    var friends: [Person] = []
    var bestFriend: Person? = nil

    init(name: String) {
        self.name = name
    }
}

let gabrielle = Person(name: "Gabrielle")
let jim = Person(name: "Jim")
let yuanyuan = Person(name: "Yuanyuan")
gabrielle.friends = [jim, yuanyuan]
gabrielle.bestFriend = yuanyuan

#keyPath(Person.name)
// "name"
gabrielle.value(forKey: #keyPath(Person.name))
// "Gabrielle"
#keyPath(Person.bestFriend.name)
// "bestFriend.name"
gabrielle.value(forKeyPath: #keyPath(Person.bestFriend.name))
// "Yuanyuan"
#keyPath(Person.friends.name)
// "friends.name"
gabrielle.value(forKeyPath: #keyPath(Person.friends.name))
// ["Yuanyuan", "Jim"]
</code></pre>

<h1 id="Swift-和-Objective-C-在相同的工程"><a href="#Swift-和-Objective-C-在相同的工程" class="headerlink" title="Swift 和 Objective-C 在相同的工程"></a>Swift 和 Objective-C 在相同的工程</h1><p>Swift 和 Objective-C 的兼容性, 让你可以用两种语言写的文件来创建一个工程。你可以使用混合匹配的特性, 来写混合代码的应用。使用混合匹配, 你可以用最新的 Swift 的特性来实现应用的部分功能, 然后无缝合并入已有的 Objective-C 代码。</p>
<h1 id="混合匹配概述"><a href="#混合匹配概述" class="headerlink" title="混合匹配概述"></a>混合匹配概述</h1><p>Objective-C 和 Swift 文件可以在一个工程里共存, 不管这个工程原先是用哪个语言写的。你可以向现有工程添加另外一个语言的文件。这使得创建混合语言的应用和框架目标, 和用一种语言直接创建的应用流程一样。</p>
<p>使用混合语言的区别只是取决于你写的是一个应用还是一个框架。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/DAG_2x.png" alt="" width="473" height="321"></p>
<h1 id="从相同应用Target内部导入代码"><a href="#从相同应用Target内部导入代码" class="headerlink" title="从相同应用Target内部导入代码"></a>从相同应用Target内部导入代码</h1><p>如果你在写一个混合语言的应用, 你可能需要在 Swift 代码里访问 Objective-C 的代码, 同时也需要在 Objective-C 代码里访问 Swift 的代码。</p>
<h1 id="向-Swift-导入-Objective-C"><a href="#向-Swift-导入-Objective-C" class="headerlink" title="向 Swift 导入 Objective-C"></a>向 Swift 导入 Objective-C</h1><p>为了把 Objective-C 文件导入同个目标的 Swift 代码, 你要依赖一个 Objective-C 的桥接头来把这些文件暴露给 Swift. Xcode 提供了这个功能。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/bridgingheader_2x.png" alt="" width="592" height="168"></p>
<p>如果你接受, Xcode 在你创建文件的时候同时创建这个头文件, 然后用产品名加上”-Bridging-Header.h”来命名。</p>
<p>或者, 你也可以自己创建这个头文件, 选择 File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, 或者 macOS) &gt; Source &gt; Header File.</p>
<p>你需要编辑这个桥接头文件, 把 Objective-C 代码暴露给 Swift 的代码。</p>
<p>在相同工程把 Objective-C 代码导入 Swift</p>
<ul><br><li>在 Objective-C 桥接头文件中, 导入每个需要暴露给 Swift 的 Objective-C 头文件。例如:</li><br><pre><code><br>#import “XYZCustomCell.h”<br>#import “XYZCustomView.h”<br>#import “XYZCustomViewController.h”<br></code></pre><br><li>在 Build Settings 中, 在 Swift Compiler - Code Generation, 确保 Objective-C Bridging Header build setting 下面有这个桥接头文件的路径。<br><br>这个路径应该关联你的工程, 类似工程里的 Info.plist 路径设置。大多数情况下, 你不需要修改这个设置。</li></ul><br>桥接头文件里列出的所有 Objective-C 头文件对 Swift 都是可见的。Objective-C 功能可以用在任意 Swift 文件里, 不需要任何导入语句。 用相同的 Swift 语法使用自定义的 Objective-C 代码。<br><pre><code><br>let myCell = XYZCustomCell()<br>myCell.subtitle = “A custom cell”<br></code></pre><br><br># 向 Objective-C 导入 Swift<br>当你向 Objective-C 导入 Swift 代码时, 你要依赖 Xcode-产生的头文件来把这些文件暴露给 Objective-C. 这个自动产生的文件是一个 Objective-C 头文件, 它声明了 Swift 的接口。头文件的名字是你的产品名加上”-Swift.h”.<br><br>默认情况下, 产生的头文件, 包含的 Swift 声明的接口带有public 或者 open 修饰符。如果你的应用有一个 Objective-C 桥接头文件, 它也会包含标记为 internal 修饰符的接口。标记为 private 或者 fileprivate 修饰符的接口不会出现在头文件里。除非显式标记为 @IBAction, @IBOutlet, 否则 Private 声明不会暴露给 Objective-C, @objc 也一样。如果你的应用打开了测试, 一个单元测试目标可以访问任何带有 internal 修饰符的声明, 通过把 @testable 放在产品模块导入语句, 就像它们用 public 声明一样。<br><br>你不需要做什么来创建这个头文件—只要在 Objective-C 代码中导入它。注意, 头文件里的 Swift 接口包括对所有用到的 Objective-C 类型的调用。如果你在 Swift 代码里使用你自己的 Objective-C 类型, 在导入 Swift 产生的头文件到 Objective-C .m 文件之前, 确保为这些类型导入 Objective-C 头文件。<br><br>在相同的 target 把 Swift 代码导入 Objective-C<br><ul><li>导入 Swift 代码使用这个语法, 然后替换成对应的名字:</li></ul><br><pre><code><br>#import “ProductModuleName-Swift.h”<br></code></pre><br>包含这些输入语句的 Objective-C .m 文件就可以看见你 Swift 代码。<br># 在同一个框架 Target 内部导入代码<br><br>如果你正在写一个混合语言的框架, 你可能需要互相访问对方语言的代码。<br># 向 Swift 导入 Objective-C<br>为了导入一组 Objective-C 文件, 你需要为这个框架导入这些 Objective-C 头文件。<br><br>为了向 Swift 导入 Objective-C 代码<br><ul><br><li>在 Build Settings 下, 在 Packaging, 确保 Defines Module 设置为 “Yes”.</li><br><li>在头文件里, 导入所有想要暴露给 Swift 的 Objective-C 头文件。例如:</li><br></ul><br><pre><code><br>#import \<xyz xyzcustomcell.h=""><br>#import \<xyz xyzcustomview.h=""><br>#import \<xyz xyzcustomviewcontroller.h=""><br></xyz></xyz></xyz></code></pre><br>Swift 能看到公开暴露的每个头文件。框架里的 Objective-C 文件的内容在 Swift 中自动可用使用, 不用任何输入语句。自定义的 Objective-C 代码像使用系统类一样使用相同的 Swift 语法。<br><pre><code><br>let myOtherCell = XYZCustomCell()<br>myOtherCell.subtitle = “Another custom cell”<br></code></pre><br># 向 Objective-C 导入 Swift<br>为了把一组 Swift 文件导入 Objective-C 代码, 你不需要向头文件导入任何东西。相反, 只要导入 Xcode-产生的头文件即可。<br><br>由于为框架生成的头文件是它公开接口的一部分, 只有标记有 public 或者 open 修饰符的才会出现在生成的头文件中。<br><br>Swift 用internal 修饰符标记的方法和属性, 以及在一个继承自 Objective-C 的类中的声明可以在运行期访问 Objective-C. 不过, 它们在编译器不能访问, 也不会出现在生成的头文件中。<br><br>为了向 Objective-C 导入 Swift 代码<br><ul><br><li>在 Build Settings 下, 在 Packaging, 确保 Defines Module 设置为 “Yes”.</li><br><li>使用下面的语法, 然后替换成合适的名字:</li><br></ul><br><pre><code><br>#import \<productname productmodulename-swift.h=""><br></productname></code></pre><br>Objective-C .m 文件包含这些输入语句的, 都可以看见这些 Swift 代码。<br># 导入外部框架<br>你可以导入完全用 Objective-C 写的, 完全用 Swift 代码写的, 或者两个语言混写的框架。导入外部框架的过程, 不管它是用一种还是两种语言写的, 都是一样的。当你导入一个外部框架时, 确保 Defines Module 设置为 “Yes”.<br><br>在不同 target 下, 你可以用下面的语法导入一个框架:<br><pre><code><br>import FrameworkName<br></code></pre><br>在不同 target 下, 你可以用下面的语法向 Objective-C .m 文件中导入一个框架:<br><pre><code><br>@import FrameworkName;<br></code></pre><br><br># 在 Objective-C 中使用 Swift<br>导入 Swift 代码后, 用标准 Objective-C 语法来使用 Swift 类。<br><pre><code><br>MySwiftClass <em>swiftObject = [[MySwiftClass alloc] init];<br>[swiftObject swiftMethod];<br></em></code></pre><br>一个 Swift 类必须是一个 Objective-C 类的子类, 可以在 Objective-C 中访问和使用。<br><br># 在 Objective-C 头文件里引用 Swift 类或协议<br><br>为了避免循环引用, 不要把 Swift 代码导入 Objective-C 头文件 (.h). 替代方式是, 使用向前引用的方式。<br><pre><code><br>// MyObjcClass.h<br>@class MySwiftClass;<br>@protocol MySwiftProtocol;<br><br>@interface MyObjcClass : NSObject<br>- (MySwiftClass )returnSwiftClassInstance;<br>- (id <myswiftprotocol>)returnInstanceAdoptingSwiftProtocol;<br>// …<br>@end<br></myswiftprotocol></code></pre><br>类和协议的向前声明只能用于方法类型和属性声明。<br><br># 定义一个 Objective-C 类可以采用的 Swift 协议<br><br>为了创建这种协议, 用 @objc 特性来标记协议声明。<br><pre><code><br>@objc public protocol MySwiftProtocol {<br>    func requiredMethod()<br>    @objc optional func optionalMethod()<br>}<br></code></pre><br>一个声明了所有构造器, 属性, 下标和方法的协议, Objective-C 类必须实现它们, 来遵守这个协议。任何可选协议需求必须用 @objc 特性标记并且要有 optional 修饰符。<br><br># 在 Objective-C 实现里使用 Swift 协议<br><br>通过导入Xcode 生成的头文件和使用一个类的扩展, Objective-C 类可以在实现中采用一个 Swift 协议。<br><pre><code><br>// MyObjcClass.m<br>#import “ProductModuleName-Swift.h”<br><br>@interface MyObjcClass () <myswiftprotocol><br>// …<br>@end<br><br>@implementation MyObjcClass<br>// …<br>@end<br></myswiftprotocol></code></pre><br><br># 声明一个 Swift 错误类型用于 Objective-C<br><br>Swift 枚举遵守 Error 协议并且使用 @objc 特性声明来产生一个 NS_ENUM 声明, 同时产生一个错误域的 NSString 常量。 例如, 给定下面的 Swift 枚举声明:<br><pre><code><br>@objc public enum CustomError: Int, Error {<br>    case a, b, c<br>}<br></code></pre><br>下面是在生成的头文件里, 对应的 Objective-C 声明:<br><pre><code><br>// Project-Swift.h<br>typedef SWIFT_ENUM(NSInteger, CustomError) {<br>  CustomErrorA = 0,<br>  CustomErrorB = 1,<br>  CustomErrorC = 2,<br>};<br>static NSString <em> const CustomErrorDomain = @”Project.CustomError”;<br></em></code></pre><br><br># 为 Objective-C 接口重写 Swift 名<br><br>Swift 编译器自动把 Objective-C 代码导入成 Swift 的惯例代码。Objective-C 类的工厂方法会变成 Swift 的构造器, Objective-C 枚举 cases 会被截断名字。<br><br>在你的代码里, 可能会有边缘cases 不能自动处理。如果你需要修改导入后的名字, 你可以使用 NS_SWIFT_NAME 宏来定制怎么导入声明。<br><br># 类的工厂方法<br><br>如果 Swift 编译器识别不出来一个类的工厂方法, 你可以用 NS_SWIFT_NAME 宏, 传入 Swift 的构造器签名来确保它正确的导入。例如:<br><pre><code><br>+ (instancetype)recordWithRPM:(NSUInteger)RPM NS_SWIFT_NAME(init(RPM:));<br></code></pre><br>如果 Swift 编译器错误的把一个方法识别成一个工厂方法, 你可以用 NS_SWIFT_NAME 宏, 传入 Swift 的方法签名来保证它正确的导入。例如:<br><pre><code><br>+ (id)recordWithQuality:(double)quality NS_SWIFT_NAME(record(quality:));<br></code></pre><br><br># 枚举<br><br>默认情况, Swift 导入枚举会截断枚举值的前缀名。为了自定义枚举 case 的名字, 你可以用 NS_SWIFT_NAME 宏, 传入 Swift 枚举 case 名。例如:<br><pre><code><br>typedef NS_ENUM(NSInteger, ABCRecordSide) {<br>  ABCRecordSideA,<br>  ABCRecordSideB NS_SWIFT_NAME(FlipSide),<br>};<br></code></pre><br><br># 让 Objective-C 接口在 Swift 中可用<br><br>一些 Objective-C 接口可能不适合或者不需要作为 Swift 接口暴露。为了防止一个 Objective-C 声明被导入 Swift, 使用NS_SWIFT_UNAVAILABLE 宏。<br><br>例如, 一个 Objective-C 类提供了一个便利构造器, 这个构造器带有键值对的可变参数, 可能会建议 Swift 用户使用字典字面量来代替:<br><pre><code><br>+ (instancetype)collectionWithValues:(NSArray )values forKeys:(NSArray<nscopying> <em>)keys NS_SWIFT_UNAVAILABLE(“Use a dictionary literal instead”);<br></em></nscopying></code></pre><br>尝试调用 +collectionWithValues:forKeys: 方法会导致一个编译错误。<br><br># 改进 Objective-C 声明<br><br>你可以在一个 Objective-C 方法声明上使用 NS_REFINED_FOR_SWIFT 宏, 在一个扩展里提供一个改进的 Swift 接口, 同时保证原有的接口可以被改进后的接口调用。例如, 带有一个或者多个指针参数的 Objective-C 方法可以改进为返回一个值的元组。<br><br>导入 Swift的构造器方法, 它们第一个参数标签前带上双下划线 (<strong>)。导入 Swift 的下标方法, 它们的基本名前面带上双下划线 (</strong>), 而是作为一个 Swift 下标, 如果 getter 和 setter 方法标记为 NS_REFINED_FOR_SWIFT.<br>其他方法在它们的基本名前加上双下划线 (__).<br>给定下面的 Objective-C 声明:<br><pre><code><br>@interface Color : NSObject<br>- (void)getRed:(nullable CGFloat )red<br>         green:(nullable CGFloat <em>)green<br>          blue:(nullable CGFloat </em>)blue<br>         alpha:(nullable CGFloat *)alpha NS_REFINED_FOR_SWIFT;<br>@end<br></code></pre><br>你可以在扩展中提供一个改进的 Swift 接口, 像这样:<br><pre><code><br>extension Color {<br>    var RGBA: (red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat) {<br>        var r: CGFloat = 0.0<br>        var g: CGFloat = 0.0<br>        var b: CGFloat = 0.0<br>        var a: CGFloat = 0.0<br>        __getRed(red: &amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)<br>        return (red: r, green: g, blue: b, alpha: a)<br>    }<br>}<br></code></pre><br><br># 命名你的产品模块<br><br>Xcode 为 Swift 代码生成的头文件的名字, 还有 Objective-C 桥接头文件的名字, 都是产生自产品模块名。默认情况, 你的产品模块名和你的产品名是一样的。不过, 如果你的产品名含有非数字字母的字符, 比如 (.), 那么在产品模块名字里就会用下划线替换掉。如果名字以数字开始, 那么第一个数字会被用下划线替换掉。<br><br>你可以给产品模块提供一个自定义的名字, 当命名桥接和生成的头文件时, Xcode 会使用它。如果要这么做, 修改 Product Module Name 的设置。<br><br>备注<br><br>你不能覆盖一个框架的产品模块名。<br><br># 排错提示和提醒<br><br>把 Swift 和 Objective-C 文件看成相同的代码集合, 然后小心命名冲突。<br>如果你在使用框架, 确保 Defines Module (DEFINES_MODULE) 设置成 “Yes”.<br>如果你在使用 Objective-C 桥接头文件, 确保 Objective-C 桥接头文件设置了路径。(例如, “MyApp/MyApp-Bridging-Header.h”).<br>在命名桥接头文件和为 Swift 代码生成的头文件时, Xcode 会使用你的产品模块名而不是 target 名。<br>为什么能在 Objective-C 访问和使用, 一个 Swift 类必须是一个 Objective-C 类的子类或者用 @objc 来标记。<br>当你把 Swift 代码引入 Objective-C 时, 记住 Objective-C 不能转换成某些 Swift 才有的特性。<br>如果你在 Swift 代码里使用 Objective-C 类型, 确保这些类型的头文件导入了。<br>Swift 用 private 或者 fileprivate 修饰符标记的声明不会出现生成的头文件中。私有声明不会暴露给 Objective-C, 除非它们显式的用 @IBAction, @IBOutlet, 或者 @objc 来标记。<br>对于应用的 targets, 用 internal 修饰符标记的声明会出现在生成的头文件中, 如果应用 target 有一个 Objective-C 的桥接头文件。<br>对于框架 targets, 只有用 public 或者 open 修饰符标记的声明才会出现在生成的头文件里。你依然可以在框架的 Objective-C 部分, 使用 internal 标记的 Swift 方法和属性。只要它们声明在继承自 Objective-C 类的子类的内部。<br><br># 把 Objective-C 代码移植到 Swift<br><br>移植提供了一个重新审视已有的 Objective-C 应用并改进它的结构,逻辑和性能的机会。简单说, 应用的增量移植, 你会用到前面学过的—混合匹配和互用性。混合匹配的功能, 使得挑选哪些特性和功能在 Swift 中实现, 哪些在 Objective-C 中保留更加容易。互用性使得把这些特性集成回 Objective-C 变为可能。使用这些工具去探索 Swift 的大量功能, 然后无需重写整个项目就可以继承回已有的 Objective-C 应用。<br><br># 准备要移植的 Objective-C 代码<br><br>在你开始移植代码之前, 确保你的 Objective-C 和 Swift 代码有最优的兼容性。这意味着整理和改进已有的 Objective-C 代码库。已有的代码要遵守最新的编码实践, 这样更容易与 Swift 无缝对接。<br><br># 移植过程<br><br>移植到 Swift 最有效的方式是基于每个文件—就是说, 一次一个类。因为你不能在 Objective-C 中子类化 Swift的类, 最好在应用找那些没有任何子类的类。用一个.swift 文件来替换 .m 和 .h 文件。所有的实现和接口直接写进这个 Swift 文件。你不能创建一个头文件了; Xcode 在你需要引用它的时候会自动产生头文件。<br><br># 开始前<br><br><ul><br><li>通过选择 File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, 或者 macOS) &gt; Source &gt; Swift File, 来给对应的Objective-C .m 和 .h 文件创建一个 Swift 文件。你可以用原来的名字或者换一个名字都可以。类的前缀是可选的。</li><br><li>导入相关的系统框架。</li><br><li>如果需要在 Swift 中访问 Objective-C 代码, 那就填写一个 Objective-C 的桥接头文件。</li><br><li>为了让 Swift 可以在 Objective-C 中访问和使用, 让它变成 Objective-C 类的子类。指定一个特殊的名字, 用 @objc(name) 标记, 这个名字是 Objective-C 使用的 Swift 类名。</li><br></ul>

<h1 id="工作时"><a href="#工作时" class="headerlink" title="工作时"></a>工作时</h1><ul><br><li>通过子类化 Objective-C 的类, 采用 Objective-C 协议等等, 你可以设置 Swift 类和 Objective-C 的交互行为。</li><br><li>当你使用 Objective-C APIs 时, 你需要知道 Swift 怎么转换特定的 Objective-C 语言特性。</li><br><li>在写包含 Cocoa 框架的 Swift 代码时, 记住桥接的类型, 意味着你可以在 Objective-C 类型的位置使用 Swift 类型。</li><br><li>当你在 Swift 类中包含 Cocoa 模式时, 参见才有 Cocoa 设计模式。</li><br><li>为了从 Objective-C 的属性转到 Swift, 参见 Swift 编译语言的属性。(Swift 3.0.1).</li><br><li>必要时为属性和方法使用 @objc(name) 特性来提供 Objective-C 名。例如, 你可以标记一个属性有一个 getter 名 isEnabled, 在 Objective-C 里像这样:<br><pre><code><br>var enabled: Bool {<br>@objc(isEnabled) get {<br>    // …<br>}<br>}<br></code></pre></li><br><li>分别用 func 和 class 来表示实例方法 (-) 和类方法 (+).</li><br><li>声明简单的宏作为一个全局常量, 复杂的宏写成函数。</li><br></ul>

<h1 id="完成后"><a href="#完成后" class="headerlink" title="完成后"></a>完成后</h1><ul><br><li>在你的 Objective-C 代码中更新输入语句 (#import “ProductModuleName-Swift.h”)</li><br><li>移除原来的 Objective-C .m 文件。 不要立即删除 .m 和 .h 文件; 留着它们做故障排除。</li><br><li>如果 Swift 类名不同, 用新名字更新替换 Objective-C 名。</li><br></ul>

<h1 id="故障排除提示和提醒"><a href="#故障排除提示和提醒" class="headerlink" title="故障排除提示和提醒"></a>故障排除提示和提醒</h1><ul><br><li>尽管每次移植经验都是不同的, 这里依然有一些通用的步骤和工具帮助你排除故障:</li><br><li>记住你不能在 Objective-C 中子类化一个 Swift 类。因此, 移植类不要有任何 Objective-C 的子类。</li><br><li>一旦你把一个类移植到 Swift, 你必须移除相应的 .m 文件, 防止出现重复符号的错误。</li><br><li>为了能在 Objective-C 中访问和使用, 一个 Swift 类必须是一个 Objective-C 类的子类。</li><br><li>当你在 Objective-C 中引入 Swift 代码时, 记住 Objective-C 不能转换 Swift 专有特性。</li><br><li>Command-点击一个 Swift 类名来看它生成的头文件。</li><br><li>Option-点击一个符号来看它的隐式信息, 比如类型, 特性, 和文档注释。</li><br></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本构建&quot;&gt;&lt;a href=&quot;#基本构建&quot; class=&quot;headerlink&quot; title=&quot;基本构建&quot;&gt;&lt;/a&gt;基本构建&lt;/h1&gt;&lt;p&gt;Swift 被设计成可以与 Cocoa 和 Objective-C无缝兼容。你可以在 Swift 中使用 Objective
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>苹果Background Modes</title>
    <link href="http://yoursite.com/2016/12/22/%E8%8B%B9%E6%9E%9CBackground-Modes/"/>
    <id>http://yoursite.com/2016/12/22/苹果Background-Modes/</id>
    <published>2016-12-22T08:12:31.000Z</published>
    <updated>2017-01-13T05:21:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发人员和用户经常很困惑,iOS的多任务系统到底允许做什么事。苹果限制后台操作的使用位置,为了提升用户体验和延长电池的使用。你的应用只允许在某些场景下运行在后台。例如, 播放音频, 获取位置更新, 或者从服务器获取最新的内容。<br>如果你的工作不是属于上述分类。超出范围使用后台模式,应用审核时会被苹果拒绝。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BackgroundModes-feature.png" height="250"><br></div></p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>进入工程前, 这里有个在iOS中可用的后台模式的预览。 在 Xcode 8里, 你可以在应用目标的 Capabilities 标签下看到这个列表。它看起来是这样的:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/EnableBackgroundCapability.png" width="480" height="262"><br></div><br>要获取后台模式能力列表,你 (1) 从 Project Navigator 选择工程, (2) 选择应用 target, (3) 选择 Capabilities 标签, 然后 (4) 打开 Background Modes 开关。<br>在这个教程里,你会研究四种后台处理方式。</p>
<ul><br><li><em>播放音频</em>: 应用可以在后台继续播放或者录制音频。</li><br><li><em>获取位置更新</em>: 设备位置变化时,应用可以继续获取反馈。</li><br><li><em>执行有限时长的任务</em>: 应用运行代码一段时间。</li><br><li><em>后台获取</em>: 获取iOS预定的最新内容。</li><br></ul>

<p>下载工程开始。开始运行工程前,设置一下开发团队, 如下所示:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SetDevTeam.png" width="650" height="349"><br></div><br>运行实例程序感受一下。这里有4个标签; 分别对应一种模式:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-StarterProjectTabs.png" width="372" height="110"><br></div><br><em>备注:</em> 为了效果完整, 你应该使用真实的设备。以我的经验, 如果忘记配置, 应用可能在模拟器后台运行良好。不过, 当你换到真实设备时, 它完全不工作。</p>
<h1 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h1><p>首先, 后台音频。<br>在iOS上有几种播放音频的方法, 大多数方法要求回调来提供更多的播放数据。<br>如果你想用流数据播放音频, 你可以启动网络连接, 连接回调会提供连续的音频数据。<br>当你激活音频后台模式后, 即使应用不是当前激活的应用,iOS 也会继续这些回调。事实上,音频后面模式是自动的。你只需要激活它然后提供合适的处理。<br>在这个部分,你会审查应用里的音频播放器, 验证后台模式不起作用, 打开音频后台模式能力, 然后显示它起作用了。<br>打开 AudioViewController.swift 看看。<br>这个应用使用 AVQueuePlayer 来排队歌曲然后依次播放它们。视图控制器通过观察播放器的 currentItem 值来提供更新。<br>启动器工程包含了来自 incompetech.com 的音频文件, 一个最受欢迎的免版税的音乐网站。<br>当应用处于激活状态时, 音乐标题会显示,如果在后台,控制台会打印这个标题。在后台的时候,标题依然会更新。但是这里只是展示,当你的应用在后台时,它依然可以收到回调。<br>编译运行,你会看到这个:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AudioScreen.png" width="273" height="500"><br></div><br>现在点击播放,音乐就开始了。好棒!<br>测试一下后台。当在真实设备运行的时候,点击home键,音乐就会停止。为什么? 好吧, 这里还缺少关键部分!<br>返回 Xcode, 按照下面这样做:</p>
<p><ol></ol></p>
<p><li>在 <em>Project Navigator</em>下点击工程;</li></p>
<p><li>点击 <em>TheBackgrounder</em> 目标;</li></p>
<p><li>点击 <em>Capabilities</em> 标签;</li></p>
<p><li>到 <em>Background Modes</em> 打开开关;</li></p>
<p><li>选择 <em>Audio, AirPlay and Picture in Picture</em>.</li><br></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableAudioInBG.png" width="650" height="354"><br></div><br>再次编译运行。播放音乐并按home键, 这时,即使应用在后台,你也可能听见音乐了。<br>你也可以在Xcode控制台看见时间在更新, 证明代码在后台也是工作的。<br>喔, 如果你已经有了一个音频播放器, 后台播放就很容易了!</p>
<h1 id="获取位置更新"><a href="#获取位置更新" class="headerlink" title="获取位置更新"></a>获取位置更新</h1><p>在位置后台模式, 应用依然可以接收到用户位置更新的代理信息。在后台时,你可以控制位置更新的精度,甚至可以修改它。<br>第二个标签是位置更新, 所以打开 LocationViewController.swift 看一下。 和后台音频例子很像, 如果你的应用有了位置功能, 位置后台模式很容易建立和运行!<br>在这个控制器里,你可以找到 CLLocationManager. 它用来接收你创建的位置信息,并且配置 CLLocationManager 实例。在这种情况下,当屏幕 UISwitch 开关激活时,应用会监视位置。当位置更新时, 应用会在地图上绘制大头针。如果应用是在后台, 你会在Xcode的控制台看见位置更新的日志。<br>CLLocationManager 实例调用 requestAlwaysAuthorization() 这行需要注意。这是 iOS 8 开始后的要求, 然后会弹出一个对话框,请求后台接收位置的许可。<br>既然你熟悉了后台模式, 你就不会犯以前同样的错误了! 确认对话框,让 iOS 知道你的应用需要在后台接收位置更新。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableLocationInBG.png" width="650" height="354"><br></div><br>除了确认对话框, iOS 8 及以上会要求你在Info.plist中设置一个键来向用户说明为什么需要位置更新。如果你没有这个, 位置请求就会失败。</p>
<p><ul></ul></p>
<p><li> 在 Xcode中选择project.</li></p>
<p><li> 在 <em>TheBackgrounder</em> 目标下选择<em>Info</em>.</li></p>
<p><li> 选择已经存在的一行.</li></p>
<p><li> 点击 + 按钮添加一个新的键.</li></p>
<p><li> 添加键 <em>Privacy &#8211; Location Always Usage Description</em>.</li></p>
<p><li> 写一个简短说明,解释为什么需要在后台请求位置.</li><br></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AddLocationPrivacyMessage.png" width="650" height="354"><br></div><br>现在编译运行! 切换到第二个标签然后打开开关。<br>在你第一次这么做时, 你会看到你写的位置隐私原因。点击允许,然后走出办公室。你就可以看见位置更新了, 模拟器也可以。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AllowLocationAccess.png" width="281" height="500"><br></div><br>过一会, 你会看到类似这样的:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-LocationUpdatesOnMap.png" width="272" height="500"><br></div><br>如果你把应用切到后台, 你可以在控制台看见应用在更新位置的日志。再次打开应用, 你能看到所有在后台更新的位置的大头针。<br>如果你用模拟器, 你可以可以用它模拟移动! 选择 Debug \ Location 菜单:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DebugLocationSimulation.png" width="492" height="366"><br></div><br>试着设置位置为 Freeway Drive 然后点击home键。你会看到控制台日志,打印出你在加州高速公路的移动过程:</p>
<p><div class="wp_codebox"><table><tr id="p1431281"><td class="code" id="p143128code1"><pre class="console" style="font-family:monospace;">App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time<br>App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time<br>App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time</pre></td></tr></table></div><br>没问题,对吧?! 来到第三个标签,第三个后台模式!<br>下一个模式官方叫做 </p>
<h1 id="Executing-a-Finite-Length-Task-in-the-Background"><a href="#Executing-a-Finite-Length-Task-in-the-Background" class="headerlink" title="Executing a Finite-Length Task in the Background."></a>Executing a Finite-Length Task in the Background.</h1><p>从技术上说, 这个根本不是后台模式, 你不用在Capabilities里使用这个模式。相反, 它只是一个 API,让你在后台执行一段时间的代码。<br>在过去, 这个模式用来完成上传和下载,提供大概10分钟的时间（不能保证）来完成这些任务。不过,如果连接很慢,这个过程没有完成呢? 你的程序会处于奇怪的状态, 而你必须提供大量的错误处理代码来保证任务稳定进行。因为这个原因, Apple 引入了 NSURLSession.<br>尽管它不是这个教程的主题, NSURLSession 面对后台是稳健的, 高效的,即使设备重启。如果你需要处理大量的下载, 可以查看 NSURLSession 教程。<br>后台模式一个很有效的用途是完成一些长任务, 例如渲染和写视频到相机胶卷中。</p>
<p><div style="text-align:center"><br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/04/Whatever_cheers.png" width="480" height="177"><br></div><br>不过这只是一个例子。因为你可以运行任意代码, 你可以用这个 API 做很多事: 执行长时间的计算, 对图片使用滤镜, 渲染复杂的 3D 网!<br>退到后台,你能获得多少时间取决于 iOS. 获取的时间是没有保证的, 不过你可以一直在 UIApplication里 判断。 这个会告诉你还有多少时间可用。<br>一般来说, 基于观察的共识是,你可以获得三分钟。再说一次, 这个不保证,而且 API 也没有说大约多少数 – 所以不要信赖这个数字。你也可能获得5分钟或者5秒钟, 所以你的应用需要…<br>这里有个 CS 学生都很熟悉的基本任务: 计算斐波拉契序列的个数。这里要在后台计算这个数字!<br>打开 WhateverViewController.swift 看一下已经有了什么。按照目前情况, 这个视图会按照序列计算斐波拉契数字并显示结果。如果你要在真实设备挂起这个应用, 计算会停止,应用激活后再次计算。你的任务是创建一个后台任务,这样计算可以一直保持运行,直到 iOS 说, ‘不用了!’<br>首先你要给 WhateverViewController 添加下面的属性。</p>
<p><div class="wp_codebox"><table><tr id="p1431282"><td class="code" id="p143128code2"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">var</span> backgroundTask<span style="color: #002200;">:</span> UIBackgroundTaskIdentifier <span style="color: #002200;">=</span> UIBackgroundTaskInvalid</pre></td></tr></table></div><br>这个属性用来标示任务在后台运行的请求。<br>然后给 WhateverViewController 添加下面的方法。</p>
<p><div class="wp_codebox"><table><tr id="p1431283"><td class="code" id="p143128code3"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> registerBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  backgroundTask <span style="color: #002200;">=</span> <span style="color: #400080;">UIApplication</span>.shared.beginBackgroundTask <span style="color: #002200;">&#123;</span> <span style="color: #002200;">&#91;</span>weak <span style="color: #a61390;">self</span><span style="color: #002200;">&#93;</span> <span style="color: #a61390;">in</span><br>    <span style="color: #a61390;">self</span>?.endBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>  <span style="color: #a61390;">assert</span><span style="color: #002200;">&#40;</span>backgroundTask <span style="color: #002200;">!=</span> UIBackgroundTaskInvalid<span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #a61390;">func</span> endBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">print</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Background task ended.&quot;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #400080;">UIApplication</span>.shared.endBackgroundTask<span style="color: #002200;">&#40;</span>backgroundTask<span style="color: #002200;">&#41;</span><br>  backgroundTask <span style="color: #002200;">=</span> UIBackgroundTaskInvalid<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br>registerBackgroundTask() 告诉 iOS 你需要更多的时间在后台做事情。调用之后, 如果你的应用还在后台, 它会一直获取 CPU 时间,直到你调用 endBackgroundTask().<br>如果在后台一段时间后,你不调用 endBackgroundTask(), 当你调用beginBackgroundTask(expirationHandler:)时,iOS 会调用定义的关闭方法,给你一个机会来停止代码的执行。所以最好调用 endBackgroundTask() 来告诉 OS 你要做什么。如果你不这样做,然后继续执行,你的应用会被终止!<br>现在是重要的部分, 你需要更新 didTapPlayPause(_:) 来注册后台任务和结束任务。这里有两个注释。<br>在 “register background task” 注释下面调用registerBackgroundTask() .</p>
<p><table><tr id="p1431284"><td class="code" id="p143128code4"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// register background task</span><br>registerBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span></pre></td></tr></table><br>registerBackgroundTask() 当计算开始时调用,因此你可以在后台继续计算数字。<br>在 “end background task” 注释下面添加下面的block.</p>
<p><table><tr id="p1431285"><td class="code" id="p143128code5"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// end background task</span><br><span style="color: #a61390;">if</span> backgroundTask <span style="color: #002200;">!=</span> UIBackgroundTaskInvalid <span style="color: #002200;">&#123;</span><br>  endBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>endBackgroundTask() 调用,计算停止,向iOS表明你不需要额外的 CPU 时间了。<br>每次调用beginBackgroundTask(expirationHandler:) 时记得调用endBackgroundTask()非常重要。 如果你调用beginBackgroundTaskWithExpirationHandler(_:) 两次,但是只调用 endBackgroundTask() 一次, 只有你再次调用endBackgroundTask(), 你才会停止获取 CPU 时间。<br>现在更新 calculateNextNumber() 方法, 让它基于程序的不同状态有不同的表现。<br>用下面的代码替换最后一行, resultsLabel.text = resultsMessage:</p>
<p><div class="wp_codebox"><table><tr id="p1431286"><td class="code" id="p143128code6"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">switch</span> <span style="color: #400080;">UIApplication</span>.shared.applicationState <span style="color: #002200;">&#123;</span><br><span style="color: #a61390;">case</span> .active<span style="color: #002200;">:</span><br>  resultsLabel.text <span style="color: #002200;">=</span> resultsMessage<br><span style="color: #a61390;">case</span> .background<span style="color: #002200;">:</span><br>  <span style="color: #a61390;">print</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;App is backgrounded. Next number = <span style="color: #2400d9;">(</span>resultsMessage)&quot;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">print</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Background time remaining = <span style="color: #2400d9;">(</span>UIApplication.shared.backgroundTimeRemaining) seconds&quot;</span><span style="color: #002200;">&#41;</span><br><span style="color: #a61390;">case</span> .inactive<span style="color: #002200;">:</span><br>  break<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br>只有程序激活标签才会更新。程序在后台时,控制台会打印一条消息来代替。表示新结果是什么,还有多少后台时间。<br>编译运行, 然后切换到第三个标签。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-RunningWhatever.png" width="281" height="500"><br></div><br>点击 Play 你会看到应用在计算数值。现在点击home键,然后看 Xcode 控制台的输出。你会看到时间在走,数值也在更新。<br>在大多数情况下, 这个时间以180开始 (180 seconds = 3 minutes) 然后走到 5 秒。到5秒时, 如果你等着过期, 过期 block 会调用,然后应用停止输出。这时如果你回到应用, 定时器会重新开始,整个过程会继续。<br>这个代码里只有一个 bug. 设想你的应用在后台,然后等到分配的时间耗尽。在这种情况下, 你的应用会调用 endBackgroundTask(), 结束后台时间的需求。<br>如果这是你回到应用, 定时器会继续启动。如果你再次离开应用, 你就不会再有后台时间。为什么? 因为在过期和回到后台之间,没地方调用beginBackgroundTaskWithExpirationHandler(_:).<br>你怎么解决这个问题? 有很多方法,其中之一就是使用状态改变的通知。<br>你可以在苹果的 App States for Apps 文档里看到所有响应状态变化的细节。<br>是时候修复 bug 了。首先, 添加一个新方法 reinstateBackgroundTask().</p>
<p><table><tr id="p1431287"><td class="code" id="p143128code7"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> reinstateBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">if</span> updateTimer <span style="color: #002200;">!=</span> <span style="color: #a61390;">nil</span> <span style="color: #002200;">&amp;&amp;</span> <span style="color: #002200;">&#40;</span>backgroundTask <span style="color: #002200;">==</span> UIBackgroundTaskInvalid<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    registerBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>如果存在一个定时器在运行并且后台任务是无效的,你只需要去恢复一下。你只要简单的调用 registerBackgroundTask().<br>现在重写 viewDidLoad(), 然后添加下面的代码来订阅 UIApplicationDidBecomeActiveNotification:</p>
<p><table><tr id="p1431288"><td class="code" id="p143128code8"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  NotificationCenter.<span style="color: #a61390;">default</span>.addObserver<span style="color: #002200;">&#40;</span><span style="color: #a61390;">self</span>, selector<span style="color: #002200;">:</span> <span style="color: #6e371a;">#selector(reinstateBackgroundTask), name: NSNotification.Name.UIApplicationDidBecomeActive, object: nil)</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>当程序激活的时候, 就会调用你的新方法reinstateBackgroundTask().<br>一旦你订阅通知, 你应该考虑在哪里取消订阅。使用 deinit 来做这件事。添加如下代码:</p>
<p><table><tr id="p1431289"><td class="code" id="p143128code9"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">deinit</span> <span style="color: #002200;">&#123;</span><br>  NotificationCenter.<span style="color: #a61390;">default</span>.removeObserver<span style="color: #002200;">&#40;</span><span style="color: #a61390;">self</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>现在你有了这个, 你可以做想做的任何事了, 至少只要iOS说它是ok的就行。<br>本教程最后一个后台模式: Background Fetching.</p>
<h1 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h1><p>Background fetch 是 iOS 7 引入的模式, 它可以让你的应用总显示最新的信息, 同时减小对电池的影响。设想一下, 例如, 你正在实现一个新闻提要。后台获取之前, 你可能在 viewWillAppear(_:)中获取新数据。<br>这个解决方案的问题是,在新数据到来前,用户要看几秒的老数据。如果打开应用,新数据已经在那里了,这样会不会好点? 这就是后台获取所能给予你的。<br>一旦打开, 系统用使用模式来决定什么时候触发后台获取是最佳的。例如, 如果你的用户每天早上9点打开应用, 后台获取可能早于这个时间安排。系统决定发送后台获取的最佳时间, 因此, 对于关键的更新你不要使用它。<br>实现后台获取要做三件事:</p>
<p><ul></ul></p>
<p><li>在应用的<em>Capabilities</em>下面的<em>Background Modes</em>中打开<em>Background fetch</em>.</li></p>
<p><li>使用 <code>setMinimumBackgroundFetchInterval(_:)</code> 设置一个适合你的应用的时间间隔.</li></p>
<p><li>实现代理方法 <code>application(<em>:performFetchWithCompletionHandler:)</em></code>.</li><br><br>就像它的名字所说, 后台获取通常从比如网络服务这样的外部资源获取信息。<br>相比一定长度的任务, 后台获取通常只有几秒时间来操作 – 一般最多的30秒, 不过更短的时间更好。如果你需要下载比较大的资源, 你需要用 NSURLSession 的后台传输服务。<br>是时候开始了。首先, 打开 FetchViewController.swift 看看它做了什么, 其实没有做什么事。<br>fetch(:) 方法简单取代了你实际想要从外部获取数据的部分。因为可能需要几秒钟去获取和解析数据, 你传入完成处理器在过程结束时调用。晚些时候,你会看到它的重要性。<br>updateUI() 格式化时间并显示。围绕 updateLabel 的 guard 语句保证视图被加载。time 是可选类型,因此不需要设置。它显示信息 “Not updated yet”.<br>在视图首次加载时你没有获取 (在 viewDidLoad()), 但是直接去 updateUI() 意味着 “Not yet updated” 会先出现。最后, Update 按钮点击时,它执行获取并更新 UI.<br>视图控制器正在工作。这里你不需要做什么。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-FetchNotUpdated.png" width="281" height="500"><br></div><br>不过, 后台获取不用。<br>第一步是打开后台获取。现在有点过时了。那就做一下。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableBackgroundFetch.png" width="650" height="363"><br></div><br>下一步, 打开 AppDelegate.swift 把下面的代码添加到 application(_:didFinishLaunchingWithOptions:):</p>
<p><table><tr id="p14312810"><td class="code" id="p143128code10"><pre class="swift" style="font-family:monospace;"><span style="color: #400080;">UIApplication</span>.shared.setMinimumBackgroundFetchInterval<span style="color: #002200;">&#40;</span>UIApplicationBackgroundFetchIntervalMinimum<span style="color: #002200;">&#41;</span></pre></td></tr></table><br>通过设置最小后台获取时间间隔来请求后台获取。默认的时间间隔是 UIApplicationBackgroundFetchIntervalNever, 你也可以设置一个指定的间隔,单位是秒。系统至少会等到这个间隔才发送后台请求。<br>注意不要把这个值设置的太小, 因为它可能会像砸服务器一样毁掉你的电池。最后这个精确的获取时间传给系统,然后至少要等到这个时间间隔才会执行。一般来说, UIApplicationBackgroundFetchIntervalMinimum 是一个很好的默认值。<br>最后, 实现 application(_:performFetchWithCompletionHandler:). 添加到 AppDelegate:</p>
<p><div class="wp_codebox"><table><tr id="p14312811"><td class="code" id="p143128code11"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// Support for background fetch</span><br><span style="color: #a61390;">func</span> application<span style="color: #002200;">&#40;</span><em> application<span style="color: #002200;">:</span> <span style="color: #400080;">UIApplication</span>, performFetchWithCompletionHandler completionHandler<span style="color: #002200;">:</span> @escaping <span style="color: #002200;">&#40;</span>UIBackgroundFetchResult<span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #a61390;">Void</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> tabBarController <span style="color: #002200;">=</span> window?.rootViewController <span style="color: #a61390;">as?</span> <span style="color: #400080;">UITabBarController</span>,<br>         <span style="color: #a61390;">let</span> viewControllers <span style="color: #002200;">=</span> tabBarController.viewControllers<br>  <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">for</span> viewController <span style="color: #a61390;">in</span> viewControllers <span style="color: #002200;">&#123;</span><br>      <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> fetchViewController <span style="color: #002200;">=</span> viewController <span style="color: #a61390;">as?</span> FetchViewController <span style="color: #002200;">&#123;</span><br>        fetchViewController.fetch <span style="color: #002200;">&#123;</span><br>          fetchViewController.updateUI<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>          completionHandler<span style="color: #002200;">&#40;</span>.newData<span style="color: #002200;">&#41;</span><br>        <span style="color: #002200;">&#125;</span><br>      <span style="color: #002200;">&#125;</span><br>    <span style="color: #002200;">&#125;</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></em></pre></td></tr></table></div><br>首先你要获取 FetchViewContoller. 然后, 可选转换,因为 rootViewController 在每个应用中不必须是 UITabBarController, 尽管这个应用是,所以它永远不会失败。<br>下一步, 循环遍历标签栏控制器中的控制器,找到可以转换为 FetchViewController 那个。在这个应用里,你知道它是最后一个视图控制器。所以你可以硬编码, 不过在你后面添加或者移除标签时,这个循环会使它健壮一些。<br>最后调用 fetch(:). 在它完成后, 你更新 UI 然后调用 completionHandler. 操作的最后调用完成处理器非常重要。指定获取结果最为第一参数。可能值是 .newData, .noData, 或者 .failed.<br>为了简单, 教程一直用 .newData, 因为获取时间不会失败,而且总是与最后一次调用不同。iOS 可以使用这个值更好的定时后台获取。<br><em>更新备注:</em> 相比单独传完成闭包, 也可以尝试把它存储为属性变量,然后在完成时调用。别这样做。如果你多次调用 application(_:performFetchWithCompletionHandler:), 前一个处理器会被覆盖,以后不会再调用。最好是传递处理器然后调用。</p>
<h1 id="测试-Background-Fetch"><a href="#测试-Background-Fetch" class="headerlink" title="测试 Background Fetch"></a>测试 Background Fetch</h1><p>测试后台获取的一个方法是坐着等系统的决定。这要求很多时间。幸运的时, Xcode 提供了模拟后台获取的方法。有两个场景需要去测试。 一个是你的应用在后台, 另外一个是你的应用从挂起中恢复。第一个最简单,只需要选择一个菜单。</p>
<p><ul></ul></p>
<p><li>在真机上启动应用;</li></p>
<p><li>来到 Fetch 标签</li></p>
<p><li>注意信息是 &#8220;Not yet updated&#8221;</li></p>
<p><li>在 Xcode 的 <em>Debug</em> 菜单, 选择<em>Simulate Background Fetch</em>;<br></li></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SimulateBGFetch.png" width="336" height="500"><br></div><br>应用会进入后台,然后 Xcode的调试器会捕获。告诉调试器继续。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ContinueDebugger.png" width="650" height="331"><br></div><br>重新打开应用<br>注意时间已经更新了!.<br>另外一个测试是从挂起中恢复。有一个开始选项可以让你直接挂起应用。最好的方式是生成一个新的 Scheme 把这个设置好。Xcode 很容易做到。<br>首先选择 Manage Schemes.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ManageSchemes.png" width="401" height="168"><br></div><br>然后, 选择列表里唯一的 scheme, 然后点击齿轮图标,选择 Duplicate.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DuplicateScheme.png" width="650" height="360"><br></div><br>最后, 重命名 scheme, 例如, “Background Fetch” 。然后选中 Launch due to a background fetch event.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ConfigureNewScheme.png" width="650" height="384"><br></div><br>在这个 scheme 下运行你的应用。你会注意到应用永远不会打开,只是进入了挂起状态。手动启动应用来到 Fetch 标签。现在你会看到时间已经更新了,不再是 “Not yet updated”.<br>使用后台模式,可以高效的让用户获取最新的内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发人员和用户经常很困惑,iOS的多任务系统到底允许做什么事。苹果限制后台操作的使用位置,为了提升用户体验和延长电池的使用。你的应用只允许在某些场景下运行在后台。例如, 播放音频, 获取位置更新, 或者从服务器获取最新的内容。&lt;br&gt;如果你的工作不是属于上述分类。超出范围使
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TestFlight:iOS Beta测试</title>
    <link href="http://yoursite.com/2016/12/16/TestFlight-iOS-Beta%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2016/12/16/TestFlight-iOS-Beta测试/</id>
    <published>2016-12-16T04:48:45.000Z</published>
    <updated>2016-12-19T01:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>TestFlight Beta 测试是苹果公司的产品,旨在更容易的邀请用户,在你发布产品到App Store之前,让他们能够参与测试你的 iOS, watchOS 和 tvOS 应用。<br>这个教程不需要你去编码 — 跟着下面的步骤做,你就可以学会使用 TestFlight</p>
<h1 id="提交版本到-iTunes-Connect"><a href="#提交版本到-iTunes-Connect" class="headerlink" title="提交版本到 iTunes Connect"></a>提交版本到 iTunes Connect</h1><p>在 Xcode中打开你的工程, 确保它有一个正确的 Bundle Identifier, 你的 Team ID 也设置了, 你也选择了自动 Distribution Certificate Code Signing Identity:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/1-Code-Signing.png" width="612"><br></div><br>从顶部工具栏选择 Product\Archive:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2015/04/2-Product-Archive1.png" width="193" height="120"><br></div><br>当 Xcode 完成归档后, 点击 Upload to App Store… 按钮:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/3-Archive1.png" width="650" height="153"><br></div><br>现在要选择你的开发团队:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/4-Choose-Team1.png" width="579"><br></div><br>最后点击 Upload:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/5-Upload1.png" width="578"><br></div><br>等几分钟。 </p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/6-Upload2.png" width="579"><br></div><br>完成后, 你会看到下面的成功信息:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/Success.png" width="577"><br></div><br>这些是XCode要做的全部工作。iTunes Connect 上现在有了你的构建版本, 下面是设置TestFlight 的剩下工作。</p>
<h1 id="为Beta测试应用创建和开启用户"><a href="#为Beta测试应用创建和开启用户" class="headerlink" title="为Beta测试应用创建和开启用户"></a>为Beta测试应用创建和开启用户</h1><p>你的版本准备测试了, 可是谁来测试它呢?<br>Apple 为Test Flight定义了两类测试:<br>内部测试: 这是一个 iTunes Connect 用户,他是一个管理员,技术,App 管理,开发或者市场角色,有权限访问你的应用。通常是团队成员或者应用的客户。你可以添加25个内部测试。</p>
<p></p><p><br><em>备注:</em> 苹果正在舍弃技术角色转而选择App 管理的角色。转换期间两个角色都是有效的。如果你已经有了带有技术角色的用户,你应该把他们迁移到 App 管理角色。新用户直接用 App 管理来创建即可。<br></p><br>外部测试: 这是想要测试应用的任何人。外部测试是无法访问你的 iTunes Connect 账户的。只能下载和安装应用。你可以添加2000个外部测试。<br>在外部测试你的应用之前, 你需要提交应用给Apple审核, 跟正常版本提交一样。这个审核比正常提交审核要快 (也不能完全指望), 通过审核后,你就可以让外部来测试你的应用了。而对于内部测试来说, 相反, 无需审核即可测试。<br>你可以学习更多关于外部测试的知识, 但是现在, 让我们关注内部测试先。<br>为了添加一个内部测试, 先来到 Users and Roles 部分,它在 iTunes Connect里面:<p></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/10-Users-and-Roles.png" width="603"><br></div><br>在 Users and Roles 页面, 点击 + 按钮来添加一个新的用户:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/11-Users-650x95.png" width="650" height="95"><br></div><br>填好用户信息然后点击 Next:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/15-Roles.png" width="650" height="270"><br></div><br>新用户需要用唯一的邮箱地址（用作AppleID）。<br>现在给用户分配角色。通常情况下, 你应该选择 App Manager. 你可以查看更多每个角色的权限。</p>
<p></p><p><em>备注:</em> 不同角色的权限是不同的! 下面的表格可能会帮助你。</p><p></p>
<p><div style="text-align:center"><br><img src="http://a3.qpic.cn/psb?/V13UfvND3TZFZo/b4KMEn6L7*Ssezi3CPC0Rq373U3gvUbCnmtLoGi1yaY!/b/dNoAAAAAAAAA&bo=3QKSAAAAAAADB28!&rf=viewer_4" width="600" height="150"><br></div><br>完成点击 Next:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/16-Roles2.png" width="650" height="466"><br></div><br>选择测试需要接收的通知类型, 然后点击Save:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/17-Notifications.png" width="700"><br></div><br>你的用户现在创建好了, 不过在账号出现在iTunes Connect前,用户需要去邮箱验证他的地址。<br>创建内部beta测试只是整个过程的一部分。剩下的步骤就是邀请这些用户测试你最后发布的版本。<br>是时候开启应用测试了 — 不过测试用户还有一些事情要准备。</p>
<h1 id="开始Beta测试"><a href="#开始Beta测试" class="headerlink" title="开始Beta测试"></a>开始Beta测试</h1><p>为了开始测试Beta版本, 去iTunes Connect主页选择并点击 My Apps:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/20-My-Apps.png" width="603"><br></div><br>选择 Activity 标签,找到你最后构建的版本。确保它不是正在处理。如果是这样, 就去喝杯咖啡再回来。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/Activity.png" width="603"><br></div><br>下一步, 点击TestFlight 标签, 然后选择左边菜单里的内部测试。点击 Select Version to Test 然后选择你刚刚上传的版本。 最后, 点击 Start Testing 然后在弹出的提示框再次点击 Start Testing.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/StartTesting.png" width="603"><br></div><br>所有被选择的测试人员都会收到一封邮件, 让他们从TestFlight 客户端上下载安装这个版本。这个教程的后面会详细介绍如何做。<br>这些都是针对内部测试做的, 那外部测试怎么弄?<br>很简单! 首先, 来到 Test Information 标签,填写你的邮箱, Marketing URL 和 Privacy Policy URL. 如果你愿意你还可以在最后添加一个 License Agreement, 不过这不是必须的。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/30-TestInformation.png" width="700" height="327"><br></div><br>下一步, 来到 External Testing, 点击 + 按钮然后选择 Add New Testers:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/32-External1.png" width="700"><br></div><br>给你想添加的用户填写邮箱地址。完成后, 点击 Add 把他们添加到你的账户。 所有外部测试不能超过2000人:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/33-External2.png" width="603"><br></div><br>点击 Save.<br>现在你需要为外部测试选择一个版本, 并且让它通过 Beta App Review.</p>
<p></p><p><br><em>备注:</em> 为什么需要再选择一次版本? 你可能想让你的内部测试和外部测试,测试不同的版本。例如, 你的外部测试可能要测试你的候选版本, 而你的内部测试要测试你的主版本。<br></p><br>点击 Add Build To Test, 选择版本然后点击 Next.<p></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/34-BetaTest1.png" width="603"><br></div><br>填写所有的地方。记住 – 信息提供越多,审核越容易! 最后, 点击 Submit.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/35-BetaTest2.png" width="603"><br></div><br>你的应用将会被加入审核列表。</p>
<p></p><p><br><em>备注:</em> 根据我的经验, 你的第一个beta版本可能要花费48 小时。后续版本就快多了。<br></p><p></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/31-AppInReview.png" width="603"><br></div><br>一旦应用通过审核,你会收到一封邮件,说你的应用可以给外部测试了。</p>
<p></p><p><br><em>备注:</em> 一个版本有效期是 60 天。如果测试人员想继续使用, 你要在过期前再提交一个新版本。<br></p><br>回到 External Testing, 选择 build and hit 保存. 会弹出一个对话框,来确认你要通知别人测试你的应用。点击 Start Testing.<p></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/Screen-Shot-2016-05-30-at-11.58.51.png" width="603"><br></div><br>外部测试人员会收到一封邀请邮件,跟上面提到的内部测试类似。</p>
<p></p><p><br><em>备注:</em> 如果没有收到邀请怎么办? 现在的情况是,重发邀请并不容易。对于内部测试最容易的方式是上传一个新版本(因为不需要审核)。对于外部测试来说,或者你把他删了再加, 或者从外部测试移除你的应用然后再快速的添加它。 第二个方法会重新给外部测试发邀请邮件,慎用。<br></p><br>以上是从开发的角度看应用测试, 那么从测试角度看会怎样?<p></p>
<h1 id="测试应用"><a href="#测试应用" class="headerlink" title="测试应用"></a>测试应用</h1><p>作为一个内部测试, 你需要把你的 Apple ID 连接到iTunes Connect (外部测试可以跳过这个)。现在, 你应该收到了这样的邮件:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/21-Email.png" width="700"><br></div><br>点击 activate your account 然后按照步骤做。当你准备测试了, 拿着你的iOS 设备然后进入设置。滑到 iTunes &amp; App Store:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/19-Settings1.png" width="245"><br></div><br>用你刚刚验证过的账号登录。如果你登录了其他账号,先退出:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/20-Log-In.png" width="245"><br></div></p>
<h1 id="TestFlight-应用"><a href="#TestFlight-应用" class="headerlink" title="TestFlight 应用"></a>TestFlight 应用</h1><p>去 App Store, 搜索 TestFlight:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/21-Search.png" width="245" height="500"><br></div><br>下载安装并启动。</p>
<p></p><p><br><em>备注:</em> 如果要求你登录, 使用相同的凭证,就是你刚刚验证账户的那些。<br></p><br>当新版本上传到iTunes Connect, 内部测试会收到一封邮件。外部测试会收到类似的邮件,不过要等到版本通过审核, 而且需要 Admin 或者 App Manager 在 iTunes Connect推送给外部测试:<p></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/24-Invite-Email.png" width="245" height="500"><br></div><br>打开测试设备的邮件, 然后点击 Start Testing. 这个会启动TestFlight 然后显示要测试的应用。测试必须点击 Start Testing ; 否则应用不能下载。点击 Accept, 然后安装, 然后等待应用下载:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/25-Accept.png" width="245" height="500"><br></div><br>应用下载安装后会出现在主界面上!<br>这是作为测试最艰难的部分了。从现在开始, 只要这个应用的新版本可用, 你都会看到来自 TestFlight的通知。你要做的就是更新你的应用到最新的版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TestFlight Beta 测试是苹果公司的产品,旨在更容易的邀请用户,在你发布产品到App Store之前,让他们能够参与测试你的 iOS, watchOS 和 tvOS 应用。&lt;br&gt;这个教程不需要你去编码 — 跟着下面的步骤做,你就可以学会使用 TestFligh
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift 编程语言（Swift 3.0.1）</title>
    <link href="http://yoursite.com/2016/10/28/Swift-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%88Swift-3-0-1%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/</id>
    <published>2016-10-28T05:54:48.000Z</published>
    <updated>2017-01-23T03:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。</p>
<p>基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dictionary。</p>
<p>跟C类似，Swift 通过变量名来存取值。Swift 还大量使用常量，这里的常量比C的常量更加强大。常量使用贯穿Swift，用来让代码更加安全和容易推断，特别是在你不想变量值发生改变的时候。</p>
<p>除了基本类型，Swift 还引进了objective-C中没有的高级类型，比如元组。元组让你可以创建和传递多值。你可以在一个函数里返回元组来作为一个单独的混合值。</p>
<p>Swift 还引进了可选类型，用来处理缺值的情况。可选的意思是‘这里有一个值，它等于x’ 或者‘这里没有任何值’。用可选值跟objective-C里使用nil指针有点像，不过可选类型可以服务任何类型，不仅仅是类类型。可选类型不仅仅安全而且更容易表达意思，它是Swift最重要特性里的核心特性。</p>
<p>Swift是一门类型安全的语言，这也就意味着这门语言可以让你更清晰的知道代码使用的值类型。如果你的代码需要一个String，类型安全会保护你不至于传递一个Int类型。同样，类型安全也会保护你，让你不会把非可选类型传递给需要可选类型的代码块。类型安全让你在开发阶段尽快发现问题，修复错误。</p>
<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>常量和变量是一个有特定类型的值，带有一个名字。常量值一旦确定就不能改变，变量在可用随时改变其值。</p>
<p>定义常量和变量<br>常量和变量必须要在使用前定义，常量使用let关键字，变量使用var关键字。下面是一个例子来展示如何使用常量和变量，这个例子是跟踪用户尝试的登录次数。</p>
<pre><code>let maximumNumberOfLoginAttempts = 10 
var currentLoginAttempt = 0</code></pre>
这段代码可以这样解读：
定义个常量maximumNumberOfLoginAttempts，给它一个值10.然后定义一个变量currentLoginAttempt，给它一个值0.
在这个例子里，最大登录次数定义为一个常量，因为最大登录数不会改变。当前登录数定义为变量，因为这个值随着用户的登录尝试会逐渐增长。
你也可以定义多个常量或变量在一行，用逗号分开即可：
<pre><code>var x = 0.0, y = 0.0, z = 0.0</code></pre>

<p>类型注释<br>当定义常量或者变量的时候，你可以提供一个类型注释，这样可以更清楚的知道存储类型是什么。在变量名或者常量名后面加一个冒号，然后一个空格，然后是要使用的类型。</p>
<p>这个例子为变量welcomeMessage提供一个类型解释，来说明这个变量可以存储String值：</p>
<pre><code>var welcomeMessage: String</code></pre>
这段代码可以理解为：
定义个变量叫welcomeMessage，它的类型是String。
welcomeMessage变量现在可以存储任何的字符串：
<pre><code>welcomeMessage = "Hello"</code></pre>
你可以在一行定义多个相关的相同类型的变量，用逗号分开，然后再最后加上类型注释：
<pre><code>var red, green, blue: Double</code></pre>

<p>常量和变量命名<br>常量和变量命名可以包含几乎任何的字符，包括Unicode字符：</p>
<pre><code>let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"</code></pre>
常量和变量命名不能包含空格字符，数学符号，箭头，私有（无效）的Unicode字符码，或者-等。也不能以数字开始，虽然数字可以出现在名字里的任何地方。

一旦你给常量或者变量确定了类型，你就不能用同样的名字来重定义它们，或者改变他们存储的值类型。你也不能把常量改为变量，或者把变量变成常量。

你可以把常量的值改变成同样类型的其他的值。这个例子里，变量friendlyWelcome的值从"Hello!" 变成 "Bonjour!":
<pre><code>var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome is now "Bonjour!"</code></pre>
与变量不同，常量值一旦确定就不能再改变。如果尝试改变编译器会报错：
<pre><code>let languageName = "Swift"
languageName = "Swift++"
// This is a compile-time error: languageName cannot be changed.
</code></pre>
打印常量和变量
你可以使用print(_:separator:terminator:)函数打印常量或者变量的当前值：
<pre><code>print(friendlyWelcome)
// Prints "Bonjour!"</code></pre>
print(_:separator:terminator:)是一个全局函数，可以打印一个或者多个值。在XCode里，例如，print(_:separator:terminator:)打印结果会出现在控制台里。separator 和 terminator 参数都有默认值, 所以你可以忽略他们。 默认的, 这个函数打印完会加上换行符。 如果不想打印后换行, 传入一个空字符串作为终止—例如, print(someValue, terminator: "")

Swift 使用 string interpolation 在长字符串里插入常量或者变量名, 同时会提示 Swift 去用当前的常量值活变量值来替换它。 用括号包含名字，然后在前面加上反斜杠:

<pre><code>print("The current value of friendlyWelcome is \(friendlyWelcome)")
// Prints "The current value of friendlyWelcome is Bonjour!"</code></pre>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在代码中，把注释加到不执行的文本，作为一个备注或者提醒。代码编译的时候，注释会被编译器忽略。<br>Swift注释和C语言注释很像，不在赘述。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>跟其他语言不同，Swift不要求在每条语句后写分号（；），不过，在一行写很多语句的时候，还是需要带上分号的：</p>
<pre><code>let cat = "🐱"; print(cat)
// Prints "🐱"
</code></pre>

<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><p>Integers 意思是整个数字没有小数，比如 42 和 -23，整数要么是 signed（负数，0，正数） 要么是 unsigned（正数或者0）</p>
<p>Swift提供8，16，32 和 64位的有符号和无符号的整数。这些整数类型和C语言很像，8位的无符号的整数是UInt8，32位的有符号正数是Int32.</p>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><p>你可以用min 和max属性来获取每个整数类型的最小值和最大值：</p>
<pre><code>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8</code></pre>

<h1 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h1><p>大多数情况下，你不需要指定整数的位数。Swift提供了额外的整数类型Int，这个和当前平台的本地字数一样：<br>32位机器，Int等于Int32<br>64位机器，Int等于Int64<br>除非你要用规定大小的整数，否则，一般只要用Int就可以了。</p>
<h1 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h1><p>Swift也提供了无符号的整形，UInt，这个和当前平台的本地字数也是一样的：<br>32位机器，UInt等于UInt32<br>64位机器，UInt等于UInt64</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>Floating-point 是带有小数部分的数字，比如 3.14159，0.1和-273.15.<br>浮点数类型比整数类型表达更多的值域，比存在Int中的值更大或者更小。Swift提供了两个有符号的浮点数类型：<br>Double 表示64位的浮点数。<br>Float 表示32位的浮点数。</p>
<h1 id="类型安全与推断"><a href="#类型安全与推断" class="headerlink" title="类型安全与推断"></a>类型安全与推断</h1><p>Swift是类型安全的语音。类型安全的语言鼓励你清楚知道自己代码使用的值的类型。如果你的代码需要String类型，那么你就不要传递Int给它。</p>
<p>因为Swift是类型安全的，在编译代码的时候type checks会执行来标记不匹配的类型错误。这让你可以尽可能早的发现代码中的错误。</p>
<p>类型检查帮你避免使用不同类型的时候犯错，然而，这并不意味你必须给所有的常量和变量指定类型。你不需要指定类型，Swift使用type inference来推断合适的类型。类型推断使得编译器可以在编译代码的时候自动推断表达式的类型，只是通过简单的检查你提供的值。</p>
<p>因为有类型推断，Swift 对类型声明要求的比其他语言要少的多。常量和变量依然要显示输入，但是大部分指定类型的工作都已经帮你做了。</p>
<p>类型推断在给常量或者变量赋初值的时候尤为有用。这个发生在你声明常量或者变量，并给他们指定literal value（字面量）的时候。所谓的字面量就是指直接出现在你的源码中的值，比如下面例子里的 42 和 3.14159</p>
<p>例如，如果你给一个新常量指定一个字面量是42， Swift就会推断你想要这个常量的类型是Int， 因为你给他初始化一个数字：</p>
<pre><code>let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int</code></pre>
同样，你也不需要给浮点数指定类型，Swift会推断说你想要一个Double：
<pre><code>let pi = 3.14159
// pi is inferred to be of type Double</code></pre>
Swift在推断浮点数的时候总是选择Double而不是Float
如果你合并整数和浮点数在一个表达式中，Double类型将会被推断出来：
<pre><code>let anotherPi = 3 + 0.14159
// anotherPi is also inferred to be of type Double</code></pre>

<h1 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h1><p>整数字面量这可以写：<br>十进制数字，没有前缀<br>二进制数字，用0b做前缀<br>八进制数字，用0o做前缀<br>十六进制数字，用0x做前缀<br>下面所有整数字面量值都是17：</p>
<pre><code>let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation</code></pre>

<p>浮点数字面量可以是十进制或者十六进制。在十进制点的两边都必须有数字。十进制浮点数也有个可选的exponent，用大小写e标明；十六进制浮点数也有exponent，用大小写的p标明。</p>
<p>用 exp 指数表示十进制数, 基础数字乘以 10exp:<br>1.25e2 意思是 1.25 x 102, 或者是 125.0.<br>1.25e-2 意思是 1.25 x 10-2, 或者是 0.0125.<br>用 exp 指数表示十六进制数, 基础数字乘以 2exp:</p>
<p>0xFp2 意思是 15 x 22, 或者是 60.0.<br>0xFp-2 意思是 15 x 2-2, 或者是 3.75.<br>下面所有这些浮点数字面量十进制数都是 12.1875:</p>
<pre><code>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0</code></pre>

<h1 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h1><p>在你的代码中使用Int做为一般用途的整形常量和变量，尽快知道他们是非负数的。日常开发使用默认整形类型意味着整形变量和常量立即可以使用，而且它们匹配整形字面量的推断类型。</p>
<p>特别指定的工作才会使用其他的整形类型，因为指定大小的整形类型需要额外的开销。日常开发中，使用指定大小的类型帮助捕获特定值的溢出，同时记录被使用的数据。</p>
<h1 id="整形转换"><a href="#整形转换" class="headerlink" title="整形转换"></a>整形转换</h1><p>不同数值类型，存储在常量或变量中的数值范围是不同的。一个Int8常量或者变量可以存储 -128 到 127， UInt8 常量或者变量能存储 0 到 255 之间的数值。如果数值不适合指定大小的整形类型，编译后会报错。</p>
<pre><code>let cannotBeNegative: UInt8 = -1
// UInt8 cannot store negative numbers, and so this will report an error
let tooBig: Int8 = Int8.max + 1
// Int8 cannot store a number larger than its maximum value,
// and so this will also report an error</code></pre>


<p>为了转换一个特定数值类型，先用一个存在的值初始化一个新的想要类型的新数值。下面的例子，常量twoThousand的类型是UInt16， 而常量one的类型是UInt8.他们不能直接相加，因为类型不同。取而代之的是，这个例子调用UInt16（one）来创建一个新的Uint16，并用one初始化它，并在原来的位置使用这个值：</p>
<pre><code>let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)</code></pre>

<p>因为加好两边的值类型都是UInt16，所以加法是进行的。输出常量推断是UInt16，因为它是两个UInt16值的和。</p>
<p>SomeType(ofInitialValue) 默认调用Swift类型的初始化函数，然后传递一个初始值。这个语句之前，UInt16有一个初始化器接受一个UInt8的值，所以这个初始化器就用存在的UInt8 创建了一个新的UInt16.这里你不能随便传入类型-必须传入UInt16初始化器接受的值。</p>
<h1 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h1><p>整数和浮点数之间的转换必须是显示的：</p>
<pre><code>let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi equals 3.14159, and is inferred to be of type Double</code></pre>

<p>这里，常量three用来创建新的Double数值，现在加号两边的类型是一样的，所以可以相加。如果没有这里的转换，加法是不允许的。</p>
<p>浮点数转整数也必须是显示进行的。一个整形可以用Double 或者 Float的值来初始化：</p>
<pre><code>let integerPi = Int(pi)
// integerPi equals 3, and is inferred to be of type Int</code></pre>

<p>用这种方式初始化一个新的整形数值，浮点数会被截断。意思就是 4.75 会变成 4， -3.9会变成-3.</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>type aliases 为已知类型定一个别名。定义类型别名使用typealias关键字。</p>
<p>类型别名在你想通过名字调用一个已知类型的时候很有用，这种名字在上下文中更合适，比如使用指定大小的外部数据时：</p>
<pre><code>typealias AudioSample = UInt16</code></pre>
定义好类型别名后，你可以在任何使用原名的地方使用它：
<pre><code>var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound is now 0</code></pre>

<p>这里，AudioSample就是UInt16的别名。因为是别名，调用AudioSample.min实际上就是调用UInt16.min，这给maxAmplitudeFound变量提供一个初始值0.</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>Swift有个一基础布尔类型， 叫做 Bool。布尔值用作逻辑调用，因为它只能是true或者false。Swift提供了两个布尔常量值，true和falseL</p>
<pre><code>let orangesAreOrange = true
let turnipsAreDelicious = false</code></pre>

<p>orangesAreOrange 和 turnipsAreDelicious 的类型被推断是Bool。同上面的Int 和 Double 一样，你不需要声明常量或者变量为Bool</p>
<p>布尔值在if 语句这种条件语句中尤其有用：</p>
<pre><code>if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// Prints "Eww, turnips are horrible."</code></pre>

<p>Swift 类型安全防止非布尔值被替换成布尔值。下面的例子报一个编译错误：</p>
<pre><code>let i = 1
if i {
    // this example will not compile, and will report an error
}</code></pre>

<p>替代的例子如下：</p>
<pre><code>let i = 1
if i == 1 {
    // this example will compile successfully
}</code></pre>

<p>i==1比较的结果是Boo类型，所以第二个例子通过了类型检查。</p>
<p>和其他类型安全例子一样，这个方法避免了突发的错误，确保特别代码块推断总是清晰的。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>Tuples 包含多值到一个单独的组合值。元组里的值可以是任何类型，彼此之间可以是不同类型。</p>
<p>在这个例子中，(404, “Not Found”)是一个元组，代表Http的错误码。一个Http错误码是访问网页时网页服务器返回的特殊数值。如果你请求的网页不存在，就会返回404 Not Found的错误码。</p>
<pre><code>let http404Error = (404, "Not Found")
// http404Error is of type (Int, String), and equals (404, "Not Found")</code></pre>

<p>(404, “Not Found”) 元组包含了一个Int 和一个String，一个数字和一个人工可读的描述。它可以描述成一个类型为（Int, String）的元组。</p>
<p>你可以用任何变化的类型创建元组，你可以按照需要要创建不同的元组。</p>
<p>你可以分解元组到分离的常量或者变量，通常你会访问它们：</p>
<pre><code>let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// Prints "The status code is 404"
print("The status message is \(statusMessage)")
// Prints "The status message is Not Found"</code></pre>

<p>如果你只需要元组中的某些值，当你分解元组的时候可以用下划线替换忽略的部分：</p>
<pre><code>let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// Prints "The status code is 404"</code></pre>

<p>或者，通过下标访问元组中单独的元素值：</p>
<pre><code>print("The status code is \(http404Error.0)")
// Prints "The status code is 404"
print("The status message is \(http404Error.1)")
// Prints "The status message is Not Found"</code></pre>

<p>你可以在元组定义时，给单独的原色命名：</p>
<pre><code>let http200Status = (statusCode: 200, description: "OK")</code></pre>

<p>如果你在元组中命名了元素，那么，你可以在访问元素值的时候通过名字访问它们的值：</p>
<pre><code>print("The status code is \(http200Status.statusCode)")
// Prints "The status code is 200"
print("The status message is \(http200Status.description)")
// Prints "The status message is OK"</code></pre>

<h1 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h1><p>当一个值可能缺失的时候使用optionals。一个可选值包含两种可能：或者有一个值，你可以通过拆包访问这个值，或者根本没有值。</p>
<p>这里有一个例子，说明可选类型如何在值缺失的时候使用。Swift 的Int 类型有一个初始化器，可以把String 转换为Int 值。不过，不是每一个字符串都可以转换的。“123”可以转换为123，但是“helloworld”就不可以。</p>
<p>下面的例子使用初始化器去转换String：</p>
<pre><code>let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"</code></pre>

<p>因为初始化器有可能失败，所以它返回一个optional Int，而不是Int。一个可选Int写作Int？，不是Int。问号表示包含的值是可选的，意思就是它可能包含某个Int值，也可能不包含任何值。</p>
<h1 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h1><p>通过赋值nil来把可选值设置成无值状态：</p>
<pre><code>var serverResponseCode: Int? = 404
// serverResponseCode contains an actual Int value of 404
serverResponseCode = nil
// serverResponseCode now contains no value</code></pre>

<p>如果如果定义一个可选变量，但是没有提供默认值，这个变量会被自动设置为nil：</p>
<pre><code>var surveyAnswer: String?
// surveyAnswer is automatically set to nil</code></pre>

<h1 id="if语句和强制拆包"><a href="#if语句和强制拆包" class="headerlink" title="if语句和强制拆包"></a>if语句和强制拆包</h1><p>用if语句，通过与nil做比较，你可以知道一个可选项是否包含一个值，用（==）或者（！=）来做比较。如果一个可选项有值，那么它不等于ni：</p>
<pre><code>if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// Prints "convertedNumber contains some integer value."</code></pre>

<p>一旦你确定可选项包含一个值，你可以通过在可选项的名字后面加（！）来获取它的值。这个感叹号是说：我知道这个可选项一定有值；请使用它！这就是强制拆包获取可选项的值：</p>
<pre><code>if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// Prints "convertedNumber has an integer value of 123."</code></pre>


<h1 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h1><p>使用optional binding找出一个可选项是否包含一个值。如果这样的话，使这个值作为一个临时常量或者变量。可选绑定用if和while语句来判断可选项的值，然后提取这个值到常量或者变量，作为操作的一部分。</p>
<p>用if语句写可选绑定像下面这样：</p>
<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>

<p>你可以重写possibleNumber实例，通过使用可选绑定而不是强制拆包：</p>
<pre><code> if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" could not be converted to an integer")
}
// Prints ""123" has an integer value of 123"</code></pre>

<p>代码可以这样解释;<br>如果Int（possibleNumber）返回的可选Int包含一个值，设置一个新的常量叫actualNumber，它的值就是包含在可选项中的值。</p>
<p>如果转换成功，actualNumber 常量变的可用，执行第一个分支的语句。因为已经初始化了可选项的值，所以不需要用感叹号去拆包。</p>
<p>你可以同时使用常量和变量，如果你想操作if语句第一个分支里的actualNumber，你可能要写 if var actualNumber来替换代码，然后可选项的值会变成变量值而不是常量值。</p>
<p>你可以在单独的if语句包括尽可能多的可选绑定和布尔条件，用逗号分开即可。如果任何可选项的值为nil或者布尔条件等于false，if条件被认为是false。下面的if语句是一样的：</p>
<pre><code>if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"</code></pre>

<h1 id="隐式拆包可选项"><a href="#隐式拆包可选项" class="headerlink" title="隐式拆包可选项"></a>隐式拆包可选项</h1><p>如上所述，可选项表示一个常量或者变量可以没有值。可选项可以用if语句判断是否存在值，如果不存在，可以有条件用可选绑定拆包来访问可选项的值。</p>
<p>有时候，通过程序的结构可以很清楚的知道可选项有值，然后这个值被第一次设置。这种情况，就不需要每次都判断和拆包了，因为可以安全的假设总是有值。</p>
<p>这种可选项定义为隐式拆包可选项。隐式拆包可选项的写法是，在类型后面假设感叹号而不是问号。</p>
<p>当可选项的值在首次定义后就能确定存在的事，隐式拆包可选项很有用。隐式拆包可选项主要用在类的初始化。</p>
<p>隐式拆包可选项在这种场景下，是正常可选项，但是也可以用作一个非可选项，无需每次访问都拆包。下面的例子展示了，可选字符串和隐式拆包可选项字符串作为显示String时访问它们包含的值的不同行为。</p>
<pre><code>let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark</code></pre>

<p>你依然可以把隐式拆包可选项当做正常的可选项，来判断它是否包含一个值：</p>
<pre><code>if assumedString != nil {
    print(assumedString)
}
// Prints "An implicitly unwrapped optional string."</code></pre>

<p>你可以结合可选绑定来使用隐式拆包可选项，然后在一行语句中判断和拆包它的值：</p>
<pre><code>if let definiteString = assumedString {
    print(definiteString)
}
// Prints "An implicitly unwrapped optional string."</code></pre>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>使用error handling 响应程序执行中错误条件。<br>与可选项做对照，可选项用有无值来表示一个函数的成功失败，错误处理允许你检测迁走的失败原因，同时如果必要的话，会把错误传递到程序的另外一部分。</p>
<p>当函数遇到一个错误情况，它就会throws 一个错误。函数调用者可以捕获这个错并正确响应。</p>
<pre><code>func canThrowAnError() throws {
    // this function may or may not throw an error
}</code></pre>

<p>一个函数表明它可以通过在定义中包含throws关键词来抛出一个错误。当你调用这个可以抛出错误的函数时，你要准备try关键词。</p>
<p>Swift 自动把错误往外抛知道它被一个catch语句处理。</p>
<pre><code>do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}</code></pre>

<p>do 语句创建了一个代码块，它允许错误可以传递给一个或者多个catch 项。</p>
<p>这里有一个列子，展示响应不同错误条件的错误处理方式：</p>
<pre><code>func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}</code></pre>

<p>在这个例子里，如果没有干净的餐具可用或者任何调料确实，makeASandwich将会抛出一个错误。因为makeASandwich可以抛出错误，所以函数调用包含在try表达式。经过do语句包含处理，任何抛出的错误都会传递到catch项。</p>
<p>如果没有错误抛出，eatASandwich函数会被调用。如果一个错误抛出然后匹配SandwichError.outOfCleanDishes这个条件，那么washDishes会被调用。如果一个错误抛出然后匹配SandwichError.missingIngredients条件，那么buyGroceries会被调用</p>
<h1 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h1><p>operator 是特殊的符号或者短语，用来检查，改变，或者合并数值。比如，加号（+）用来加两个数值，比如 let = 1 + 2，逻辑与（&amp;&amp;）合并两个布尔值，比如 enteredDoorCode &amp;&amp; passedRetinaScan<br>Swift支持大部分的C语言操作符，并且提升了消除一般编码错误的能力。赋值运算符（=）不会返回一个值，用来防止错误是使用（==）。算数运算符—（+，-，*，/，%等等）监测和拒绝值溢出，为了避免值溢出造成未知的结果。你可以用Swift的溢出运算符选择值溢出行为。</p>
<p>Swift同时提供了两个范围运算符（a..&lt;b和a…b），这在C语言里没有。这些作为表达一个范围值的快捷方式。</p>
<p>这个章节介绍Swift的普通运算符。Advanced Operators 包含了Swift的高级运算符，描述如何定义你自己的运算符，然后为你自定义的类型实现标准运算符。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>运算符是一元的，二元的，或者三元的：<br>    一元运算符操作单一目标（比如-a）。一元前缀操作费直接写在目标前（比如！b），一元后缀操作费则直接出现在目标后（比如c！）。<br>    二元运算符操作两个目标（比如2+3），并且出现在两个目标的中间。<br>    三元运算符操作三个目标，跟C语言一样，Swift 只有一个三元运算符，也就是三元条件运算符（a ？b ：c）。<br>运算符作用的值是操作数。在表达式1+2里，+号是二元运算符，两个操作数分别是1和2.</p>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>assignment operator（a=b）用b的值初始化或者更新a的值。</p>
<pre><code>let b = 10
var a = 5
a = b
// a is now equal to 10</code></pre>
如果赋值语句的右侧是多值的元组，它的元素可以一次分解为多个常量或者变量：

<pre><code>let (x, y) = (1, 2)
// x is equal to 1, and y is equal to 2</code></pre>
与C语言 和 Objective-C语言不同，Swift赋值运算符自身不返回值。下面的语句是无效的：

<pre><code>if x = y {
    // This is not valid, because x = y does not return a value.
}</code></pre>

<p>这个特性防止=与==混淆。 让if x = y 无效, Swift 帮你避免这种错误。</p>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>Swift 对所有类型支持四种标准算术运算符:</p>
<p>加号 (+)<br>减号 (-)<br>乘号 (<em>)<br>除号 (/)<br>1 + 2   // 等于 3<br>5 - 3       // 等于 2<br>2 </em> 3       // 等于 6<br>10.0 / 2.5  // 等于 4.0<br>与C语言 和 Objective-C语言不同, Swift 算术运算符默认不允许值溢出。 你可以通过Swift溢出运算符来选择值溢出行为(例如 a &amp;+ b)。</p>
<p>加号也支持字符串连接:</p>
<pre><code>"hello, " + "world"  // 等于 "hello, world"</code></pre>

<h1 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h1><p>余数运算符 (a % b) 计算a中b的倍数，并且返回余数。</p>
<p>备注</p>
<p>余数运算符 (%) 在其他语言中作为取模运算符。 不过, 在 Swift 中对负数来说, 严格来讲, 它是余数而不是一个取模运算。</p>
<p>下面演示余数运算符是如何工作的。 计算 9 % 4, 你首先算出9里有多少个4:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png"><br></div>

<p>你可以确定9里有两个4, 余数是 1 (橙色显示)。</p>
<p>在 Swift 里, 这个会写作:</p>
<pre><code>9 % 4    // 等于 1</code></pre>
为了确定 a % b 的结果, % 运算符计算下面的方程式，然后返回余数作为输出:

a = (b x 倍数) + 余数

这里倍数是a里面b的最大倍数。

把 9 和 4 代入方程式值域:

<pre><code>9 = (4 x 2) + 1</code></pre>

<p>计算负值a的余数也是用相同的方法:</p>
<pre><code>-9 % 4   // 等于 -1</code></pre>
把 -9 和 4 代入方程式值域:

<pre><code>-9 = (4 x -2) + -1</code></pre>

<p>活的余数 -1.</p>
<p>负值b被忽略。 意思就是 a % b 和 a % -b 结果是一样的。</p>
<h1 id="一元减法运算符"><a href="#一元减法运算符" class="headerlink" title="一元减法运算符"></a>一元减法运算符</h1><p>数值符号可以用前缀 - 连接, 也就是大家熟知的一元减法运算符:</p>
<pre><code>
let three = 3
let minusThree = -three       // minusThree equals -3
let plusThree = -minusThree   // plusThree equals 3, or "minus minus three"
</code></pre>
一元减法运算符 (-) 直接放在操作数前, 没有空格。

# 一元加法运算符

一元加法运算符 (+) 返回操作数值, 没有任何改变:
<pre><code>
let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6
</code></pre>
尽管一元加法运算符实际上不做任何事, 你可以用它来提供对称的代码，当在代码中使用正负数的时候。

# 复合赋值运算符

和 C 语言相似, Swift 提供复合赋值运算符来合并赋值 (=) 和其他操作数。 一个例子就是加法赋值运算符 (+=):
<pre><code>
var a = 1
a += 2
// a 现在等于 3
</code></pre>
表达式 a += 2 是 a = a + 2 的快捷方式。 实际上, 加法和赋值合并进一个操作符，同时做了两件事。

备注

复合赋值运算符不返回值。 比如, 你不能这样写 let b = a += 2.

# 比较运算符

Swift 支持所有标准C语言比较运算符:

等于 (a == b)
不等于 (a != b)
大于 (a > b)
小于 (a < b)
大于等于 (a >= b)
小于等于 (a <= 1="=" 2="" b)="" 备注="" swift="" 同时提供两个相等运算符="" (="==" and="" !="=)," 你可以用来测试两个对象引用是否引用了相同的对象实例。="" 更多信息参考="" classes="" structures.="" 每个比较运算符都返回一个布尔值，来表明语句是否是真的:="" 真，因为1="" 等于="" 真，因为2="" 不等于=""> 1    // 真，因为2 大于 1
1 < 2    // 真，因为1 小于 2
1 >= 1   // 真，因为1大于或者等于1
2 <= 1="" 假，因为2不小于或者等于1="" 比较运算符通常用于条件语句,="" 例如if语句:="" <pre=""><code>
let name = "world"
if name == "world" {
    print("hello, world")
} else {
    print("I'm sorry \(name), but I don't recognize you")
}
// Prints "hello, world", because name is indeed equal to "world".
</code>
更多if语句, 参考 Control Flow.

你可以比较含有相同数量值的元组, 只要元组里的值可以比较。 例如, Int 和 String 可以比较, 意思就是 (Int, String) 可以比较。 相反, Bool 不能比较, 意思就是包含布尔值的元组不能作比较。

元组是从左到右做比较的, 每次一个值, 直到比较发现两个值不等为止。 这两个被比较的值, 比较的结果决定了整个元组比较的结果。 如果所有元素都相等, 那么元组就是相等的。例如:
<pre><code>
(1, "zebra") < (2, "apple")   // 真，因为1小于2; "zebra" 和 "apple" 不比较
(3, "apple") < (3, "bird")    // 真，以为3等于3, "apple" 小于 "bird"
(4, "dog") == (4, "dog")      // 真，因为4等于4, "dog" 等于 "dog"
</code></pre>
上面这个例子, 在第一行你可以看见从左到右比较的行为。 因为1小于2, (1, "zebra") 被认为小于 (2, "apple"), 不用管元组里的其他值。 不管 "zebra" 是不是小于 "apple", 因为比较已经取决于元组里的第一个元素了。 不过, 当元组第一个元素相等的时候，比较就像第二行，第三行发生的那样。

# 三元条件运算符

三元条件运算符是含有三部分的特殊运算符, 样式是 问题 ? 答案1 : 答案2。 这是基于问题是真假对表达式之一的判断。 如果问题是真, 求 answer1 的值并返回; 否则, 求 answer2 的值并返回。

三元条件运算符是下面代码的简写:
<pre><code>
if question {
    answer1
} else {
    answer2
}
</code></pre>
这里有一个例子, 用例计算列表行高。 如果行有头部，那么行高比内容高度加50，如果没有头部，那么高度加20:
<pre><code>
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight is equal to 90

let contentHeight = 40
let hasHeader = true
let rowHeight: Int
if hasHeader {
    rowHeight = contentHeight + 50
} else {
    rowHeight = contentHeight + 20
}
// rowHeight is equal to 90
</code></pre>
第一个例子使用三元条件运算符，意味着行高可以在一行代码里正确设置, 这个比第二个例子的代码要简洁。

三元条件运算符提供一个简写，来决定使用两个表达式中的哪一个。 小心使用三元条件运算符。 过度使用，代码就是很难理解。 尽量避免把三元条件运算符的多个实例合并到一个符合语句。

# Nil-联合运算符

nil-联合运算符 (a ?? b) 展开一个可选项 a 如果它包含一个值的话, 或者返回一个默认值 b 如果 a 是 nil。 表达式 a 总是一个可选类型。 表达式 b 必须匹配存储在a里的值类型。

nil-联合运算符是下面代码的简写:

a != nil ? a! : b
上面的代码使用三元条件运算符,然后强制展开 (a!) 来获取a中的值，如果这个值不空的话, 否则返回 b 。 nil-联合运算符提供了更优雅简洁的方式来压缩这个条件判断和展开。

备注

如果值非空, b的值不会得到。 这就是人们熟知的短路估算。

下面的例子使用 nil-联合运算符在默认颜色名称和可选用户定义的颜色名称之间做选择:
<pre><code>
let defaultColorName = "red"
var userDefinedColorName: String?   // 默认是 nil

var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName 是 nil, 所以colorNameToUse 设置成默认值 "red"
</code></pre>
userDefinedColorName 变量定义成可选的 String, 默认值是 nil. 因为 userDefinedColorName 是个可选类型, 你可以使用nil-联合运算符来获取它的值。 上面的例子, 运算符用来决定变量 colorNameToUse 的一个初始值。 因为 userDefinedColorName 是 nil,  userDefinedColorName ?? defaultColorName 表达式返回了defaultColorName 的值, 或者 "red".

如果你给 userDefinedColorName 赋了一个非空的值，然后执行 nil-联合运算符再次判断, userDefinedColorName 中包含的值 就取代了默认值:
<pre><code>
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName is not nil, so colorNameToUse is set to "green"
</code></pre>

<h1 id="范围运算符"><a href="#范围运算符" class="headerlink" title="范围运算符"></a>范围运算符</h1><p>Swift 有两个范围运算符, 是表达值范围的简写。</p>
<h1 id="闭合区间运算符"><a href="#闭合区间运算符" class="headerlink" title="闭合区间运算符"></a>闭合区间运算符</h1><p>闭合区间运算符 (a…b) 定义从a到b的范围, 包含a和b的值。 a的值不能比b大。</p>
<p>闭合区间运算符在范围迭代很有用，特别是你想使用所有的值的时候。例如 for-in 循环:</p>
<pre><code>
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
</code></pre>
更多 for-in 循环, 参考 Control Flow.

# 半开区间运算符

半开区间运算符 (a..<b) 定义了从a到b的范围,="" 但是不包含b，="" 之所以成为半开是因为它包含初值,="" 但是不包含终值。="" 正如闭合区间运算符,="" a的值不能大于b。="" 如果a的值等于b的值,="" 这个范围就会是空的。="" 半开区间在你使用类似数组这种基于零的列表时非常有用,="" 计算列表长度="" (但是不包括)="" 很有帮助:="" <pre=""><code>
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count 1="" 2="" 3="" 4="" {="" print("person="" \(i="" +="" 1)="" is="" called="" \(names[i])")="" }="" person="" anna="" alex="" brian="" jack="" <="" code="">
数组包含4项, 不过 0..<count 只计算到3="" (数组最后一项的索引),="" 因为是半开区间。="" 更多数组,="" 参见="" arrays.="" #="" 逻辑运算符="" 逻辑运算符改变或者合并布尔值真和假。="" swift="" 支持三种基于c语言的标准逻辑运算符:="" 逻辑非="" (!a)="" 逻辑与="" (a="" &&="" b)="" 逻辑或="" ||="" 逻辑非运算符="" 反转布尔值，这样真就变成假,="" 假变成了真。="" 逻辑非运算符是个前缀运算符,="" 直接写在操作数前面,="" 没有任何空格。="" 可以读作="" “not="" a”,="" 下面的例子可以看到:="" <pre=""><code>
let allowedEntry = false
if !allowedEntry {
    print("ACCESS DENIED")
}
// Prints "ACCESS DENIED"
</code>
语句 if !allowedEntry 可以读作 “if not allowed entry.” 后面一行仅执行 “not allowed entry” 是 true; 也就是, if allowedEntry 是 false.

在这个例子中, 谨慎定义布尔常量和变量名，可以让代码具有可读性和简洁性, 同时避免双重否定或者混乱的逻辑语句。

# 逻辑与运算符

逻辑与运算符 (a && b) 创建逻辑表达式，这个表达式中两个值为真，表达式也要为真。

如果任何一个值为假, 表达式的结果也将是假。 事实上, 如果第一个值为假, 第二个值不会再计算, 因为它不会让所有表达式都等于真。 这就是人们熟知的短路估值。

这个例子有两个布尔值，只有两个值都是真的时候才允许访问:
<pre><code>
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Prints "ACCESS DENIED"
</code></pre>
# 逻辑或运算符

逻辑或运算符 (a || b) 是两个竖线组成的中间运算符。 用来创建逻辑表达式，这个表达式中只要有一个值为真，表达式的结果就是真。

跟上面逻辑与类似, 逻辑或使用短路估值去计算表达式。 如果逻辑或的左侧是真, 右侧就不再估值, 因为它不会改变整个表达式的结果。

下面的例子, 第一个布尔值 (hasDoorKey) 是假, 但是第二个布尔值 (knowsOverridePassword) 是真。 因为一个值为真, 表达式结果就是真, 所以允许访问:
<pre><code>
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Prints "Welcome!"
</code></pre>
# 合并逻辑运算符

你可以合并多个逻辑运算符来创建更长的复合表达式:
<pre><code>
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Prints "Welcome!"
</code></pre>
这个例子使用了多个 && 和 || 运算符来创建一个更长的复合表达式。 不过, && 和 || 运算符依然只能操作两个值, 所以，这实际上是三个小表达式链接起来的。 

备注

Swift 逻辑运算符 && 和 || 是左联想的, 意思就是多个逻辑运算符的复合表达式，首先计算最左边的子表达式。
# 显示括号

虽然不是严格需要，但是包含括号还是有用的, 使得复杂表达式的意图很容易理解。 上述实例, 给第一部分加上括号很有用，会让它的意图很明显:
<pre><code>
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Prints "Welcome!"
</code></pre>
括号让第一部分作为独立可能的状态，这样在整个逻辑中就很清晰。 符合表达式的输出不变, 但是整体意图很清晰。 比起简洁，可读性是首选的。使用括号会让你的意图清晰明了。


# 字符串和字符
字符串是字符集合, 比如 "hello, world" 或者 "albatross". Swift 字符串用 String 类型表示。 字符串内容有多种访问方法, 包括字符值的集合。

Swift的 String 和 Character 类型提供一个快速的, Unicode 方式来作用于你的文本。 字符串创建和操作的语法是轻量和可读的, 字面语法跟C类似。 字符串连接和使用加号运算符一样简单, 字符的可变性由选择常量还是变量来管理, 就像Swift中其他值。 你还可以使用字符串把常量,变量,字面量,和表达式插入更长的字符串, 在一个众所周知的字符串插值。 这让显示自定义字符串变得容易。

尽快语法简单, Swift的 String 类型是个快速, 现代化的字符串实现。 每个字符串有独立编码的 Unicode 字符组成, 提供用多种Unicode形式访问这些字符的支持。

# 字符串字面量

你可以在代码中为字符串预定义字符值。 字符串字面量是由（""）包围的固定的文字字符序列。

用字符串值作为一个常量或者变量的初始值:

<pre><code>let someString = "Some string literal value"</code></pre>
注意 Swift 推断someString 常量是一个 String 类型, 因为它用字符串值初始化。
# 初始化空字符串

创建空字符串值作为更长字符串的起点, 或者给一个变量赋一个空字符串值, 或者用初始化方法来初始化一个新的字符串实例:
<pre><code>
var emptyString = ""               // empty string literal
var anotherEmptyString = String()  // initializer syntax
// these two strings are both empty, and are equivalent to each other
Find out whether a String value is empty by checking its Boolean isEmpty property:

if emptyString.isEmpty {
    print("Nothing to see here")
}
// Prints "Nothing to see here"
</code></pre>

<h1 id="字符串易变性"><a href="#字符串易变性" class="headerlink" title="字符串易变性"></a>字符串易变性</h1><p>你来指定一个特定字符串能不能改变（或者突变），这种变化通过把它赋给一个变量实现。 (这种情况它是可以改变的), 或者赋值给一个常量实现 (这种情况它不能被改变):</p>
<pre><code>
var variableString = "Horse"
variableString += " and carriage"
// variableString is now "Horse and carriage"

let constantString = "Highlander"
constantString += " and another Highlander"
// this reports a compile-time error - a constant string cannot be modified
</code></pre>
# 字符串是值类型

Swift 的字符串类型是值类型。 如果你创建了一个新的字符串值, 这个字符串值在传给函数或者方法的时候被复制, 或者当它被赋值给一个常量或者变量的时候。这两种情况, 已存在字符串值的拷贝被创建, 新的拷贝被传递或者赋值, 而不是原来的字符串。 值类型在 Structures and Enumerations Are Value Types 中有描述。

很清楚你拥有精确的字符串值，而不用关心它从哪里来的。你可以确信传给你的字符串不会被改变,除非你自己改变它。

在幕后, Swift 的编译器优化了字符串的使用，这使得实际的拷贝只有真正需要的时候才会占用空间。 这就意味你使用字符串作为值类型总可以获得高性能。

# 使用字符

你可以用for-in 循环语句,通过它的字符属性来迭代访问每一个单独的字符:
<pre><code>
for character in "Dog!🐶".characters {
    print(character)
}
// D
// o
// g
// !
// 🐶
</code></pre>

<p>或者, 你可以创建一个单独的字符常量或者变量，这变量通过提供一个字符类型注释的单字符字符串值。:</p>
<pre><code>
let exclamationMark: Character = "!"
String values can be constructed by passing an array of Character values as an argument to its initializer:

let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]
let catString = String(catCharacters)
print(catString)
// Prints "Cat!🐱"
</code></pre>
# 连接字符串和字符

字符串值可以通过加号连接成新的字符串:
<pre><code>
let string1 = "hello"
let string2 = " there"
var welcome = string1 + string2
// welcome now equals "hello there"
</code></pre>
你也可以通过赋值运算符（+=）把字符串添加到已存在的字符串变量:
<pre><code>
var instruction = "look over"
instruction += string2
// instruction now equals "look over there"
You can append a Character value to a String variable with the String type’s append() method:

let exclamationMark: Character = "!"
welcome.append(exclamationMark)
// welcome now equals "hello there!"
</code></pre>
# 字符串插入

String 字符串插入是构建新字符串的一种方法，这种方法通过混合常量,变量,字面量,表达式中的字面量来实现。每个你要插入的值都包括在括弧里,前面是一个反斜杠:
<pre><code>
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// message is "3 times 2.5 is 7.5"
</code></pre>
上面这个例子,  multiplier 的值以 \(multiplier) 的形式插入到一个字符串。 这个占位符会被 multiplier 的实际值取代，当插值被计算创建新字符串的时候。

multiplier 的值是字符串后面大表达式的一部分。 这个表达式计算 Double(multiplier) * 2.5 的值，然后把结果 (7.5) 插入字符串。 这种情况下, 当它被包括进字符串字面量的时候，表达式就写作 \(Double(multiplier) * 2.5) .
# Unicode

Unicode 是在不同写作体系中用作编码,表达,处理文字的一种国际标准。 让你可以用一种标准形式表示任何语言的任何字符, 在诸如文本文件或者网页等外部资源,去读写这些字符。 Swift 的字符串和字符是完全 Unicode 编译的。

# Unicode 标量

背后, Swift 的本地字符串类型建立于 Unicode 标量值。对应字符或者修饰符来说, 一个 Unicode 标量是唯一的一个21位数字, 例如 U+0061 是 LATIN SMALL LETTER A ("a"), 或者 U+1F425 是 FRONT-FACING BABY CHICK ("🐥").
注意并非所有 21-位 Unicode 标量都会被赋值给一些给未来预留的字符标量。 分配给字符的标量通常有一个名字, 比如 LATIN SMALL LETTER A 和 FRONT-FACING BABY CHICK .

# 字符串字面量里的特殊字符

字符串字面量可以包括下面的特殊字符:

转义字符 \0 (空字符), \\ (反斜杠), \t (水平制表符), \n (换行), \r (回车), \" (双引号) and \' (单引号)
任意一个 Unicode 标量, 写作 \u{n}, n 是 一个 1–8 位十六进制数字，这个数字有个和 有效的Unicode 编码点相等的值。
下面四个例子显示了特殊字符的编码。wiseWords 常量包括两个转义的双引号字符。 dollarSign, blackHeart, 和sparklingHeart 常量展示了Unicode 标量的格式:
<pre><code>
let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
// "Imagination is more important than knowledge" - Einstein
let dollarSign = "\u{24}"        // $,  Unicode scalar U+0024
let blackHeart = "\u{2665}"      // ♥,  Unicode scalar U+2665
let sparklingHeart = "\u{1F496}" // 💖, Unicode scalar U+1F496
</code></pre>
# 扩展字形集

Swift的每个字符类型的实例带包一个单独的扩展字形集。 一个扩展字形集是一个或者多个 Unicode 标量，这些标量（当合并时）生成一个人可读的字符。

这里有个例子。 字符 é 可以表示成单独的 Unicode 标量 é (LATIN SMALL LETTER E WITH ACUTE, 或者 U+00E9). 不过, 相同的字母也可以表示成标量集的一部分，字母 e (LATIN SMALL LETTER E, or U+0065), 后面跟着 COMBINING ACUTE ACCENT 标量 (U+0301).COMBINING ACUTE ACCENT 标量 应用于之前的标量, 在一个Unicode识别 文本渲染系统渲染的时候，把 e 变成 é.

在这两个例子里, 字符 é 表示为一个单独的Swift 字符值，这个值表示一个扩展字形集。 第一个例子, 集合包含一个单独的标量; 第二个例子, 是两个标量的集合:
<pre><code>
let eAcute: Character = "\u{E9}"                         // é
let combinedEAcute: Character = "\u{65}\u{301}"          // e followed by ́
// eAcute is é, combinedEAcute is é
</code></pre>
扩展字形集是一种灵活的方式去表示很多复杂脚本字符作为单独字符值。 比如, 来自朝鲜字母的朝鲜语音节可以表示成复合或者分离的序列。 在Swift里,这些表达都是合格的字符值:
<pre><code>
let precomposed: Character = "\u{D55C}"                  // 한
let decomposed: Character = "\u{1112}\u{1161}\u{11AB}"   // ᄒ, ᅡ, ᆫ
// precomposed is 한, decomposed is 한
</code></pre>
扩展字形集使得封闭标志的标量 (比如 COMBINING ENCLOSING CIRCLE, 或者 U+20DD) 可以装入其他 Unicode 标量作为一个单独字符值的一部分:
<pre><code>
let enclosedEAcute: Character = "\u{E9}\u{20DD}"
// enclosedEAcute is é⃝
</code></pre>
Unicode 局部指示器符号标量可以成对组合来生成一个单独的字符值, 比如 REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA) 和 REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8) 的组合:
<pre><code>
let regionalIndicatorForUS: Character = "\u{1F1FA}\u{1F1F8}"
// regionalIndicatorForUS is 🇺🇸
</code></pre>
# 计算字符

在字符串中获取字符值的数量, 可以使用字符串字符属性中的计数属性:
<pre><code>
let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
print("unusualMenagerie has \(unusualMenagerie.characters.count) characters")
// Prints "unusualMenagerie has 40 characters"
</code></pre>
注意 Swift 对字符值使用扩展字形集，意味着字符拼接和修改可能不会总是影响字符串的字符数。

例如, 如果你用四个字符的单词咖啡来初始化一个新字符串, 然后添加 COMBINING ACUTE ACCENT (U+0301) 到字符串的尾部, 最后字符的数量还是4, 第四个字符是 é, 而不是 e:
<pre><code>
var word = "cafe"
print("the number of characters in \(word) is \(word.characters.count)")
// Prints "the number of characters in cafe is 4"

word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301

print("the number of characters in \(word) is \(word.characters.count)")
// Prints "the number of characters in café is 4"
</code></pre>
# 访问和修改字符串

你可以通过方法和属性来访问和修改字符串, 或者用下标语法。

# 字符串索引

每个字符串值都有一个对应的索引类型, String.Index, 代表每个字符在字符串中的位置。

上面提到的,不同字符要求不等数量的内存, 所以为了决定哪个字符在一个特定的位置, 你必须从头到尾枚举每个 Unicode 标量。 因为这个原因, Swift 字符串不能通过整数值来索引。

使用 startIndex 属性访问字符串的首字符位置。 endIndex 属性是字符串中最后一个字符的位置。 因此, endIndex 属性不是一个字符串下标的有效参数。 如果一个字符串是空的, startIndex 和 endIndex 相等。

你可以用 index(before:) 和 index(after:) 字符串方法访问给定索引前后的索引, 你可以使用 index(_:offsetBy:) 方法代替多次调用这些方法。

你可以使用下标语法访问特定索引位置的字符。
<pre><code>
let greeting = "Guten Tag!"
greeting[greeting.startIndex]
// G
greeting[greeting.index(before: greeting.endIndex)]
// !
greeting[greeting.index(after: greeting.startIndex)]
// u
let index = greeting.index(greeting.startIndex, offsetBy: 7)
greeting[index]
// a
</code></pre>
尝试访问越界的索引和字符都会引发运行时的错误。
<pre><code>
greeting[greeting.endIndex] // Error
greeting.index(after: greeting.endIndex) // Error
</code></pre>
用字符属性中的索引属性获取字符串中的所有字符。
<pre><code>
for index in greeting.characters.indices {
    print("\(greeting[index]) ", terminator: "")
}
// Prints "G u t e n   T a g ! "
</code></pre>
# 插入和移除

在特定位置向字符串插入一个字符, 使用 insert(_:at:) 方法, 插入其他字符串内容到制定索引使用 insert(contentsOf:at:) 方法。
<pre><code>
var welcome = "hello"
welcome.insert("!", at: welcome.endIndex)
// welcome now equals "hello!"

welcome.insert(contentsOf:" there".characters, at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 "hello there!"
</code></pre>
从指定索引移除字符, 使用 remove(at:) 方法, 在指定范围移除一个字串, 用 removeSubrange(_:) 方法:
<pre><code>
welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 "hello there"

let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endindex welcome.removesubrange(range)="" welcome="" 现在等于="" "hello"="" <="" code=""></welcome.endindex></code></pre>
备注

你可以使用 insert(_:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(_:) 这些方法,只要符合 RangeReplaceableCollection 协议的任何类型。 这包括 String, 还有集合类型 Array, Dictionary, 和 Set.

# 比较字符串

Swift 提供三种方式来比较文本值: 字符串和字符等式, 前缀等式, 和后缀等式。

# 字符串和字符等式

字符串和字符等式用“equal to” 运算符 (==) 和 “not equal to” 运算符 (!=) 来判断, 在 Comparison Operators 中描述:
<pre><code>
let quotation = "We're a lot alike, you and I."
let sameQuotation = "We're a lot alike, you and I."
if quotation == sameQuotation {
    print("These two strings are considered equal")
}
// Prints "These two strings are considered equal"
</code></pre>
两个字符串的值 (或者两个字符的值) 如果他们的扩展字形集相同,就被认为是相等的。 扩展字形集如果有相同的语义和表现形式，就是相等的, 即使他们背后是由不同 Unicode 标量组成。

比如, LATIN SMALL LETTER E WITH ACUTE (U+00E9) 常规等于 LATIN SMALL LETTER E (U+0065) 加上 COMBINING ACUTE ACCENT (U+0301). 两种扩展字形集都是有效的方式来表示字符 é, 隐藏它们被认为相等:
<pre><code>
// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"

// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"

if eAcuteQuestion == combinedEAcuteQuestion {
    print("These two strings are considered equal")
}
// Prints "These two strings are considered equal"
</code></pre>
相反, LATIN CAPITAL LETTER A (U+0041, 或者 "A"), 英语中使用, 不等于俄语中使用的 CYRILLIC CAPITAL LETTER A (U+0410, 或者 "А")。 这两个字符看上去相似, 但是语义不同:
<pre><code>
let latinCapitalLetterA: Character = "\u{41}"

let cyrillicCapitalLetterA: Character = "\u{0410}"

if latinCapitalLetterA != cyrillicCapitalLetterA {
    print("These two characters are not equivalent.")
}
// Prints "These two characters are not equivalent."
</code></pre>
备注

字符串和字符比较在Swift中不是地区敏感的。

# 前缀和后缀等式

判断字符串是否有一个特定前缀或者后缀, 调用字符串的 hasPrefix(_:) and hasSuffix(_:) 方法, 两个方法都一个 String 类型，然后返回一个布尔值。 

下面这个例子有一个字符串数组，用来表示场景的位置,它们来自莎士比亚的罗密欧与朱丽叶的前两个表演:
<pre><code>
let romeoAndJuliet = [
    "Act 1 Scene 1: Verona, A public place",
    "Act 1 Scene 2: Capulet's mansion",
    "Act 1 Scene 3: A room in Capulet's mansion",
    "Act 1 Scene 4: A street outside Capulet's mansion",
    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
    "Act 2 Scene 1: Outside Capulet's mansion",
    "Act 2 Scene 2: Capulet's orchard",
    "Act 2 Scene 3: Outside Friar Lawrence's cell",
    "Act 2 Scene 4: A street in Verona",
    "Act 2 Scene 5: Capulet's mansion",
    "Act 2 Scene 6: Friar Lawrence's cell"
]
</code></pre>
你可以用 hasPrefix(_:) 方法用 romeoAndJuliet 数组来技术表演1中的场景数:
<pre><code>
var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix("Act 1 ") {
        act1SceneCount += 1
    }
}
print("There are \(act1SceneCount) scenes in Act 1")
// Prints "There are 5 scenes in Act 1"
</code></pre>
相似的, 用 hasSuffix(_:) 方法来计算发生在 Capulet’s mansion 和 Friar Lawrence’s cell 的场景数:
<pre><code>
var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix("Capulet's mansion") {
        mansionCount += 1
    } else if scene.hasSuffix("Friar Lawrence's cell") {
        cellCount += 1
    }
}
print("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
// Prints "6 mansion scenes; 2 cell scenes"
</code></pre>
# Unicode 字符串表示

当一个 Unicode 字符串写入文本文件或者别的存储时,字符串里的 Unicode 标量会以一些Unicode 定义的编码形式进行编码。 每种字符串编码在人们熟知的代码单元块中。 包括 UTF-8 编码 (把字符串编码成一个 8-位的代码单元), UTF-16 编码 (把字符串编码成一个16-位的代码单元), 和 UTF-32 编码 (把字符串编码成 32-位代码单元)

Swift 提供了几种不同的方式去访问字符串的Unicode 形式。你可以用for-in语句遍历字符串, 访问作为Unicode 扩展字形集的单个字符值。这个过程在 Working with Characters 描述。

或者, 或者用以下三种形式来访问字符串的值:

UTF-8 代码单元集合 (用字符串的utf8属性来访问)
UTF-16 代码单元集合 (用字符串的utf16属性来访问)
21-位 Unicode 标量值的集合, 等于字符串的 UTF-32 编码方式 (用字符串的 unicodeScalars 属性访问)
下面的例子展示字符串的不同表现形式,字符串由字符 D, o, g, ‼ (DOUBLE EXCLAMATION MARK, 或者 Unicode scalar U+203C), 和 🐶 字符 (DOG FACE, 或者 Unicode scalar U+1F436)组成:

let dogString = "Dog‼🐶"
# UTF-8 形式

你可以通过遍历字符串的utf8属性来访问它的 UTF-8 表现形式。 这是属性是 String.UTF8View, 这是无符号的 8-位 (UInt8)值的集合, 每个字节一个:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png">
</div>
<pre><code>
for codeUnit in dogString.utf8 {
    print("\(codeUnit) ", terminator: "")
}
print("")
// 68 111 103 226 128 188 240 159 144 182
</code></pre>
上面这个例子, 前三个十进制 codeUnit 值 (68, 111, 103) 代表字符 D, o, 和 g, 它们的 UTF-8 形式和它们的 ASCII 表现形式一样。 接下来三个十进制 codeUnit 值 (226, 128, 188) 是双感叹号的三个字节的 UTF-8 形式。 最后四个 codeUnit 值 (240, 159, 144, 182) 是个四个字节的 UTF-8 形式，代表小狗的脸字符。

# UTF-16 形式

你可以通过遍历字符串的utf16属性来访问它的 UTF-16 形式。 这个属性是 String.UTF16View, 它是无符号16-位 (UInt16)的值的集合, 每个16-位代码单元一个:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png">
</div>
<pre><code>
for codeUnit in dogString.utf16 {
    print("\(codeUnit) ", terminator: "")
}
print("")
// Prints "68 111 103 8252 55357 56374 "
</code></pre>
同样, 前三个 codeUnit 值 (68, 111, 103) 代表字符 D, o, 和 g, 它们的 UTF-16 代码单元和它们的 UTF-8 形式一样(因为这些 Unicode 标量表示 ASCII 字符).

第四个 codeUnit 值 (8252) 是十六进制 203C的十进制数值, 用 Unicode 标量 U+203C表示双感叹号字符。 在 UTF-16 里表示为一个单独的编码单元。

第五六个 codeUnit 值 (55357 和 56374) 狗脸字符。 这些值是高八位 U+D83D (十进制值是 55357) 和一个第八位 U+DC36 (十进制值 56374)。

# Unicode 标量形式

你可以通过遍历字符串的 unicodeScalars 属性来访问它的Unicode 标量形式。 这个是属性是 UnicodeScalarView,它是类型 UnicodeScalar 值的集合。

每个 UnicodeScalar 有一个值属性，它返回这个标量的 21-位值, 用一个 UInt32 值表示:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png">
</div>
<pre><code>
for scalar in dogString.unicodeScalars {
    print("\(scalar.value) ", terminator: "")
}
print("")
// Prints "68 111 103 8252 128054 "
</code></pre>
前三个 UnicodeScalar 值 (68, 111, 103) 再次代表 D, o, 和 g.

第四个 codeUnit 值 (8252) 是十六进制 203C 的十进制值, 是双感叹的 Unicode 标量 U+203C 。

第五个和最后一个 UnicodeScalar 值, 128054, 是十六进制 1F436的十进制值, 是狗脸字符的的 Unicode 标量 U+1F436。

作为查询它们值属性的替代, 每个 UnicodeScalar 值也可以用来构建新的字符串, 例如用做字符串插值:
<pre><code>
for scalar in dogString.unicodeScalars {
    print("\(scalar) ")
}
// D
// o
// g
// ‼
// 🐶
</code></pre>

<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>Swift 提供了三个主要的集合类型, 数组, 集合, 和字典, 用来存储值的集合。 数组是有序的。 集合是唯一值的无序集。 字典是健值匹配的无序集合。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png"><br></div><br>数组, 集合, 和字典在 Swift 里总是清楚的知道存储的值的类型和能够存储的健。 这就意味着你不能往集合里插入错误类型的值。也意味着 你知道可以从集合里或者的值的类型。<br><br>备注<br><br>Swift 的数组, 集合, 和字典类型是用泛型集合实现的。更多泛型和集合, 参见 Generics.<br><br># 集合的不稳定性<br><br>如果你创建了一个数组, 一个集合, 或者一个字典, 然后赋给一个变量。创建的这个集合就是可变的。这就意味着你可以改变这个集合，方式是通过添加, 移除, 或者改变集合里的项。如果把它们赋给一个常量, 这个集合就是不可改变的, 它的大小和内容都不能改变。<br><br>备注<br><br>如果集合不需要变化，在所有情况下创建不可变的集合是个好的实践。这样做的好处是让你容易理解自己的代码,同时让编译器可以优化你创建的集合。<br><br># 数组<br><br>数组有序存储同类型的值。 相同的值可以多次出现在数组的不同位置。<br><br>备注<br><br>Swift的数组类型跟 Foundation的 NSArray 类相桥接。<br><br># 数组类型缩写语法<br><br>T数组类型的全写法是 Array<element>, 这里Element是数组运行存储的值类型。 你可以缩写数组类型为[Element]. 尽管这两种形式功能一样, 缩写是优先考虑的而且这个教程后面一直这么写。<br><br># 创建空数组<br><br>你可以用初始化语法创建一个特定类的空数组:<br><pre><code><br>var someInts = <a href="">Int</a><br>print(“someInts is of type [Int] with (someInts.count) items.”)<br>// Prints “someInts is of type [Int] with 0 items.”<br></code></pre><br>注意 someInts 变量的类型经过初始化类型被推断为 [Int]<br><br>或者, 如果上下文已经提供类型信息, 例如一个函数参数或者一个确定类型的变量或者常量, 你可以用空的字面量来创建空数组, 这个数组通常写作 [] (一个空的中括号对):<br><pre><code><br>someInts.append(3)<br>// someInts now contains 1 value of type Int<br>someInts = []<br>// someInts is now an empty array, but is still of type [Int]<br></code></pre><br># 用默认值创建数组<br><br>Swift的数组类型也提供了一初始化器来创建相同默认值固定大小的数组。 给初始化器传一个匹配类型的默认值 (调用 repeating): 然后是在新数组中需要重复的值的个数 (调用 count):<br><pre><code><br>var threeDoubles = Array(repeating: 0.0, count: 3)<br>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]<br></code></pre><br># 通过合并数组创建数组<br><br>你可以通过合并两个已存在的数组来创建新的数组,这两个数组只要类型匹配就可以通过加法运算符 (+)来合并。 新数组的类型从合并的数组可以推断出来:<br><pre><code><br>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)<br>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]<br><br>var sixDoubles = threeDoubles + anotherThreeDoubles<br>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]<br></code></pre><br># 用字面量创建数组<br><br>你也可以用字面量来初始化数组, 这是种快速写一个或者多个数组值的方式。 一个数组字面量写作一列值, 用逗号分开, 一对方括号包括起来:<br><pre><code><br>[value 1, value 2, value 3]<br></code></pre><br>下面的的例子创建了一个购物列表来存储字符串值:<br><pre><code><br>var shoppingList: [String] = [“Eggs”, “Milk”]<br>// shoppingList has been initialized with two initial items<br></code></pre><br>购物列表变量定义为 “字符串值的数组”, 写作 [String]. 因为这个数组已经指定一个字符串类型值, 它就值运行存储字符串值。 这里, 购物列表数组用两个字符串值 (“Eggs” 和 “Milk”)来初始化, 写在数字字面量里。<br><br>备注<br><br>这个数组被声明为一个变量而不是一个常量，是因为在下面的例子将有更多的项目加入这个购物列表。<br><br>这种情况, 数组字面量只包含两个字符串值。 这个匹配购物列表变量的声明类型 (只能包括字符串值的数组), 用数组字面量赋值来初始化购物列表是被允许的一种方式。<br><br>由于 Swift 的类型推断, 如果你用相同类型的字面量来初始化数组,就不需要写出数组的类型。购物列表的初始化可以简写成以下形式:<br><pre><code><br>var shoppingList = [“Eggs”, “Milk”]<br></code></pre><br>因为数组里所有的值都是同样的类型, Swift 能够推断出 [String] 用作购物列表变量是正确的类型。<br><br># 访问和修改数组<br><br>你可以通过数组的方法,属性或者下标语法来访问和修改一个数组。<br><br>为了确定数组的项数, 使用只读属性count:<br><pre><code><br>print(“The shopping list contains (shoppingList.count) items.”)<br>// Prints “The shopping list contains 2 items.”<br></code></pre><br>使用布尔属性 isEmpty 来判断数量属性是否0:<br><pre><code><br>if shoppingList.isEmpty {<br>    print(“The shopping list is empty.”)<br>} else {<br>    print(“The shopping list is not empty.”)<br>}<br>// Prints “The shopping list is not empty.”<br></code></pre><br>通过调用 append(<em>:) 方法你可以在数组最后添加新项:<br><pre><code><br>shoppingList.append(“Flour”)<br>// shoppingList now contains 3 items, and someone is making pancakes<br></code></pre><br>或者, 使用赋值运算 (+=) 添加一个或多个符合的项:<br><pre><code><br>shoppingList += [“Baking Powder”]<br>// shoppingList now contains 4 items<br>shoppingList += [“Chocolate Spread”, “Cheese”, “Butter”]<br>// shoppingList 现在包含 7项<br></code></pre><br>用下标语法从数组中获取一个值, 在数组后的方括号里传入你想得到值的索引:<br></em></element></count></count></code><br>var firstItem = shoppingList[0]<br>// firstItem is equal to “Eggs”<br><br>备注<br><br>数组第一项的索引是0,不是1。 Swift 数组总是基于0开始索引。<br><br>你可以使用下标语法去改变给定索引下的值:<br><pre><code><br>shoppingList[0] = “Six eggs”<br>// 第一项现在是 “Six eggs” 而不是 “Eggs”<br></code></pre><br>你还可以通过下标语法一次改变一个范围的值, 尽管取代值跟被取代的长度不同。 下面的例子用 “Bananas” 和 “Apples” 取代了 “Chocolate Spread”, “Cheese”, 和 “Butter”:<br><pre><code><br>shoppingList[4…6] = [“Bananas”, “Apples”]<br>// shoppingList 现在包含 6项<br></code></pre><br>备注<br><br>你不能用下标语法添加新的项到数组最后。<br><br>在特定位置插入新项, 调用数组插入方法 insert(:at:):<br><pre><code><br>shoppingList.insert(“Maple Syrup”, at: 0)<br>// shoppingList now contains 7 items<br>// “Maple Syrup” is now the first item in the list<br></code></pre><br>调用 insert(<em>:at:) 方法在购物列表头插入一个新的项 “Maple Syrup”, 用索引0标明。<br><br>类似的, 移除一项使用 remove(at:) 方法。 这个方法移除指定索引的项然后返回这个移除项 (尽管你可能无视这个返回值):<br><pre><code><br>let mapleSyrup = shoppingList.remove(at: 0)<br>// 位于索引0的项被移除<br>// 购物列表现在包含6项, 没有 Maple Syrup<br>// mapleSyrup 常量现在等于被移除的 “Maple Syrup” 字符串<br></code></pre><br>备注<br><br>如果越界访问数组的值, 你会触发运行时错误。你可以用它跟数组个数属性对比来判断索引的有效性。除了个数为0的情况 (意味着数组是空的), 最大索引值通常是数组个数 - 1, 因为数组是从0开始计数的。<br><br>一个数据项被移除数组空隙就会闭合,所以索引 0 的值再次等于 “Six eggs”:<br><pre><code><br>firstItem = shoppingList[0]<br>// firstItem 现在等于 “Six eggs”<br></code></pre><br>如果你想移除最后一项, 使用 removeLast() 方法而不是 remove(at:) 方法,这样就避免需要查询数组的个数属性。和 remove(at:) 方法一样, removeLast() 返回移除的项:<br><pre><code><br>let apples = shoppingList.removeLast()<br>// 最后一项被移除<br>// 购物列表现在包含5项, 没有苹果<br>// apples 常量现在等于被移除的 “Apples” 字符串<br></code></pre><br># 遍历数组<br><br>你可以用for-in循环来遍历数组中的所有值集:<br><pre><code><br>for item in shoppingList {<br>    print(item)<br>}<br>// Six eggs<br>// Milk<br>// Flour<br>// Baking Powder<br>// Bananas<br></code></pre><br>如果需要数据项的值和整数索引, 使用 enumerated() 方法来遍历数组。对于数组中的每一项, enumerated() 方法返回一个包含索引和值的元组。 整数以0开始每项递增; 如果你遍历整个数组, 这些整数匹配数据项的索引。你可以分解元组到临时的常量或者变量,来作为迭代的部分:<br><pre><code><br>for (index, value) in shoppingList.enumerated() {<br>    print(“Item (index + 1): (value)”)<br>}<br>// Item 1: Six eggs<br>// Item 2: Milk<br>// Item 3: Flour<br>// Item 4: Baking Powder<br>// Item 5: Bananas<br></code></pre><br><br># 集合<br><br>集合无序存储同样类型的不同值。 如果排序不重要可以选择使用集合代替数组, 或者你需要确保每项只出现一次。<br><br>备注<br><br>Swift 的 Set 类型跟 Foundation 的 NSSet 类桥接。<br><br># 集合类型的哈希值<br><br>集合里一个类型为了存储就必须可哈希—就是说, 这个类型必须提供一个方式去计算自己的哈希值。 一个哈希值是一个整型值, 这对于相等的对象都是一样的, 如果 if a == b, 那么 a.hashValue == b.hashValue.<br><br>所有 Swift 的基本类型默认都是可哈希的 (比如 String, Int, Double, 和 Bool), 可以被用作集合值类型或者字典建类型。 枚举case 值没有相应的值默认也是可哈希的。<br><br>备注<br><br>你可以使用自定义类型作为集合值类型或者字典健类型,通过让它们遵守Swift 标准库中的 Hashable 协议。 符合协议的类型必须提供一个可获取的整形属性 hashValue. 在相同程序中的不同执行,或者在不同程序中, 类型的哈希属性返回的值不要求相同。<br><br>因为 Hashable 协议符合 Equatable, 符合类型必须提等号运算符 (==)的实现。 Equatable 协议要求任何符合==实现的都是一个相等关系。 就是说, ==  的实现必须满足下面的条件, 对于 a, b, 和 c 所有值:<br><br>a == a (自反性)<br><br>a == b 表示 b == a (对称性)<br><br>a == b &amp;&amp; b == c 表示 a == c (传递性)<br><br># 集合类型语法<br><br>集合类型写作 Set<element>, 这里 Element 是集合允许存储的类型。 跟数组不同, 集合没有等价的缩写形式。<br><br># 创建和初始化空集合<br><br>你可以通过使用初始化器语法创建特定类型的空集合:<br><pre><code><br>var letters = Set<character>()<br>print(“letters is of type Set<character> with (letters.count) items.”)<br>// 打印 “letters is of type Set<character> with 0 items.”<br></character></character></character></code></pre><br>备注<br><br>letters 变量的类型推断为 Set<character>, 通过初始化器的类型。<br><br>或者, 如果上下文已经提供了类型信息, 比如一个函数参数或者一个已经指定类型的变量和常量, 你可以用一个空的数组字面量来创建一个空集合:<br><pre><code><br>letters.insert(“a”)<br>// letters 现在包含了一个字符类型的值<br>letters = []<br>// letters 现在是一个空集合, 但是依然是 Set<character> 类型<br></character></code></pre><br># 用数组字面量创建集合<br><br>你可以用数组字面量初始化一个集合, 这是一个速写方式来给一个集合赋值。<br><br>下面的例子创建一个存储字符串值的集合 favoriteGenres:<br><pre><code><br>var favoriteGenres: Set<string> = [“Rock”, “Classical”, “Hip hop”]<br>// favoriteGenres 有了三个初始值<br></string></code></pre><br>favoriteGenres 变量声明成 “字符串值的集合”, 写作 Set<string>. 因为这个集合指定了一个字符串的值类型, 它只允许存储字符串值, favoriteGenres 集合用三个字符串 (“Rock”, “Classical”, 和 “Hip hop”)来初始化, 写在一个数组字面量里。<br><br>备注<br><br>favoriteGenres 集合声明成一个变量而不是一个常量, 这是因为添加和移除的项在下面的示例里。<br><br>集合通过数组字面量不能推断出类型, 所以类型必须显示声明。 不过, 由于Swift的类型推断, 如果数组字面量包含的值类型相同,你就不需要写集合的类型。favoriteGenres 初始化可以简写如下:<br><pre><code><br>var favoriteGenres: Set = [“Rock”, “Classical”, “Hip hop”]<br></code></pre><br>因为数组字面量里的值都是同样类型, Swift 可以推断 Set<string> 用作favoriteGenres 变量是正确的类型。<br><br># 访问和修改集合<br><br>你可以通过集合的方法和属性来访问和修改它。<br><br>为了得到集合的项数, 使用只读的 count 属性:<br><pre><code><br>print(“I have (favoriteGenres.count) favorite music genres.”)<br>// 打印 “I have 3 favorite music genres.”<br></code></pre><br>使用布尔属性 isEmpty 快速判断 count 属性是否等于 0:<br><pre><code><br>if favoriteGenres.isEmpty {<br>    print(“As far as music goes, I’m not picky.”)<br>} else {<br>    print(“I have particular music preferences.”)<br>}<br>// 打印 “I have particular music preferences.”<br></code></pre><br>调用集合的 insert(</string></string></character></element></em>:) 方法插入一个新项:<br><pre><code><br>favoriteGenres.insert(“Jazz”)<br>// favoriteGenres 现在包含 4 项<br></code></pre><br>你可以用集合的 remove(<em>:) 方法从集合里移除项, 如果它是集合一员的话, 然后返回被移除的项, 如果集合不包含这项就返回nil。 或者, 移除所有项可以用 removeAll() 方法。<br><pre><code><br>if let removedGenre = favoriteGenres.remove(“Rock”) {<br>    print(“(removedGenre)? I’m over it.”)<br>} else {<br>    print(“I never much cared for that.”)<br>}<br>// 打印 “Rock? I’m over it.”<br></code></pre><br>检查集合是否包含特定项, 用 contains(</em>:) 方法。<br><pre><code><br>if favoriteGenres.contains(“Funk”) {<br>    print(“I get up on the good foot.”)<br>} else {<br>    print(“It’s too funky in here.”)<br>}<br>// 打印 “It’s too funky in here.”<br></code></pre><br># 遍历集合<br><br>你可以用for-in循环遍历集合的值。<br><pre><code><br>for genre in favoriteGenres {<br>    print(“(genre)”)<br>}<br>// Jazz<br>// Hip hop<br>// Classical<br></code></pre><br><br>Swift 的集合类型是无序的。以特定顺序去遍历集合的值, 使用 sorted() 方法, 这个方法返回一个值数组,按照小于运算符排序。<br><pre><code><br>for genre in favoriteGenres.sorted() {<br>    print(“(genre)”)<br>}<br>// Classical<br>// Hip hop<br>// Jazz<br></code></pre><br># 集合操作<br><br>你可以有效进行基础的集合操作, 比如合并两个集合, 判断两个集合是否有共同值, 或者判读两个集合是否包含所有,几个,或者没有任何相同值。<br><br># 基本集合操作<br><br>下面的图描述了两个集合a 和 b, 共享区域表示集合操作结果。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png"><br></div><br>用 intersection(<em>:) 方法创建交集。<br>用 symmetricDifference(</em>:) 方法创建交集之外的集合。<br>用 union(<em>:) 方法创建并集。<br>用 subtracting(</em>:) 方法创建去掉指定集合的集合。<br><pre><code><br>let oddDigits: Set = [1, 3, 5, 7, 9]<br>let evenDigits: Set = [0, 2, 4, 6, 8]<br>let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]<br><br>oddDigits.union(evenDigits).sorted()<br>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>oddDigits.intersection(evenDigits).sorted()<br>// []<br>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()<br>// [1, 9]<br>oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()<br>// [1, 2, 9]<br></code></pre><br># 集合成语和等式<br><br>下面的图描述了三个集合 a, b 和 c, 重叠区域表示集合共享的元素。 集合a是集合b的超集, 因为a包含b的所有元素。 相反, 集合b是集合a的子集, 因为b中的元素都包含在集合a中。 集合b与集合c不相交, 因为它们没有共同的元素。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png"><br></div><br>用相等运算符 (==) 判断两个集合是否所有值都相同。<br>用 isSubset(of:) 方法判断一个集合是否是另外一个集合的字集。<br>用 isSuperset(of:) 方法判断一个集合是否是另外一个集合的超集。<br>用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法判断一个集合是否是一个子集或者超集, 但是不等于一个指定的集合。用 isDisjoint(with:) 方法判断是否两个集合不相交。<br><pre><code><br>let houseAnimals: Set = [“🐶”, “🐱”]<br>let farmAnimals: Set = [“🐮”, “🐔”, “🐑”, “🐶”, “🐱”]<br>let cityAnimals: Set = [“🐦”, “🐭”]<br><br>houseAnimals.isSubset(of: farmAnimals)<br>// true<br>farmAnimals.isSuperset(of: houseAnimals)<br>// true<br>farmAnimals.isDisjoint(with: cityAnimals)<br>// true<br></code></pre><br># 字典<br><br>字典无序存储匹配的同类型的健值。每个值对应一个唯一的健, 它作为值在字典里的标识符。 跟数组项不同, 字典里的项是无序的。如果基于标识符查找值你可以用字典, 很像真实世界字典的用法。<br><br># 字典类型速记语法<br><br>Swift 字典类型完整写法是 Dictionary<key, value="">, Key 是可以用作字典值的值类型, Value 是字典为健存储的值类型。<br><br>备注<br><br>字典 Key 类型一定要符合 Hashable 协议, 跟集合值类型一样。<br><br>你也可以字典类型的简写形式 [Key: Value]. 尽管两个形式功能一样, 简写形式优先使用并贯穿整个教程。<br><br># 创建一个空字典<br><br>跟数组一样, 你可用用初始化语法创建一个特定类型的字典:<br><pre><code><br>var namesOfIntegers = <a href="">Int: String</a><br>// namesOfIntegers is an empty [Int: String] dictionary<br></code></pre><br>这个例子定义了一个空字典,类型是 [Int: String],用来存储人类可读的整数名字。健是整形, 值是字符串类型。<br><br>如果上下文已经提供了类型信息, 你可以用一个空的字典字面量来创建一个空字典, 写作 [:] (一对中括号中间一个冒号):<br><pre><code><br>namesOfIntegers[16] = “sixteen”<br>// namesOfIntegers 现在包含 1 key-value pair<br>namesOfIntegers = [:]<br>// namesOfIntegers 再次成为空,类型是[Int: String]<br></code></pre><br># 用字面量创建字典<br><br>你还可以用字面量来初始化一个字典, 跟早前数组字面量语法相似。字典字面量是定义一个或者多个键值对集合的速写方法。<br><br>键值对是健和值的组合。 在一个字典字面量里, 健和值在键值对里用冒号分开。 键值对写作一个列表, 用逗号分开, 包含在一对中括号里:<br><pre><code><br>[key 1: value 1, key 2: value 2, key 3: value 3]<br></code></pre><br>下面的例子创建一个字典来存储国际机场名字。在这个字典里, 健是三个字母的国际航空公司编码, 值是机场名:<br><pre><code><br>var airports: [String: String] = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br></code></pre><br>airports 字典类型是 [String: String], 意思是 “一个字典健值都是字符串类型”.<br><br>备注<br><br>airports 字典声明成一个变量而非常量, 因为下面的例子需要添加更多机场进去。<br><br>airports 用两个键值对字面量初始化。第一个键值对有一个健 “YYZ” 和一个值 “Toronto Pearson”. 第二个键值对有一个健 “DUB” 和一个值”Dublin”.<br><br>字面量包含两个 String: String 对。 简直类型匹配机场类型的变量声明 (一个字典只有字符串健和字符串值), 所以字面量赋值是允许的,可以用来初始化机场字典。<br><br>跟数组一样, 如果你用相同类型的键值字典初始化，你就不需要写出字典的声明类型。初始化方法可以简写如下:<br><pre><code><br>var airports = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br></code></pre><br>因为字面量的所有健类型都是一样的, 同样所有的值也是, Swift 可以推断出来 [String: String] 是正确的类型声明。<br><br># 访问和修改字典<br><br>你可以通过字典的方法和属性来访问和修改它, 或者使用下标语法。<br><br>跟数组一样, 使用count 属性获取字典的项数:<br><pre><code><br>print(“The airports dictionary contains (airports.count) items.”)<br>// 打印 “The airports dictionary contains 2 items.”<br></code></pre><br>用 isEmpty 属性判断count 属性是否等于 0:<br><pre><code><br>if airports.isEmpty {<br>    print(“The airports dictionary is empty.”)<br>} else {<br>    print(“The airports dictionary is not empty.”)<br>}<br>// 打印 “The airports dictionary is not empty.”<br></code></pre><br>你可以用下标语法往字典添加新项。 使用对应的类型的键作为下标索引, 并赋一个对应的新值:<br><pre><code><br>airports[“LHR”] = “London”<br>// airports 现在包含 3 项<br></code></pre><br>你可以用下标语法改变指定键对应的值:<br><pre><code><br>airports[“LHR”] = “London Heathrow”<br>// “LHR” 的值已经变成”London Heathrow”<br></code></pre><br>作为下标的替代方案, 用字典的 updateValue(<em>:forKey:) 方法设置或者更新指定键的值。 跟上面下标实例一样,  updateValue(</em>:forKey:) 方法在键不存在时设置值, 如果键存在则进行更新。和下标不像的是, updateValue(<em>:forKey:) 方法在执行更新后返回老的值。 这个可以让你知道更新是否生效。<br><br>updateValue(</em>:forKey:) 方法返回可选类型的值。对个存储字符串值的字典来说, 比如, 这个方法返回 String?, 或者 “optional String”. 可选值包括未更新前存在的键对应的老值, 如果值不存在则包括nil:<br><pre><code><br>if let oldValue = airports.updateValue(“Dublin Airport”, forKey: “DUB”) {<br>    print(“The old value for DUB was (oldValue).”)<br>}<br>// 打印 “The old value for DUB was Dublin.”<br></code></pre><br>你可以用下标语法获取特定键对应的值。因为有可能去请求不存在值的键, 字典的下标就会返回一个可选值。 如果字典包含请求键对应的值, 下标就返回一个可选值，这个值包含这个键对应的存在的值。否则返回 nil:<br><pre><code><br>if let airportName = airports[“DUB”] {<br>    print(“The name of the airport is (airportName).”)<br>} else {<br>    print(“That airport is not in the airports dictionary.”)<br>}<br>// 打印 “The name of the airport is Dublin Airport.”<br></code></pre><br>你可以通过把键对应的值赋空的方式,用下标语法从字典移除一个键值对:<br><pre><code><br>airports[“APL”] = “Apple International”<br>// “Apple International” is not the real airport for APL, so delete it<br>airports[“APL”] = nil<br>// APL 现在已经从字典移除<br></code></pre><br>或者, 用 removeValue(forKey:) 这个方法来移除。 这个方法移除的键值对如果存在返回被移除的值,否则返回nil:<br><pre><code><br>if let removedValue = airports.removeValue(forKey: “DUB”) {<br>    print(“The removed airport’s name is (removedValue).”)<br>} else {<br>    print(“The airports dictionary does not contain a value for DUB.”)<br>}<br>// Prints “The removed airport’s name is Dublin Airport.”<br></code></pre><br># 遍历字典<br><br>你用for-in 循环来遍历字典。 字典中的每一项都以 (key, value) 元组形式返回, 你可以分解元组到临时的变量或者常量:<br><pre><code><br>for (airportCode, airportName) in airports {<br>    print(“(airportCode): (airportName)”)<br>}<br>// YYZ: Toronto Pearson<br>// LHR: London Heathrow<br></code></pre><br><br>你可以通过访问字典的键值属性来获取键值的集合:<br><pre><code><br>for airportCode in airports.keys {<br>    print(“Airport code: (airportCode)”)<br>}<br>// Airport code: YYZ<br>// Airport code: LHR<br>for airportName in airports.values {<br>    print(“Airport name: (airportName)”)<br>}<br>// Airport name: Toronto Pearson<br>// Airport name: London Heathrow<br></code></pre><br>如果你想使用字典的键值的数组实例, 用键值来初始化一个新的数组:<br><pre><code><br>let airportCodes = <a href="airports.keys">String</a><br>// airportCodes is [“YYZ”, “LHR”]<br><br>let airportNames = <a href="airports.values">String</a><br>// airportNames 是 [“Toronto Pearson”, “London Heathrow”]<br></code></pre><br>Swift的字典类型无序的。 为了用特定顺序去遍历字典的键值, 用这个 sorted() 方法。<br><br># 控制流<br>Swift 提供了一系列控制流语句。 包括 while 循环来执行多次任务; if, guard, 金额 switch 语句来再不同条件这些不同代码; 还有 break 和 continue 来转移控制流。<br><br>Swift 同时提供了 for-in 循环使得遍历数组, 字典, 范围, 字符串, 和其他序列变得容易。<br><br>Swift的 switch 语句比多数类C语言相同语句更加高效有力。 因为Swift 的 switch 语句的分支不会落到下一分支, 这就避免了C常见的错误。 分支可以匹配不同的模式, 包括区间匹配, 元组, 转换成指定类型。 switch 分支匹配的值可以绑定到临时的变量或者常量。每个分支可以用where 族来表达符合匹配条件。<br><br># For-In 循环<br><br>你使用 for-in 循环来遍历序列, 比如数值范围, 数组中的项, 字符串中的字符。<br><br>下面的例子是五倍乘法表的前几个条目:<br><pre><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index <em> 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br></em></code></pre><br>遍历的序列是1 到 5的数值范围, 包括1和5,使用闭合区间运算符 (…)提到过。索引值设置给 range (1)的第一个数, 然后循环体中的语句就会执行。 这种情况, 循环体只有一个语句, 打印当前索引值5的倍数。 这个语句执行后, 索引值更新为包含在 range (2) 中的第二个值, print(<em>:separator:terminator:) 函数再次调用。 这个过程直到区间结束。<br><br>上面的例子, 索引值是常量而且自动设置。 像这样, 索引在使用前不必声明。 在循环声明中隐式声明, 不需要let关键字。<br><br>如果你不需要序列中的所有值, 可以在变量名位置处使用下划线来忽略这个值。<br><pre><code><br>let base = 3<br>let power = 10<br>var answer = 1<br>for </code></pre></em> in 1…power {<br>    answer = base<br>}<br>print(“(base) to the power of (power) is (answer)”)<br>// 打印 “3 to the power of 10 is 59049”<br><br>上面的例子计算一个数的幂(这个例子里, 3 的10次幂)。 它乘以一个初始值 1 (就是 3 的0次幂), 十次, 使用一个闭合区间,1开始10结束。下划线用在这里,使得单个值被忽略同时不会在遍历过程中访问当前值。<br><br>使用 for-in 循环来遍历数组的项。<br><pre><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>for name in names {<br>    print(“Hello, (name)!”)<br>}<br>// Hello, Anna!<br>// Hello, Alex!<br>// Hello, Brian!<br>// Hello, Jack!<br></code></pre><br>你还可以遍历一个字典来遍历它的键值对。 字典遍历时每次返回一个 (key, value) 元组, 你可以在for-in循环中显示分解元组的值给常量赋值。这里, 字典的键分解给animalName 常量, 字典的值分配给了 legCount 常量。<br><pre><code><br>let numberOfLegs = [“spider”: 8, “ant”: 6, “cat”: 4]<br>for (animalName, legCount) in numberOfLegs {<br>    print(“(animalName)s have (legCount) legs”)<br>}<br>// ants have 6 legs<br>// spiders have 8 legs<br>// cats have 4 legs<br></code></pre><br>字典项遍历的顺序不需要和插入顺序一致。 字典内容是无序的, 遍历时不能保证获取的顺序。<br><br># While 循环<br><br>while 循环执行一组语句,直到条件失败。 首次遍历前,遍历次数不知道的时候使用这种方式是最好的。Swift 提供两种 while 循环:<br><br>while 每次循环前评估条件。<br>repeat-while 每次循环后评估条件。<br># While<br><br>while 循环从评估条件开始。 如果条件是真的, 一组语句会重复执行直到条件变成假的。<br><br>这是while 循环的基本形式:<br><pre><code><br>while condition {<br>    statements<br>}<br></code></pre><br>这个例子是个蛇与梯子的游戏:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png"><br></div><br>游戏规则如下:<br><br>棋盘有25个方格, 目标是占据或者超过25。<br>每次, 摇一个6边的骰子然后移动对应数目方格, 沿着上图的点箭头的水平路径移动。<br>如果位于梯子底部, 往梯子上方移动。<br>如果位于蛇头, 往蛇下方移动。<br>游戏棋盘用整形值数组表示。大小基于 finalSquare 常量, 用来初始化数组并且判断取胜的条件。 棋盘用26个0值初始化, 而不是25 (每个索引从0到25)。<br><pre><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br></code></pre><br>一些方格会为蛇和梯子设置更多的指定值。梯子方格是正数,蛇方格是负数。<br><pre><code><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br></code></pre><br>方格 3 包含了梯子的底部,可以爬到方格11。 为了表示这个, board[03] 等于 +08, 这等于整数值8 (3和11的差值) 加号 (+i) 和减号 (-i)相等, 数值低于10的用0填充,这样所以棋盘都被定义了。<br><br>玩家开始方格是 “方格0”, 靠着棋盘的左下角。 第一次摇骰子总是让玩家进入棋盘。<br><pre><code><br>var square = 0<br>var diceRoll = 0<br>while square &lt; finalSquare {<br>    // roll the dice<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // move by the rolled amount<br>    square += diceRoll<br>    if square &lt; board.count {<br>        // if we’re still on the board, move up or down for a snake or a ladder<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br></code></pre><br>上面的例子用了一个很简单方法去摇骰子。 不用随机数, 用一初始值为0的 diceRoll。 每次循环, diceRoll 加一然后判断它是否过大。 当返回值等于7, 骰子值过大然后重置为1。diceRoll 值总是 1, 2, 3, 4, 5, 6, 1, 2 然后不停循环。<br><br>摇完筛子, 往前移动 diceRoll 方格。 如果移动超过25, 游戏结束。考虑边界安全，在操作方格的时候。<br><br>备注<br><br>没有这个判断, board[square] 可能会越界访问棋盘数组的值, 这会触发一个错误。 如果方格等于 26, 代码会判断board[26] 的值, 这会超过数组的大小。<br><br>当前while 循环执行然后结束, 然后循环的条件会被判断是否再次执行。如果玩家已经移动或者超过25, 循环的条件变成假然后游戏就结束。<br><br>while 循环适合这个例子, 因为开始循环的时候游戏的长度并不清楚。 相反, 一个特定条件满足后循环被执行了。<br><br># Repeat-While<br><br>另外一种while循环的变种, 就是 repeat-while 循环, 先执行一次循环, 然后再考虑循环的条件。 然后继续执行直到条件变成假。<br><br>备注<br><br>Swift 里的 repeat-while 循环类似其他语言里的 do-while 循环。<br><br>这里是 repeat-while 循环的基本样式:<br><pre><code><br>repeat {<br>    statements<br>} while condition<br></code></pre><br>这里还是蛇与梯子的例子, 用 repeat-while 循环来写而不是 while 循环。 finalSquare, board, square, 和 diceRoll的值初始化方式跟while循环一样。<br><pre><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br></code></pre><br>这个游戏版本, 第一步是判断梯子和蛇。 没有梯子带着玩家直接去方格25, 因为不太可能通过爬梯子去赢得游戏。因此, 判断有没有蛇和梯子是很安全的。<br><br>游戏开始, 玩家在 “square zero”. board[0] 总是等于0没有影响。<br><pre><code><br>repeat {<br>    // move up or down for a snake or ladder<br>    square += board[square]<br>    // roll the dice<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // move by the rolled amount<br>    square += diceRoll<br>} while square &lt; finalSquare<br>print(“Game over!”)<br></code></pre><br>蛇与梯子判断后, 摇动筛子玩家往前移动 diceRoll 方格。 当前循环执行然后结束。<br><br>循环条件 (while square &lt; finalSquare) 和以前一样, 不过这次开始不评估,直到第一次循环结束才评估。repeat-while 循环比 while loop 循环更适合这个游戏。上面的 repeat-while 循环, 当条件确认方格还在棋盘上后, square += board[square] 总是立即执行。 这就不需要像之前那样判断数组边界。<br><br># 条件语句<br><br>基于特定条件执行不同代码片段经常用到。 在碰到错误时你可能想运行额外的代码片段, 或者在数值变得太高或者太低的时候也是。为了做这件事, 你让部分代码带有条件性。<br><br>Swift 提供两种方式给你的代码添加条件分支: if 语句和 switch 语句。你用 if 语句评估条件会有一些可能的结果。 switch 语句在比较复杂的多个排列时很有用, 在模式匹配可以帮助选择合适代码分支执行的情况也是。<br><br># If<br><br>最简单的形式, if 语句有一个单一条件。 条件为真执行一个语句集合。<br><pre><code><br>var temperatureInFahrenheit = 30<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>}<br>// 打印 “It’s very cold. Consider wearing a scarf.”<br></code></pre><br>上面的例子判断文档是否小于等于华氏32度 (冰点)。 如果是, 打印一条信息。 否则, 不打印消息, 代码在大括号后继续执行。<br><br>if 语句还可以提供一个替代语句集合, 就是 else 字句, 针对条件是假的情况。 这些语句用else 关键字表示。<br><pre><code><br>temperatureInFahrenheit = 40<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 打印 “It’s not that cold. Wear a t-shirt.”<br></code></pre><br>两个分支之一总会执行。 因为温度已经增长到华氏40度, 这不够冷到戴围巾,因此else分支被触发了。<br><br>你可以链接多个if语句来考虑额外的语句。<br><pre><code><br>temperatureInFahrenheit = 90<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 打印 “It’s really warm. Don’t forget to wear sunscreen.”<br></code></pre><br>在这个库, 额外的if语句用来响应特别温暖的温度。 最后的else语句保留, 它响应既不太热也不太冷的情况。<br><br>最后的else语句是可选的, 不过, 如果不需要执行可以去掉。<br><pre><code><br>temperatureInFahrenheit = 72<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>}<br></code></pre><br>因为这个温度既不太冷也不太热,所以不会触发if或者else语句,没有打印信息。<br><br># Switch<br><br>switch 语句设想一个值,然后跟一些可能的匹配模式比较。然后执行合适的代码, 基于第一次匹配成功。switch 语句提供了if语句的替代方法来响应多种潜在状态的情况。<br><br>最简单的形式, 一个 switch 语句用一个值跟一个或者多个同类型的值相比较。<br><pre><code><br>switch some value to consider {<br>case value 1:<br>    respond to value 1<br>case value 2,<br>     value 3:<br>    respond to value 2 or 3<br>default:<br>    otherwise, do something else<br>}<br></code></pre><br>每个 switch 语句由多个case分支组成, 每个分支以case 关键字开始。 除了跟指定值比较外, Swift 为case分支提供了指定更复杂匹配模式的方法。这些选项本章后面会描述。<br><br>跟if语句体很像, 每个 case 是代码执行的单独分支。 switch 语句决定是否选择这个分支。这个过程叫分发。<br><br>每个switch 语句务必是详尽的。 就是说, 每个能想到的类型值都要case匹配。 为每个可能值都提供case是不合适的。你可以定义一个默认case覆盖没有显示处理的值。 默认case使用default关键字指明, 必须总是出现在最后。<br><br>这个例子使用一个 switch 语句来出处理一个小写字母someCharacter:<br><pre><code><br>let someCharacter: Character = “z”<br>switch someCharacter {<br>case “a”:<br>    print(“The first letter of the alphabet”)<br>case “z”:<br>    print(“The last letter of the alphabet”)<br>default:<br>    print(“Some other character”)<br>}<br>// 打印 “The last letter of the alphabet”<br></code></pre><br>switch 语句第一个case匹配英文字母表第一个字母 a, 第二个case匹配最后一个字母 z. 因为 switch 语句对于每个可能的字符都要有case, 不是每个字母表字符都需要。这个switch 语句使用了一个default case 去处理a 和 z之外的其他所有字母。这保证了switch语句的详细性。<br><br># 非隐式 Fallthrough<br><br>和C 与 objective-C 的switch语句对比, Swift 中的switch语句不会 fall through case底部并且跳到下一个case。 相反, 在第一次匹配到case后整个switch语句执行就完成了。不要求显示的break语句。 这使得switch语句更安全,更容易使用,而且避免执行多个case的错误。<br><br>备注<br><br>尽管Swift 不要求break, 你仍然可以在Swift中使用。 具体可以参见 Break in a Switch Statement.<br><br>case 体必须包含至少一句可执行语句。下面的代码的无效的, 因为第一个case是空的:<br><pre><code><br>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”: // Invalid, the case has an empty body<br>case “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// 这会报一个编译期错误<br></code></pre><br>跟C中的switch语句不同, 这个 switch 语句不能同时匹配 “a” 和 “A”. 相反, 它会报一个编译期错误,因为case “a”: 没有任何可以执行的语句。这个方法避免了突然从一个case跳入另外一个case, 让代码意图清晰安全。<br><br>如果要用一个case同时匹配”a” 和 “A”, 把这两个值合并到一个case语句, 用逗号把它们分开。<br><pre><code><br>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”, “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// Prints “The letter A”<br></code></pre><br>为了可读性, 复合case也可以写作多行。 具体参见 Compound Cases.<br><br>备注<br><br>为了显式fall through 到某个case下面, 使用 fallthrough 关键字。<br><br># 区间匹配<br><br>switch case里面的值可以包含在区间里判断。 这个例子使用数字区间来提供一个对任何数字大小的自然语言统计。<br><pre><code><br>let approximateCount = 62<br>let countedThings = “moons orbiting Saturn”<br>var naturalCount: String<br>switch approximateCount {<br>case 0:<br>    naturalCount = “no”<br>case 1..<5: naturalcount="a few" case="" 5..<12:="" 12..<100:="" 100..<1000:="" default:="" }="" print("there="" are="" \(naturalcount)="" \(countedthings).")="" prints="" "there="" dozens="" of="" moons="" orbiting="" saturn."="" <="" code=""></5:></code></pre><br>上面的例子, approximateCount 在switch语句里估算。 每个case把这个值跟一个数字或者区间进行比较。因为 approximateCount 值落在 12 和 100之间, naturalCount 被赋值为 “dozens of”, 然后代码执行跳出switch语句继续执行。<br><br># 元组<br><br>你可以在switch语句中使用元组测试多值。元组元素可以跟一个不同值或者值区间进行测试。或者, 使用通配下划线 (<em>) 去匹配可能的值。<br><br>下面的例子有一个 (x, y) 点, 用一个简单的元组类型 (Int, Int) 表示, 并且在下面的图表中标示。<br><pre><code><br>let somePoint = (1, 1)<br>switch somePoint {<br>case (0, 0):<br>    print(“(0, 0) is at the origin”)<br>case (</code></pre></em>, 0):<br>    print(“((somePoint.0), 0) is on the x-axis”)<br>case (0, _):<br>    print(“(0, (somePoint.1)) is on the y-axis”)<br>case (-2…2, -2…2):<br>    print(“((somePoint.0), (somePoint.1)) is inside the box”)<br>default:<br>    print(“((somePoint.0), (somePoint.1)) is outside of the box”)<br>}<br>// 打印 “(1, 1) is inside the box”<br><br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png"><br></div><br>switch 语句决定这个点是否位于原点 (0, 0), 红色的 x-轴, 橙色 y-轴, 在蓝色 4-by-4 方块里原点在中心, 或者在方块之外。<br><br>跟 C 不同, Swift 允许多个case 去处理相同的值。 事实上, (0, 0)点可以满足例子的四个case。不过, 如果多个匹配都可能, 第一个匹配上的总是执行。 (0, 0) 点首先匹配case (0, 0), 其他所有匹配的case都会被忽略。<br><br># 值绑定<br><br>一个 switch case 可以绑定值到临时的常量或者变量, 用在case 体中。这个就是值绑定, 因为值绑定到case 体中的临时常量或者变量上。<br><br>下面这个例子有一个(x, y) 点, 是元组类型 (Int, Int), 在下面的图表中标示:<br><pre><code><br>let anotherPoint = (2, 0)<br>switch anotherPoint {<br>case (let x, 0):<br>    print(“on the x-axis with an x value of (x)”)<br>case (0, let y):<br>    print(“on the y-axis with a y value of (y)”)<br>case let (x, y):<br>    print(“somewhere else at ((x), (y))”)<br>}<br>// Prints “on the x-axis with an x value of 2”<br></code></pre><br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png"><br></div>

<p>switch 语句判断这个点是在红色的 x-轴, 橙色的 y-轴, 还是其他什么地方 (不在轴上)。</p>
<p>这三个 switch case声明了占位符常量 x 和 y, 临时存放来自 anotherPoint 的一个或者两个元组值。第一个 case, case (let x, 0), 匹配任何y值为0 然后把坐标点x的值赋给临时常量 x. 类似的, 第二个case, case (0, let y), 匹配任何x值为0,然后把坐标点y值赋给临时常量y.</p>
<p>临时常量声明后, 它们就可以用在case 体中。在这里, 它们用来打印这个点的标示。</p>
<p>这个 switch 语句没有默认的default case. 最后一个case, case let (x, y), 声明了带有两个占位符常量的元组,它可以匹配任何值。因为 anotherPoint 总是两个值的元组, 这个case 匹配所有可能的剩余值, 所以默认的default case 是不需要的。</p>
<h1 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h1><p>一个 switch case 可以用 where 字句来判断额外的条件。</p>
<p>下面的例子在下面的图表中标示一个(x, y) 点:</p>
<pre><code>
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
// 打印 "(1, -1) is on the line x == -y"
</code></pre>

<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png"><br></div>

<p>switch 语句确定这个点是否在x == y这个绿色对角线上, 或者是x == -y这个紫色对角线上,或者两者都不在。</p>
<p>三个 switch case 都声明了占位符常量 x 和 y, 临时接受来自 yetAnotherPoint 两个元组值。这些常量用作where字句的一部分, 去创建一个动态的过滤器。case 匹配坐标点的当前值,如果where字句条件为真的话。</p>
<p>和前面一个例子一样, 最后的case 匹配所有剩余值, 不再需要 default case</p>
<h1 id="复合-Cases"><a href="#复合-Cases" class="headerlink" title="复合 Cases"></a>复合 Cases</h1><p>共享相同代码块的多个switch case 分支可以合并, 写在case后用逗号分开。如果任何模式匹配, 这个case 就被认为匹配。如果列表很长可以写作多行。如下：</p>
<pre><code>
let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    print("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
     "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
    print("\(someCharacter) is a consonant")
default:
    print("\(someCharacter) is not a vowel or a consonant")
}
// 打印 "e is a vowel"
</code></pre>
第一个case 匹配英文中五个小写元音字母。 类似的, 第二个case匹配所有小写辅音字母。最后, default case 匹配其余的字母。

符合 case 可以包含值绑定。 符合case所有形式必须包括相同的值绑定集合, 每个绑定必须获取一个相同类型的值。这个确保, 无论复合case哪个部分匹配, case 代码总是访问一个绑定值,而且这个值总有相同类型。
<pre><code>
let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print("On an axis, \(distance) from the origin")
default:
    print("Not on an axis")
}
// 打印 "On an axis, 9 from the origin"
</code></pre>

<p>上面的case有两种形式: (let distance, 0) 匹配x轴上的点, (0, let distance) 匹配y轴上点。两个形式都绑定了一个距离值,两种形式下距离都是整形,这就意味着case代码总是可以访问距离的值。</p>
<h1 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h1><p>控制转移语句改变代码执行的顺序, 通过转移控制从一块代码到另外一块代码。Swift 有五个控制转移语句:</p>
<p>continue<br>break<br>fallthrough<br>return<br>throw<br>continue, break, 和 fallthrough 下面描述。return 语句在函数部分描述, throw 语句在 Propagating Errors Using Throwing Functions 部分描述。</p>
<h1 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h1><p>continue 语句告诉当前循环停止,然后开始下一次循环。它说 “我在当前循环迭代” 没有离开当前的循环。</p>
<p>下面的例子从一个小写字符串移除所有的元音字母和空格,来创建一个谜语:</p>
<pre><code>
let puzzleInput = "great minds think alike"
var puzzleOutput = ""
let charactersToRemove: [Character] = ["a", "e", "i", "o", "u", " "]
for character in puzzleInput.characters {
    if charactersToRemove.contains(character) {
        continue
    } else {
        puzzleOutput.append(character)
    }
}
print(puzzleOutput)
// 打印 "grtmndsthnklk"
</code></pre>
上面的代码遇见元音或者空格就会调用 continue 关键字, 当前迭代立即结束然后进入下一次迭代。

# Break

break 立即结束整个控制流语句的执行。break 语句可以用在一个 switch 语句或者循环语句,如果你想早点结束执行的话。

# Break 在循环语句

用在循环语句时, break 立即结束循环,然后跳出循环所在的大括号。

# Break 在Switch 语句

用在switch 语句时, break 终止 switch 语句的执行,然后跳出switch语句所在的大括号。

这种行为可以在switch语句中用来匹配或者忽略一个或者多个case. 因为 Swift 的 switch 语句是详尽的而且不允许有空 case, 有时候需要故意匹配和忽略一个case,为了让你的意图明显。整个case写一个break就可以忽略。当case 匹配时, case 里的break语句立即终止switch语句的执行。


下面的例子转换一个字符值,然后判断它在四种语言之一是否表示一个数字, 单个switch case 覆盖了多个值。
<pre><code>
let numberSymbol: Character = "三"  // Chinese symbol for the number 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    print("The integer value of \(numberSymbol) is \(integerValue).")
} else {
    print("An integer value could not be found for \(numberSymbol).")
}
// 打印 "The integer value of 三 is 3."
</code></pre>
上面的例子判断 numberSymbol 是不是拉丁语, 阿拉伯语, 汉语, 或者泰语中的1到4。如果匹配到, switch中的一个case会赋值给可选类型变量 possibleIntegerValue 一个合适的整数值。

在 switch 语句执行完成之后, 例子中使用可选绑定去判断一个值是否找到。possibleIntegerValue 变量是一个可选类型有一个初始值nil, 如果四个case之一给possibleIntegerValue 设置了一个实际值,这个可选绑定就成功了。

因为不可能列出所有的可能字符, 一个默认的case 用来处理其他没匹配的字符。默认case不需要做任何事, 所以它只有一个break语句。当默认case被匹配后, break 语句就结束switch语句的执行n, 代码开始从 if let 语句处继续执行。

# Fallthrough

Swift 的 Switch 语句不会 fall through 到下一个case。 相反, 只有第一个匹配到的case语句执行完成,整个switch语句就完成了执行。不同的是, C 语言要求每个case后面都要加上break 语句,防止 fallthrough. 明显Swift 更加简洁和安全。

如果你想要C语言那种效果的 fallthrough, 你可以选择在case后面加上 fallthrough 关键字。 下面的例子使用fallthrough 创建一个数字的文字描述。
<pre><code>
let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough
default:
    description += " an integer."
}
print(description)
// 打印 "The number 5 is a prime number, and also an integer."
</code></pre>
上例声明了一个字符串变量 description ,然后赋了一个初始值。后面的函数在switch语句中用了这个值 integerToDescribe. 如果 integerToDescribe 的是列表中的一个素数, 函数就把一段文本添加到 description 的后面, 去备注说这个数字是素数。然后用了fallthrough 关键字进入默认的case. 默认的case添加一段额外的文本到 description 之后, 然后switch语句就结束了。

除非integerToDescribe 的值在已知素数列表里, 否则第一个case就不会匹配。 因为没有其他case, integerToDescribe 会被默认的case 匹配。

switch 语句执行完后, 使用 print(_:separator:terminator:) 函数打印description。 这个例子里, 数字5就是一个素数。

# 标签语句

在 Swift 里, 你可以在循环和条件语句种内嵌循环和条件语句,来创建更复杂的控制流结构。不过, 循环和条件语句都可以使用break 语句来提前结束执行。因此, 有时候这很有用,当你决定哪个循环或者条件语句要用break来终止执行。类似的, 如果你有多个嵌套的循环, 它也是有用的,可以明确哪个循环语句继续有效。

为了达到这些目的, 你可以用一个语句标签来标记一个循环或者条件语句。对于条件语句, 你可以使用带着break语句的语句标签来结束标签的语句。对于循环语句, 你可以用带着break或者continue的语句标签来结束或者继续标签语句的执行。

一个标签语句通过放置一个标签来指示,标签放在相同行作为语句的关键字。跟着是一个冒号。 这里有一个while循环语法的例子, 对于所有的循环和switch语句都是相当的规则:
<pre><code>
label name: while condition {
    statements
}
</code></pre>
下面的例子使用带着标签的break和continue语句,这次游戏有了一个额外的规则:

想要赢,你就要登上方格25
如果掷骰子让你超过了方格25, 你必须重掷,直到投出能够登上方格25的数字为止。

游戏的棋盘和原来一样。
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
</div>

finalSquare, board, square, 和 diceRoll 初始化方式跟以前一样:
<pre><code>
let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
</code></pre>
这个版本的游戏使用了一个 while 循环和一个switch 语句来实现游戏的逻辑。 while 循环有一个语句标签 gameLoop 用来表示它是游戏的主要循环。

while 循环的条件是是 while square != finalSquare, 告诉你必须登上方格25。
<pre><code>
gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // diceRoll will move us to the final square, so the game is over
        break gameLoop
    case let newSquare where newSquare > finalSquare:
        // diceRoll will move us beyond the final square, so roll again
        continue gameLoop
    default:
        // this is a valid move, so find out its effect
        square += diceRoll
        square += board[square]
    }
}
print("Game over!")
</code></pre>
每次循环开始摇色子。 循环使用了一个switch语句来考虑移动的结果和是否允许移动,而不是立即用的玩家的位置:

如果摇色子使得玩家移动到最后的方格,那么游戏就结束了。break gameLoop 语句转移控制到整个循环的外面的第一行代码, 结束游戏。
如果摇色子使得玩家超出了最后的方格, 那么移动无效,玩家需要重新摇色子。continue gameLoop 语句结束当前的迭代然后开始下一次迭代。
其他所有情况, 摇色子都是有效的移动。 玩家往前移动 diceRoll 方格, 游戏逻辑检查所有的蛇与梯子。 循环结束, 控制返回条件判断,决定是否需要再来一次。
备注

如果break 语句不使用 gameLoop 标签, 它只会跳出switch 语句,而不会跳出while 语句。使用 gameLoop 标签清楚知道要终止哪个控制语句。

不是必须用 gameLoop 标签,当调用 continue gameLoop 来跳到下一次循环迭代。游戏里只有一个循环。continue 语句影响哪个循环是很清楚的。不过, 使用 gameLoop 标签也没有坏处。这样做是为了和break 标签使用一致,并且让逻辑更加轻易阅读和理解。

# 尽早退出

guard 语句, 很像 if 语句, 根据表达式布尔值执行语句。 使用guard 语句要求条件必须为真。和 if 语句不同, guard 语句总有一个else 字句—如果条件是假 else 会执行。
<pre><code>
func greet(person: [String: String]) {
    guard let name = person["name"] else {
        return
    }

    print("Hello \(name)!")

    guard let location = person["location"] else {
        print("I hope the weather is nice near you.")
        return
    }

    print("I hope the weather is nice in \(location).")
}

greet(person: ["name": "John"])
// 打印 "Hello John!"
// 打印 "I hope the weather is nice near you."
greet(person: ["name": "Jane", "location": "Cupertino"])
// 打印 "Hello Jane!"
// 打印 "I hope the weather is nice in Cupertino."
</code></pre>
如果 guard 语句的条件满足, 代码继续在guard 语句的大括号后执行。所有变量或者常量使用一个可选绑定赋值,它们作为条件的一部分。
如果条件没有满足, else 分支会执行。这个分支转移控制跳出guard 语句所在的代码块。可以使用控制转移语句 return, break, continue, 或者 throw, 或者也可以调用不返回的函数或者方法, 比如 fatalError(_:file:line:).

跟 if 语句做同样的判断比较,使用 guard 语句为了提高代码的可读性。它让你可以写通常不在else 快执行的代码, 同时让你保持代码,来处理违法要求的要求。

# 判断 API 可用性

Swift 支持判断 API 的有效性, 这样可以保证你不会在给定设备上使用不可用的API。

编译器使用SDK中的有效性信息来判断你代码中的所有API。 如果你使用不可用的API,Swift 会报一个编译错误。

在if或者guard语句中使用一个可用性条件去执行一块代码, 取决于你用的API是否运行时可用。一旦编译器验证API在代码块可以用,它就会用这些信息。
<pre><code>
if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}
</code></pre>
上面的可用性条件指出, 对于iOS, if 语句只能在 iOS 10 和以后的版本上执行; 对于 macOS, 只能用在 macOS 10.12 和以后的版本。 最后一个参数, *, 是需要的,用来指定其他平台。if 语句执行在你指定的最小部署设备上。

一般形式中, 可用性条件带着一列平台名和版本号。平台名例如 iOS, macOS, watchOS, 和 tvOS—完整列表, 除了指定大版本号比如 iOS 8, 你还可以指定小版本号比如 iOS 8.3 和 macOS 10.10.3.
<pre><code>
if #available(platform name version, ..., *) {
    statements to execute if the APIs are available
} else {
    fallback statements to execute if the APIs are unavailable
}
</code></pre>
# 函数
函数包含执行特定任务的代码块。你给出一个函数名来表明它是做什么的, 需要时使用函数名来调用。

Swift 统一的函数语法是很灵活的, 可以像C语言一样没有参数名,也可以像objective-C一样带有名称和参数标签。参数可以提供默认值给简单的函数调用,同时可以作为输入输出参数传入。一旦函数调用就会修改传入的变量。

Swift 中的函数都有类型, 由参数类型和返回类型组成。你可以像使用其他类型一样使用这个类型, 这个让传递函数作为参数变得容易, 也可以从函数返回函数。 函数可以写在其他函数里, 在一个内嵌函数范围封装哟有用的功能。

# 定义和调用函数

当你定义一个函数时, 你可以定义一个或者多个命名, 函数的类型值作为输入, 也就是参数。你还可以定义一个值类型,函数执行完传回值。也就是返回值。

每个函数都有名字, 用来描述函数执行的任务。 为了使用一个函数, 你通过名字调用函数,传给它输入值 (参数) 匹配函数参数的类型。函数参数按照相同顺序提供。

下面例子里的函数叫 greet(person:), 因为它做的事情—它输入一个人的名字然后返回一个问候。为了完成这个, 你定义一个输入参数—一个字符串类型 person—然后返回一个字符串类型, 它包含了对这个人问候语。
<pre><code>
func greet(person: String) -> String {
    let greeting = "Hello, " + person + "!"
    return greeting
}
</code></pre>
所有信息都在函数里, 前缀是func 关键字。函数的返回类型用返回箭头-> (连字符跟着一个右方向箭头), 箭头后是返回的类型名。

定义描述了函数的功能, 希望接收的参数, 执行完成返回的值。 定义使得函数在代码各处可以清晰明确的调用:
<pre><code>
print(greet(person: "Anna"))
// Prints "Hello, Anna!"
print(greet(person: "Brian"))
// Prints "Hello, Brian!"
</code></pre>
在person 标签后出入一个字符串类型,调用 greet(person:) 函数, 比如 greet(person: "Anna"). 因为这个函数返回一个字符串类型, greet(person:) 可以被 print(_:separator:terminator:) 函数调用去打印返回值。

备注

print(_:separator:terminator:) 函数第一个参数没有标签, 其他参数是可选的,因为他们有默认值。这些函数语法的变化在下面函数参数标签、参数名和默认参数值中描述。

greet(person:) 函数体先是定义了一个新的字符串常量 greeting,然后设置一个简单的问候信息。然后 greeting 作为返回值传出。函数结束执行然后返回greeting 的当前值。

你可以输入不同值多次调用 greet(person:) 函数。上面的例子展示了输入"Anna" 和 "Brian" 发生了什么。函数返回了定制的问候语。

为了让函数体变短, 你可以合并信息创建和返回语句到一行代码:
<pre><code>
func greetAgain(person: String) -> String {
    return "Hello again, " + person + "!"
}
print(greetAgain(person: "Anna"))
// 打印 "Hello again, Anna!"
</code></pre>
# 函数参数和返回值

Swift 中函数的参数和返回值非常灵活。 你可以定义任何,从带有不具名参数的简单工具函数到具有表达式参数名和不同参数选项的复杂函数。

# 没有参数的函数

函数不要求有输入参数。 这里有个没有输入参数的函数, 调用的时候总是返回相同字符串信息:
<pre><code>
func sayHelloWorld() -> String {
    return "hello, world"
}
print(sayHelloWorld())
// 打印 "hello, world"
</code></pre>
函数定义是还是需要再函数名后加括号, 尽管它没有任何参数。函数调用的时候函数名后面还是跟着一堆括号。

# 多个参数的函数

函数可以有多个输入参数, 写在函数的括号里, 用逗号分开。

这个函数有两个参数,一个人名和是否他们已经被问候过。然后返回对这个人的问候语:
<pre><code>
func greet(person: String, alreadyGreeted: Bool) -> String {
    if alreadyGreeted {
        return greetAgain(person: person)
    } else {
        return greet(person: person)
    }
}
print(greet(person: "Tim", alreadyGreeted: true))
// 打印 "Hello again, Tim!"
</code></pre>
你调用 greet(person:alreadyGreeted:) 函数,传入两个参数,一个是带有person标签的字符串值,一个是带有alreadyGreeted标签的布尔值。用逗号分开。注意这个函数跟上面的 greet(person:) 函数不同。 尽管两个函数名字一样,  greet(person:alreadyGreeted:) 函数有两个参数而 greet(person:) 函数只有一个参数。

# 没有返回值的函数

函数不要求必须有返回值。 这里有个版本的 greet(person:) 函数, 它打印自己的字符串而不是返回字符串:
<pre><code>
func greet(person: String) {
    print("Hello, \(person)!")
}
greet(person: "Dave")
// 打印 "Hello, Dave!"
</code></pre>
因为不需要返回一个值, 所以函数定义没有返回箭头 (->) 或者一个返回值。

备注

严格来说, 这个版本的 greet(person:) 函数依然返回一个值, 尽管返回值没有定义。函数没有返回值是返回了一个特殊的类型 Void. 就是一个简单的空元组, 写作 ().

函数调用的时候返回值被忽略:
<pre><code>
func printAndCount(string: String) -> Int {
    print(string)
    return string.characters.count
}
func printWithoutCounting(string: String) {
    let _ = printAndCount(string: string)
}
printAndCount(string: "hello, world")
// 打印 "hello, world" and returns a value of 12
printWithoutCounting(string: "hello, world")
// 打印 "hello, world" but does not return a value
</code></pre>
第一个函数, printAndCount(string:), 打印一个字符串, 然后返回它的字符数。 第二个函数, printWithoutCounting(string:), 调用第一个函数, 不过忽略了它的返回值。一旦第二个函数被调用, 依然由第一个函数打印信息,但是不用返回值。

备注

返回值可以忽略, 但是如果函数说要返回值就一直要这么做。带有返回值的函数禁止控制流跳出函数底部,如果没有返回一个值的话。如果坚持这么做会导致编译错误。

# 带有多返回值的函数

你可以用元组做为函数的返回值,来实现返回多个值。

下面的例子定义了一个函数 minMax(array:), 用来茶盅整形数组里面的最小值和最大值:
<pre><code>
func minMax(array: [Int]) -> (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {="" if="" value="" <="" currentmin="" }="" else=""> currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
</array.count]></code></pre>
minMax(array:) 函数返回包含两个整数值的元组。这些值用最小和最大标签表明,这个可以在查询函数返回值的时候通过名字访问它们。

minMax(array:) 函数体开始时设置两个变量currentMin 和 currentMax值为数组第一项的值。然后函数开始遍历剩下的值,然后重复和 currentMin 和 currentMax 值进行大小比较。 最后, 最大值和最小值作为一个元组返回。

因为元组的成员值作为函数返回值被命名, 所以可以点语法来访问最大值和最小值:
<pre><code>
let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print("min is \(bounds.min) and max is \(bounds.max)")
// 打印 "min is -6 and max is 109"
</code></pre>
注意函数返回元组时,元组的成员不需要命名, 因为它们的名字作为函数返回类型已经被指定了。

# 可选元组返回类型

如果函数返回的元组类型有可能不存在值,你可以使用一个可选元组返回类型来反应整个元组可能为nil。一个可选元组返回类型括号后面跟着一个问号, 比如 (Int, Int)? 或者 (String, Int, Bool)?.

备注

可选元组类型比如s (Int, Int)? 不同于元组中包含可选类型比如 (Int?, Int?). 有一个可选元组类型, 整个元组都是可选的, 不单单是元组里的值。

minMax(array:) 函数返回的元组包含两个整数值。 然而, 函数不会对传入的数组做任何安全检查。 如果数组包含空数组, minMax(array:) 函数, 上面定义的, 尝试访问 array[0] 会触发运行时错误。

为了处理这种情况, minMax(array:) 函数返回值写成可选元组返回类型,如果数组为空则返回nil:
<pre><code>
func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {="" if="" value="" <="" currentmin="" }="" else=""> currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
</array.count]></code></pre>
你可以用一个可选绑定来判断, 这个版本的 minMax(array:) 函数是返回一个实际元组值还是nil:
<pre><code>
if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print("min is \(bounds.min) and max is \(bounds.max)")
}
// 打印 "min is -6 and max is 109"
</code></pre>
# 函数参数标签和参数名

每个函数参数既有参数标签也有参数名。参数标签在调用函数时使用; 函数中的每个参数调用时使用它们的标签。 参数名用于函数的实现。 默认情况, 参数使用参数名作为标签。
<pre><code>
func someFunction(firstParameterName: Int, secondParameterName: Int) {
    // In the function body, firstParameterName and secondParameterName
    // refer to the argument values for the first and second parameters.
}

someFunction(firstParameterName: 1, secondParameterName: 2)
</code></pre>
所有参数名必须唯一。 尽管多个参数可能有相同的标签, 唯一的参数标签会让你的代码更有可读性。

# 指定参数标签

参数标签写在参数名之前, 用空格分开:
<pre><code>
func someFunction(argumentLabel parameterName: Int) {
    // In the function body, parameterName refers to the argument value
    // for that parameter.
}
</code></pre>
这里有一个 greet(person:) 函数的变种,接受一个人名和家乡然后返回一个问候:
<pre><code>
func greet(person: String, from hometown: String) -> String {
    return "Hello \(person)!  Glad you could visit from \(hometown)."
}
print(greet(person: "Bill", from: "Cupertino"))
// 打印 "Hello Bill!  Glad you could visit from Cupertino."
</code></pre>
参数标签的使用允许函数用表达方式调用, 像句子一样。

# 省略参数标签

如果你不想要参数标签, 写一个下划线代替显式的参数标签。
<pre><code>
func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    // In the function body, firstParameterName and secondParameterName
    // refer to the argument values for the first and second parameters.
}
someFunction(1, secondParameterName: 2)
</code></pre>
如果一个参数有参数标签, 那么调用函数的时候参数必须带上标签。

# 默认参数值

你可以给函数参数赋一个默认值,写在类型的后面。如果定义了默认值, 调用函数时你就可以忽略这个参数。
<pre><code>
func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    // If you omit the second argument when calling this function, then
    // the value of parameterWithDefault is 12 inside the function body.
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12
</code></pre>
没有默认值的参数放在函数参数列表前, 带有默认值的放在后面。没有默认值的参数通常更重要—首先写它们更容易知道相同的函数被调用, 不用管默认参数是否被忽略。

# 可变参数

可变参数接受零个或者多个指定类型的值。你用可变参数指定函数调用时可以传入不同个数的输入值。可变参数写法是在参数类型名后写三个点。

传入可变参数的值在函数体中作为对应类型的数组是可用的。 例如, 带有数字名的可变参数和 Double... 在函数中作为常量数组 [Double]是可用的。

下面的例子计算任意长度的数字的平均数:
<pre><code>
func arithmeticMean(_ numbers: Double...) -> Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers
</code></pre>
备注

一个函数最多有一个可变参数。

# 输入输出参数

函数参数默认是常量。 尝试改变会导致编译期错误。这就意味着你不能错误的改变参数值。如果你想函数改变参数值, 想要这些改变持续到函数调用结束, 你可以定义输入输出参数来代替。

通过把 in-out 关键字写在参数类型前面来写一个输入输出参数。 输入输出参数有一个传入函数的值, 会被函数修改, 然后传出函数取代原有的值。 详情请参照 In-Out Parameters.

你可以只传入一个变量作为输入输出参数。 你不能传入一个常量或者字面值作为参数, 因为常量和字面量不能改变。当你使用它作为输入输出参数时,你可以直接在变量名前加上 (&), 来表示它可以被函数改变。

备注

输入输出参数不能有默认值, 可变参数不能标记为输入输出的。

这里有一个函数 swapTwoInts(_:_:), 有两个输入输出整形参数 a 和 b:
<pre><code>
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>
swapTwoInts(_:_:) 函数简单的交换a和b的值,这个函数通过把a的值存储到一个临时的常量temporaryA 来实现交换, 把b的值赋给a, 然后把 temporaryA 的值赋给b.

你可以调用 swapTwoInts(_:_:) 函数交换两个整形变量的值。 注意 someInt 和 anotherInt 在传给函数的时候前面都加上了 &:
<pre><code>
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 打印 "someInt is now 107, and anotherInt is now 3"
</code></pre>
上面例子展示 someInt 和 anotherInt 的原始值被 swapTwoInts(_:_:) 函数改变, 尽管它们定义在函数之外。

备注

输入输出参数与函数返回值不一样。swapTwoInts 没有定义一个返回值或者返回一个值。但是它依然改变了 someInt 和 anotherInt 的值。 输入输出参数是函数影响外部的一种备选方式。

# 函数类型

每个函数都有一个指定的函数类型, 由参数类型和返回值类型组成。

例如:
<pre><code>
func addTwoInts(_ a: Int, _ b: Int) -> Int {
    return a + b
}
func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {
    return a * b
}
</code></pre>
这个例子定义了两个简单的数学函数 addTwoInts 和 multiplyTwoInts. 两个函数都接受两个整形值, 然后返回一个整形值, 执行合适的数学运算会得出这个结果。

两个函数的类型都是(Int, Int) -> Int. 可以解读为:

“一个函数类型有两个参数, 两个都是整数类型t, 然后返回一个整形值”

这里有另外一个例子, 一个没有参数和返回值的函数:
<pre><code>
func printHelloWorld() {
    print("hello, world")
}
</code></pre>
这个函数类型是 () -> Void, 或者 “一个函数没有参数,返回 Void.”

# 使用函数类型

使用函数类型跟Swift中其他类型很像。例如, 你可以定义一个函数的常量或者变量,然后把一个函数赋值给这个变量:
<pre><code>
var mathFunction: (Int, Int) -> Int = addTwoInts
</code></pre>
这段代码可以解读为:

“定义一个变量 mathFunction, 带有两个整形值的函数类型, 然后返回一个整形值。’ 调用函数 addTwoInts 给这个变量设置值。”

addTwoInts(_:_:) 函数和 mathFunction 变量一样有相同的类型, 所有赋值是允许的。

你现在可以使用 mathFunction 名字调用赋值函数:
<pre><code>
print("Result: \(mathFunction(2, 3))")
// 打印 "Result: 5"
</code></pre>
有相同匹配类型的不同函数也可以赋值给相同的变量, 和非函数类型一样:
<pre><code>
mathFunction = multiplyTwoInts
print("Result: \(mathFunction(2, 3))")
// 打印 "Result: 6"
</code></pre>
其他任何类型, 当你把函数赋值给一个常量或者变量时,你可以留给 Swift 去推断函数类型:
<pre><code>
let anotherMathFunction = addTwoInts
// anotherMathFunction is inferred to be of type (Int, Int) -> Int
</code></pre>
# 函数类型作为参数类型

你可以使用一个函数类型比如 (Int, Int) -> Int 作为另外一个函数的参数。当函数调用的时候,你可以把函数实现的一部分留给调用者。

这里有个一个例子打印上面数学函数的结果:
<pre><code>
func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \(mathFunction(a, b))")
}
printMathResult(addTwoInts, 3, 5)
// 打印 "Result: 8"
</code></pre>
这个例子定义了一个函数 printMathResult(_:_:_:), 有三个参数。第一个参数是 mathFunction, 类型 (Int, Int) -> Int. 你可以传递任何这种类型的函数作为第一个参数。 第二个和第三个参数是 a 和 b, 都是整型, 用来作为数学函数的输入值。

当 printMathResult(_:_:_:) 调用时, 传入 addTwoInts(_:_:) 函数, 和整数 3 和 5. 调用提供的函数, 然后打印结果 8.

printMathResult(_:_:_:) 任务就是打印特定类型数学函数的结果。它不关心函数的实际实现—它只关心函数类型是否正确。 这使得 printMathResult(_:_:_:) 以一种类型安全的方式放手一些功能给函数的调用者。

# 函数类型和返回值

你可以用一个函数类型作为另外一个函数的返回类型。把一个完整的函数类型写在返回箭头后面就可以了。

下一个例子定义了两个简单的函数 stepForward(_:) 和 stepBackward(_:). stepForward(_:) 函数返回一个比输入值大一的值, stepBackward(_:) 函数返回一个比输入值小一的值。两个函数都有一个类型 (Int) -> Int:
<pre><code>
func stepForward(_ input: Int) -> Int {
    return input + 1
}
func stepBackward(_ input: Int) -> Int {
    return input - 1
}
</code></pre>
这里有一个函数 chooseStepFunction(backward:), 返回类型是 (Int) -> Int. chooseStepFunction(backward:) 函数基于一个布尔参数backward 来返回 stepForward(_:) 函数或 stepBackward(_:) 函数:
<pre><code>
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return backward ? stepBackward : stepForward
}
</code></pre>
现在你可以使用 chooseStepFunction(backward:) 去获取一个函数, 然后往前走或者往后走:
<pre><code>
var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero 调用 stepBackward() 函数
</code></pre>
前面的例子决定是否需要一个负数或者正数步去移动currentValue ,让它逐渐趋近于0. currentValue 有个初始值3, 意味着 currentValue > 0 返回真, chooseStepFunction(backward:) 会返回 stepBackward(_:) 函数。 引用的返回函数存储在一个常量 moveNearerToZero.

moveNearerToZero 指向恰当的函数, 它可以用来计步到0:
<pre><code>
print("Counting to zero:")
// Counting to zero:
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// 3...
// 2...
// 1...
// zero!
</code></pre>
# 嵌套函数

到目前为止,你在本章看见的函数都是全局的示例, 它们定义在全局范围。你也可以在其他函数体内定义函数,这就是嵌套函数。

嵌套函数默认对外界隐藏, 但是对于它们的封闭函数依然可以使用。封闭函数可以返回一个嵌套函数, 并允许它给外部使用。

你可以重写上面的 chooseStepFunction(backward:) 例子来使用和返回嵌套函数:
<pre><code>
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the nested stepForward() function
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// -4...
// -3...
// -2...
// -1...
// zero!
</code></pre>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是自包含的功能块,可以传递和用在代码中。Swift 中的闭包和C 和 Objective-C 中的相似。</p>
<p>闭包可以捕获和存储上下文定义的任何常量和变量的引用。这就是关闭了常量和变量。Swift 替你处理闭包的所有内存管理。</p>
<p>备注</p>
<p>如果不熟悉闭包的概念不用担心。 下面会详细描述。</p>
<p>全局和嵌套函数实际上是一种特殊的闭包。闭包通常是下面三种形式之一:</p>
<p>全局函数是闭包,没有名字也不捕获任何值。<br>嵌套函数是闭包,有一个名字也可以从封闭函数中捕获值。<br>闭包表达式是匿名闭包,使用轻量级语法书写,可以捕获上下文的值。<br>Swift 的闭包表达式有一个清楚清晰的风格, 鼓励简洁,整齐的语法优化。这些优化包括:</p>
<p>从上下文推断参数和返回值的类型<br>从单个表达式闭包隐式返回<br>简约参数名<br>尾部闭包语法</p>
<h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><p>嵌套函数, 是一个方便的命名方法,也是在较大函数中定义自包含代码块的方式。不过, 有时候写一个更短的版本很有用, 它很像函数但是没有完整的声明和名字。函数作为参数的时候这个尤其有用。</p>
<p>闭包表达式是内联闭包的一种简写。 闭包表达式提供一些语法优化,以更短的样式书写闭包,但不失清晰和目的性。下面的闭包实例通过精炼一个排序函数来展示这些优化, 每个表达式功能一样,只是更简洁。</p>
<h1 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h1><p>Swift 标准库提供了一个方法 sorted(by:), 对已知类型数组值进行排序, 基于你提供的排序闭包输出。一旦排序完成, sorted(by:) 方法就会返回一个跟旧数组相同类型相同大小的新数组, 数组元素按照正确的顺序。原来的数组并没有被排序方法改变。</p>
<p>下面的闭包表达式使用 sorted(by:) 方法按照字母表倒序排列一个字符串数组。这是要排序的原来的数组:</p>
<pre><code>
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>
sorted(by:) 方法接受带有两个相同类型参数的闭包,作为数组的内容。然后返回一个布尔值,来说明排序后第一个值是出现在第二个值的前面还是后面。

这个例子是排序一个字符串值的数组, 所以排序闭包需要是一个函数类型 (String, String) -> Bool.

提供排序闭包的一个方式是写一个正确类型的函数, 然后把它作为参数传给 sorted(by:) 方法:
<pre><code>
func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}

var reversedNames = names.sorted(by: backward)
// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>
如果第一个字符串 (s1) 大于第二个字符串 (s2), backward(_:_:) 函数返回真, 表明在排序后数组中 s1 应该出现在 s2 前面。 对于字符串中字符, “大于” 意思是 “字母表中出现较晚”。 也就说字母 "B" 大于字母 "A", 字符串"Tom" 大于字符串 "Tim". 这是提供了一个字母表的倒序, "Barry" 排在 "Alex"前面, 等等。

不过, 这种写法很冗长,它本质上是个单一表达式函数 (a > b). 这个例子里, 写成内联排序闭包更可取, 使用闭包表达式语法。

# 闭包表达式语法

闭包表达式一般是下面这种形式:
<pre><code>
{ (parameters) -> return type in
    statements
}
</code></pre>
闭包表达式语法参数可以是输入输出参数, 但是它们不能有默认值。 如果你命名可变参数,那么可变参数也是可以用的。元组也可以用作参数和返回类型。

下面的例子展示了之前 backward(_:_:) 函数的闭包表达式版本:
<pre><code>
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})
</code></pre>
内联闭包的参数和返回类型声明跟backward(_:_:)函数的声明一样。两种情况下, 它写作 (s1: String, s2: String) -> Bool. 不过, 对于内联闭包表达式, 参数和返回类型都写作花括号里,而不是外部。

闭包体以关键字in 开始。这个关键词的意思是闭包参数和返回类型的定义完成了, 闭包体开始了。

因为闭包体太短, 它甚至可以写成一行:
<pre><code>
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )</code></pre>
这个说明 sorted(by:) 方法调用还是一样的。一对括号包括方法的所有参数。 只不过,现在参数在一个内联闭包里。

# 根据上下文推断类型

由于排序闭包作为参数传给函数, Swift 可以推断它的参数类型和返回值类型。sorted(by:) 方法被字符串数组调用, 所以它的参数类型是一个函数类型 (String, String) -> Bool. 这就是说 (String, String) 和 Bool 类型无需写出来作为闭包表达式定义的一部分。因为所有的类型都可以推断, 返回箭头 (->) 和参数名字外的括号都可以被忽略:
<pre><code>
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )</code></pre>
当把闭包传给一个函数或者方法作为内联闭包表达式时,总是可能要推断参数类型和返回类型。结果是, 一旦这个闭包用作函数或者方法参数,你就不需要用完整的形式书写内联闭包。

尽管如此, 如果你想你依然可以显式说明类型, 如果可以避免代码的二义性,这样做是鼓励的。sorted(by:) 方法这种情况, 闭包的目的很清晰,就是排序。读者假设这个闭包可能作用于字符串值是安全的。因为它帮助字符串数组的排序。

# 从单一表达式闭包隐式返回

通过忽略声明的返回关键字,单一表达式闭包可以隐式返回它们单一表达式的结果, 就像前一个例子的版本:
<pre><code>
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )</code></pre>
这里, sorted(by:) 函数的方法参数清晰表明闭包要返回一个布尔值。因为闭包体包含了单一表达式(s1 > s2) ,而且返回值是布尔值, 这里没有二义性, 而且返回值可以忽略。
# 速记参数名

Swift 自动提供速记参数名给内联闭包, 可以用 $0, $1, $2, 来调用闭包参数值

如果你在闭包表达式使用这些速记参数名, 你可以忽略闭包定义的参数列表和个数,然后速记参数名类型会被期望的函数类型推断出来。 关键字in 也可以被忽略, 因为闭包表达式由它的整个包体组成。
<pre><code>
reversedNames = names.sorted(by: { $0 > $1 } )</code></pre>
这里, $0 和 $1 调用闭包的第一个和第二个字符串参数。

# 运算符方法

这里其实有一个更短的方式去写上面的闭包。 Swift 的字符串类型定义了它特有的大于号的实现, 是带有两个字符串类型参数的方法,然后返回一个布尔类型。这很符合 the sorted(by:) 方法的类型需要。因此, 你可以简单的传入大于号, 然后 Swift 会推断你想要用它的字符串特有的实现:
<pre><code>
reversedNames = names.sorted(by: >)</code></pre>

<h1 id="尾闭包"><a href="#尾闭包" class="headerlink" title="尾闭包"></a>尾闭包</h1><p>如果你需要传给函数一个闭包表达式作为最后的参数并且闭包表达式很长的话, 用尾闭包代替是很有用的。尾闭包写在函数调用的括号后面, 尽管它依然是函数的一个参数。 当你使用尾闭包语法时, 作为函数调用部分,你不要给闭包写参数标签。</p>
<pre><code>
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}

// 不使用尾闭包调用函数:

someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})

// 使用尾闭包调用函数:

someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}
</code></pre>
字符串排序闭包也可以使用尾闭包:
<pre><code>
reversedNames = names.sorted() { $0 > $1 }</code></pre>
如果闭包表达式是作为函数或者方法的唯一参数,并且你使用这个表达式作为尾闭包的话, 你调用这个函数的时候可以不用在函数名后写括号:
<pre><code>
reversedNames = names.sorted { $0 > $1 }</code></pre>
当闭包太长无法写成内联单行的时候, 使用尾闭包是最有用的。有一个例子, Swift 数组类型有个方法 map(_:) ,带有一个闭包表达式作为它的单一参数。数组中的每一项都会调用它一次, 为每项返回一个替代映射值 (可能是其他类型)。映射的性质和返回值的类型由闭包决定。

对每个数组元素应用提供的闭包后, map(_:) 方法返回包含新的映射值的新数组, 和原有数组对应值的顺序一致。

这里展示使用带尾闭包的 map(_:) 方法如何把整型值数组转换为字符串值数组。数组 [16, 58, 510] 用来创建新数组 ["OneSix", "FiveEight", "FiveOneZero"]:
<pre><code>
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]</code></pre>
上面的代码创建了一个字典,在整数字和英文名之间建立迎神。同时定义了一个整数数组, 准备转换为字符串数组。

现在你可以用这个数字数组来创建一个字符串数组, 把闭包表达式作为尾闭包传入数组的 map(_:) 方法即可:
<pre><code>
let strings = numbers.map {
    (number) -> String in
    var number = number
    var output = ""
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0
    return output
}
// strings is inferred to be of type [String]
// its value is ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>
数组每个元素调用一次 map(_:) 方法。 你不需要指定闭包输入参数的类型, number, 因为这个值可以被推断出来。

这个例子里, 变量 number 用闭包的 number 参数值来初始化, 所以这个值可以在闭包中修改。 (函数和闭包的参数总是常量的) 闭包表达式指定了一个字符串返回值类型, 来说明存储在映射输出数组中的类型。

每次调用闭包表达式创建一个字符串 output. 它使用余数运算符结算数字的最后一位 (number % 10), 然后用这个位去字典中查找对应的字符串。这个闭包可以用来创建任何大于0数字的字符串表示。

备注

调用字典下标后面跟着感叹号 (!), 因为字典下标返回一个可选值来表示如果键不存在查找就会失败。上面的例子里, 可以保证每次能找到有效的下标键, 所以感叹号用来强制解包存在的值。

从字典获取的字符串会加到 output 前, 有效的建立了倒序的数字字符串版本。

然后数字变量除以10, 因为它是一个整数, 因为取整数倍, 所以 16 变成 1, 58 变成 5, 510 变成 51.

这个过程直到nubmer等于0, 这时闭包返回输出字符串, 然后通过 map(_:) 方法添加到数组。

上例尾闭包语法的使用,完整封装了闭包的功能。不要把整个闭包包含在 map(_:) 方法的method 外面括弧里。

# 捕获值

闭包可以在其定义的上下文中捕获常量和变量值。闭包可以在包体内调用和修改这些常量和变量值, 即使定义常量和变量的原来的范围不存在了。

在 Swift 中, 可以捕获值的最简单的闭包形式是一个内嵌函数, 写在另外一个函数体内。 内嵌函数可以捕获它外部函数的任何参数,而且可以捕获定义在外部函数的任何常量和变量。

这里有函数实例 makeIncrementer, 包含了一个内嵌函数 incrementer. 内嵌函数从它的上下文 incrementer() 捕获两个值, runningTotal 和 amount. 捕获这两个值以后, incrementer 被 makeIncrementer 作为闭包返回, 这个闭包每次调用时会把 runningTotal 增加 amount.
<pre><code>
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}</code></pre>
makeIncrementer 的返回类型是 () -> Int. 意思就是返回一个函数, 而不是一个简单值。返回的函数没有参数, 每次调用有一个整型值。

makeIncrementer(forIncrement:) 函数定义了一个整型变量 runningTotal, 用来保存incrementer 返回的增加的总步数。这个变量初始化值是 0.

makeIncrementer(forIncrement:) 有一个整型参数带有forIncrement 标签, 和一个变量名 amount. 这个参数传给指定 runningTotal 应该增加多少步数。makeIncrementer 定义了一个内嵌函数incrementer, 用来执行实际的递增操作。 这个函数简单把 amount 加到 runningTotal 上去然后返回结果。

单独拿出来, 内嵌函数 incrementer() 不太寻常:
<pre><code>
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}</code></pre>
incrementer() 函数没有任何参数, 然而它从函数体内部调用runningTotal 和 amount。 它从包围它的函数里捕获 runningTotal 和 amount. 引用捕获确保 runningTotal 和 amount 在调用 makeIncrementer 结束后不会消失, 也确保了 runningTotal 在下一次调用 incrementer 函数时依然有效。

备注

作为一个优化, 如果闭包修改一个值, 而且闭包创建后这个值没有改变的话,Swift 可能会不会捕获和保存这个值的副本。

Swift 同时处理了变量释放后的所有的内存管理。

这里有一个 makeIncrementer 活动的例子:
<pre><code>
let incrementByTen = makeIncrementer(forIncrement: 10)</code></pre>
这个例子设置了一个常量 incrementByTen,它调用增量器函数,这个函数每次调用把 runningTotal 变量加10. 多次调用效果如下:
<pre><code>
incrementByTen()
// returns a value of 10
incrementByTen()
// returns a value of 20
incrementByTen()
// returns a value of 30
</code></pre>
如果你再创建一个增量器, 它会有自己新的单独的runningTotal 变量:
<pre><code>
let incrementBySeven = makeIncrementer(forIncrement: 7)
incrementBySeven()
// returns a value of 7
</code></pre>
调用原先的增量器(incrementByTen) 继续增加它的 runningTotal 变量, 不会影响 incrementBySeven 捕获的变量:
<pre><code>
incrementByTen()
// returns a value of 40</code></pre>
备注

如果你把闭包赋值给一个类实例的属性, 然后闭包会通过引用这个实例或者它的成员来捕获这个实例。你将在闭包和实例之间建立一个强引用循环。 Swift 使用捕获列表来打破这种强引用循环。

# 闭包是引用类型

上面的例子, incrementBySeven 和 incrementByTen 都是常量, 但是这些常量引用的闭包依然可以改变它们已经捕获的 runningTotal 变量。 这是因为函数和闭包是引用类型。

每当你赋值函数或者闭包给一个常量或者变量, 实际上你是设置常量或者变量去引用函数或者闭包。上面的例子, incrementByTen 引用的闭包选择是常量, 而不是闭包本身的内容。

这也意味着如果你把一个闭包赋值给两个不同的常量或者变量,它们引用的是相同的闭包:
<pre><code>
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// returns a value of 50
</code></pre>
# 逃逸闭包

闭包被传给函数作为参数的事据说会逃逸, 但是会在函数返回时调用。 一旦你定义带有闭包作为参数的函数, 你可以在参数类型前书写 @escaping 来表示这个闭包允许逃逸。

闭包逃逸的方式之一是,通过存储在定义在函数外部的变量中。作为一个例子, 很多函数用闭包参数作为一个完成处理器来异步工作。 任务开始时函数返回, 但是函数完成之前闭包不会调用—这个闭包需要逃逸, 后面再调用。例如:
<pre><code>
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
</code></pre>
someFunctionWithEscapingClosure(_:) 函数接受一个闭包作为参数,并且把它添加到外部定义的数组。如果你不把这个参数标记为 @escaping, 你会收到一个编译错误。

标记 @escaping 意思是你必须在闭包里显式引用self。例如, 下面的代码, 传给 someFunctionWithEscapingClosure(_:) 的闭包是一个逃逸闭包, 意思是需要显式引用self。 相反, 传给 someFunctionWithNonescapingClosure(_:) 的闭包是非逃逸的, 意思是可以隐式引用self.
<pre><code>
func someFunctionWithNonescapingClosure(closure: () -> Void) {
    closure()
}

class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}

let instance = SomeClass()
instance.doSomething()
print(instance.x)
// Prints "200"

completionHandlers.first?()
print(instance.x)
// Prints "100"
</code></pre>
# 自动闭包

自动闭包是自动创建的闭包, 它包含了作为参数传入函数的表达式。它没有任何参数, 并且被调用时, 它会返回表达式的值。 这个语法便利让你可以忽略函数参数的花括号,只要写一个正常的表达式替代显式的闭包。

调用带有自动闭包的函数很常见, 但是实现那种函数却不常见。例如, assert(condition:message:file:line:) 函数为它的 condition 和 message 参数带了一个自动闭包; 它的condition 参数只在调试模式执行, message 参数则在 condition 是假的时候执行。

自动闭包让你延迟执行, 直到你调用闭包内部代码才会运行。延迟作用对于边界影响和昂贵计算代码很有用, 因为它可以让控制代码什么时候执行。 下面的代码展示闭包的延迟执行。
<pre><code>
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)
// Prints "5"

let customerProvider = { customersInLine.remove(at: 0) }
print(customersInLine.count)
// Prints "5"

print("Now serving \(customerProvider())!")
// Prints "Now serving Chris!"
print(customersInLine.count)
// Prints "4"
</code></pre>
尽管 customersInLine 数组第一个元素被闭包内的代码给移除了, 但是直到这个闭包实际被调用,数组的元素才会被移除。如果闭包永不调用, 闭包内的表达式永远不会执行, 也就是说数组元素永不会被移除。注意 customerProvider 类型不是 String 而是 () -> String—不带参数的函数只是返回一个字符串。

当你把闭包传给函数时,你会得到相同的延迟执行效果。
<pre><code>
// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: { customersInLine.remove(at: 0) } )
// Prints "Now serving Alex!"
</code></pre>
serve(customer:) 函数有一个显式闭包用户返回一个用户名。 下面版本的 serve(customer:) 做了相同的操作,不过, 不是接受一个显式闭包, 而是在参数类型前用了 @autoclosure 属性。 现在你可以调用这个函数,好像他是带有一个String 参数而不是一个闭包。这个参数会自动转换为闭包,因为 customerProvider 参数类型已经标记为 @autoclosure .
<pre><code>
// customersInLine is ["Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customersInLine.remove(at: 0))
// 打印 "Now serving Ewa!"
</code></pre>
备注

过度使用自动闭包会让你的代码很难理解。 上下文和函数名字应该让人知道执行推迟了。

如果你想让自动闭包可以逃逸, 同时使用 @autoclosure 和 @escaping 属性。 
<pre><code>
// customersInLine is ["Barry", "Daniella"]
var customerProviders: [() -> String] = []
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
    customerProviders.append(customerProvider)
}
collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")
// Prints "Collected 2 closures."
for customerProvider in customerProviders {
    print("Now serving \(customerProvider())!")
}
// 打印 "Now serving Barry!"
// 打印 "Now serving Daniella!"
</code></pre>
上面的代码, 不是调用作为 customerProvider 参数的闭包, collectCustomerProviders(_:) 函数添加闭包到 customerProviders 数组。 数组在函数外部声明, 意味着函数返回后数组中的闭包会执行。 结果就是, customerProvider 参数值必须被允许逃离函数范围。

# 枚举
一个枚举定义一组相关的常见类型的值, 让你在代码中用一个类型安全的方式工作。

如果你熟悉 C, 你就会知道 C 枚举会给相关的名字赋值一组整型值。 Swift 中的 枚举更加灵活, 不需要给每个枚举分支赋值。 如果提供一个值 ( “raw” 值), 这个值可以是字符串,字符,或者任意一个整型或者浮点型的值。

另外, 枚举的不同分支可以指定任何类型对应值。很像其他语言的 unions 或者 variants. 你可以定义一个常见的相关的case集合来作为枚举的一部分。每部分都有相应的值对应它们。

Swift 的枚举是第一等类型。它们采用传统上只有类才支持的多种特性, 例如计算属性来提供关于枚举当前值的额外信息, 实例方法来提供有关枚举表示值的功能。枚举还可以用初始化来定义初始化值; 可以扩大它们原有实现的功能; 并且可以遵守协议去提供标准功能。

# 枚举语法

用enum关键字引入枚举,在大括号中定义整个枚举:
<pre><code>
enum SomeEnumeration {
    // enumeration definition goes here
}</code></pre>
这里有个指南者四个方位的例子:
<pre><code>
enum CompassPoint {
    case north
    case south
    case east
    case west
}</code></pre>
定义在枚举中的值就是枚举case (比如 north, south, east, and west) 你可以用case 关键之来引入新的枚举case.

备注

不像 C 和 Objective-C, Swift 枚举case创建时不设一个默认的整数值。上面的 CompassPoint 例子, north, south, east 和 west 不会隐式等于 0, 1, 2 和 3. 相反, 不同的枚举case 在右方都有值t, 有一个显式定义的 CompassPoint 类型。

多个case可以出现在一行,用逗号分开:
<pre><code>
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}</code></pre>
每个枚举定义定义了一个全新的类型。 像Swift中的其他类型一样,它们的名字 (比如 CompassPoint 和 Planet) 应该以大写字母开始。 用单数名而不是复数名:
<pre><code>
var directionToHead = CompassPoint.west</code></pre>
directionToHead 类型在初始化时推断类型。只要 directionToHead 声明为 CompassPoint, 你可以用一个短的点语法来给它设置一个不同的 CompassPoint 值:
<pre><code>
directionToHead = .east</code></pre>
directionToHead 类型已经知道了, 所以设置值的时候可以丢掉类型了。使用显式类型枚举值时这个会让代码高度可读。

# 用Switch语句匹配枚举值

你可以用一个switch语句来匹配单个枚举值:
<pre><code>
directionToHead = .south
switch directionToHead {
case .north:
    print("Lots of planets have a north")
case .south:
    print("Watch out for penguins")
case .east:
    print("Where the sun rises")
case .west:
    print("Where the skies are blue")
}
// 打印 "Watch out for penguins"
</code></pre>
你可以这样解读代码:

“考察 directionToHead 的值。等于 .north, 打印 "Lots of planets have a north". 等于 .south, 打印 "Watch out for penguins".”

…等等。

控制流里描述过, switch 语句考察枚举case 时一定要详尽。 如果 .west case 忽略掉, 代码会编译不过, 因为它没有完整考察 CompassPoint 所有case. 要求详尽保证枚举case不会被疏忽掉。

如果提供所有的case 不合适, 你可以提供一个默认case来覆盖没有显式指明的case:
<pre><code>
let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print("Mostly harmless")
default:
    print("Not a safe place for humans")
}
// 打印 "Mostly harmless"
</code></pre>
# 关联值

上部分实例展示枚举case是一个定义值（类型值）。 你可以把一个常量或者变量设置成 Planet.earth, 然后稍晚再判断这个值。 不过, 有时候存储其他类型的对应值是很有用的。这让你可以随着case存储其他自定义信息。

你可以定义 Swift 枚举来存储给定类型的对应值, 如果需要每个case的值类型可以不同。枚举和其他语言的可辨识联合，标签联合或者变体很类似。

例如, 假设库存跟踪系统需要用两种不同类型的条形码来追踪产品。一些产品用UPC格式标记为 1D 条形码, 这些使用数字 0 到 9. 每个条形码有一个“数字系统” 位, 后面是5个 “制造商码” 位然后是5个“产品码”位。 最后是“校验” 位来校验扫码正确性:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png">
</div>
其他产品用二维码标记, 它使用任意的 ISO 8859-1 字符并且可以编码2953个字符长度:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png">
</div>
这就方便库存跟踪系统能够用四个整数元组存储 UPC 条形码, 用一个任意长度的字符串存储二维码。

在 Swift 里, 枚举定义两种类型条形码可能如下所示:
<pre><code>
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}</code></pre>
可以这样解读:

“定义一个枚举类型 Barcode, 有一个upd的值对应 (Int, Int, Int, Int)类型, 和一个 qrCode 值对应 String 类型。”

定义没有提供任何实际的 Int 或者 String 值—它仅仅定义了对应值的类型。

新的条形码可以用任何一个类型来创建:
<pre><code>
var productBarcode = Barcode.upc(8, 85909, 51226, 3)</code></pre>
这个例子创建了一个新的变量 productBarcode 然后用一个元组值(8, 85909, 51226, 3)赋给它一个 Barcode.upc值。

相同的产品可以指定一个不同的二维码类型:
<pre><code>
productBarcode = .qrCode("ABCDEFGHIJKLMNOP")</code></pre>
这时候, 原先的 Barcode.upc 和它的整数值被新的 Barcode.qrCode 和它的字符串值取代。类型的常量或者变量可以存储 .upc 或者 .qrCode (带着对应的值), 不过在给定时间它们只能存储其中之一。

可以用一个switch语句判断不同的条形码类型。 这次, 无论如何, 对应的值被提取作为switch语句的部分。提取的值作为常量或者变量在switch语句的case中使用:
<pre><code>
switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
case .qrCode(let productCode):
    print("QR code: \(productCode).")
}
// 打印 "QR code: ABCDEFGHIJKLMNOP."
</code></pre>
如果一个case的所有对应值都提取成常量或者变量, 或者都提取成变量, 你可以在这个case 名字前单独放一个let 或者 var, 为简洁性考虑:
<pre><code>
switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")
case let .qrCode(productCode):
    print("QR code: \(productCode).")
}
// 打印 "QR code: ABCDEFGHIJKLMNOP."
</code></pre>
# Raw Values

Associated Values 中的条形码例子展示枚举case如何声明它们存储的不同类型的对应值。作为关联值的替代方式, 枚举case 可以填充默认值 (raw values), 它们都是相同的类型。

这里有个例子,在指定的枚举case 旁存储 raw ASCII 值:
<pre><code>
enum ASCIIControlCharacter: Character {
    case tab = "\t"
    case lineFeed = "\n"
    case carriageReturn = "\r"
}
</code></pre>
这里, 枚举 ASCIIControlCharacter 的raw 值定义为字符类型, 设成成一些比较常见的 ASCII 控制字符。

Raw 值可以是字符串, 字符, 或者任意整型或者浮点型数字类型。 每个raw 值在枚举声明里必须是唯一的。

备注

Raw 值作为对应值是不相同的。Raw 值用来在首次声明枚举时填充值, 就像上面三个 ASCII 码。特定case 的raw 值总是相同的。基于枚举case之一创建一个新的常量或者变量时设置关联值, 每次设置都可以不同。

# 隐式赋 Raw 值

使用存储整型或者字符串类型的raw值时, 你不需要显式为每个case指定一个raw 值。如果你不设置, Swift 会为你自动指定值。

例如, 当整型用作raw 值时, 每个case 的隐式值比前一个case多一。如果第一个case没有设置值, 它的值是0.

下面的枚举是早期 Planet 枚举的细化版本, 带有整数 raw 值来代表距离每个星球距离太阳的顺序:
<pre><code>
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}</code></pre>
上面的例子, Planet.mercury有个显式的raw 值1, Planet.venus 有个显式的值 2, 以此类推。

字符串用作raw 值时, 每个case的隐式值是case 名字的文本字符串。

下面的枚举是早期 CompassPoint 枚举的细化版本, 使用字符串raw 值表示每个方向的名字:
<pre><code>
enum CompassPoint: String {
    case north, south, east, west
}</code></pre>
上面的例子, CompassPoint.south 有个隐式的raw 值 "south", 以此类推。

使用 rawValue 属性来访问枚举case的raw 值:
<pre><code>
let earthsOrder = Planet.earth.rawValue
// earthsOrder is 3

let sunsetDirection = CompassPoint.west.rawValue
// sunsetDirection is "west"
</code></pre>
# 用 Raw 值初始化

如果你用raw-值类型定义一个枚举, 枚举自动得到一个初始化方法, 这个初始化方法有一个raw值类型 (参数 rawValue) 并且返回一个枚举case或者nil. 你可以用这个初始化方法试着创建新的枚举实例。

这个例子用raw 值7标识 Uranus :
<pre><code>
let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet 是 Planet?类型并且等于Planet.uranus
</code></pre>
不是所有的整数值都能找到一个对应的星球, 不过。 因为如此, raw 值初始化方法总是返回一个可选的枚举case. 上面的例子, possiblePlanet 是Planet?类型, 或者 “可选的 Planet.”

备注

raw 值初始化方法是灵活的, 因为不是每个raw 值都会返回一个枚举case.

如果尝试查找位置是11的星球, raw值初始化方法返回的 Planet 值为nil:
<pre><code>
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print("Mostly harmless")
    default:
        print("Not a safe place for humans")
    }
} else {
    print("There isn't a planet at position \(positionToFind)")
}
// 打印 "There isn't a planet at position 11"
</code></pre>
这个例子使用可选绑定访问raw值是11的星球。 语句 if let somePlanet = Planet(rawValue: 11) 创建了一个可选的 Planet, 然后设置 somePlanet 值为这个可选绑定的 Planet. 这种情况, 不可能获取到位置是11的星球, 所有else分支被执行了。

# 递归枚举

递归枚举是这样一种枚举,它有另外一个枚举的实例,这个实例作为一个或者多个case的关联值。通过在枚举case 前书写indirect 来标明枚举是递归的。告诉编译器插入必要的间接层。

例如, 这里有一个枚举存储了简单的算术表达式:
<pre><code>
enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}
</code></pre>
你也可以在枚举开始写 indirect, 来保证所有需要的枚举case 是间接的:
<pre><code>
indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}
</code></pre>
这个枚举可以存储三种算术表达式: 一个简单数字, 两个表达式相加, 两个表达式相乘。 加法和乘法分支对应值也是算术表达式—内嵌表达式。 例如, 表达式 (5 + 4) * 2 乘法右边有一个数字,乘法左边有一个表达式。 因为数据是嵌套的, 枚举存储这个数据也需要支持嵌套—意思就是说枚举需要递归。 下面的代码展示为(5 + 4) * 2创建了一个递归枚举 ArithmeticExpression :
<pre><code>
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))
</code></pre>
递归函数直接使用具有递归结构的数据。例如, 这里有个函数执行一个算术表达式:
<pre><code>
func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}

print(evaluate(product))
// 打印 "18"
</code></pre>
这个函数通过返回关联值执行一个简单的数字。它执行一个加法和一个乘法,执行左边的表达式和右边的表达式,然后相加或者相乘它们。

# 类和结构体
类和结构体是通用的,灵活的结构, 成为你程序代码的构建块。通过对常量,变量,函数使用相同的语法,你定义属性和方法来给类和结构体添加功能

跟其他语言不一样, Swift 不要你给类和结构体创建单独的接口和实现文件。在 Swift里, 你在一个单独的文件中定义类和结构体。 这些类和结构的对外接口对于其他代码是自动可用的。

备注

类的实例一般认为是一个对象。 不过, Swift 的类和结构体在功能上比其他语言更加接近, 这种描述的功能即可用在类的实例也可以用在结构体的实例上。因为如此, 更多通用术语实例被使用了。

# 比较类和结构体

在Swift里类和结构体有很多相同的地方,它们都可以:

定义属性来存储值
定义函数提供功能
定义下标,提供下标语法访问值
定义初始化方法来设定初始状态
扩展默认实现的功能
遵守协议提供特定类型的标准功能

类具备结构体没有的额外能力:

继承,让一个类继承另外一个类的特征。
类型转换,类型转换让你可以在运行是判断和解释类的实例。
析构器可以释放类实例分配的任何资源。
引用计数允许对类实例的多次引用。

备注

结构体传值时都是拷贝,它不使用引用计数。

# 定义语法

类和结构体有相同的定义语法。 使用class 关键字引入类,使用struct关键字引入结构体。两者都把全部定义放在一堆大括号内:
<pre><code>
class SomeClass {
// class definition goes here
}
struct SomeStructure {
// structure definition goes here
}</code></pre>
备注

一旦你定义了一个新的类或者结构体, 你就有效定义了一个全新的Swift类型。给一个大写驼峰式命名 (比如 SomeClass 和 SomeStructure here) 来匹配标准 Swift 类型大写。(比如 String, Int, 和 Bool). 相反, 属性和方法总是小写驼峰式命名 (比如 frameRate 和 incrementCount)

这里有一个结构体和一个类定义的例子:
<pre><code>
struct Resolution {
var width = 0
var height = 0
}
class VideoMode {
var resolution = Resolution()
var interlaced = false
var frameRate = 0.0
var name: String?
}</code></pre>
上面的例子定义了一个新的结构体 Resolution, 描述一个基于像素的显示器解决方案。 这个结构体有两个存储属性 width 和 height. 存储属性是常量或者变量,捆绑存储作为类或者结构体的一部分。这两个属性因为初始值为0而被推断为整型。

上面的例子同时定义了一个新类 VideoMode, 来描述一个指定的视频模式用来视频显示。 这个类有四个变量存储属性。 第一个是 resolution, 用一个新的 Resolution 结构体实例来初始化, 推断为 Resolution 属性类型。 其他三个属性, 新的 VideoMode 实例将会用一个设置为false的交错设置来初始化 (意思是 “非交错视频”), 一个回放帧率是 0.0, 一个可选字符串 name. name 属性自动得到默认值nil, 或者 “没有名字值”, 因为它是一个可选类型。

# 类和结构体实例

Resolution 结构体定义和 VideoMode 类定义仅仅描述了一个 Resolution 或者 VideoMode 看起来是什么样子。 他们没有描述一个指定的 resolution 或者video mode. 为了实现这个, 你需要创建结构体或者类的实例。

结构体和类实例的创建语法非常相似:
<pre><code>
let someResolution = Resolution()
let someVideoMode = VideoMode()</code></pre>
结构体和类都使用初始化方法创建实例。 最简单的初始化语法就是使用类或者结构的类型名后面跟着一个空的括号, 比如 Resolution() 和 VideoMode(). 这个创建了类或者结构体的实例,给所有属性设置默认值。

# 访问属性

你可以用点语法访问实例的属性。 在点语法中, 属性名跟着实例名, 用点分开 (.), 没有任何空格:
<pre><code>
print("The width of someResolution is \(someResolution.width)")
// 打印 "The width of someResolution is 0"
</code></pre>
在这个例子里, someResolution.width 调用 someResolution 的宽度属性, 然后返回它的默认值0.

你可以获取子属性, 比如 width 属性就是 VideoMode 中的resolution 的属性:
<pre><code>
print("The width of someVideoMode is \(someVideoMode.resolution.width)")
// 打印 "The width of someVideoMode is 0"
</code></pre>
你还可以用点语法为变量属性指定新值:
<pre><code>
someVideoMode.resolution.width = 1280
print("The width of someVideoMode is now \(someVideoMode.resolution.width)")
// 打印 "The width of someVideoMode is now 1280"
</code></pre>
备注

跟 Objective-C 不同, Swift 让你可以直接设置结构体属性的子属性。 上面最后一个例子, someVideoMode 属性resolution的子属性width 就是直接设置的, 无需你把整个resolution 属性设置成新值。

# 结构体类型成员初始化方法

所有的结构体都有一个自动产生的成员初始化方法, 你可以用来初始化新的结构体实例的成员属性。 新实例属性的初始值可以根据名字传入成员初始化方法:
<pre><code>
let vga = Resolution(width: 640, height: 480)</code></pre>
跟结构体不同, 类实例不会接受一个默认的成员初始化方法。

# 结构体和枚举是值类型

值类型指的是赋给变量或者常量的时候会进行拷贝的类型, 或者在传给函数使用的时候。

通过前面的章节,你实际上已经广泛使用了值类型。 事实上, 所有Swift 的基础类型—整型, 浮点数, 布尔类型, 字符串类型, 数组和字典都是值类型, 背后都是用结构体实现。

Swift 中所有的结构体和枚举都是值类型。意思就是你创建的任何结构体和枚举—任何它们作为属性的值类型—当它们在你的代码中传递时总是拷贝的。

看一下这个例子, 使用了前一个例子中的 Resolution 结构体:
<pre><code>
let hd = Resolution(width: 1920, height: 1080)
var cinema = hd</code></pre>
这个例子定义了一个常量 hd 然后用初始化方法赋值给它。

然后声明一个变量 cinema 并且把hd 的当前值赋给它。因为 Resolution 是一个结构体, 存在实例的拷贝就创建了。新的拷贝赋值给 cinema. 尽管 hd 和 cinema 现在有了相同的宽和高, 它们背后是完全不同的两个实例。

下一步, cinema 宽度属性修改为2K标准的宽度,用于数字电影项目(2048 像素宽和 1080 像素高):
<pre><code>
cinema.width = 2048
检查cinema的宽度属性,显示它的确被修改为 2048:

print("cinema is now \(cinema.width) pixels wide")
// 打印 "cinema is now 2048 pixels wide"

不过, 原来hd 的宽度属性依然是旧值 1920:

print("hd is still \(hd.width) pixels wide")
// 打印 "hd is still 1920 pixels wide"
</code></pre>
一旦cinema赋值为hd的值, 存储在hd中的值就会拷贝到新的cinema实例。 最后的结果是两个完全独立的实例, 正好都包含相同的数值。 因为它们是单独的实例, 设置cinema 的宽度为 2048 并不影响 hd 的宽度。

相同的行为适用于枚举:
<pre><code>
enum CompassPoint {
case north, south, east, west
}
var currentDirection = CompassPoint.west
let rememberedDirection = currentDirection
currentDirection = .east
if rememberedDirection == .west {
print("The remembered direction is still .west")
}
// 打印 "The remembered direction is still .west"
</code></pre>
当 rememberedDirection 被赋值为 currentDirection的值时, 实际上设置的是一个值的拷贝。 改变 currentDirection 的值之后不会影响原先存储在rememberedDirection 中的值。

# 类是引用类型

跟值类型不同, 它们赋值给变量或者常量的时候不会发生拷贝, 传递给函数也一样。 相对一个拷贝, 用的是引用已经存在的实例。

这里有一个例子, 使用上面定义的 VideoMode 类:
<pre><code>
let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0
</code></pre>
这个例子声明了一个新的变量 tenEighty 并且把一个新的VideoMode 实例赋值给它。视频模式还是用的19020乘以1080 的HD 的拷贝。它设置成交错的,给了一个名字 "1080i". 最后, 设置了25 帧每秒的帧速。

下一步, tenEighty 赋值给一个新的常量 alsoTenEighty, 然后改变 alsoTenEighty 帧速:
<pre><code>
let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
</code></pre>
因为类是引用类型, tenEighty 和 alsoTenEighty 实际上引用的是相同的 VideoMode 实例。它们不过是同一个实例的两个不同的名字。

查看tenEighty 的帧速属性, 显示它变成了新的帧速率 30.0:
<pre><code>
print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")
// 打印 "The frameRate property of tenEighty is now 30.0"</code></pre>
注意 tenEighty 和 alsoTenEighty 声明成常量而不是变量。 不过, 你仍然可以改变 tenEighty.frameRate 和 alsoTenEighty.frameRate, 因为 tenEighty 和 alsoTenEighty 常量的值实际没有改变。 tenEighty 和 alsoTenEighty 它们不保存 VideoMode 实例, 背后它们都是引用一个 VideoMode 实例。 是VideoMode 下面的 frameRate 属性被改变了, 不是引用VideoMode 的常量值被改变。

# 等号运算符

因为类是引用类型, 背后可能是多个常量或变量引用同一个类实例。 (结构体和枚举不是这样, 因为它们赋值给常量或者变量,或者传给函数总是拷贝的)

有时候,找出两个常量或者变量是否引用同一个类实例是很有用的。为了实现这个, Swift 提供了两个等号运算符:
<pre><code>
相同 (===)
不相同 (!==)</code></pre>
用这两个运算符去判断两个常量或者变量是否引用同一个实例:
<pre><code>
if tenEighty === alsoTenEighty {
print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
}</code></pre>
// 打印 "tenEighty and alsoTenEighty refer to the same VideoMode instance."
注意“相同” (用三个等号表示) 跟“等于” (用两个等号表示)还不同:

“相同” 意思是两个类实例常量或者变量引用相同的类实例。
“等于” 意思是两个实例值相等, 一些“等于”的相关意思, 由类型设计者定义。
当你自定义类和结构体时, 你有责任决定两个实例“等于”在符合条件。实现“等于” and “不等于” 运算符的过程在等于运算符中描述。

# 指针

如果你熟悉 C, C++, 或者 Objective-C, 你可能会知道这些语言使用指针来指向内存地址。 Swift 的常量或者变量,引用一个实例很像C语言的指针, 但是不会直接指向内存地址, 并且不需要你书写 (*)来表明你要创建一个引用。 相反, 这些引用和Swift 中的其他任何常量或者变量的定义很像。

# 在类与结构体中选择

你可以在你的代码块中同时使用类和结构体来定义自定义数据类型。

不过, 结构体实例总是用值传递, 而类总是使用引用传递。这就意味着它们适用于不同的任务种类。在你需要考虑数据构建和功能时, 觉得是否每一个数据构建应该选用类还是结构体。

一个通用的指导是, 下面一个或者多个条件符合时考虑使用一个结构体:

结构体的主要目的是封装一些相关的简单数据值。
传递结构体实例是拷贝而非引用。
结构体存储的任意属性也是值类型, 这些属性期望是拷贝而非引用使用。
结构体不需要继承其他存在类型的属性或者行为。
适合结构体的好例子:

几何形状的大小, 可能要封装一个宽度属性和一个高度属性, 两者都是浮点型。
使用一个系列的范围, 可能封装一个起点属性和一个长度属性, 两者都是整型。
3D坐标系的点, 可能要封装 x, y 和 z 属性, 每个都是浮点型。
其他情况, 定义一个类, 然后创建类的实例用来管理和传递引用。 在实践中, 意思自定义数据构建使用类而不是结构体。

# 字符串,数组和字典的赋值和拷贝行为

在 Swift 中, 一些基本的数据类型像String, Array, 和 Dictionary 都是用结构体实现的。 这就意味着例如字符串,数组和字典在赋值给常量或者变量时,也是被拷贝的, 传递给函数或者方法时也一样。

这个行为不同于 Foundation: NSString, NSArray, 和 NSDictionary, 它们是用类实现的。字符串,数组和字典在 Foundation 中赋值时用的引用而非拷贝。

备注

上面描述的拷贝。 在你的代码里这种行为似乎总是发生。 然而, Swift 只有在真正需要这么做的时候才进行实际的拷贝。 Swift管理所有的值拷贝来确保性能最优, 所以你不应避免赋值来抢占这种优化。

# 属性
属性关联特定的类,结构体或者枚举的值。 存储属性作为实例的一部分用来存储常量或者变量的值, 而计算属性用来计算一个值。 计算属性由类,结构体和枚举提供。 存储属性仅由类和结构体提供。

存储和计算属性通常关联特定类型的实例。 不过, 属性也可以管理类型本身。 比如类型属性。

另外, 你可以定义观察者来监视属性值的改变, 自定义响应的行为。 属性观察者可以添加到你定义的存储属性, 也可以是子类集成父类的属性。

# 存储属性

最简单的形式, 一个存储属性是作为特定类和结构体的常量或者变量。 存储属性既可以是变量也可以是常量。

你可以提供一个默认值作为存储属性定义的一部分。你也可以在初始化时改变它的初始值。对于常量存储属性也是如此。

下面的例子定义了一个结构体 FixedLengthRange, 描述了一个整型的范围, 它有一个长度一旦创建就不可修改:
<pre><code>
struct FixedLengthRange {
var firstValue: Int
let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// the range represents integer values 0, 1, and 2
rangeOfThreeItems.firstValue = 6
// the range now represents integer values 6, 7, and 8
</code></pre>
FixedLengthRange 实例有一个变量存储属性 firstValue 和一个常量存储属性 length. 上面这个例子, length 在新实例创建时初始化而后不可修改, 因为它是一个常量属性。

# 常量结构体的存储属性

如果你创建一个结构体实例并把它赋值给一个常量, 你就不能修改这个实例的属性, 即使它们定义成变量属性:
<pre><code>
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// this range represents integer values 0, 1, 2, and 3
rangeOfFourItems.firstValue = 6
// 这里会报错, 即使 firstValue 是变量属性
</code></pre>
因为rangeOfFourItems 声明成一个常量, 所以不能修改 firstValue 属性, 即使 firstValue 是一个变量属性。

这个行为是因为结构体是值类型。 一个值类型的实例被标记为常量, 那么它所有的属性也变成了常量。

对于类来说不是这样, 类是引用类型。 如果你把类实例赋值给一个常量, 你依然可以修改类的变量属性。

# 延迟存储属性

延迟存储属性的初始值在首次使用时才会计算。标示延迟存储属性通过在声明前书写 lazy 修饰符实现。

备注

你应该总是把延迟属性声明成变量, 因为它的初始值可能在实例初始化完成后才获取到。Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.

延迟属性在初始化值需要依赖外部因素时很有用,它们的值直到实例初始化完成后才知道。 当属性初始值需要复杂和大量计算时，延迟属性需要时再执行加载也非常有用。

下面的例子使用一个延迟存储属性来避免一个复合类的不必要的初始化。这个例子定义了两个类 DataImporter 和 DataManager, 两个都没有完整显示:
<pre><code>
class DataImporter {
/*
DataImporter is a class to import data from an external file.
The class is assumed to take a non-trivial amount of time to initialize.
*/
var fileName = "data.txt"
// the DataImporter class would provide data importing functionality here
}

class DataManager {
lazy var importer = DataImporter()
var data = [String]()
// the DataManager class would provide data management functionality here
}

let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// the DataImporter instance for the importer property has not yet been created
</code></pre>
DataManager 类有一个存储属性 data, 用一个新的,空的字符串数组初始化。 尽管它其余的功能没有显示, DataManager 类的目的是管理和提供对字符串数据数组的访问。

类的部分功能是可以从文件导入数据。 这个功能由 DataImporter 类提供, 假设初始化时间微不足道。 这是因为当DataImporter实例被初始化时, DataImporter 实例需要读取文件内容到内存。

DataManager 实例在没有任何文件输入的情况下管理数据也是有可能的, 所以 DataManager 创建时不需要创建一个新的 DataImporter 实例。 相反, 真正需要使用DataImporter的时候再创建更有意义。

因为它标记了lazy 修饰符, DataImporter 实例只会在 importer 属性首次被访问的时候创建, 比如当它的 fileName 属性需要的时候:
<pre><code>
print(manager.importer.fileName)
// the DataImporter instance for the importer property has now been created
// 打印 "data.txt"
</code></pre>
备注

如果lazy 标示的属性被多线程同时访问并且这个属性还未初始化, 不能保证这个属性只会初始化一次。

# 存储属性和实例变量

如果你熟悉 Objective-C, 你可能了解它提供了两种方式来存储值和引用。 除了属性, 你可以使用实例变量作为属性的后备来存储值。

Swift 把这些概念结合到单独的属性声明。 一个 Swift 属性没有相应的实例变量, 属性的后备存储不能直接访问。 这个方法避免了在不同上下文访问值的混乱并且把属性的声明简化到单独明确的语句。所有的属性信息—包括它的名字, 类型, 和内存管理特性—作为类型定义的部分定义在单独的位置。

# 计算属性

除了存储属性, 类, 结构体, 和枚举还可以定义计算属性, 计算属性不存储值。相反, 它们提供了一个 getter 和一个可选的 setter 方法来简介获取或者设定其他属性和值。
<pre><code>
struct Point {
var x = 0.0, y = 0.0
}
struct Size {
var width = 0.0, height = 0.0
}
struct Rect {
var origin = Point()
var size = Size()
var center: Point {
get {
let centerX = origin.x + (size.width / 2)
let centerY = origin.y + (size.height / 2)
return Point(x: centerX, y: centerY)
}
set(newCenter) {
origin.x = newCenter.x - (size.width / 2)
origin.y = newCenter.y - (size.height / 2)
}
}
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// 打印 "square.origin is now at (10.0, 10.0)"
</code></pre>
这个例子定义了三个结构体使用几何形状:

Point 封装了一个点的x和y坐标。
Size 封装了一个宽度和高度。
Rect 用一个原点和大小定义了一个矩形。
Rect 结构体也提供了一个计算属性 center. 一个Rect 的当前中心位置总是取决于它的原点和大小。所以你不需要显示存储中心的值。 相反, Rect 为计算center自定义了 getter 和 setter 方法。确保你像使用真正的存储属性一样使用矩形的中心。

前面的例子创建了一个新的 Rect 变量 square. square 原点初始化为 (0, 0), 宽度和高度都是 10. 这个正方形在下面的图表里用蓝色正方形表示。

square 变量的 center 属性通过点语法访问, 这个导致 getter 方法被调用, 来获取当前属性值。 相比返回存在的值, getter 实际上计算并返回一个新的 Point 来表示正方形的中心。从上面可以看到, getter 正确返回了中心点 (5, 5).

center 属性然后被设置成新值 (15, 15), 这会把正方形往右上方移动, 如下图中的橙色正方形。 设置 center 属性会调用 setter 方法, 这个会修改原点属性的x和y值, 然后移动正方形到新的位置。
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png">
</div>
# Setter 简化声明

如果一个计算属性的 setter 没有定义设置用的新值名, 默认的名字 newValue 会被使用。这里有一个Rect 结构体的替代版本, 使用了这种简化符号:
<pre><code>
struct AlternativeRect {
var origin = Point()
var size = Size()
var center: Point {
get {
let centerX = origin.x + (size.width / 2)
let centerY = origin.y + (size.height / 2)
return Point(x: centerX, y: centerY)
}
set {
origin.x = newValue.x - (size.width / 2)
origin.y = newValue.y - (size.height / 2)
}
}
}
</code></pre>
# 只读计算属性

只有getter 没有 setter 的计算属性就是人们所说的只读计算属性。一个只读计算属性总是返回一个值, 可以通过点语法访问, 但是不可以设置为其他值。

备注

你必须把计算属性包含只读计算属性声明为变量, 因为它们的值是不固定的。let 关键字只有用于常量属性, 表明它们一旦初始化就不能再更改。

去掉 get 关键字和它的括号,你可以简化一个只读计算属性的声明:
<pre><code>
struct Cuboid {
var width = 0.0, height = 0.0, depth = 0.0
var volume: Double {
return width * height * depth
}
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// 打印 "the volume of fourByFiveByTwo is 40.0"
</code></pre>
这个例子定义了一个新的结构体 Cuboid, 表示一个三维长方体, 具有 width, height, 和 depth 属性。 这个结构体同时有一个只读计算属性 volume, 用来计算和返回长方体的体积。 设置体积是没有意义的, 因为特定体积值用哪些长宽高是不清楚的。 尽管如此, 给外部用户提供一个只读计算属性来得到立方体的计算后的体积还是有用的。

# 属性观察者

属性观察者观察并响应一个属性值的变化。 每次属性值设置都会调用属性观察者, 即使新值和属性当前值一样也会调用。

你可以给任何你定义的存储属性添加观察者, 除了延迟加载的存储属性。 你也可以给一个继承来的属性添加观察者,只需要在子类重写这个属性即可。你不需要给一个非重写的计算属性添加属性观察者, 因为你可以在它们的setter 方法里观察和响应变化。

你可以选择定义这些属性观察者之一或全部:

willSet 在值存储前调用。
didSet 在新值存储后立即调用。
如果你实现一个 willSet 观察者, 它会以常量参数形式传递新属性的值。 你可以简化参数名作为 willSet 的实现部分。 如果你在实现中不写参数名和括号, 参数名默认是 newValue.

类似的, 如果你实现 didSet 观察者, 它包含旧的属性值作为常量产生传递。 你可以命名这个参数或者使用默认参数名 oldValue. 如果你在它自己的didset 观察者里给这个属性设置值, 你赋给它的新值会替换刚刚设置的值。

备注

父类初始化方法调用后, 父类属性的 willSet 和 didSet 观察者在子类初始化属性的时候调用。 在父类初始化调用之前, 当一个类设置它自己的属性时它们不会再被调用。

这里有一个 willSet 和 didSet 的例子。 下面的例子定义了一个新类 StepCounter, 用来计算一个人走路的总步数。 这个类用在输入数据或者其他记录一个人日常锻炼的计步器。
<pre><code>
class StepCounter {
var totalSteps: Int = 0 {
willSet(newTotalSteps) {
print("About to set totalSteps to \(newTotalSteps)")
}
didSet {
if totalSteps > oldValue  {
print("Added \(totalSteps - oldValue) steps")
}
}
}
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
</code></pre>
StepCounter 类声明了一个整型 totalSteps. 这是一个存储属性,带有 willSet 和 didSet 观察者。

totalSteps 属性设置新值的时候 willSet 和 didSet 观察者会调用。即使这个新值跟当前值一样, 也会调用。

这个例子 willSet 观察值使用一个自定义的参数 newTotalSteps 来更新值。在这个例子里, 它简单打印将要设置的值。

didSet 观察者在 totalSteps 值更新后调用。它比较 totalSteps 的新旧值。如果总步数增加了, 打印增加步数的信息。didSet 观察者没有提供一个自定义参数名, 用的是and the default name of oldValue is used instead.

备注

你如果传递一个带有观察者的属性给函数作为输入输出参数的话, willSet 和 didSet 观察者总会被调用。这是因为输入输出参数的内存赋值模型: 函数结尾这个值总会写回属性。

# 全局变量和局部变量

上述描述的计算和观察属性的能力也可以用于全局变量和局部变量。全局变量定义在函数,方法,闭包或者类型上下文之外。局部变量则是定义在函数,方法或者闭包上下文内。

前面章节遇到的全局和局部变量都是存储变量。 存储变量很像存储属性, 提供特定类型值的存储并且允许值的设置和获取。

不过, 不过你可以在全局获取局部范围,定义计算变量,为存储变量定义观察者。计算变量计算它们的值, 而非存储它, 它们和计算属性写法一样。

备注

Global 常量和变量总是延迟计算, 跟延迟的存储属性类似方式。但是和延迟存储属性不同的是, 全局常量和变量不需要标记 lazy 修饰符。

局部常量和变量不能是延迟计算的。

# 类型属性

Instance 属性属于特定类型的实例。 每次你创建这种类型的实例, 它都有自己一组属性值, 和其他实例区分开来。

你还可以定义类型自己的属性, 而不是这种类型实例的属性。这里只会有这些属性一个拷贝, 不管你创建多少那种类型的实例。这些属性就是类型属性。

定义某种类型实例的通用值时类型属性很有用, 比如常量属性所有实例都可以用 (像C里面的静态常量), 或者变量属性用来存储那种类型的通用值 (想C里面的静态变量).

存储类型属性可以是常量或者变量。计算类型属性总是变量, 和计算实例属性一样。

备注

跟存储实例属性不同, 你必须给存储类型属性一个默认值。这是因为类型本身没有初始化方法, 不能在初始化时给存储类型属性指定一个初始值。

存储类型属性首次访问时是延迟初始化的。它们保证只进行一次初始化, 即使被多线程同时访问, 它们不需要用lazy 修饰符标记。

# 类型属性语法

在 C 和 Objective-C 中, 你定义静态常量和变量作为全局静态变量。 在 Swift 里, 类型属性写作类型定义的一部分, 在类型外部的大括号里, 并且每种类型属性显式局限于它支持的类型。

用static关键字定义类型属性。 对于类的计算类型属性, 你可以用 class 关键字去允许子类重写父类的实现。下面的例子展示存储和计算类型属性的语法:
<pre><code>
struct SomeStructure {
static var storedTypeProperty = "Some value."
static var computedTypeProperty: Int {
return 1
}
}
enum SomeEnumeration {
static var storedTypeProperty = "Some value."
static var computedTypeProperty: Int {
return 6
}
}
class SomeClass {
static var storedTypeProperty = "Some value."
static var computedTypeProperty: Int {
return 27
}
class var overrideableComputedTypeProperty: Int {
return 107
}
}
</code></pre>
备注

上面的例子是只读类型的计算属性, 不过你要可以定义读写类型的计算属性。

# 查询和设置类型属性

类型查询和设置使用点语法, 跟实例属性很像。不过, 类似属性使用类型查询和设置, 不是使用类型的实例。 例如:
<pre><code>
print(SomeStructure.storedTypeProperty)
// Prints "Some value."
SomeStructure.storedTypeProperty = "Another value."
print(SomeStructure.storedTypeProperty)
// Prints "Another value."
print(SomeEnumeration.computedTypeProperty)
// Prints "6"
print(SomeClass.computedTypeProperty)
// Prints "27"
</code></pre>
下面的例子用了两个存储属性作为结构体的一部分, 对多个音轨模拟了一个音频水平计。每个音轨有一个在0和10之间的整数音频水平。

下面图展示了两个音轨怎样合成一个立体音频水平计。当一个音轨的音频水平是0时, 那个音轨的没有灯会亮。 当这个音频水平是10时, 那个音轨的灯全部点亮。 这个图中, 左边音轨当前水平值是 9, 右边音轨当前水平是 7:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png">
</div>
上面描述的音轨用 AudioChannel 结构体的实例表示:
<pre><code>
struct AudioChannel {
static let thresholdLevel = 10
static var maxInputLevelForAllChannels = 0
var currentLevel: Int = 0 {
didSet {
if currentLevel > AudioChannel.thresholdLevel {
// cap the new audio level to the threshold level
currentLevel = AudioChannel.thresholdLevel
}
if currentLevel > AudioChannel.maxInputLevelForAllChannels {
// store this as the new overall maximum input level
AudioChannel.maxInputLevelForAllChannels = currentLevel
}
}
}
}
</code></pre>
AudioChannel 结构体定义了两个存储类型属性来支持它的功能。 第一个是 thresholdLevel, 定义了音频水平最大阈值。对于所有AudioChannel 实例这是一个常量值10. 如果音频信号遇到大于10的值, 它封顶就是阈值。

第二个类型属性是一个变量存储属性 maxInputLevelForAllChannels. 这个保持追踪 AudioChannel 实例接收的最大输入值。 它的初始值是 0.

AudioChannel 结构体同时定义了一个存储实例属性currentLevel, 用来表示0到10之间的音轨当前音频水平。

currentLevel 属性有一个didSet 属性观察者来判断 currentLevel 设置时的值。这个观察者执行两个判断:

如果新值大于阈值, currentLevel 封顶值就是阈值。
如果新值(还没有封顶) 大于之前 AudioChannel 实例接收的值, 属性观察者把新的 currentLevel 值存储到 maxInputLevelForAllChannels 类型属性中。
备注

第一个判断, didSet 观察值把 currentLevel 设置成一个不同值。这个不会导致观察者被再次调用。

你可以用 AudioChannel 结构体创建两个新的音轨 leftChannel 和 rightChannel, 来表示这个音频水平是一个立体声系统:
<pre><code>
var leftChannel = AudioChannel()
var rightChannel = AudioChannel()
If you set the currentLevel of the left channel to 7, you can see that the maxInputLevelForAllChannels type property is updated to equal 7:

leftChannel.currentLevel = 7
print(leftChannel.currentLevel)
// Prints "7"
print(AudioChannel.maxInputLevelForAllChannels)
// Prints "7"
If you try to set the currentLevel of the right channel to 11, you can see that the right channel’s currentLevel property is capped to the maximum value of 10, and the maxInputLevelForAllChannels type property is updated to equal 10:

rightChannel.currentLevel = 11
print(rightChannel.currentLevel)
// Prints "10"
print(AudioChannel.maxInputLevelForAllChannels)
// Prints "10"
</code></pre>
# 方法
方法是对应特定类型的函数。类,结构体和枚举都可以定义实例方法, 封装了特定的任务和功能用于给定类型的实例。类, 结构体和枚举也可以定义类型方法, 它们对应类型本身。类型方法很像 Objective-C 中的类方法。

结构体与枚举可以定义方法,是Swift 与 C 和 Objective-C之间一个巨大的区别。在Objective-C, 只有类可以定义方法。在 Swift, 你可以选择是否定义一个类,结构体或者枚举, 并且可以灵活定义你创建类型下的方法。

# 实例方法

实例方法属于特定类,结构体或者枚举实例的函数。或者提供方式访问和修改实例的属性,或者提供实例目的相关的功能。实例方法和函数语法一样。

在它所属的类型开闭括号里书写一个实例方法。 一个实例方法可以隐式访问这个类型所有其他的实例方法和属性。一个实例方法只能被它属于的类型调用。 没有实例不能单独调用。

这里有个例子,定义了一个简单的类 Counter , 来计算一个行为的次数:
<pre><code>
class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}
</code></pre>
Counter 类定义了三个实例方法:

increment() 把计数器加1.
increment(by: Int) 把计数器增加指定整数。
reset() 重置计数器为0
Counter 类同时声明了一个变量属性, count, 来跟踪当前计步器的值。

调用实例方法跟属性一样使用点语法:
<pre><code>
let counter = Counter()
// the initial counter value is 0
counter.increment()
// the counter's value is now 1
counter.increment(by: 5)
// the counter's value is now 6
counter.reset()
// the counter's value is now 0
</code></pre>
Function 参数可以用一个名字和一个参数标签。

# self 属性

每个类型的实例都有一个隐式的属性 self, 等于实例自己。 你可以用在实例方法内引用当前实例。

The increment() method in the example above could have been written like this:
<pre><code>
func increment() {
    self.count += 1
}</code></pre>
在实践中, 你不需要经常在代码中写self. 如果不显示书写 self, 一旦你在一个方法里使用了已知的属性或者方法名, Swift 就会假设你引用的是当前实例的属性或者方法。这个假设在Counter三个实例方法中count被证明了。

这个规则的例外情况是, 一个实例方法的参数名和实例的属性名一样。这种情况下, 参数优先, 有必要用更有效的方式调用属性。用self 属性来区分参数名和属性名。

这里, self 避免一个方法参数叫 x 与一个实例属性叫 x 的混乱:
<pre><code>
struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOf(x: Double) -> Bool {
        return self.x > x
    }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOf(x: 1.0) {
    print("This point is to the right of the line where x == 1.0")
}
// 打印 "This point is to the right of the line where x == 1.0"
</code></pre>
不带self 前缀, Swift 会假设两个 x 都是引用方法的参数 x.

# 在实例方法中修改值类型

结构体和枚举是值类型。默认情况下, 值类型的属性不能在实例方法内部修改。

不过, 如果你需要再特定方法中修改结构体和枚举的属性, 你可以选择这个方法的变异行为。方法就可以在内部变异它的属性, 方法结束后这个种改变会写回先前的结构体。这个方法也可以给隐式的self属性指定一个完全全新的实例, 方法结束后这个新值会替代原先存在的。

可以在方法的func 关键字前加上 mutating 关键字来实现这个行为:
<pre><code>
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// 打印 "The point is now at (3.0, 4.0)"
</code></pre>
Point 结构体定义了一个变异方法 moveBy(x:y:), 使用一个特定数量移动一个点。不是返回一个新的点, 这个方法实际上修改了这个点。mutating 关键字加在定义是为了保证它可以修改自己的属性。

注意你不能用结构体类型的常量来调用变异方法, 因为它的属性不能改变, 即使它们是变量属性:
<pre><code>
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveBy(x: 2.0, y: 3.0)
// 这会报一个错误
</code></pre>
# 在变异方法里赋值给self

变异方法可以把一个全新的实例赋给隐式 self 属性。上面的 Point 例子可以用下面的写法代替:
<pre><code>
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}</code></pre>
这个版本的变异 moveBy(x:y:) 方法创建了一个全新的结构体,它的x和y的值被设置为目标位置。调用这个版本的结果和早前版本是完全一样的。

枚举的变异方法可以把隐式self属性设置为一个不同的case:
<pre><code>
enum TriStateSwitch {
    case off, low, high
    mutating func next() {
        switch self {
        case .off:
            self = .low
        case .low:
            self = .high
        case .high:
            self = .off
        }
    }
}
var ovenLight = TriStateSwitch.low
ovenLight.next()
// ovenLight is now equal to .high
ovenLight.next()
// ovenLight is now equal to .off
</code></pre>
这个例子定义了三联开关的枚举。 每次调用 next() 方法这个开关就在三种不同的状态下循环。

# 类型方法

实例方法, 如上所述, 是特定类型实例调用的方法。 你也可以定义类型本身调用的方法。这些方法称为类型方法。在方法的func 关键字前加上static 关键来标示类型方法。类可以用class 关键字来允许子类覆盖父类的方法实现。

备注

在 Objective-C 中, 你只能给类定义类型级别的方法。 而在 Swift 里, 你可以给类,结构体和枚举都定义类型级别的方法。每个类型方法仅限于它支持的类型使用。

类型方法使用点语法调用, 和实例方法一样。 不过, 你使用类型调用方法而不是类型的实例。这里有一个类,展示在一个类如何调用类型方法:
<pre><code>
class SomeClass {
    class func someTypeMethod() {
        // type method implementation goes here
    }
}
SomeClass.someTypeMethod()
</code></pre>
在类型方法的函数体中, 隐式self属性调用类型自己而非类型的实例。 这就意味着你可以用self属性来消除类型属性和类型方法参数之间的歧义, 跟处理实例属性和实例方法参数一样。

更一般的是, 用在类型方法内的任何不合适的方法和属性名将会引用其他类型级别的方法和属性。一个类型方法可以用其他方法名调用另外一个类型方法, 不需要再前面加上类型名。相似的, 结构体和枚举的类型方法可以用类型属性名访问类型属性。

下面的例子定义了一个结构体 LevelTracker, 用来跟踪玩家通过游戏不同级别或者阶段的过程。它是一个单人游戏, 但是可以在单机上存储多个玩家的信息。

第一次玩游戏时所有游戏的关都是锁定的 (除了第一关)。 每当玩家完成一关, 这一关在设备上对所有玩家打开。LevelTracker 结构体使用类型属性和方法来跟踪哪些关已经打开了。它同时跟踪单个玩家所在的当前关。
<pre><code>
struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1
    static func unlock(_ level: Int) {
        if level > highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func isUnlocked(_ level: Int) -> Bool {
        return level <= highestunlockedlevel="" }="" @discardableresult="" mutating="" func="" advance(to="" level:="" int)="" -=""> Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
</=></code></pre>
LevelTracker 结构体保持记录任何玩家已经打开的最高关。这个值存储在类型属性 highestUnlockedLevel.

LevelTracker 同时定义了两个类型方法来使用highestUnlockedLevel 属性。第一个类型方法是 unlock(_:), 一旦新的关通过了就更新 highestUnlockedLevel 的值。第二个是便利类型方法 isUnlocked(_:), 如果特定关已经通过就返回真。 (注意,这两个方法访问 highestUnlockedLevel 类型属性需要写成 LevelTracker.highestUnlockedLevel.)

除了它的类型属性和方法, LevelTracker 还跟踪了个体玩家通过这个游戏的过程。它用一个实例属性 currentLevel 来跟中玩家当前正在玩的关。

为了帮助管理 currentLevel 属性, LevelTracker 定义了一个实例方法 advance(to:). 在更新currentLevel的值之前, 这个方法会判断请求的关是否打开。advance(to:) 方法返回布尔值是否可以设置currentLevel. 因为调用 advance(to:) 方法去忽略这个返回值是不需要一个错误, 这个函数被标记为 @discardableResult 属性。

LevelTracker 结构体和 Player 类一起使用, 下面展示跟踪和更新个体玩家的过程:
<pre><code>
class Player {
    var tracker = LevelTracker()
    let playerName: String
    func complete(level: Int) {
        LevelTracker.unlock(level + 1)
        tracker.advance(to: level + 1)
    }
    init(name: String) {
        playerName = name
    }
}</code></pre>
Player 创建了新的LevelTracker 实例来跟踪玩家的过程。它同时提供了一个方法 complete(level:), 一旦玩家通过一关就会调用。这个方法为所有玩家打开下一关并且更新玩家的过程,把他们带到下一关。(advance(to:) 的布尔返回值被忽略了, 因为通过调用 LevelTracker.unlock(_:) 已经知道这个关被打开了)

你可以为一个新的玩家创建一个Player 类的实例, 并且看看玩家通过第一关会发生什么:
<pre><code>
var player = Player(name: "Argyrios")
player.complete(level: 1)
print("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
// 打印 "highest unlocked level is now 2"
如果你创建第二个玩家, 如果尝试移动他到没有任何玩家打开的关, 那么尝试设置玩家的当前关就会失败:

player = Player(name: "Beto")
if player.tracker.advance(to: 6) {
    print("player is now on level 6")
} else {
    print("level 6 has not yet been unlocked")
}
// 打印 "level 6 has not yet been unlocked"
</code></pre>
# 下标
类,结构体和枚举都快要定义下标, 它是用来访问集合元素的速写方式。你无需单独的设置和获方法,使用下标索引就可以设置和获取元素值。例如, 你访问数组实例的元素用 someArray[index] ,访问字典实例元素用 someDictionary[key].

你可以为单个类型定义多个下标, 选择适当的下标重载使用取决于你传给下标的索引值的类型。一维下标没有限制, 你可以用多个输入参数定义下标来满足自定义类型的需要。

# 下标语法

在一个方括号里写一个或多个值,下标就可以查询一个类型的实例。这个语法跟实例方法和计算属性的语法很像。使用 subscript 关键字定义下标, 同时指定一个或多个输入参数和一个返回值, 跟实例方法一样。和实例方法不同的是, 下标可以读写或者只读。和计算属性方式一样,这个用 setter 和 getter 实现:
<pre><code>
subscript(index: Int) -> Int {
get {
// return an appropriate subscript value here
}
set(newValue) {
// perform a suitable setting action here
}
}
</code></pre>
newValue 类型和返回值类型一样。 和计算属性一样, 你可以不指定setter 的参数名。默认的参数名 newValue 会提供。

和只读计算属性一样, 只读下标可以去掉get 关键字:
<pre><code>
subscript(index: Int) -> Int {
// return an appropriate subscript value here
}</code></pre>
这里有个只读下标实现的例子, 它定义了一个结构体 TimesTable 来表示整数n倍数表:
<pre><code>
struct TimesTable {
let multiplier: Int
subscript(index: Int) -> Int {
return multiplier * index
}
}
let threeTimesTable = TimesTable(multiplier: 3)
print("six times three is \(threeTimesTable[6])")
// 打印 "six times three is 18"
</code></pre>
这个例子里, 一个新的 TimesTable 实例被创建来表示整数的3倍数表。数字3传入结构体的初始化方法来作为乘法的参数。

你可以用下标获取 threeTimesTable 实例, 通过调用 threeTimesTable[6]. 这请求三倍数表中的第六个实体, 返回18, 或者3乘以 6.

备注

n倍数表基于固定的数学规则。把 threeTimesTable[someIndex] 设置为一个新值是不合适的。所以 TimesTable 的下标定义为只读的。

# 使用下标

下标的确切意思取决于它使用的上下文。下标是访问集合元素的速写方式。你可以自由的用最合适的方式为特定的类或者结构体实现下标。

例如, Swift的字典类型实现一个下标去存取存储在字典实例中的值。你可以在下标括号里使用字典的键来设置值, 也可以给下标设置值:
<pre><code>
var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</code></pre>
上面的例子定义了一个变量 numberOfLegs , 然后用一个包含三个键值对的字典字面量来初始化它。numberOfLegs 字典类型被推断为 [String: Int]. 字典创建后, 这个例子使用下标赋值,向字典添加一个键值对 "bird" 和 2 .

备注

Swift 的字典类型实现的键值下标接受和返回一个可选类型。 对于上面的 numberOfLegs 字典, 键值下标接受和返回一个 Int? 类型值, 或者 “可选 int”. 字典类型使用了一个可选的下标类型来模拟这个事实,不是每一个键都有对应的值, 同时提供了一个方法去删除值,只需要给这个键赋一个nil即可。

# 下标选项

下面可以接受任意数量的输入参数, 并且这些输入参数可以是任意类型。 下标也可以返回任意类型。 下标可以使用可变参数, 但是它们不能使用输入输出参数也不能给参数提供默认值。

一个类或者结构体可以提供需要的多个下标实现, 使用的下标基于值类型或者包含在下标括号里的值来推断。这个多个下标的定义就是人们常说的重载。

虽然下标接受一个参数很常见, 但是如果它符合你的类型,你还是可以定义个带多个参数的下标。下面的例子定义了一个结构体 Matrix, 用来表示一个二维的浮点值矩阵。Matrix 结构体的下标带有两个参数:
<pre><code>
struct Matrix {
let rows: Int, columns: Int
var grid: [Double]
init(rows: Int, columns: Int) {
self.rows = rows
self.columns = columns
grid = Array(repeating: 0.0, count: rows * columns)
}
func indexIsValid(row: Int, column: Int) -> Bool {
return row >= 0 && row < rows && column >= 0 && column < columns
}
subscript(row: Int, column: Int) -> Double {
get {
assert(indexIsValid(row: row, column: column), "Index out of range")
return grid[(row * columns) + column]
}
set {
assert(indexIsValid(row: row, column: column), "Index out of range")
grid[(row * columns) + column] = newValue
}
}
}</code></pre>
Matrix 提供了一个初始化方法,它有两个参数 rows 和 columns, 然后创建一个足够存储 rows * columns 个浮点值的数组。矩阵的每个位置的值初始化为 0.0. 为了实现这个, 数组的大小, 初始的cell 值是 0.0, 传给数组的初始化方法, 初始化一个正确大小的数组。

传入一个合适的行列值给初始化方法,你可以创建一个 Matrix 的实例:
<pre><code>
var matrix = Matrix(rows: 2, columns: 2)</code></pre>
前面的例子创建两行两列的 Matrix 实例。实例的grid 数组实际上是一个平的矩阵:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png">
</div>
通过传入行列值给下标来设置矩阵中的值,用逗号分开:
<pre><code>
matrix[0, 1] = 1.5
matrix[1, 0] = 3.2</code></pre>
这两个语句调用下标的setter 设置矩阵右上方位置的值为1.5 (行是0列是1), 然后设置左下位置的值为3.2(行是1列是0):
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png">
</div>
矩阵下标的 getter 和 setter 都包含一个断言,用来判断下标的行列值是有效的。 为了协助这些断言, Matrix 含有一个便利方法 indexIsValid(row:column:), 用来判断需要的行列是否在矩阵的边界内:
<pre><code>
func indexIsValidForRow(row: Int, column: Int) -> Bool {
    return row >= 0 && row < rows && column >= 0 && column < columns
}</code></pre>
如果你访问越界的下标,就会触发断言:
<pre><code>
let someValue = matrix[2, 2]
// 触发断言, 因为 [2, 2] 超出了矩阵的边界
</code></pre>
# 继承
一个类可以从另外一个类继承方法,属性和其他特征。当一个类继承另外一个类时, 继承类叫子类, 被继承的类叫超类。继承是类区别于Swift其他类型的基本行为。

Swift 中的类可以调用和访问超类的方法,属性和下标,并且可以覆盖这些方法,属性和下标来重定义或者修改它们的行为。 Swift 会通过判断覆定义在超类是否有对应定义来确保覆盖的正确。

类可以给继承属性添加属性观察者,在属性值改变时可以接到通知。属性观察者可以添加给任何一个属性, 不管它本来定义成存储还是计算属性。

# 定义一个基类

任何不继承其他类的类就叫做基类。

备注

Swift 的类不会继承一个通用基类。如果你定义的类没有超类,它就会自动变成基类。

下面的例子定义了一个基类 Vehicle. 这个基类定义了一个存储属性 currentSpeed, 有个默认值 0.0 (推断是一个浮点类型的属性)。 currentSpeed 属性被只读计算字符串属性 description 用来创建一个汽车的描述。

Vehicle 基类同时定义了一个方法 makeNoise. 这个方法实际上不对基类实例做任何事, 但是后面会被子类定制行为:
<pre><code>
class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return "traveling at \(currentSpeed) miles per hour"
    }
    func makeNoise() {
        // do nothing - an arbitrary vehicle doesn't necessarily make a noise
    }
}
</code></pre>
使用初始化语法创建一个 Vehicle 实例, 写作类型名后面跟着括号:
<pre><code>
let someVehicle = Vehicle()
</code></pre>
已经创建了一个新的 Vehicle 实例, 你可以访问它的 description 属性,来打印汽车当前速度的人类可读的信息:
<pre><code>
print("Vehicle: \(someVehicle.description)")
// Vehicle: traveling at 0.0 miles per hour
</code></pre>
Vehicle 类为任意汽车定义了通用特性, 但是对于自己没有多少用处。为了让它变的更有用, 你需要充完善它来描述更具体的汽车。

# 子类化

子类化的行为是基于现有类的一个新类。子类从现有类继承特性, 然后你可以完善。你也可以给子类添加新的特性。

为了标明子类有一个超类, 子类名写在超类名之前,用冒号分开:
<pre><code>
class SomeSubclass: SomeSuperclass {
    // subclass definition goes here
}</code></pre>
下面的例子定义了一个子类 Bicycle, 有一个超类 Vehicle:
<pre><code>
class Bicycle: Vehicle {
    var hasBasket = false
}</code></pre>
新的 Bicycle 类自动获得 Vehicle 的所有特性, 比如 currentSpeed 和 description 属性还有它的 makeNoise() 方法。

除了继承的特性, Bicycle 类还定义了一个新的存储属性, hasBasket, 默认值是 false (属性类型推断为布尔型).

默认情况下, 你创建的任何 Bicycle 实例都不会有个篮子。你可以在Bicycle 实例创建后给把它的 hasBasket 属性设置为真:
<pre><code>
let bicycle = Bicycle()
bicycle.hasBasket = true</code></pre>
你可以修改继承来的 currentSpeed 属性, 同时查询实例继承的 description 属性:
<pre><code>
bicycle.currentSpeed = 15.0
print("Bicycle: \(bicycle.description)")
// Bicycle: traveling at 15.0 miles per hour
</code></pre>
子类本身也可以子类化。下面的例子创建了一个双座自行车,作为 Bicycle 的子类:
<pre><code>
class Tandem: Bicycle {
    var currentNumberOfPassengers = 0
}</code></pre>
Tandem 从Bicycle继承了所有的属性和方法, Bicycle 依次继承了Vehicle的所有属性和方法。 Tandem 子类也添加了一个新的存储属性 currentNumberOfPassengers, 默认值是 0.

如果你创建一个 Tandem 实例, 你可以使用它的新的和继承来的任意属性, 也可以查询继承自Vehicle的只读 description 属性:
<pre><code>
let tandem = Tandem()
tandem.hasBasket = true
tandem.currentNumberOfPassengers = 2
tandem.currentSpeed = 22.0
print("Tandem: \(tandem.description)")
// Tandem: traveling at 22.0 miles per hour
</code></pre>
# 重写

一个子类可以自定义实现另外继承超类的一个实例方法,类型方法,实例属性,类型属性或者下标。

为了重写另外继承的特性, 在需要重写的定义前书写 override 关键字。 做这样的澄清,你想要提供一个重写,却没有提供一个匹配的定义的错误。 意外重写会导致不希望的行为, 重写不带上 override 关键字,代码编译时会报错。

override 关键字提醒 Swift 编译器去检查超类是否有一个匹配的声明。这个判断确保你的重新定义是正确的。

# 访问超类的方法,属性和下标

当你为子类提供方法,属性和下标的重写时, 使用超类实现作为子类重写的部分是很有用的。比如, 你可以完善已存在实现的行为, 或者在一个已存在的继承变量存储改变的值。

任何合适的地方, 你都可以用super 前缀访问超类版本的方法,属性或者下标:

重写的方法 someMethod() 可以在实现里通过super.someMethod() 调用超类的 someMethod().
重写的属性 someProperty 可以在重写的setter和getter 实现里通过super.someProperty访问超类的 someProperty.
重写的下标 someIndex 可以在重写的下标实现里通过super[someIndex] 访问超类的下标 super[someIndex].
# 重写方法

你可以重写一个实例或者类型方法,在你的子类中提供一个定制的方法实现。

下面的例子定义了一个 Vehicle 的子类 Train, 它重写了继承自Vehicle 的 makeNoise()方法:
<pre><code>
class Train: Vehicle {
    override func makeNoise() {
        print("Choo Choo")
    }
}</code></pre>
如果你创建了一个新的 Train 实例并且调用它的 makeNoise() 方法, 你可以看到 Train 子类版本的方法被调用了:
<pre><code>
let train = Train()
train.makeNoise()
// 打印 "Choo Choo"
</code></pre>
# 重写属性

你可以重写一个继承实例或者类型属性,来给属性提供自定义的 getter 和 setter, 或者添加属性观察者确保重写属性可以观察潜在的属性值的改变。

# 重写属性的 Getters 和 Setters

你可以提供一个自定义的 getter (和setter, 如果合适) 来重写任何继承的属性, 不管继承的属性是存储属性还是计算属性。 子类并不知道继承属性是计算的还是存储的—它只知道继承来的属性有一个名字和类型。 你应该声明重写属性的名字和类型, 来确保编译器判断你重新的属性和超类的属性有一样的名字和类型。

你可以在子类重写的时候提供setter和getter,把继承的只读属性变成读写属性。不过你不能把继承的读写属性变为只读属性。

备注

如果你提供一个setter作为重写的一部分, 你必须也提供一个getter. 如果你不想在getter里改变继承过来的属性的值, 你可以简单通过返回 super.someProperty 获取这个值, someProperty 是你要重写属性的名字。

下面的例子定义了一个新的类 Car, 它是 Vehicle 的子类。 Car 类引入了一个新的存储属性 gear, 默认值是 1. Car 类同时重写从Vehicle 继承来的 description 属性, 提供包含当前档位的自定义描述:
<pre><code>
class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.description + " in gear \(gear)"
    }
}</code></pre>
description 属性重写首先调用 super.description, 它放回 Vehicle 类的description 属性。Car 类的 description 版本在描述后添加了一些额外的文本来提供当前档位的信息。

如果你创建一个新的 Car 实例并且设置它的 gear 和 currentSpeed 属性, 你可以看到它会返回自定义的描述信息:
<pre><code>
let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print("Car: \(car.description)")
// Car: traveling at 25.0 miles per hour in gear 3
</code></pre>
# 重写属性观察者

你可以用属性重写给继承来的属性添加观察者。这个确保继承来的属性改变时你会得到通知, 不管属性原先是怎么实现的。

备注

你不能给继承来的常量存储属性或者只读计算属性添加属性观察者。这些属性的值不能设置, 因此不适合在重写时提供 willSet 或者 didSet.

注意你也不能对同一个属性同时提供重写的 setter 和 重写的属性观察者。 如果你想观察属性值的变化, 而且你已经给属性提供了自定义的 setter, 你可以在自定义的setter里观察任何值的变化。

下面的例子定义了一个新的类 AutomaticCar, 它是Car的子类。 AutomaticCar 类表示一辆车是自动挡的。它会基于当前速度自动选择合适的档位:
<pre><code>
class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1
        }
    }
}</code></pre>
只要你设置 AutomaticCar 实例的 currentSpeed 属性, 属性的didSet 观察者会为新速度设置合适的档位。特别的是, 属性观察选择的档位等于新的 currentSpeed 值除以 10, 然后转换为最接近的整数再加1. 35.0 的速度产生的档位是 4:
<pre><code>
let automatic = AutomaticCar()
automatic.currentSpeed = 35.0
print("AutomaticCar: \(automatic.description)")
// AutomaticCar: traveling at 35.0 miles per hour in gear 4
</code></pre>
# 防止重写

你可以通过标记为final来防止方法,属性或者下标被重写。 你可以在方法,属性或者下标的关键字前书写final标识符来实现这个 (比如 final var, final func, final class func, 和 final subscript)。

在子类任何尝试去重写一个 final 方法,属性或者下标都会触发编译器错误。 在扩展中添加到类里的方法,属性或者下标也可以在扩展定义时标记为 final.

你可以在类定义的关键字前标记final来表明整个类都是不能重写的。任何尝试去子类化这个类都会报一个编译器错误。
# 初始化
初始化是类,结构体或者枚举使用前的准备过程。这个过程包括给每个存储属性设置初始化值并且执行其他实例使用前的设置和初始化工作。

通过定义初始化方法来实现这个过程, 它很像特殊函数用来创建特定类型的实例。跟 Objective-C 初始化方法不同, Swift 初始化方法不会返回值。它们的主要任务是确保一个类型的实例在使用前可以正确的初始化。

类类型的实例还可以实现去初始化方法, 它在类销毁之前执行清理工作。 

# 为存储属性设置初始值

类或者结构体实例创建的时候,它们的存储属性必须设置成合适的初始值。存储属性不可以是未设置状态。

你可以在初始化方法内给存储属性设置初始值, 或者指定一个默认属性值作为属性定义的部分。这些操作下面会描述。

备注

当你给存储属性指定默认值, 或者在初始化方法里给它设置初始值, 这个设置是直接的, 没有调用任何属性观察者。

# 初始化方法

初始化方法用来创建特定类型的实例。最简单的形式, 一个初始化方法很像一个没有参数的实例方法, 用关键字 init 书写:
<pre><code>
init() {
// perform some initialization here
}</code></pre>
下面的例子定义了一个新的结构体 Fahrenheit,它存储了 Fahrenheit 温度表达式。Fahrenheit 结构体有一个存储属性temperature, 类型是 Double:
<pre><code>
struct Fahrenheit {
var temperature: Double
init() {
temperature = 32.0
}
}
var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// 打印 "The default temperature is 32.0° Fahrenheit"
</code></pre>
这个结构体定义了一个单独的初始化方法 init, 没有带参数, 初始化temperature值为 32.0 (Fahrenheit 温度的冰点)。

# 默认属性值

你可以在初始化方法内部设置存储属性的值, 就像上面展示的那样。 另外一种方法是, 可以指定默认属性值作为属性定义的一部分。

备注

如果一个属性总是带有相同的初始值, 提供一个默认值而不是在初始化中设置一个值。结果是一样的, 不过默认值把属性的初始化跟它的定义联系的更紧密。 它更短,更清晰。保证你可以根据默认值推断属性的类型。默认值让你更容易利用默认初始化方法和初始化方法继承, 本章稍后会描述。

你可以用简单的形式写上面的结构体 Fahrenheit ,在属性声明的时候给它提供一个默认值:
<pre><code>
struct Fahrenheit {
var temperature = 32.0
}</code></pre>
# 自定义初始化

你可以用输入参数和可选属性类型来自定义初始化过程。或者通过初始化时赋值常量属性, 下面会描述。

# 初始化参数

你可以提供初始化参数作为初始化方法定义的部分, 定义类型和值名。初始化参数跟函数和方面参数的语法和能力是一样的。

下面的例子定义了一个结构体 Celsius, 存储摄氏温度的表达。 Celsius 结构体实现了两个自定义的初始化方法init(fromFahrenheit:) 和 init(fromKelvin:), 它们使用不同的温标来初始化结构体的实例:
<pre><code>
struct Celsius {
var temperatureInCelsius: Double
init(fromFahrenheit fahrenheit: Double) {
temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
temperatureInCelsius = kelvin - 273.15
}
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
</code></pre>
第一个初始化方法只有一个参数,这个参数有一个参数标签 fromFahrenheit 和一个参数名 fahrenheit. 第二个初始化方法也只有一个参数,这个参数有一个标签 fromKelvin 和一个参数名 kelvin. 两个初始化方法都是把参数转换为对应的摄氏温度值并把它存在属性 temperatureInCelsius 里。

# 参数名和参数标签

跟函数和方法参数一样, 初始化参数可以用参数名和参数标签。

不过, 初始化方法不能像函数和方法那样在括号前有一个标示函数名。因此, 所以初始化方法的参数名和参数类型扮演很重要的角色,用来区分应该调用哪个初始化方法。因为这个, 如果你不能提供参数标签,Swift 会自动提供一个这样的标签。

下面的例子定义了一个结构体 Color, 带有三个常量属性 red, green, 和 blue. 这些属性存储0.0到1.0之间的值来表示 red, green, 和 blue 在颜色中的数量。

Color 为三原色提供了一个初始化方法,带有三个有命名的参数,类型是 Double. Color 同时提供了带有一个white参数的初始化方法, 用来给三原色提供相同的值。
<pre><code>
struct Color {
let red, green, blue: Double
init(red: Double, green: Double, blue: Double) {
self.red   = red
self.green = green
self.blue  = blue
}
init(white: Double) {
red   = white
green = white
blue  = white
}
}</code></pre>
通过给每个初始化参数赋值,两个初始化方法都快要创建新 Color 实例:
<pre><code>
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
</code></pre>
注意,不用参数标签无法调用这些初始化方法。如果已经定义，参数标签必须总是使用。忽略它们会导致编译错误:
<pre><code>
let veryGreen = Color(0.0, 1.0, 0.0)
// 这个会报编译错误 - 需要参数标签
</code></pre>
# 没有参数标签的初始化参数

如果你不想使用参数标签, 使用下划线 (_) 替代参数的显式参数标签来重写默认行为。

这里有一个早前Celsius例子的扩充版本, 用了一个额外的初始化方法从浮点值创建新的 Celsius 实例,浮点值已经是摄氏温标:
<pre><code>
struct Celsius {
var temperatureInCelsius: Double
init(fromFahrenheit fahrenheit: Double) {
temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
temperatureInCelsius = kelvin - 273.15
}
init(_ celsius: Double) {
temperatureInCelsius = celsius
}
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0
</code></pre>
初始化方法调用 Celsius(37.0) 目的很清楚,不需要使用参数标签。因此初始化方法写作 init(_ celsius: Double) 很合适, 通过无名浮点值可以调用它。

# 可选属性类型

如果你自定义类型有一个存储属性允许无值—可能因为它的值在初始化的时候不能设置, 或者因为它在某个时刻允许无值—定义这个属性为可选类型。可选类型属性自动初始化为nil, 表明这个属性故意在初始化时“没有值”。

下面的例子定义了一个类 SurveyQuestion, 带有一个可选字符串属性 response:
<pre><code>
class SurveyQuestion {
var text: String
var response: String?
init(text: String) {
self.text = text
}
func ask() {
print(text)
}
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// 打印 "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
</code></pre>
调查问题的回复只有问后才会知道, 所有 response 属性声明为 String? 类型, 或者 “可选 String”. 当一个新的 SurveyQuestion 实例初始化的时候, 它自动赋默认值为nil, 意思是“还没有字符串”。 

# 初始化时访问常量属性

在初始化时,你可以在任何时候给常量属性赋值, 只要在初始化完成时给它设置一个确定值。一旦一个常量属性指定一个值,后面就不能再修改了。

备注

对于类实例, 被类引入的常量属性在初始化时只能被这个类改变。 它不能被子类修改。

你可以修改上面的e SurveyQuestion 例子, 对问题文本使用常量属性而不是变量属性, 来表明一旦SurveyQuestion 实例创建,问题就不能再被修改。即使text 属性现在是一个常量, 它依然可以在初始化方法里设置:
<pre><code>
class SurveyQuestion {
let text: String
var response: String?
init(text: String) {
self.text = text
}
func ask() {
print(text)
}
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// Prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
</code></pre>
# 默认初始化方法

Swift 为任何结构体或者类提供一个默认初始化方法, 这些类和结构体给所有的属性提供了初始值,但是没有提供一个初始化方法。默认初始化方法简单创建一个新的实例,然后把所有属性设置为默认值。

这个例子定义了一个类 ShoppingListItem, 封装了购物列表中一项的名字, 数量和购买状态:
<pre><code>
class ShoppingListItem {
var name: String?
var quantity = 1
var purchased = false
}
var item = ShoppingListItem()
</code></pre>
因为所有的 ShoppingListItem 属性都有默认值, 又因为它是基类没有超类, ShoppingListItem 会自动创建默认的初始化方法, 来创建实例并把所有属性设置成默认值。(name 属性是一个可选字符串类型属性, 它会自动设为 nil, 即使这个值没有写在代码里) 这个例子使用默认初始化方法来创建新实例, 初始化语法是 ShoppingListItem(), 然后赋值给一个变量 item.

# 结构体类型成员初始化方法

Structure 如果没有定义自己的初始化方法, 它会自动获取到一个成员初始化方法。跟默认初始化方法不同, 即使结构体有未设置默认值的存储属性,它也会接收到一个成员初始化方法。

成员初始化方法是简写方式,用来初始化新结构体实例的成员属性。新实例的初始值可以通过名字传给成员初始化方法。

下面的例子定义了一个结构体 Size, 它有两个属性 width 和 height. 两个属性根据初始值推断为 Double 类型。

Size 结构体自动获取一个成员初始化方法 init(width:height:), 你可以用来初始化一个新的 Size 实例:
<pre><code>
struct Size {
var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>
# 值类型初始化方法代理

初始化方法可以调用其他初始化方法来执行实例的部分初始化工作。这个过程, 称为初始化方法代理, 通过多个初始化方法避免重复代码。

初始化方法代理如何工作的规则, 代理被允许是什么形式, 对于值类型和类类型是不同的。值类型不支持继承 (结构体和枚举), 所以它们的初始化函数代理过程相对简单, 因为它们只能代理它们自己提供的其他初始化方法。不过类可以继承其他类。这就意味着类有额外的责任,以确保它们继承来的所有存储属性在初始化时都分配了合适的值。

对于值类型, 在写你自己定义的初始化方法时,你使用 self.init 从相同的值类型调用其他初始化方法。你可以只在一个初始化方法里调用 self.init.

注意,如果你为一个值类型定义一个初始化方法, 你将不再访问那种类型的默认初始化方法 (或者成员初始化方法, 如果它是一个结构体)。这种情况下复合初始化方法提供的额外必要的设置, 这个防止不小心被使用自动初始化方法规避。

备注

如果你想自定义值类型使用默认初始化方法和成员初始化方法来初始化, 同时使用你自定义的初始化方法, 那就在扩展里实现自定义初始化方法而不是作为值类型原先实现的部分。更多信息, 参见扩展。

下面的例子定义了一个Rect 结构体来表示一个几何矩形。这个例子需要两个支持的结构体 Size 和 Point, both of which provide default values of 0.0 for all of their properties:
<pre><code>
struct Size {
var width = 0.0, height = 0.0
}
struct Point {
var x = 0.0, y = 0.0
}
</code></pre>
你可以用下面三种方式初始化 Rect 结构体—默认初始化值为0, 提供一个特定的原点和大小, 或者指定一个特定的中心点和大小。三个初始化选择用三个自定义的初始化方法表示:
<pre><code>
struct Rect {
var origin = Point()
var size = Size()
init() {}
init(origin: Point, size: Size) {
self.origin = origin
self.size = size
}
init(center: Point, size: Size) {
let originX = center.x - (size.width / 2)
let originY = center.y - (size.height / 2)
self.init(origin: Point(x: originX, y: originY), size: size)
}
}</code></pre>
第一个初始化方法, init(), 功能和结构体未定义初始化方法自动分配的默认初始化方法一样。这个初始化方法函数体为空, 有一堆空的大括号表示 {}. 调用这个初始化方法,返回一个 Rect 实例, 它的原点和大小都是默认值, 分别是 Point(x: 0.0, y: 0.0) 和 Size(width: 0.0, height: 0.0):
<pre><code>
let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
</code></pre>
第二个初始化方法, init(origin:size:), 功能和结构体未定义初始化方法自动分配的成员初始化方法一样。这个初始化方法简单指定原点和大小参数值给对应的存储属性:
<pre><code>
let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
</code></pre>
第三个初始化方法, init(center:size:), 稍微有点复杂。开始基于中心点和大小值计算一个合适的原点值。然后调用 (或者代理)  init(origin:size:) 初始化方法, 存储新的原点值和大小到对应的属性:
<pre><code>
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
</code></pre>
init(center:size:) 初始化方法可以给对应的属性指定新的原点值和大小。不过, 对于 init(center:size:) 初始化方法来说采用已存在的初始化器更加遍历。


# 类继承和初始化

类的所有存储属性—包含来自超类的任何属性—初始化的时候必须分配一个初始值。

Swift 为了类类型定义了两种初始化方法,帮助确保所有的存储属性都有初始值。这就大家熟知的指定初始化方法和便利初始化方法。

# 指定构造器和便利构造器

指定初始化方法是类的主要初始化方法。一个指定初始化方法会完全初始化类引入的所有属性,同时会调用合适的超类初始化方法来继续超类链的初始化过程。

Classes 倾向于有很少的指定初始化方法, 对于类来说只有一个很平常。 指定构造器是通过初始化发生地的漏斗点, 通过它初始化继续往超类链上走。

每个类至少应该有一个指定构造器。在某些情况下, 这个需求通过继承超类的一个或者多个指定构造器来实现。

便利构造器是次要的, 对类来说只是支持初始化方法。你可以定义一个便利构造器来调用同类的指定构造器, 这个便利构造器设置指定构造器的参数为默认值。你可以定义一个便利构造器来创建类的实例,用作特定用途或者输入值类型。

如果你的类不需要便利构造器,你就不必要提供它们。什么时候要简化构造形式来节省时间或者让类的初始化意图更清楚,可以创建便利构造器。

# 指定构造器和便利构造器的语法

类的指定构造器写法和值类型的简单构造器一样:
<pre><code>
init(parameters) {
statements
}</code></pre>
便利构造器写法一样, 但是init 关键字之前有个 convenience 修饰符, 用空格分开:
<pre><code>
convenience init(parameters) {
statements
}</code></pre>
# 类的初始化代理

为了简化指定构造器和便利构造器之间的关系, Swift 使用下面三种规则在构造器之间代理调用:

规则 1
一个指定构造器必须调用它的直接超类的指定构造器。

规则 2
一个便利构造器必须调用同类的其他构造器。

规则 3
一个便利构造器最后必须调用一个指定构造器。

一个简单的方式可以记住这个:

指定构造器必须总是向上代理。
便利构造器必须总是横着代理。
下图列出了这三个规则:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png">
</div>
这里, 超类有一个指定构造器和两个便利构造器。一个便利构造器调用另外一个便利构造器, 它依次调用这个单独的指定构造器。这个满足了上面的规则2和3. 超类本身没有超类, 所以第1条规则不适用。

图中的子类有两个指定构造柱和一个便利构造器。便利构造器必须调用这两个指定构造器之一, 因为它只能调用同类的另外的构造器。这个满足上面的规则2和3. 两个指定构造器必须调用超类的指定构造器, 这个满足上面的规则1.

备注

这个规则不影响你类的使用者如何创建每个类的实例。 上图中的任何构造器都可以用来完全初始化它们所属类的实例。这个规则只是影响你对类构造器的实现。

下面的图展示了更加复杂的四个类继承关系。 它展示了继承关系中的指定构造器如何扮演类构造器的漏斗点, 简化继承链中的类的相互关系:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png">
</div>
# 两阶段初始化

Swift 中的类初始化是两阶段的过程。在第一阶段, 每个存储属性被指定一个初始值。一旦每个存储属性初始状态确定了, 第二阶段就开始了, 在新实例将要使用之前, 每个类都有机会去定制存储属性。

两阶段初始化过程的使用使得初始化更安全, 在类层次中依然给予完全的灵活性。两阶段初始化防止属性值在初始化前被访问, 同时也防止了属性值被另外的构造器意味的设置成一个不同的值。

备注

Swift 的两阶段初始化过程很像 Objective-C 的初始化。 主要区别是阶段 1, Objective-C 会给每个属性设定零或者空值 (比如 0 或者 nil). Swift 的初始化更加灵活, 可以让你自定义初始值, 可以应对0或者nil不是有效默认值的情况。

Swift 的编译器执行四项安全检查来确保两阶段初始化无错误的完成:

安全检查 1
一个指定构造器必须确保, 在向上代理超类构造器之前,所属类的所有属性都被初始化。

就像上面提及的, 对象的内存只考虑完全初始化一次所有的存储属性的初始状态。为了让这条规则满足, 一个指定构造器必须保证在向上传递前自己所有的属性都已经初始化。

安全检查 2
在给继承来的属性赋值前,一个指定构造器必须向上委托超类的构造器。如果不这样做, 指定构造器指定的新值会被超类自己的构造器给覆盖了。

安全检查 3
在给任意属性赋值前, 一个便利构造器必须委托另外一个构造器。(包括相同类定义的属性)。如果不这样做, 便利构造器指定的新值会被本类的指定构造器覆盖。

安全检查 4
一个构造器不能调用任何实例方法, 不能读任何实例属性的值, 或者直到第一阶段初始化完成才可以引用self.

第一阶段初始化结束后类的实例才完全有效。第一阶段类的实例有效后,属性只能被访问, 方法只能被调用。

这里是两阶段初始化的呈现, 基于以上四个安全检查:

阶段 1

一个指定构造器或者便利构造器在类里调用。
给类的实例分配内存。内存尚未初始化。
类的指定构造器确保所有存储属性都有一个值。这些存储属性的内存开始初始化。
指定构造器放手给超类的构造器,对它的存储属性执行同样的操作。
沿着继承链继续往上直到尽头。
一旦到了继承链的尽头, 继承链最后的类已经确保所有存储属性都有一个值。实例的内存被认为已经全部初始化, 第一阶段完成。.
阶段 2

从继承链尽头回来, 链中的每个指定构造器都有选择去继续定制实例。构造器现在可以访问 self 和改变属性, 也可以调用函数。
最后, 链中的任何便利构造器都有选择去定制实例并且使用 self.
这里展示第一阶段如何为一个假设的子类和超类寻找初始化调用的:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png">
</div>
在这个例子中, 初始化开始于调用子类的便利构造器。这个便利构造器尚不能修改任何属性。它委托了本类的一个指定构造器。

指定构造器确保所有的子类属性都有一个值, 根据安全检查 1. 然后在它的超类调用一个指定构造器继续沿着链初始化。

超类指定构造器确保超类属性都有一个值。因为没有更深的超类要初始化, 所以也不需要更深的委托。

只要所有超类的属性都有一个初始值, 它的内存就被认为已经完成初始化, 那么阶段1就完成了。

这里是阶段2如何寻找相同的初始化调用:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png">
</div>
子类的指定构造器现在有机会更进一步去定制实例 (尽管它不必要这么做)。

一旦子类指定构造器完成, 超类的指定构造器可以执行额外的定制(尽管它没有必要这么做)。

最后, 一旦子类的指定构造器完成, 原先调用的便利构造器就可以执行额外的定制。

# 初始化方法的继承和覆盖

不像 Objective-C 中的子类, Swift 子类默认不继承它的超类的初始化方法。 Swift 的方法防止了一种情况,在这种情况下来自一个超类的初始化方法被一个更专业的子类继承,并且用来这个子类的新实例,但是这个实例并未完全或者正确的初始化。

备注

超类的初始化方法在特定情况下被继承, 只有安全而且合适才会这么做。

如果你想让自定义子类展示和超类一样的一个或者多个初始化方法, 你可以在子类内提供这些初始化方法的自定义实现。

当你写一个子类初始化方法,这个方法匹配一个超类的指定构造器, 你可以提供这个指定构造器的重写。因此, 你必须在子类初始化方法定义前写上 override 修饰符。 即使你重写一个自动提供的默认初始化方法,也是这样。

跟一个重写的属性,方法或者下标一样, override 修饰符提醒Swift 去判断超类有这么一个指定构造器可以重写, 并且验证重写初始化方法的参数已经有目的的指定了。

备注

当重写超类指定构造器时你应该总是写上 override 修饰符, 即使子类初始化方法的实现是一个便利构造器。

相反, 如果你写一个子类初始化方法匹配超类的便利构造器, 超类便利构造器不能直接被子类调用。因此, 你的子类不能提供一个超类初始化方法的重写。结果是, 当提供一个超类便利构造器的匹配实现时,你不能写上 override 修饰符。

下面的例子定义了一个基类 Vehicle. 这个基类声明了一个存储属性 numberOfWheels, 带有一个默认值 0. numberOfWheels 被一个计算属性 description用来创建汽车特征的字符串描述:
<pre><code>
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}</code></pre>
Vehicle 类给它唯一的存储属性提供了一个默认值, 本身没有提供任何自定义的初始化方法。结果是, 它会自动收到一个默认的初始化方法。这个默认的初始化方法总是一个指定构造器, 可以用来创建一个 numberOfWheels 为0的Vehicle 实例:
<pre><code>
let vehicle = Vehicle()
print("Vehicle: \(vehicle.description)")
// Vehicle: 0 wheel(s)
</code></pre>
下面的例子定义了一个 Vehicle 的子类 Bicycle:
<pre><code>
class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}</code></pre>
Bicycle 定义了一个自定义指定构造器init(). 这个构造器匹配来着超类的指定构造器, 所以 Bicycle 版本的这个构造器用override 修饰符标记。

init() 初始化方法先调用 super.init(), 这是超类的默认初始化方法。这个确保 numberOfWheels 属性在被子类修改前可以被 Vehicle 初始化。调用 super.init() 后, numberOfWheels 原有值会被新值2替代。

如果你创建一个 Bicycle 实例, 你可以调用它的继承来的计算属性 description 来查看 numberOfWheels 属性是否被更新了:
<pre><code>
let bicycle = Bicycle()
print("Bicycle: \(bicycle.description)")
// Bicycle: 2 wheel(s)
</code></pre>
备注

子类在初始化的时候可以改变继承来的变量属性, 但是无法改变继承来的常量属性。

# 自动初始化方法的继承

就像上面提到的, 默认情况子类并不继承超类的初始化方法。不过, 不过如果某种条件满足了,超类的初始化方法还是可以被自动继承的。在实践中, 这意味着你通常不需要重写初始化方法, 只要这样做安全,你可以用最小的代价继承超类的初始化方法。

假设你给子类的任何新属性都设定了默认值, 下面的规则适用:

规则 1
如果你的子类没有定义任何指定构造器, 它会自动继承超类所有的指定构造器。

规则 2
如果你的子类提供了超类所有指定构造器的实现—或者通过像规则1那样的继承, 或者提供自定义实现—然后它会自动继承超类所有的便利构造器。

即使你的子类添加更深的便利构造器,这个规则都适用。

备注

一个子类可以实现一个超类的指定构造器,来作为自己的便利构造器,这个是满足规则2的部分。

# 指定和便利构造器的初始化

下面的例子展示了指定构造器,便利构造器和自动构造器继承的活动。这个例子定义了三个类 Food, RecipeIngredient 和 ShoppingListItem 的继承关系, 并且展示了它们如何交互。

这个继承关系中的基类是 Food, 它是封装了一个食品名字的简单类。Food 类引入了一个单独的字符串属性 name 并且提供了两个构造器来创建 Food 实例:
<pre><code>
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
</code></pre>
下图展示了Food 类的构造链:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png">
</div>
类没有默认的成员构造器, 所以 Food 类提供了一个指定构造器,这个构造器有一个参数 name. 这个构造器可以用一个指定名字来创建一个新的 Food 实例:
<pre><code>
let namedMeat = Food(name: "Bacon")
// namedMeat's name is "Bacon"
</code></pre>
init(name: String) 构造器是一个指定构造器, 因为它可以保证一个新的Food 实例的所有存储属性完全初始化。Food 类没有超类, 所以 init(name: String) 不需要调用 super.init() 来完成初始化。

Food 类同时提供了一个便利构造器, init(), 没有任何参数。 通过委托Food 类的init(name: String), init() 为新食物提供了一个默认的占位符名字 [Unnamed]:
<pre><code>
let mysteryMeat = Food()
// mysteryMeat's name is "[Unnamed]"
</code></pre>
继承关系中的第二个类 RecipeIngredient 是Food 类的子类。RecipeIngredient 类模拟了烹调配方的成分。它引入了一个 Int 属性quantity (除了从Food 继承来的name属性) 然后定义了两个构造器用来创建 RecipeIngredient 实例:
<pre><code>
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}</code></pre>
下图展示了 RecipeIngredient 类的构造链:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png">
</div>
RecipeIngredient 类只有一个指定构造器, init(name: String, quantity: Int), 它可以填充一个新 RecipeIngredient 实例的所有属性。构造器首先把传入的数量参数赋值给 quantity 属性, 这个是 RecipeIngredient 唯一的新属性。这个操作之后, 构造器向上委托基类的 init(name: String) 构造器。这个过程符合两阶段初始化的安全检查1.

RecipeIngredient 同时定义了一个便利构造器, init(name: String), 它用名字来创建一个 RecipeIngredient 实例。任何 RecipeIngredient 实例没有显式数量的,这个便利构造器都会假设一个数量值为1. 这个便利构造器方便 RecipeIngredient 实例快速创建, 并且当创建一些单个数量的实例时可以避免代码重复。这个便利构造器简单调用了指定构造器, 传入数量值 1.

init(name: String) 便利构造器跟指定构造器 init(name: String) 接受一样的参数。因为这个便利构造器重写了超类的指定构造器, 它必须标记 override 修饰符。

尽管 RecipeIngredient 提供了 init(name: String) 作为便利构造器, RecipeIngredient 也提供了所有超类的指定构造器的实现。因此, RecipeIngredient 也就自动继承了超类的所有便利构造器。

在这个例子里, RecipeIngredient 的超类是 Food, 它只有一个便利构造器 init(). 这个构造器会被 RecipeIngredient 继承。继承 init() 函数版本和 Food 版本是一样的。除了它是调用e RecipeIngredient 版本的 init(name: String) 而不是 Food 版本之外。

三个构造器都快要用来创建新的 RecipeIngredient 实例:
<pre><code>
let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)</code></pre>
继承关系里的最后一个类ShoppingListItem也是 RecipeIngredient 子类。ShoppingListItem 模拟了一个配方成分。

购物清单中的每一项都以“unpurchased”开始。为了说明这个事实, ShoppingListItem 引入一个布尔属性 purchased, 带有一个默认值 false. ShoppingListItem 同时添加了一个计算属性description, 它提供了ShoppingListItem 实例的文本描述:
<pre><code>
class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}</code></pre>
备注

ShoppingListItem 没有提供构造器来为 purchased 设定初始值, 因为购物清单里的项目一开始都是未购买的。

因为它给所有的属性提供了默认值并且没有提供任何构造函数, ShoppingListItem 自动从超类继承了所有的指定和便利构造器。

下图展示了三个类所有的构造函数:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png">
</div>
你可以用所有继承来的构造函数创建一个新的 ShoppingListItem 实例:
<pre><code>
var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    print(item.description)
}
// 1 x Orange juice ✔
// 1 x Bacon ✘
// 6 x Eggs ✘
</code></pre>
这里, 用数组字面量创建了一个新的数组 breakfastList, 它包含了3个 ShoppingListItem 实例。 数组类型推断为 [ShoppingListItem]. 这个数组创建后, 数组开始项 ShoppingListItem 名字从"[Unnamed]" 变成 "Orange juice" 并且标记为已购买。打印数组中的每一项来表示它们的默认状态按照预期设置了。

# 可失败构造器

有时候允许类,结构体或者枚举构造失败是有用的。无效初始化参数值,缺少必需的外部资源,或者其他阻止初始化成功的条件都会引起构造失败。

为了应对这些引起失败的初始化条件, 在类,结构体或者枚举体中定义一个或者多个可失败构造器。写一个可失败构造器的方法是在 init 关键字后面加上问号 (init?).

备注

你不可以用相同的参数类型和名称来同时定义一个可失败或者非失败的构造器。

一个可失败构造器创建一个可选类型值。通过在可失败构造器中返回 nil 来表明某个时刻初始化失败发生。

备注

严格来说, 构造器不会任何值。相反, 它们的角色是确保初始化结束时self被完全而正确的初始化。尽管你写了返回 nil 去触发构造失败, 你不能用 return 关键字来表明构造成功。

下面的例子定义了一个结构体 Animal, 有一个常量字符串属性 species.Animal 同时定义了带有一个参数species 的可失败构造器。 这个构造器判断species 是否为空。如果是空字符串, 构造失败触发。否则, 设置species 的属性值, 然后初始化成功:
<pre><code>
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
</code></pre>
你可以使用可失败构造器尝试去初始化一个新的 Animal 实例,然后判断构造是否成功:
<pre><code>
let someCreature = Animal(species: "Giraffe")
// someCreature is of type Animal?, not Animal

if let giraffe = someCreature {
    print("An animal was initialized with a species of \(giraffe.species)")
}
// Prints "An animal was initialized with a species of Giraffe"
If you pass an empty string value to the failable initializer’s species parameter, the initializer triggers an initialization failure:

let anonymousCreature = Animal(species: "")
// anonymousCreature is of type Animal?, not Animal

if anonymousCreature == nil {
    print("The anonymous creature could not be initialized")
}
// 打印 "The anonymous creature could not be initialized"
</code></pre>
备注

判断空字符串和判断可选值为nil是不同的。在上面的例子中, 一个空字符串 ("") 是一个有效,非可选的字符串。不过, 对于动物来说species属性值为空不太合适。 为了模拟这种限制, 如果这个字符串为空,就触发构造失败。

# 枚举的可失败构造器

你可以基于一个或多个参数使用构造器去选择一个合适的枚举case. 如果提供的参数没有匹配合适的case,构造就会失败。

下面的例子定义了一个枚举 TemperatureUnit, 有三种可能的状态 (kelvin, celsius, 和 fahrenheit). 可失败构造器根据代表温度符号的字符值来寻找一个合适的枚举case:
<pre><code>
enum TemperatureUnit {
    case kelvin, celsius, fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .kelvin
        case "C":
            self = .celsius
        case "F":
            self = .fahrenheit
        default:
            return nil
        }
    }
}</code></pre>
你使用可失败构造器为三种可能的状态选择一个合适的枚举case, 如果参数不匹配三种状态之一就会引发构造失败:
<pre><code>
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// Prints "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</code></pre>
# 带Raw值枚举的可失败构造器

带有raw值的枚举会自动接收一个可失败构造器, init?(rawValue:), 有一个参数 rawValue, 如果找到就匹配一个枚举case, 否则触发构造失败。

你用raw值重写上面的 TemperatureUnit 例子,然后使用 init?(rawValue:) 构造器:
<pre><code>
enum TemperatureUnit: Character {
    case kelvin = "K", celsius = "C", fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// Prints "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</code></pre>
# 构造可失败的传递

在相同类,结构体或者枚举中可失败构造器可以委托调用另外的可失败构造器。相似的, 子类可失败构造器可以向上调用超类的可失败构造器。

另外一种情况, 如果你委托其他构造器导致构造失败, 那么整个构造过程就会立即失败, 后面的构造代码不会再执行。

备注

一个可失败构造器要可以委托调用一个非失败构造器。如果你需要给一个存在的初始化过程添加一个潜在的失败状态,可以用这个方法。

下面的例子定义了一个 Product 的子类 CartItem. CartItem 模拟了在线购物车的一项。CartItem 引入了一个存储常量属性 quantity 并且保证这个属性的值至少为 1:
<pre><code>
class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}

class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity < 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
</code></pre>
CartItem 可失败构造器首先判断 quantity 是否小于1. 如果 quantity 无效, 整个初始化过程立即失败并且后面的初始化代码不会执行。 同样的, Product 的可失败构造器判断 name 的值, 如果name是空字符串这个构造过程也会立即失败。

如果使用非空name和quantity大于等于1的值构造一个 CartItem 实例, 初始化就成功了:
<pre><code>
if let twoSocks = CartItem(name: "sock", quantity: 2) {
    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}
// 打印 "Item: sock, quantity: 2"
</code></pre>
如果你用quantity 等于0来创建一个 CartItem 实例, CartItem 构造器会引起初始化失败:
<pre><code>
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    print("Unable to initialize zero shirts")
}
// 打印 "Unable to initialize zero shirts"
</code></pre>
相似的, 如果你使用空名字去创建一个 CartItem 实例, 超类 Product 构造器会导致初始化失败:
<pre><code>
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    print("Unable to initialize one unnamed product")
}
// 打印 "Unable to initialize one unnamed product"
</code></pre>
# 重写可失败构造器

你可以在子类重写超类的可失败构造器, 就像其他构造器一样。 或者, 你可以用子类的非失败构造器重写一个超类的构造器。 这使得你可以定义个子类,它的初始化不会失败。即使超类的构造允许失败。

注意,如果你用子类非失败构造器重写了超类的可失败构造器, 唯一向上调用超类构造器的方式是强制拆包超类可失败构造器的结果。

备注

你可以用一个非失败构造器重写一个可失败构造器,除此之外别无他法。

下面的例子定义了一个类 Document. 这个类模拟了一个文档,这个文档可以用一个非空字符串名字或者nil来初始化, 但是不能用一个空字符串:
<pre><code>
class Document {
    var name: String?
    // this initializer creates a document with a nil name value
    init() {}
    // this initializer creates a document with a nonempty name value
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
</code></pre>
下面的例子定义了 Document 的一个子类 AutomaticallyNamedDocument. AutomaticallyNamedDocument 子类重写了两个 Document 类引入的指定构造器。这些重写保证了一个 AutomaticallyNamedDocument 有一个初始值 "[Untitled]" :
<pre><code>
class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Untitled]"
        } else {
            self.name = name
        }
    }
}
</code></pre>
AutomaticallyNamedDocument 用非失败init(name:)构造器重写了超类的可失败构造器init?(name:). 因为 AutomaticallyNamedDocument 处理空字符串的情况和超类不同, 它的构造器不需要失败, 所以它提供了一个非失败的构造器版本。

你可以在构造器里使用强制拆包,来调用超类的可失败构造器。 例如, UntitledDocument 子类总是命名为 "[Untitled]", 并且在它的初始化过程中,它会使用超类的可失败构造器init(name:)
<pre><code>
class UntitledDocument: Document {
    override init() {
        super.init(name: "[Untitled]")!
    }
}</code></pre>
在这种情况下, 如果超类的 init(name:) 构造器用空名字字符串调用, 强制拆包操作会引发一个运行时错误。不过, 它是用常量字符串调用的, 你可以看到这个初始化器不会失败, 所以这种情况不会发生运行时错误。

# init! 可失败构造器

通过在init关键之后面加上一个问号,你可以定义一个可失败构造器来创建一个对应类型的可选实例。或者, 你可以定义一个可失败构造器,来创建对应类型隐式拆包可选实例。 这个可以通过在init关键之后面加上感叹号而不是问好来实现。

你可以从init? 调用到 init! ,反之亦然, 而且你可以用init!重写 init? with init! ,反之亦然。你还可以从init 调用到 init!, 尽管这样做会触发一个断言,如果 init! 构造器导致构造失败的话。

# 必需构造器

在一个类的构造器前写上 required 修饰符来表明这个类的每个子类都要实现这些构造器:
<pre><code>
class SomeClass {
    required init() {
        // initializer implementation goes here
    }
}</code></pre>
你也必需在每一个实现必须构造器的子类构造器前写上 required 修饰符, 来表明在链中构造需求适用更远的子类。当重写一个必须指定构造器时,你不需要写上 override 修饰符:
<pre><code>
class SomeSubclass: SomeClass {
    required init() {
        // subclass implementation of the required initializer goes here
    }
}</code></pre>
备注

如果你可以用一个继承来的构造器满足要求,你就不必要提供一个显式的必须构造器。

# 用闭包或者函数设定默认属性值

如果一个存储属性的默认值需要定制或者设置, 你可以使用一个闭包或者一个全局函数。一旦一个属性所属的新的实例被初始化, 闭包或者函数就会调用, 然后返回值被赋值给属性的默认值。

这些闭包或者函数特别创建和属性相同类型的一个临时值, 返回的临时值用来作为这个属性的默认值。

这里有一个框架, 来展示一个闭包如何用来提供默认属性值:
<pre><code>
class SomeClass {
    let someProperty: SomeType = {
        // create a default value for someProperty inside this closure
        // someValue must be of the same type as SomeType
        return someValue
    }()
}
</code></pre>
注意闭包花括号结束后跟着一对空括号。这个会通知 Swift 立即执行这个闭包。如果你忽略这对括号, 你在尝试把闭包本身赋值给这个属性, 而不是闭包的返回值。

备注

如果你用闭包初始化一个属性, 记住,闭包执行时,实例的其他部分还没有进行初始化。这就意味着你不能在闭包里访问其他任何属性, 即使这些属性具有默认值。你也不能使用隐式self 属性, 或是调用任何实例方法。

下面的例子定义了一个结构体 Chessboard, 它为象棋游戏模拟了一个棋盘。象棋是在一个 8 x 8 的去棋盘上玩的, 带着交替的黑白方格。

<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png">
</div>
为了表示这个游戏棋盘, Chessboard 结构体有一个属性 boardColors, 它是一个带有64个布尔值的数组。真值代表黑色方块,假值代表白色方块。第一项代表棋盘的左上方块,最后一项代表棋盘的右下方块。

boardColors 数组使用一个闭包初始化,设定它的颜色值:
<pre><code>
struct Chessboard {
    let boardColors: [Bool] = {
        var temporaryBoard = [Bool]()
        var isBlack = false
        for i in 1...8 {
            for j in 1...8 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
    }()
    func squareIsBlackAt(row: Int, column: Int) -> Bool {
        return boardColors[(row * 8) + column]
    }
}
</code></pre>
一旦新的Chessboard 实例创建, 闭包就会执行, boardColors 默认值会计算和返回。上面例子里的闭包在一个临时数组temporaryBoard 为棋盘上每个方块计算和设置了对应的颜色值, 并且等设置完成就作为闭包返回值返回。返回数组值存储在 boardColors 中,并且可以用squareIsBlackAtRow 功能函数进行查询:
<pre><code>
let board = Chessboard()
print(board.squareIsBlackAt(row: 0, column: 1))
// Prints "true"
print(board.squareIsBlackAt(row: 7, column: 7))
// 打印 "false"
</code></pre>
# 析构器
在一个类实例销毁前,一个析构器会立即调用。使用deinit 关键字来表示析构器, 跟构造器写法类似。析构器只能用在类类型上。 types.

# 析构器如何工作

Swift 在实例不需要时会自动析构它, 去释放资源。Swift 通过自动引用计数来管理实例的内存(ARC). 当实例销毁时你不需要手动执行清理操作。不过, 当你使用自己的资源时, 你可能需要额外执行一些清理。例如, 如果你创建一个类去读写文件, 在类的实例销毁前你可能需要去关闭这个文件。

类最多只能有一个析构器。析构器没有任何参数也没有括号:
<pre><code>
deinit {
    // perform the deinitialization
}</code></pre>
析构器会自动调用, 在实例销毁发生前。禁止自己去调用析构器。子类会继承超类的析构器, 超类析构器在子类析构器实现后调用。 即使子类不提供自己的析构器,超类析构器也会调用。

因为实例直到析构器调用才会销毁, 一个析构器可以访问调用实例的所有属性,同时也可以改变基于这些属性的行为 (例如寻找需要关闭的文件名).

# 析构器的活动

这里有一个析构器活动的例子。这个例子定义了两个新类型, Bank 和 Player, Bank 类管理一个虚拟货币, 它的流通货币不会超过 10,000 硬币。游戏里只有能有一个银行, 所以 Bank 用类实现,带有类型属性和方法来存储和管理它的当前状态:
<pre><code>
class Bank {
    static var coinsInBank = 10_000
    static func distribute(coins numberOfCoinsRequested: Int) -> Int {
        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)
        coinsInBank -= numberOfCoinsToVend
        return numberOfCoinsToVend
    }
    static func receive(coins: Int) {
        coinsInBank += coins
    }
}</code></pre>
Bank 用coinsInBank 属性跟中当前硬币的数量。它同时提供了两个方法s—distribute(coins:) 和 receive(coins:)—来管理硬币的发行和回收。

distribute(coins:) 方法判断在发行前银行是否有足够的硬币。如果没有足够的硬币, Bank 返回一个比要求数量少的数量 (如果银行没有硬币了就返回0). 它返回一个整数来表示实际提供的硬币数量。

receive(coins:) 方法简单加上收到的硬币数量。

Player 类描述了游戏中的一个玩家。 每一个玩家在任何时间都有一定数量的硬币在钱包里。这个用玩家的coinsInPurse 来表示:
<pre><code>
class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.distribute(coins: coins)
    }
    func win(coins: Int) {
        coinsInPurse += Bank.distribute(coins: coins)
    }
    deinit {
        Bank.receive(coins: coinsInPurse)
    }
}</code></pre>
在初始化过程中,每个玩家都会用一定数量的硬币来初始化, 尽管玩家可能在银行硬币不足的时候获取较少的数量。

Player 类定义了一个方法 win(coins:), 它从银行获取一定数量的硬币然后把它们加入玩家的钱包。Player 类同时实现了一个去构造器, 它在 Player 实例销毁前调用。在这里, 这个构造器简单把玩家的硬币返还给银行:
<pre><code>
var playerOne: Player? = Player(coins: 100)
print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
// 打印 "A new player has joined the game with 100 coins"
print("There are now \(Bank.coinsInBank) coins left in the bank")
// 打印 "There are now 9900 coins left in the bank"
</code></pre>
一个新的 Player 实例被创建, 如果有硬币就请求100个硬币。这个Player 实例存在一个可选的 Player 变量 playerOne 中。可选变量用在这里, 因为玩家可能在任何时间离开游戏。可选项让你跟踪玩家当前是否还在游戏中。

因为 playerOne 是一个可选项, 当它的 coinsInPurse 属性被访问来打印硬币数量时, 需要使用感叹号。一旦它的 winCoins(_:) 方法被调用:
<pre><code>
playerOne!.win(coins: 2_000)
print("PlayerOne won 2000 coins & now has \(playerOne!.coinsInPurse) coins")
// 打印 "PlayerOne won 2000 coins & now has 2100 coins"
print("The bank now only has \(Bank.coinsInBank) coins left")
// 打印 "The bank now only has 7900 coins left"
</code></pre>
在这里, 玩家已经赢得了 2,000 个硬币。玩家的钱包现在有 2,100 个硬币, 银行还有 7,900 个硬币。
<pre><code>
playerOne = nil
print("PlayerOne has left the game")
// 打印 "PlayerOne has left the game"
print("The bank now has \(Bank.coinsInBank) coins")
// 打印 "The bank now has 10000 coins"
</code></pre>
玩家现在离开游戏。设置可选playerOne变量为nil 说明了这点。意思是 “没有Player 实例。” 此时, playerOne 变量引用的Player 实例被销毁。没有其他属性或者变量再引用 Player 实例, 所以它被销毁来释放内存。在这个发生之前, 它的析构器自动调用, 然后它的硬币全部归还给银行。
# 自动引用计数
Swift 使用自动引用计数来跟踪和管理你的应用的存储使用。在大多数情况里, 这就意味着内存管理 “仅仅工作” 在 Swift, 你自己不需要管理内存。类的实例不再需要的时候,ARC 会自动释放实例使用的内存。

不过, 在一些少见的情况下,为了替你管理内存,ARC 需要更多关于你代码关系的信息。这个章节描述这些场景并且向你展示你怎么使用 ARC 来管理应用的内存。

备注

引用计数只适用于类的实例。结构体和枚举是值类型, 而非引用类型, 不能用引用存储和传递。

# ARC 如何工作

每次你创建一个新的类实例, ARC 就会分配一块内存来存储实例的信息。这个内存掌握了实例类型的信息, 还有对应实例的存储属性的值。

另外, 当一个实例不再需要的时候, ARC 会释放实例使用的内存,让内存另有他用。这个确保类的实例不需要的时候,不会继续占用内存空间。

不过, 如果 ARC 将要销毁在使用的实例, 它将不能访问实例的属性, 或者是实例的方法。 事实上, 如果你访问这个实例, 你的应用可能会崩溃。

为了确保实例在使用时不会消失, ARC 跟踪有多少属性, 常量和变量正在引用类的每个实例。只要有一个对实例的引用,ARC 都不会销毁这个实例。

为了实现这种可能, 一旦你把类赋给一个属性, 常量或者变量, 这些属性,常量或者变量就会强引用这个实例。 这个引用之所以叫强引用,是因为它牢牢掌握了这个实例。只要强引用还在,就不会允许它被销毁。

# ARC 的活动

下面有个自动引用计数的例子,来展示它如何工作。这个例子以一个简单的类 Person 开始, 它定义了一个存储常量属性 name:
<pre><code>
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}</code></pre>
Person 类有一个构造器,用来设置实例的 name 属性,并且打印一条信息来表明构造在进行。Person 类同时也有一个析构器,在类的实例被销毁时打印一条信息。

下面代码定义了三个 Person? 类型的变量, 在后续代码中,它们用来设置多个对新Person 实例的引用。因为这些变量是可选类型(Person?, 不是 Person), 它们会自动初始化为nil, 并且当前不会引用一个Person 实例。
<pre><code>
var reference1: Person?
var reference2: Person?
var reference3: Person?
</code></pre>
你现在可以创建一个新的 Person 实例,并且把它赋值给三个变量的其中一个:
<pre><code>
reference1 = Person(name: "John Appleseed")
// 打印 "John Appleseed is being initialized"
</code></pre>
注意这条信息 "John Appleseed is being initialized" 在调用Person 来的构造器时打印。这个确认了初始化已经发生。

因为新的 Person 实例已经指定给 reference1 变量, 现在从reference1 到新的Person 实例有了一个强引用。因为有了至少一个强引用, ARC 确保 Person 保持在内存里不被销毁。

如果你把相同的 Person 实例赋值给另外两个变量, 指向这个实例的两个强引用就建立了:
<pre><code>
reference2 = reference1
reference3 = reference1
</code></pre>
现在有三个强引用指向这个单独的 Person 实例。

通过给其中两个变量赋值为nil,你可以打破这些强引用, 还剩一个强引用, 但是Person 实例不会被销毁:
<pre><code>
reference1 = nil
reference2 = nil
</code></pre>
ARC 直到最后一个强引用被打破才会销毁 Person 实例, 在这个时刻很清楚你无法再继续使用这个 Person 实例:
<pre><code>
reference3 = nil
// 打印 "John Appleseed is being deinitialized"
</code></pre>
# 类实例的强引用循环

上面的例子中, ARC 可以跟踪你创建的实例的引用数量,并且在实例不需要的时候销毁它。

不过, 有可能写下这种代码,在代码里一个类实例不知道什么时候强引用数量为0. 如果两个类实例互相强引用就会出现这个问题, 这样每个实例都保有其他活动的实例。这就是众所周知的强引用循环。

使用weak 或者 unowned 来代替强引用, 这样你可以解决强引用循环的问题。不过, 在你学习如何解决强引用问题前, 有必要先学习循环引用是怎么产生的。

下面的例子展示强引用循环是如何偶发的。这个例子定义了两个类 Person 和 Apartment, 它模拟了一组公寓和居民:
<pre><code>
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</code></pre>
每个 Person 实例有一个字符串类型的name属性和一个可选的 apartment 属性,后者初始化为nil. apartment 属性是可选的, 因为一个人有可能没有公寓。

相似的, 每个 Apartment 实例有一个字符串类型的 unit属性和一个可选的 tenant 属性,后者初始化为nil nil. tenant 属性是可选的,因为一个公寓有可能没有租客。

两个类都定义了析构器, 它们打印类实例被销毁的事实。这个可以帮你查看两个类的实例是否按照预期销毁了。

下面的代码片段定义了两个可选类型的变量 john 和 unit4A, 他们将会被设置为特定的 Apartment 和 Person 实例。这两个变量初始值都是 nil, 因为它们是可选的:
<pre><code>
var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
</code></pre>
这里展示创建和赋值这两个实例后,强引用的样子。john 变量现在强引用这个新的 Person 实例, unit4A 变量现在强引用这个新的 Apartment 实例:

<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png">
</div>
现在可以联系两个实例到一起,现在人有了公寓,公寓也有了一个租客。注意这里使用了感叹号来拆包和访问 john 和 unit4A 可选变量, 所以这些实例的属性可以被设置:
<pre><code>
john!.apartment = unit4A
unit4A!.tenant = john
</code></pre>
Here’s how the strong references look after you link the two instances together:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png">
</div>
不幸运的是, 联系这两个实例,导致在它们之间建立了强引用循环。Person 实例现在有了一个强引用到 Apartment 实例, 然后 Apartment 实例有一个强引用到 Person 实例。因此, 当你打破 john 和 unit4A 变量拥有的强引用, 引用计数也不会降为0, 实例也不会被ARC销毁:
<pre><code>
john = nil
unit4A = nil
</code></pre>
注意当你设置两个变量为nil时,两个析构器都不会调用。强引用循环阻止了 Person 和 Apartment 实例的销毁。导致你的应用内存泄露。

这里展示设置john 和 unit4A 变量为 nil后强引用的样子:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png">
</div>
Person 实例和 Apartment 实例之间的强引用依然没有打破。

# 解决实例间的强引用循环

针对类类型的属性, Swift 提供了两个方法来解决强引用循环问题: weak 引用 和 unowned 引用。

Weak 和 unowned references 可以使一个实例在引用循环中去调用另外一个实例,而不会强引用它。然后实例之间可以互相引用而不会出现强引用循环。

其他实例有更短的生命期的时候使用一个弱引用—就是说, 当其他实例首先被销毁的时候。 上面的 Apartment 例子, 在公寓的生命周期内, 在某个时刻没有租客是正常的。所以在这个情况下,使用弱引用来打破强引用是合适的方式。相反, 如果其他实例有着相同或者更长的生命周期,就使用无主引用。

# 弱引用
弱引用不会强持有它引用的实例, 并且不会阻止ARC处理引用的实例。这个行为防止出现强引用循环。你可以在属性或者变量声明前加上weak关键字来声明一个弱引用。

因为弱引用不会强持有它引用的实例, 在弱引用仍然引用实例的时候,有可能这个实例将要被销毁了。因此, 在引用实例销毁时, ARC 自动把弱引用设置为nil. 并且, 由于弱引用要在运行时允许它们的值修改为nil, 它们总是声明成可选类型变量, 而不是常量。

你可以判断在弱引用中一个值的存在与否, 就像其他可选值一样, 实例不存后,你不会得到一个无效的实例引用。

备注

ARC 设置一个弱引用为nil时, 属性观察者不会调用。

下面的例子和上面 Person 和 Apartment 例子是一样的, 只有一个重要的不同。这一次, Apartment 类型的 tenant 属性声明为弱引用:
<pre><code>
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</code></pre>
两个变量的强引用它们之间的联系创建如前 (john 和 unit4A):
<pre><code>
var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")

john!.apartment = unit4A
unit4A!.tenant = john
</code></pre>
这里展示联系两个实例后,引用的样子:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png">
</div>
Person 实例依然强引用 Apartment 实例, 不过 Apartment 实例现在是弱引用 Person 实例了。这就意味着, 当你设置john为nil来打破这个强引用的时候, 就不会再有对 Person 实例的强引用:
<pre><code>
john = nil
// 打印 "John Appleseed is being deinitialized"
</code></pre>
因为没有更多对Person实例的强引用, 它被销毁而且tenant 属性被设置为 nil:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png">
</div>
现在只剩下unit4A 变量对 Apartment 实例的强引用。如果你打破这个强引用, 就不会再有对Apartment实例的强引用:
<pre><code>
unit4A = nil
// 打印 "Apartment 4A is being deinitialized"
</code></pre>
因为没有更多对 Apartment 实例的强引用, 它也被销毁了:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png">
</div>
备注

在使用垃圾回收的系统里, 弱指针有时用来实现一个简单的缓存机制,因为没有强引用的对象只有在内存紧张的时候才会触发垃圾回收。不过, 使用 ARC, 只要值的强引用被移除了,它们就会被销毁, 为了这个目的使用弱引用是不合适的。

# 无主引用

很像弱引用, 无主引用不会强持有它引用的实例。跟弱引用不同的是, 当其他实例有相同或者更久的生命周期时才使用无主引用。通过在属性或者变量声明的前面加上unowned 关键字来声明无主引用。

一个无主引用总希望有值。结果是, ARC 永远不会把无主引用的值设为nil, 这意味着无主引用使用非可选类型来定义。

重要

使用无主引用前提是,只在你能确保引用的实例不会被销毁情况下使用。

如果你在实例销毁后尝试调用无主引用的值,你会得到一个运行时错误。

下面的例子定义了两个类, Customer 和 CreditCard, 它模拟了一个银行用户和用户的信用卡。这两个类都存储了对方的实例作为属性。这种关系有产生强引用循环的可能。

Customer 和 CreditCard 之间的关系与上面的Apartment 和 Person之间的关系略有不同。在这个数据模型里, 一个用户可能有或者没有一张信用卡, 但是一张信用卡总有对应的用户。一个 CreditCard 实例永远不会比它调用的用户活的更久。为了表示这个, Customer 类有一个可选的 card 属性, CreditCard 类有一个无主的 (非可选) customer 属性。

此外, 一个新的 CreditCard 实例创建时, 需要传递一个number 值和一个 customer 实例给自定义的 CreditCard 构造器。这个确保了一个 CreditCard 实例总会有一个对应的用户。

因为一张信用卡总会有一个用户, 你定义customer 属性为一个无主引用, 可以避免强引用循环:
<pre><code>
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print("\(name) is being deinitialized") }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print("Card #\(number) is being deinitialized") }
}
</code></pre>
备注

CreditCard 的number属性定义成 UInt64 类型而不是 Int, 是为了保证 number 属性的容量做够大可以在32位和64位系统上存储一个16位的信用卡号。

下面的代码片段定义了一个可选的 Customer 变量 john, 用来存储指向特定用户的引用。这个变量初始值是 nil, 因为它是可选的:
<pre><code>
var john: Customer?
</code></pre>
现在你创建了一个 Customer 实例, 然后用它初始化和分配一个新的CreditCard 实例作为用户的card 属性:
<pre><code>
john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>
这里是引用的样子, 现在你把两个实例联系起来了:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png">
</div>

Customer 实例现在强引用 CreditCard 实例, CreditCard 实例则是无主引用 Customer 实例。

由于无主的 customer 引用, 当你打破john 变量持有的强引用, 就不会有其他对 Customer 的强用了:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png">
</div>
因为没有其他对 Customer 实例的强引用, 它会被销毁，然后, 对CreditCard 实例的强引用也没有了, 所以它也被销毁了:
<pre><code>
john = nil
// 打印 "John Appleseed is being deinitialized"
// 打印 "Card #1234567890123456 is being deinitialized"
</code></pre>
最后的代码片段展示了Customer 实例和 CreditCard 实例析构器都打印出析构的信息。

备注

上面的例子展示了如何使用安全的无主引用。 Swift 同时提供了不安全的无主引用, 使用场景是你需要去禁用运行时安全检查—例如, 性能原因。使用所有的不安全操作, 你都有责任检查代码的安全问题。

通过写上unowned(unsafe)来表明这是一个不安全的无主引用。如果在实例销毁后尝试访问一个不安全的无主引用, 你的程序会访问实例原来存在的内存位置, 这是不安全的操作。

# 无主引用和隐式拆包可选属性

上面弱引用和无主引用的例子,覆盖了更多常见情况的两种,在这种场景下需要打破一个强引用循环。

Person 和 Apartment 例子展示了一个情况, 有两个属性都可以设置为nil, 有导致一个强引用循环的可能。这种情况最好使用弱引用来解决。

Customer 和 CreditCard 例子展示了一个情况,有一个属性允许设置为nil,而另外一个属性不能设置成nil,也有产生强引用循环的可能。这个情况最好用无主引用来解决。

不过, 存在第三种情况, 这种情况下两个属性都应该有值, 一旦初始化完成两个属性都不能为nil. 在这个情况下, 把一个类的无主属性和其他类的隐式拆包可选属性合并是很有用的。

一旦初始化完成,这个可以保证两个属性都可以直接访问 (没有可选拆包), 同时避免了一个引用循环。这部分内容介绍如何建立这种关系。

下面的例子定义了两个类, Country 和 City, 它们互相存储对方类的实例作为属性。在这个数据模型中, 每个国家必须有一个首都,每个城市必须属于一个国家。为了表示这个, Country 有一个 capitalCity 属性, City 有一个 country 属性:
<pre><code>
class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>
为了建立这两个类的关联, City 构造器接收一个Country 实例, 然后把这个实例存储到它的 country 属性。

City 的构造器在 Country 构造器中调用。不过, Country 构造器直到一个新的Country 实例完成构造后才可以传给 City 构造器。

为了应对这个需求, 你把Country 的capitalCity 属性声明成一个隐式拆包可选属性, 通过在类型后加上感叹号来表明 (City!). 这就意味着 capitalCity 属性默认值为 nil, 不需要拆包就可以访问它的值。

因为 capitalCity 默认值是 nil, 一个新的 Country 实例在name属性在构造器被设置后会被完全初始化。这就意味着 Country 构造器开始引用和传递隐式的 self 属性,当name属性设置的时候。当Country 构造器开始设置它的capitalCity 属性时,Country 构造器可以把self作为参数传给 City 构造器。

所有这一切意味着,你可以在一条语句里创建 Country 和 City 实例, 而不会产生强引用循环, capitalCity 属性可以直接访问, 不需要使用感叹号去拆包它的可选值:
<pre><code>
var country = Country(name: "Canada", capitalName: "Ottawa")
print("\(country.name)'s capital city is called \(country.capitalCity.name)")
// 打印 "Canada's capital city is called Ottawa"
</code></pre>
上面例子里, 隐式拆包可选意味着,所有两阶段类构造需求都满足了。一旦初始化完成, capitalCity 属性可以像非可选值一样使用和访问, 同时避免了一个强引用循环。

# 闭包强引用循环

你可以看到上面展示的,实例互相引用产生的强引用循环。你也看到如何使用弱引用和无主引用来打破这种循环。

如果你把一个闭包赋值给类属性,也可能产生一个强引用循环, 包体捕获了这个实例。因为包体访问了实例属性, 比如 self.someProperty, 或者因为闭包调用了实例方法, 例如 self.someMethod(). 在这两种情况下, 这些访问会导致闭包捕获self, 这就产生了一个强引用循环。

这个强引用循环是因为闭包产生,像类一样是引用类型。当你把闭包赋值给属性时, 你就赋值了一个引用给这个闭包。本质上, 它的问题和上面是一样的—两个强引用互相保持。不过, 相比两个类实例, 这次是一个类实例和一个闭包互相保有。

Swift 提供一个优雅的方案来解决这个问题, 就是大家熟知的捕获列表。不过, 在你知道怎么用捕获列表来打破一个强引用循环前,有必要知道它是怎么产生的。

下面的例子展示使用闭包调用self时, 是如何产生强引用循环的。这个例子定义了一个类 HTMLElement, 它提供了一个简单的模拟HTML文档里的单个元素:
<pre><code>
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -> String = {
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name)>"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
</\(self.name)></code></pre>
HTMLElement 类定义了一个name属性, 用来表示元素名, 比如头部元素 "h1" , 段落原色"p", 或者换行符"br"。HTMLElement 同时定义了一个可选text属性, 可以设置成字符串来表示渲染的文本。

除了这两个简单的属性, HTMLElement 类定义了一个lazy属性asHTML. 这个属性引用了一个闭包来把name和text合并成一个HTML片段。asHTML 属性类型是 () -> String, 或者 “没有参数的函数,返回一个字符串”。

默认情况, asHTML 属性被指定了一个闭包,这个闭包返回字符串来表示一个 HTML 标签。如果文本存在,这个标签就包含可选文本值,否则不包含文本内容。对于一个段落元素, 闭包会返回 "<p>some text</p>" 或者 "<p>", 取决于text 属性是否等于 "some text" 或者 nil.

asHTML 属性命名和使用稍微有点像实例方法。不过, 因为 asHTML 是一个闭包而不是实例方法, 你可以用自定义闭包来替换它的默认值, 如果你想为一个特殊HTML元素改变HTML渲染的话。

例如, asHTML 属性可以设置成一个闭包, 如果text属性为nil就默认设置成一些文本, 以防返回一个空的HTML标签:
<pre><code>
let heading = HTMLElement(name: "h1")
let defaultText = "some default text"
heading.asHTML = {
    return "<\(heading.name)>\(heading.text ?? defaultText)</\(heading.name)>"
}
print(heading.asHTML())
// 打印 "<h1>some default text</h1>"
</code></pre>
备注

asHTML 属性声明成lazy属性, 因为它只有在元素需要作为字符串值进行渲染的时候才需要。asHTML 是一个lazy属性意味着你可以在默认闭包里调用self, 因为初始化完成同时self存在后,lazy属性才能访问。

HTMLElement 类只提供了一个构造器,它有一个name参数和一个text参数。这个类同时定义了一个析构器, 它打印一条信息来表示HTMLElement 实例被销毁了。

这里是如何使用 HTMLElement 类来创建和打印一个新的实例:
<pre><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// 打印 "<p>hello, world</p>"
</code></pre>
注意

paragraph 变量定义成一个可选的 HTMLElement 类型, 所以它可以设置成nil。下面展示一个强引用循环的存在。

不幸的是, HTMLElement 类, 在 HTMLElement 实例和用作asHTML 值的闭包之间产生了一个强引用循环。看起来是这个样子:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png">
</div>
实例的asHTML 属性强引用它的闭包。然而, 因为这个闭包在它的包体里调用了self(self.name 和 self.text), 闭包捕获了self, 这以为着它又强引用回HTMLElement 实例。两者之间就产生了一个强引用循环。

备注

尽管这个闭包多次调用self, 它只会捕获一个对 HTMLElement 实例的强引用。

如果你把paragraph 变量设置成nil来打破这个强引用, HTMLElement 实例和它的闭包都不会销毁, 就是因为这个强引用循环:
<pre><code>
paragraph = nil
</code></pre>
注意 HTMLElement 析构器的信息没有打印, 这就说明 HTMLElement 实例没有销毁。

# 解决闭包强引用循环

通过在闭包里定义一个捕获列表,你可以解决闭包和类实例之间的强引用循环的问题。捕获列表定义了在包体里捕获一个或者多个引用类型时的使用规则。就像两个类实例间的强引用, 你声明每个捕获的引用为弱引用或者无主引用而不是强引用。弱引用和无主引用的选择取决于你代码不同部分的联系。

备注

当你在闭包中调用self 的成员时, Swift 要求你写成 self.someProperty 或者 self.someMethod() (而不是只有someProperty 或者 someMethod())。这个帮你记住, 闭包偶尔会捕获self.

# 定义捕获列表

捕获列表中的每一项都是一对 weak 或者 unowned 关键字,带有对一个类实例或者变量的引用或者使用一些值初始化的变量。这些写在一堆方括号内,用逗号分开。

把捕获列表放在闭包参数列表前,如果它们提供则返回类型:
<pre><code>
lazy var someClosure: (Int, String) -> String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
    // closure body goes here
}
</code></pre>
如果一个闭包没有指定参数列表或者返回类型, 就把捕获列表放在闭包最开始,后面跟着in关键字:
<pre><code>
lazy var someClosure: () -> String = {
    [unowned self, weak delegate = self.delegate!] in
    // closure body goes here
}
</code></pre>
# 弱引用和无主引用

当闭包和它捕获的实例将要互相引用, 并且会同时销毁时,定义成捕获无主引用。

相反, 当捕获的实例在某个时间会变成nil时,定义成捕获弱引用。弱引用总是一个可选类型, 当引用的实例销毁后自动变成nil. 这个确保你可以在包体内判断它们是否存在。

备注

如果捕获的引用永不会变成nil, 它应该总是捕获为一个无主引用, 而不是一个弱引用。

无主引用比较适合解决上面 HTMLElement 例子里的强引用循环的问题。这里是如何写 HTMLElement 类来避免这种循环:
<pre><code>
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -> String = {
        [unowned self] in
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name)>"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
</\(self.name)></code></pre>
这个版本的实现和前面版本的实现是一样的, 除了asHTML闭包里的捕获列表。在这种情况下, 捕获列表是 [unowned self], 意思是 “捕获self作为无主引用而不是强引用”。

你可以跟以前一样创建和打印一个 HTMLElement 实例:
<pre><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// 打印 "<p>hello, world</p>"
</code></pre>
这里是使用捕获列表后引用的样子:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png">
</div>
这次, 闭包捕获的self是一个无主引用, 不会强引用 HTMLElement 实例。如果你把 paragraph 变量的引用设置为nil,  HTMLElement 实例就会被销毁, 可以看到析构器打印的信息在下面:
<pre><code>
paragraph = nil
// 打印 "p is being deinitialized"
</code></pre>
更多捕获列表信息, 参见捕获列表。
# 可选链
可选链是一个过程,用来查询和调用属性, 方法和下标用一个可选项。如果可选项包含一个值, 属性, 方法或者下标调用成功; 如果可选项为nil, 属性, 方法或者下标调用返回nil. 多次调用可以写在一起, 如果任何链中任何联系为nil,整个链就会失败。

备注

Swift 中的可选链和Objective-C中的消息传递nil很像, 但是它对任何类型都一样, 可以判断失败或者成功。

# 作为强制拆包替代方案的可选链

在可选值后面加上问号就可以指定可选链, 如果可选值不为nil,你可以调用一个属性,函数或者下标。这个跟在可选值后放置感叹号来强制拆包很相似。区别是,当可选项为nil时,可选链接就会失败。如果可选项为nil,强制拆包会触发运行时错误。

为了反映可选链接可以被nil值调用的事实, 一个可选链接调用的结果总是一个可选值, 即使你查询的属性,方法或者下标返回一个非可选的值。你使用返回值来判断可选链接调用是否成功, 或者判断是否因为有nil存在导致了失败。

特别指出, 可选连接调用的结果和预期返回值的类型是一样的, 但是包在一个可选项中。如果通过可选链接访问, 正常要返回Int的属性会返回Int?

下面的代码片段展示了可选链接和强制拆包的区别, 确保你可以用来判断成功与否。

首先, 定义两个类Person 和 Residence:
<pre><code>
class Person {
    var residence: Residence?
}

class Residence {
    var numberOfRooms = 1
}
</code></pre>
Residence 实例只有一个整型属性 numberOfRooms, 默认值是 1. Person 实例有一个可选Residence?类型属性 residence.

如果你创建一个新的 Person 实例, 它的residence 属性默认初始化为nil,因为它是可选的。下面的代码里, john 有一个值为nil的属性residence:
<pre><code>
let john = Person()
</code></pre>
如果你想访问person属性 residence的属性 numberOfRooms, 可以在residence 后面放置一个感叹号来强制拆包它的值, 由于还没有值可以拆包,所以你会触发一个运行时错误:
<pre><code>
let roomCount = john.residence!.numberOfRooms
// 触发运行时错误
</code></pre>
当john.residence有一个非nil值时,上面的代码会成功,然后会把合适的房间数量设置给 roomCount. 不过, 当residence 为nil时,这个代码总会触发运行时错误。

可选链接提供了一个替代方式来访问 numberOfRooms 的值。通过在感叹号的位置使用问号来使用可选链接:
<pre><code>
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 "Unable to retrieve the number of rooms."
</code></pre>
这会告诉 Swift 去链接可选的residence 属性,如果它存在就返回 numberOfRooms 的值。

由于尝试访问 numberOfRooms 有可能失败, 可选链接尝试放回一个 Int? 类型值, 或者“可选整型”。当 residence 为nil, 这个可选整型将会是nil, 这样就不能访问 numberOfRooms. 可选整型通过可选绑定来访问,然后去拆包这个整数同时把非空值赋值给roomCount 变量。

注意,尽管numberOfRooms 是一个非空的整型,这个也是真的。通过可选链接查询的事实意味着调用numberOfRooms 总是返回 Int? 而不是 Int.

你可以把一个 Residence 实例赋值给john.residence, 这样它就不会是一个空值了:
<pre><code>
john.residence = Residence()
</code></pre>
john.residence 现在有了一个实际的 Residence 实例, 而不是nil. 如果你用之前一样的可选链接访问 numberOfRooms, 它将放回 Int? , 包含一个默认值为1的 numberOfRooms:
<pre><code>
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 "John's residence has 1 room(s)."
</code></pre>
# 为可选链接定义模型类

你可以用可选链接调用多个层次的属性,方法或者下标。这使得你可以在复合相关类型内,向下获取子属性。然后判断是否可以在这些子属性上访问属性,方法或者下标。

下面的代码片段定义了四个模型类,用于下面的例子。包括多层次可选链接的例子。这些类在 the Person 和 Residence 模型上展开, 加入了两个类 Room 和 Address, 带有对应的属性,方法和下标。

Person 类定义和以前一样:
<pre><code>
class Person {
    var residence: Residence?
}
</code></pre>
Residence 类比以前复杂。这次, Residence 类定义了一个变量属性rooms, 用一个空数组[Room]初始化:
<pre><code>
class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("The number of rooms is \(numberOfRooms)")
    }
    var address: Address?
}
</code></pre>
因为这个版本的 Residence 存储了一组 Room 实例, 它的numberOfRooms 属性实现成一个计算属性, 而不是一个存储属性。numberOfRooms 属性简单返回了rooms 数组的个数。

作为访问romms 数组的简写, 这个版本的 Residence 提供了一个读写下标,来访问rooms数组指定索引下的房间。

这个版本的 Residence 同时提供了一个方法printNumberOfRooms, 它只是简单打印住宅中的房间数。

最后, Residence 定义了一个可选属性 address, 类型是 Address?. Address 类下面定义。

用于rooms数组的Room类是带有一个属性name的简单类, 还有一个构造器,用来设置这个房间的名字:
<pre><code>
class Room {
    let name: String
    init(name: String) { self.name = name }
}
</code></pre>
模型里最后一个类是 Address. 这个类有三个类型为String?的可选属性。前面两个属性, buildingName 和 buildingNumber, 是两种方案来识别某个建筑的地址部分。第三个属性 street, 用来命名地址里的街道:
<pre><code>
class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if buildingNumber != nil && street != nil {
            return "\(buildingNumber) \(street)"
        } else if buildingName != nil {
            return buildingName
        } else {
            return nil
        }
    }
}
</code></pre>
Address 类同时提供了一个方法 buildingIdentifier(), 它有一个String?类型的返回值。这个方法判断地址的属性,如果有值就返回 buildingName, 如果buildingNumber 和 street 都有值,就返回两者的连接, 否则返回nil.

# 通过可选链接访问属性

可选链接中描述它可以作为强制拆包的替代方案, 你可以在一个可选值上使用可选链接来访问一个属性, 然后判断属性访问是否成功。

使用上面定义的类创建一个新的 Person 实例, 然后像以前一样访问它的属性numberOfRooms:
<pre><code>
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 "Unable to retrieve the number of rooms."
</code></pre>
因为 john.residence 为nil, 可选链接像以前一样会调用失败。

你也可以通过可选链接给属性设置一个值:
<pre><code>
let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress
</code></pre>
在这个例子里, 尝试设置john.residence的属性 address 将会失败, 因为 john.residence 现在是nil.

赋值是可选链接的一部分, 意味者=运算符的右侧代码不会执行。在上一个例子, 容易看到 someAddress 不会执行, 因为访问一个常量不会有任何边界影响。下面的代码做了同样的赋值, 不过它使用一个函数去创建地址。在返回值前函数会打印 “Function was called”, 这个会让你看到=运算符右侧代码是否执行了。
<pre><code>
func createAddress() -> Address {
    print("Function was called.")

    let someAddress = Address()
    someAddress.buildingNumber = "29"
    someAddress.street = "Acacia Road"

    return someAddress
}
john.residence?.address = createAddress()
</code></pre>
你可以看到createAddress() 函数不会执行, 因为什么也没有打印。

# 通过可选链接调用方法

你可以在一个可选值上通过可选链接调用一个方法, 然后判断调用是否成功。即使这个方法没有定义返回值,你也可以这么做。

Residence 类的 printNumberOfRooms() 方法打印numberOfRooms的当前值。这里是方法的样子:
<pre><code>
func printNumberOfRooms() {
    print("The number of rooms is \(numberOfRooms)")
}
</code></pre>
这个方法没有指定返回值。不过, 没有返回值的方法和函数有一个隐式的返回值Void. 这就说它们返回了(), 或者说一个空元组。

如果你使用可选链接,在一个可选值上调用这个方法。这个方法的返回类型会是 Void?, 而不是Void, 因为通过可选链接调用总是返回一个可选值。这让你可以使用if语句来判断能否调用printNumberOfRooms() 方法, 尽管这个方法本身没有定义返回值。把printNumberOfRooms 返回值和 nil 比较来查看方法调用是否成功:
<pre><code>
if john.residence?.printNumberOfRooms() != nil {
    print("It was possible to print the number of rooms.")
} else {
    print("It was not possible to print the number of rooms.")
}
// 打印 "It was not possible to print the number of rooms."
</code></pre>
如果你尝试通过可选链接设置属性也是一样。上面的例子尝试为 john.residence 设置地址值, 尽管residence 属性是nil. 通过可选链接设置属性值都会返回一个Void?, 让你可以跟nil比较,来判断设置属性是否成功:
<pre><code>
if (john.residence?.address = someAddress) != nil {
    print("It was possible to set the address.")
} else {
    print("It was not possible to set the address.")
}
// 打印 "It was not possible to set the address."
</code></pre>
# 通过可选链接访问下标

你可以在可选值上使用可选链接来获取或者设置一个下标值, 然后判断下标调用是否成功。

备注

当你通过可选链接访问可选值的下标时, 你要把问号放置在下标括号的前面而不是后面。这个问号总是直接跟在可选表达式的后面。

下面的例子尝试获取john.residence的房子数组中第一个房子的名字,使用的是定义在Residence类里的下标。因为 john.residence 现在是 nil, 下标调用会失败:
<pre><code>
if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// 打印 "Unable to retrieve the first room name."
</code></pre>
下标调用中的可选链接问号直接放在john.residence后面, 在下标括号前面, 因为 john.residence 是可选值。

相似的, 你可以使用可选链接,通过下标来设置新值:
<pre><code>
john.residence?[0] = Room(name: "Bathroom")
</code></pre>
这个下标设置的尝试也会失败, 因为residence 当前值为nil.

如果你创建一个实际的 Residence 实例并把它赋值给 john.residence, 同时带有一个或者多个 Room 实例存于rooms 数组, 你可以通过可选链接,使用 Residence 下标访问rooms数组中的实际项:
<pre><code>
let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Living Room"))
johnsHouse.rooms.append(Room(name: "Kitchen"))
john.residence = johnsHouse

if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// 打印 "The first room name is Living Room."
</code></pre>
# 访问可选类型下标

如果一个下标返回一个可选类型值—比如Swift 字典类型的key下标—在下标方括号后面加上问号来链接它的可选返回值:
<pre><code>
var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0] += 1
testScores["Brian"]?[0] = 72
// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]
</code></pre>
上面的例子定义了一个字典 testScores, 它包含了两个键值对,把一个字符串键映射到一个整数数组。这个例子用可选链接把Dave数组的第一项设置成 91; 把Bev数组的第一项值增加1; 并且尝试为键为Brian的数组设置第一项的值。前两个调用成功, 因为testScores 字典包含 "Dave" 和 "Bev". 第三个调用会失败, 因为 testScores 字典并不包含 "Brian" 键。

# 多层链接

你可以使用多层链接来访问模型的属性,方法和下标。不过, 多层链接不会给返回值添加更多可选性。

换句话说:

如果你获取的类型不是可选的, 由于可选链接,它会变成可选类型。
如果你获取的类型已经是可选的了, 它不会因为可选链接而变的更可选。
因此:

如果你通过可选链接去获取一个Int值, 会返回一个Int?, 不管使用了多少层的链接。
类似的, 如果你使用可选链接去获取一个 Int?值, 会返回一个Int?, 不管使用了多少层的连接。
下面的例子尝试访问john的属性residence 的属性address 的属性street. 这里用了两层可选链接, 来链接 residence 和 address 属性, 它们都是可选类型:
<pre><code>
if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// 打印 "Unable to retrieve the address."
</code></pre>
john.residence 的值现在有一个有效的 Residence 实例。不过, john.residence.address 的值现在是 nil. 所以,  john.residence?.address?.street 调用失败。

注意在上面的例子里, 你尝试获取street属性的值。这个属性的类型是 String?. 因此 john.residence?.address?.street 也是 String? 类型, 尽管使用了两层可选链接。

如果你为john.residence?.address?设置一个实际的地址, 并且为address的属性street设置一个实际值, 你就可以使用多层链接访问street属性的值了:
<pre><code>
let johnsAddress = Address()
johnsAddress.buildingName = "The Larches"
johnsAddress.street = "Laurel Street"
john.residence?.address = johnsAddress

if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// 打印 "John's street name is Laurel Street."
</code></pre>
在这个例子里, 尝试设置john.residence的address属性会成功, 因为john.residence现在包含了一个有效的 Residence 实例。

# 使用可选返回值链接方法

前面的例子展示如何通过可选链接获取一个可选类型的属性值。你也可以使用可选链接,调用返回值是可选类型的方法, 如果需要可以链接方法的返回值。

下面的例子使用可选链接调用 Address 类的 buildingIdentifier() 方法。这个方法返回值类型是 String?. 就像上面描述的, 可选链接最后的返回类型也是 String?:
<pre><code>
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print("John's building identifier is \(buildingIdentifier).")
}
// 打印 "John's building identifier is The Larches."
</code></pre>
如果你想执行更深的操作链接方法的返回值, 就在方法括号的后面放上可选链接的问号:
<pre><code>
if let beginsWithThe =
    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
    if beginsWithThe {
        print("John's building identifier begins with \"The\".")
    } else {
        print("John's building identifier does not begin with \"The\".")
    }
}
// 打印 "John's building identifier begins with "The"."
</code></pre>
备注

在上面的例子里, 你在括号后面放上了可选链接问号, 因为你链接的可选值是 buildingIdentifier() 方法的返回值, 并不是buildingIdentifier() 方法本身。
# 错误处理
错误处理是在你的程序中响应错误条件并恢复的过程。Swift 为在运行时抛出,捕获,传递和恢复错误提供了一级支持。

有些操作不能保证总能顺利执行或者产生有用的输出。可选用来代表缺值, 但是当一个操作失败了, 知道失败怎么产生的通常很有用, 所以你的代码可以相应作出响应。

例如, 考虑从磁盘读取和处理数据的任务。这个任务有很多方式失败, 包括指定位置文件不存在, 文件没有读的权限, 或者文件不能以兼容的格式进行编码。这些不同场景的区分允许程序去解决一些错误,和用户沟通它不能解决的任何错误。

# 表示和抛出错误

在 Swift里, 错误用符合错误协议的类型值表示。这个空协议表明一个类型可以用来错误处理。

Swift 枚举类型特别适合用来模拟一组相关的错误条件, 带有对应的值来传达错误的额外信息。例如, 这里有一组,在一个游戏中操作自动售货机的错误条件:
<pre><code>
enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
</code></pre>
抛出一个错误,让你表明异常发生了,正常执行语句不能继续了。例如, 下面的代码抛出一个错误,表明自动售货机需要五个以上的硬币:
<pre><code>
throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre>
# 处理错误

当一个错误抛出来后, 一些包围的代码要负责处理这个错误—比如, 通过修正这个问题, 尝试替代方法或者通知用户执行失败。

Swift 里有四种方法来处理错误。你可以把错误从函数传递到调用函数的代码里;使用一个 do-catch 语句来处理错误,;把错误当做一个可选值来处理;或者断言这个错误不会发生。

当一个函数抛出一个错误时, 它改变了你的程序流, 所以快速判断抛出错误代码的位置很重要。为了在你的代码里判断这些位置,在调用会抛出错误的函数,方法或者构造器的代码前写上try 关键字—或者它的变体 try? 或者 try!. 

备注

Swift 的错误处理像其他语言的异常处理, 也是使用try, catch 和throw 关键字。给很多语言不同的是—包括 Objective-C— Swift 的错误处理不涉及解除调用堆栈, 这个过程花费太多的计算。像这样, 抛出异常语句的性能可以媲美这些返回语句。

# 用抛出函数传递错误

为了表示一个函数,方法或者构造器可以抛出错误, 在函数定义里,把throws 关键字写在函数括号的后面。用throws 标记的函数就是一个抛出函数。如果函数指定了一个返回值, 把 throws 关键字写在返回箭头之前 (->).
<pre><code>
func canThrowErrors() throws -> String

func cannotThrowErrors() -> String
</code></pre>
一个抛出函数把错误传递到它被调用的地方。

备注

只有抛出函数可以传递错误。非抛出函数内部的错误只能在函数内部处理。

在下面的代码里, VendingMachine 类有一个方法 vend(itemNamed:),如果请求项目不合理,它会抛出一个对应的VendingMachineError, 超出存货, 或者有一笔消费超过了当前的存量:
<pre><code>
struct Item {
    var price: Int
    var count: Int
}
class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Pretzels": Item(price: 7, count: 11)
    ]
    var coinsDeposited = 0
    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.invalidSelection
        }
        guard item.count > 0 else {
            throw VendingMachineError.outOfStock
        }
        guard item.price <= coinsdeposited="" else="" {="" throw="" vendingmachineerror.insufficientfunds(coinsneeded:="" item.price="" -="" coinsdeposited)="" }="" var="" newitem="item" newitem.count="" inventory[name]="newItem" print("dispensing="" \(name)")="" <="" code=""></=></code></pre>
vend(itemNamed:) 方法使用 guard 语句,如果任何购买小吃的要求不能满足,就尽早退出和抛出错误。因为一个throw 语句会立即转移程序控制, 只有所有的要求都满足才会出售货品。

因为 vend(itemNamed:) 方法会传递所有抛出的错误, 任何调用这个方法的代码要么处理这个错误—用 do-catch 语句, try?, 或者 try!—要么继续传递这些错误。例如, 这个例子里的buyFavoriteSnack(person:vendingMachine:) 方法也是一个抛出函数, vend(itemNamed:) 方法抛出的错误会传递到 buyFavoriteSnack(person:vendingMachine:) 函数被调用的地方。
<pre><code>
let favoriteSnacks = [
    "Alice": "Chips",
    "Bob": "Licorice",
    "Eve": "Pretzels",
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre>
在这个例子里,buyFavoriteSnack(person: vendingMachine:) 函数查询给定客户最喜欢的小吃,然后调用vend(itemNamed:)方法来购买。由于 vend(itemNamed:) 方法可以抛出错误, 所以在它前面加上try关键字来调用。

抛出构造器和抛出函数一样可以传递错误。例如, 下面PurchasedSnack 结构体的构造器调用了一个抛出函数作为构造过程的一部分, 通过传递错误给调用者,它处理任何它遇见的错误。
<pre><code>
struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
</code></pre>
# 使用 Do-Catch 处理错误

你可以用一个 do-catch 语句来处理错误。如果一个错误被do字句的代码抛出来, 它匹配 catch 字句来决定哪一个来处理这个错误。

这里是 do-catch 语句的一般样式:
<pre><code>
do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</code></pre>
在catch后面写上模式来表明这个字句可以处理什么错误。如果一个 catch 字句没有一个模式, 字句就会匹配所有的错误并且把错误绑定到一个本地的常量 error. 更多模式匹配,参见模式。

catch 字句并不需要处理所有do字句抛出来的错误。如果没有 catch 字句处理这个错误, 这个错误就会传递到周围代码。不过, 这个错误必须被周围代码处理—或者被一个封闭的 do-catch 字句或者在一个抛出函数内部处理。例如, 下面的代码处理了VendingMachineError 列举的所有三种情况, 但是所有其他的错我必须被周围代码处理:
<pre><code>
var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.invalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
    print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
}
// 打印 "Insufficient funds. Please insert an additional 2 coins."
</code></pre>
在上面的例子里, buyFavoriteSnack(person:vendingMachine:) 在一个try表达式里调用, 因为它可以抛出一个错误。如果一个错误抛出了, 语句执行立即转到 catch 字句, 它觉得是否允许传递继续。如果没有错误抛出来, do 语句剩下的语句会继续执行。

# 转换错误成可选值

通过转换错误成一个可选值,你可以使用 try? 来处理错误。当执行try?表达式时,如果一个错误抛出来了,表达式的值就会变成nil. 例如, 下面的例子里x和y有着相同的值和行为:
<pre><code>
func someThrowingFunction() throws -> Int {
    // ...
}

let x = try? someThrowingFunction()

let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>
如果 someThrowingFunction() 抛出一个错误, x和y的值就是nil. 否则, x和y值就是函数的返回值。注意,无论函数返回什么类型,x和y都是可选的。这里函数返回的是一个整数, 所以x和y是可选的整数。

当你想处理所有相同方式的错误时,使用 try? 让你可以写出更加精确的错误处理代码。例如, 下面的代码使用了一些简单的方法来获取数据, 如果所有的方法都失败了则返回nil.
<pre><code>
func fetchData() -> Data? {
    if let data = try? fetchDataFromDisk() { return data }
    if let data = try? fetchDataFromServer() { return data }
    return nil
}
</code></pre>
# 禁用错误传递

有时,你不希望一个抛出函数或者方法在运行时抛出一个错误。这种情况下, 可以在表达式前面写上 try!来禁用错误传递并且把调用包裹在运行的断言中,这错误就不会抛出。如果一个错误时间上出现了, 你会得到一个运行时错误。

例如, 下面的代码使用了 loadImage(atPath:) 函数, 它从一个给定的路径导入图片资源,如果图片不能导入则抛出一个错误。在这种情况下, 因为图片是靠程序输送, 运行时不会有错误抛出, 所以它适合禁用错误传递。
<pre><code>
let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
</code></pre>
# 指定清理行为

在代码执行离开当前代码块之前,你可以用一个defer语句来执行一组语句。这个语句让你可以做一些必须的清理工作,这个工作执行时无视怎样离开当前代码块—不管它是因为错误发生还是因为return或者break语句。例如, 你可以使用一个defer语句,来确保文件描述符被关闭,手动分配的内存被释放。

一个defer语句一直到当前代码块退出才会执行。这个语句由defer关键字和执行语句组成。推迟语句不会包含任何把控制转移的语句。 比如 break 或者 return 语句, 也不会抛出错误。推迟行为以它们被指定的相反顺序执行—也就说, defer语句第一行代码会在第二行代码后执行,以此类推。
<pre><code>
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
    }
}
</code></pre>
上面的例子使用了一个 defer 语句来确保 open(_:) 函数会调用 close(_:).

备注

即使没有涉及错误处理代码,你也可以使用一个defer语句。
# 类型转换
类型转换是是判断实例类型的一种方法, 或者在它的继承层次里,把来自某些地方的实例作为不同的超类或者子类。

Swift中的类型转换使用is和as操作符。这两个操作符提供了简单有效的方式来判断一个值的类型或者把一个值转换成不同的类型。

你可以通过类型转换来判断一个类型是否遵守某个协议, hecking for Protocol Conformance 有描述。

# 为类型转换定义类层次

你可以在类和子类层次使用类型转换,来判断特定类实例的类型,同时可以在相同的层次里把实例转换成另外一个类类型。下面三个代码片段定义了一类层次,还有一个包含这些类实例的数组, 在类型转换的例子中使用。

第一个代码片段定义了了一个新的基类 MediaItem. 这个类为任何出现在数字媒体库中的项目提供基本的功能。特别的是, 它声明了一个字符串类型的 name属性, 还有个一个 init 构造器。 (它假定所有媒体项,包括电影和歌曲,都有名字)
<pre><code>
class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
</code></pre>
下面的代码片段定义了两个 MediaItem的子类。第一个子类, Movie, 封装了一部电影的额外信息。它添加了一个 director 属性和一个对应的构造器。第二个子类, Song, 添加了一个add属性和一个构造器:
<pre><code>
class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
</code></pre>
最后的代码片段创建了一个常量数组 library, 它包括了两个 Movie 实例和三个 Song 实例。library 数组的类型通过用字面量内容初始化可以推断出来。 Swift 类型检查者可以推断出 Movie 和 Song 有一个共同的基类 MediaItem, 所以它推断library 数组是 [MediaItem] 类型:
<pre><code>
let library = [
    Movie(name: "Casablanca", director: "Michael Curtiz"),
    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
    Movie(name: "Citizen Kane", director: "Orson Welles"),
    Song(name: "The One And Only", artist: "Chesney Hawkes"),
    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// the type of "library" is inferred to be [MediaItem]
</code></pre>
实际上存储在 library 数组里的依然是 Movie 和 Song 实例。不过, 如果遍历这个数组的内容, 你获得的类型是 MediaItem, 而不是 Movie 或者 Song. 为了使用它们本来的类型, 你需要检测它们的类型, 或者向下转换它们的类型。0

# 判断类型

使用类型判断操作符 (is) 来判断一个实例是否是每个子类类型。如果实例是那个子类类型,类型判断操作符就返回真,否则就返回假。

下面的例子定义了两个变量, movieCount 和 songCount, 用来计算存储在library数组中的 Movie 和 Song 实例的数量:
<pre><code>
var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        movieCount += 1
    } else if item is Song {
        songCount += 1
    }
}

print("Media library contains \(movieCount) movies and \(songCount) songs")
// 打印 "Media library contains 2 movies and 3 songs"
</code></pre>
上面的例子遍历library数组所有的项。每次传递, for-in 循环把item常量设置成数组里的下一个 MediaItem.

如果当前MediaItem 是一个Movie 实例, 就返回真。否则就返回假。类似的, MediaItem是 Song 就判断它是不是一个 Song 实例。for-in 循环结束后, movieCount 和 songCount 包含了对应实例的数量。

# 向下转换

实际上,特定类类型的常量或者变量调用是子类的实例。你可以使用类型转换操作符(as? 或者 as!)向下转换成子类类型。

由于向下转换会失败, 所以类型转换操作符有两种形式。条件形式, as?, 返回你想转换类型的可选值。强制形式, as!, 尝试向下转换并强制拆包结果。

当你不能确定向下转换能否成功时,使用条件形式的类型转换操作符 (as?). 这个操作符总是返回一个可选值, 如果向下转换不可能就会返回nil. 这个确保你可以判断转换的成功。

当你确定向下转换可以成功时,使用强制形式的类型转换操作符 (as!). 如果你转换到一个错误的类类型,这个形式的操作符会引发一个运行时的错误。

下面的例子遍历了library数组里的的每一个 MediaItem , 然后为每一项打印一条对应的描述信息。为了实现这个, 它需要每一项作为真实的 Movie 或者 Song来访问, 不仅仅是作为 MediaItem. 为了能可以访问 director 或者 artist 属性,然后用在描述里,这样做是必须的。

在这个例子里, 数组里的每一项有可能是 Movie, 或者 Song. 你不会提前知道每一项实际使用哪个类, 所以这里很适合使用条件形式的操作符 (as?) 来在循环中判断向下转换成功与否:
<pre><code>
for item in library {
    if let movie = item as? Movie {
        print("Movie: \(movie.name), dir. \(movie.director)")
    } else if let song = item as? Song {
        print("Song: \(song.name), by \(song.artist)")
    }
}

// Movie: Casablanca, dir. Michael Curtiz
// Song: Blue Suede Shoes, by Elvis Presley
// Movie: Citizen Kane, dir. Orson Welles
// Song: The One And Only, by Chesney Hawkes
// Song: Never Gonna Give You Up, by Rick Astley
</code></pre>
这个例子开始先尝试将当前项向下转换到类型 Movie. 因为当前项是 MediaItem 实例, 它有可能是一个 Movie; 它也有可能是一个 Song, 或者仅仅是一个基本的 MediaItem. 因为不确定性, as? 形式的类型转换符会返回一个可选值,在尝试向下转换成一个子类型时。item as? Movie 返回结果是 Movie? 类型, 或者 “可选的 Movie”.

如果对数组中的Song实例向下转换到 Movie 就会失败。为了处理这个情况, 例子里使用可选绑定来判断可选的l Movie 是否包含了一个值 (就是说, 判断向下转换是否成功) 可选绑定写作 “if let movie = item as? Movie”, 它可以这样读:

“尝试作为一个Movie来访问。 如果成功了, 把可选返回值设置给一个临时常量 movie.”

如果向下转换成功了, movie的属性用来为Movie实例打印一条描述信息, 包括导演名。相似的原则用于判断 Song 实例, 在找到Song实例的时候就打印对应的描述信息(包括艺术家名字)。

备注

转换不会修改实例的值。潜在的实例依然相同; 它会简单处理和访问作为转换的类型。

# Any 和 AnyObject的类型转换

Swift 提供两个特别类型来使用未指定的类型:

Any 可以表示任意类型的实例, 包括函数类型。
AnyObject可以表示任意类类型的实例。
当你需要它们提供的行为和能力的时候, 可以使用Any 和 AnyObject. 更好的建议是,在你的代码中指定你希望的类型。

这里有一个例子使用Any来处理不同类型的混合, 包括函数类型和非类的类型。这个例子创建了一个数组 things, 它可以存储Any类型的值:
<pre><code>
var things = [Any]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
things.append({ (name: String) -> String in "Hello, \(name)" })
</code></pre>
things 数组包含了两个整型值, 两个浮点值, 一个字符串值, 一个元组类型 (Double, Double), 电影 “Ghostbusters”, 和一组表达式,这个表达式有一个字符串参数和一个字符串返回值。

为了找出一个常量或者变量的特定类型, Any 和 AnyObject 类型, 你可以在一个switch语句分支里使用is或者as. 下面的例子遍历了things数组里的每一项,然后使用一个switch语句来查询它们的类型。一些分支绑定了指定类型常量的匹配值来确保它的值被打印出来:
<pre><code>
for thing in things {
    switch thing {
    case 0 as Int:
        print("zero as an Int")
    case 0 as Double:
        print("zero as a Double")
    case let someInt as Int:
        print("an integer value of \(someInt)")
    case let someDouble as Double where someDouble > 0:
        print("a positive double value of \(someDouble)")
    case is Double:
        print("some other double value that I don't want to print")
    case let someString as String:
        print("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        print("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        print("a movie called \(movie.name), dir. \(movie.director)")
    case let stringConverter as (String) -> String:
        print(stringConverter("Michael"))
    default:
        print("something else")
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called Ghostbusters, dir. Ivan Reitman
// Hello, Michael
</code></pre>
NOTE

Any 类型表示任意类型值, 包括可选类型。如果某个地方需要一个Any类型值,你而你使用了可选值, Swift 会给你一个警告。如果你真的需要使用一个可选值作为 Any 值, 你可以使用 as 操作符显式转换 optional 为 Any, 就像下面展示的这样。
<pre><code>
let optionalNumber: Int? = 3
things.append(optionalNumber)        // Warning
things.append(optionalNumber as Any) // No warning
</code></pre>
# 嵌套类型
枚举通常用来支持一个特定类或者结构体的功能。类似的, 有时候在一个复杂类型的内部定义工具类或者结构体来使用是很方便的。为了完成这个, Swift 确保你可以定义嵌套类型, 即在支持类型定义中内嵌支持的枚举,类和结构体。

为了在其他类型中内嵌一个类型, 在它支持类型的外部大括号内写定义。类型可以按照需要内嵌多层。

# 内嵌类型的行为

下面的例子定义了一个结构体 BlackjackCard, 它模拟了在Blackjack 游戏中玩牌。BlackJack 结构体包含了两个内嵌的枚举类型 Suit 和 Rank.

在 Blackjack里, Ace 牌面值或者是一或者是十一。这个特性用一个结构体 Values来表示, 它嵌套在 Rank 枚举里:
<pre><code>
struct BlackjackCard {

    // nested Suit enumeration
    enum Suit: Character {
        case spades = "♠", hearts = "♡", diamonds = "♢", clubs = "♣"
    }

    // nested Rank enumeration
    enum Rank: Int {
        case two = 2, three, four, five, six, seven, eight, nine, ten
        case jack, queen, king, ace
        struct Values {
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
            case .ace:
                return Values(first: 1, second: 11)
            case .jack, .queen, .king:
                return Values(first: 10, second: nil)
            default:
                return Values(first: self.rawValue, second: nil)
            }
        }
    }

    // BlackjackCard properties and methods
    let rank: Rank, suit: Suit
    var description: String {
        var output = "suit is \(suit.rawValue),"
        output += " value is \(rank.values.first)"
        if let second = rank.values.second {
            output += " or \(second)"
        }
        return output
    }
}
</code></pre>
Suit 枚举描述了玩牌的四种花色, 带有raw 字符值来表示它们的符号。

Rank 枚举描述了13种玩牌排名, 带有一个raw 整型值来表示它们的牌面值 (这个raw整型值没有用于Jack, Queen, King, 和 Ace)

正如上面提到的,Rank 枚举定义了更深的嵌套结构体 Values. 这个结构体封装了大多数牌都有一个值的事实, 不过 Ace 牌有两个值。 Values 结构体定义了两个属性来表示这个:

第一个, 类型是 Int
第二个, 类型是 Int?, 或者“可选 Int”
Rank 同时定义了一个计算属性values, 它会返回 Values 结构体的实例。这个计算属性考察牌的排名并且基于排名用对应的值来初始化新的 Values 实例。它为jack, queen, king, 和 ace使用特别的值。对于数子牌, 它使用 raw 整型值。

BlackjackCard 结构体自己有两个属性—rank 和 suit. 它也定义了一个计算属性description, 它使用rank 和 suit中的值建立牌名字和数值的描述。description 属性使用可选绑定来判断是否有第二个值需要展示, 如果是, 把第二个值插入描述信息。

由于 BlackjackCard 是一个没有自定义构造器的结构体, 它有一个隐式的成员构造器。你可以用这个构造器来构造一个新的常量theAceOfSpades:
<pre><code>
let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)
print("theAceOfSpades: \(theAceOfSpades.description)")
// 打印 "theAceOfSpades: suit is ♠, value is 1 or 11"
</code></pre>
尽管 Rank 和 Suit 嵌套在 BlackjackCard里面, 它们的类型可以通过上下文推断出来, 所以这个实例的初始化可以根据分支名调用枚举分支 (.ace 和 .spades) . 上面的例子里, description 属性正确报出黑桃 Ace 牌面值是1或者11.

# 调用嵌套类型

在定义上下文之外调用嵌套类型, 要在它的名字前加上它内嵌的类型名:
<pre><code>
let heartsSymbol = BlackjackCard.Suit.hearts.rawValue
// heartsSymbol is "♡"
</code></pre>

</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展可以给存在的类,结构体,枚举或者协议类型添加新功能。包括给你无法访问的源代码扩展类型的能力 (也就是逆向建模)。 扩展类似于Objective-C 的分类。 (跟 Objective-C 分类的是, Swift 扩展没有名字)</p>
<h1 id="Swift-扩展可以"><a href="#Swift-扩展可以" class="headerlink" title="Swift 扩展可以:"></a>Swift 扩展可以:</h1><p>添加计算实例属性和计算类型属性<br>定义实例方法和类型方法<br>提供新的构造器<br>定义下标<br>定义和使用新的嵌套类型<br>让已存在的类型符合一个协议<br>在 Swift里, 你甚至可以扩展一个协议来提供需要的实现或者或者添加额外的功能符合使用的类型。</p>
<p>备注</p>
<p>扩展可以给一个类型添加新功能, 但是它们不能覆盖已经存在的功能。</p>
<h1 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h1><p>使用 extension 关键字来声明扩展:</p>
<pre><code>
extension SomeType {
    // new functionality to add to SomeType goes here
}
</code></pre>
扩展可以让已存在的类型符合一个或者多个协议。 在这种情况下, 协议名跟类和结构体的名字写法一样:
<pre><code>
extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}
</code></pre>

<p>备注</p>
<p>如果定义一个扩展来给已存在的类型添加新功能, 这个新功能给所有这种类型的实例使用, 即使它们在扩展定义前已经创建。</p>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>扩展可以给已存在类型添加计算实例属性和计算类型属性。下面的例子给Swift的内建浮点类型添加了五个计算实例属性, 提供了基本支持来使用距离单位:</p>
<pre><code>
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// 打印 "One inch is 0.0254 meters"
let threeFeet = 3.ft
print("Three feet is \(threeFeet) meters")
// 打印 "Three feet is 0.914399970739201 meters"
</code></pre>
这些计算属性表示,一个浮点值应该被当做一个特定的长度单位。尽管它们实现成计算属性, 这些属性的名字可以用点语法添加到浮点值的后面, 使用这些字面量来执行距离的转换。

在这个例子里, 浮点值 1.0 被认为表示1米。就是为什么m计算属性返回self—1.m 表达式被认为是计算1.0的浮点值。

其他单位转换使用米测量。一千米相当于 1,000 米, 所以km计算属性把数值乘以1_000.00 来转换成用米表示的数。相似的, 一米有3.28084 尺, 所以 ft 计算属性用潜在的浮点数值除以3.28084, 把尺转换为米。

这些属性是只读的计算属性, 所以它们表示的时候没有带上 get 关键字, 为了简洁性。它们的返回值是浮点型, 可以用在接受浮点数的数学运算中。
<pre><code>
let aMarathon = 42.km + 195.m
print("A marathon is \(aMarathon) meters long")
// 打印 "A marathon is 42195.0 meters long"
</code></pre>
备注

扩展可以添加新的计算属性, 但是它们不能添加存储属性, 也不能给已存在的属性添加观察者。

# 构造器

扩展可以给已存在类型添加新的构造器。这让你可以扩展其他类型来接受你自定的类型作为构造器的参数, 或者提供额外的构造选项,这些不会包含在类型的原始实现代码中。

扩展可以给一个类添加新的便利构造器, 但是不能添加新的指定构造器或者析构器。指定构造器和析构器必须在原始类实现中提供。

备注

如果使用扩展为值类型添加一个构造器, 为所有的存储属性提供默认值,同时不会定义任何自定义的构造器。你可以在你的扩展构造器里调用默认的构造器和成员构造器。

下面的例子定义了一个 Rect 结构体来表示一个算术矩形。这个例子同时定义了两个辅助的结构体Size 和 Point, 两个结构体都给所有的属性提供默认值 0.0:
<pre><code>
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>
由于 Rect 结构体给所有的属性提供了默认值, 它会有一个默认的构造器和一个成员构造器。 这些构造器可以用来创建新的 Rect 实例:
<pre><code>
let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
                          size: Size(width: 5.0, height: 5.0))
                          </code></pre>
你可以扩展Rect结构体,提供一个额外的构造器,带有一个指定的中心点和大小:
<pre><code>
extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
 </code></pre>
新的构造器一开始先基于提供的中心点和大小,计算出一个对应的原点。然后调用结构体的成员构造器 init(origin:size:), 它在对应的属性中存储最新的原点和大小值:
<pre><code>
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
</code></pre>
备注

如果你用扩展来提供新的构造器, 你有责任确保初始化完成时,所有实例都被完全的构造了。

# 方法

扩展可以给已存在的类型添加实例方法和类型方法。下面的例子给Int类型添加了一个新的实例方法repetitions:
<pre><code>
extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {="" task()="" }="" <="" code=""></self></code></pre>
repetitions(task:) 方法只有一个参数 () -> Void, 它表明一个没有参数和返回值的函数。

扩展定义之后, 你可以在任何整数上调用 repetitions(task:) 方法来执行多次同样的任务:
<pre><code>
3.repetitions {
    print("Hello!")
}
// Hello!
// Hello!
// Hello!
</code></pre>
# 改变实例方法

用扩展添加的实例方法也可以改变实例本身。结构体和枚举方法,能改变自身或者属性的必须标记为 mutating, 就像来自原始实现的 mutating 方法一样。

下面的例子给Swift的整型添加了一个新的 mutating 方法, 它用来计算原始值的平方:
<pre><code>
extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt is now 9
</code></pre>
# 下标

扩展可以给已存在的类型添加下标。下面的例子给Swift 内建整型添加了个整型下标。下标 [n] 返回从右边算第n个十进制数字:

123456789[0] returns 9
123456789[1] returns 8
…and so on:
<pre><code>
extension Int {
    subscript(digitIndex: Int) -> Int {
        var decimalBase = 1
        for _ in 0..<digitindex 2="" 5="" 7="" 9="" 10="" {="" decimalbase="" *="10" }="" return="" (self="" decimalbase)="" %="" 746381295[0]="" returns="" 746381295[1]="" 746381295[2]="" 746381295[8]="" <="" code=""></digitindex></code></pre>
如果整数没有足够的位数满足请求索引, 下标实现会返回 0, 好像这个数字左边填充了0:
<pre><code>
746381295[9]
// returns 0, as if you had requested:
0746381295[9]
</code></pre>
# 嵌套类型

扩展可以给已存在的类,结构体和枚举添加新的嵌套类型:
<pre><code>
extension Int {
    enum Kind {
        case negative, zero, positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}
</code></pre>
这个例子向Int类型添加了一个新的嵌套枚举。这个枚举 Kind, 表示一个整数表示的数字种类。特别的是, 它表示这个数组是否是正数,0,或者负数。

这个例子同时也添加了一个新的计算属性 kind, 它会根据整数返回对应的 Kind 枚举分支。

这个嵌套的枚举可以用在任意整数值:
<pre><code>
func printIntegerKinds(_ numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .negative:
            print("- ", terminator: "")
        case .zero:
            print("0 ", terminator: "")
        case .positive:
            print("+ ", terminator: "")
        }
    }
    print("")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// 打印 "+ + - 0 - 0 + "
</code></pre>
这个函数 printIntegerKinds(_:), 输入一个整数数组然后遍历这些值。对于数组中的每一个整数来说, 函数会检查它的kind计算属性, 然后打印对应的描述信息。

备注

number.kind 已经知道是 Int.Kind 类型。因为这个原因, 所有 Int.Kind 分支值在switch语句中都是简写, 比如 .negative rather 而不是 Int.Kind.negative.
# 协议
A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.

In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.

# 协议语法

定义协议的方式跟类,结构体和枚举很相似:
<pre><code>
protocol SomeProtocol {
    // protocol definition goes here
}
</code></pre>
自定义类型规定,遵守某个协议,要把协议名写在类型名的后面,用冒号分开。多个协议可以用逗号隔开:
<pre><code>
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
</code></pre>
如果一个类有超类, 把超类名写在所有协议的前面, 后面跟着逗号:
<pre><code>
class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
</code></pre>
# 属性需求

一个协议可以要求符合类型去提供一个带有名字和类型的实例属性或者类型属性。协议不能指定属性是否应该是一个存储属性还是一个计算属性—它只能指定需要的属性的名字和类型。协议也指定了是否每一个属性必须是 gettable 或者同时是 gettable 和 settable.

如果一个协议要求属性是 gettable 和 settable, 这个属性要求对于一个常量存储属性或者一个只读计算属性是没有办法完成的。如果协议只要求属性是 gettable, 这个要求可以被任意类型的属性满足, 如果这个对你自己的代码有用的话,对于settable的属性也是有效的。

属性需求总是声明为变量属性, 前面是var关键字。Gettable 和 settable 属性,在它们的类型声明后面写上 { get set } 来标明。gettable 属性只需写上 { get }.
<pre><code>
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>
当你定义类型属性需求时,总是要在它们前面加上static 关键字。尽管类型属性需求前缀可以是static或者class,这个规则在用类实现的时候同样适用:
<pre><code>
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>
这里有一个例子,协议只有一个实例属性需求:
<pre><code>
protocol FullyNamed {
    var fullName: String { get }
}
</code></pre>
FullyNamed 协议要求符合类型提供一个完全限定的名字。协议不能指定其他关于符合类型本身的东西—它只能指定类型必须提供一个全名。协议规定任何 FullyNamed 类型必须有一个 gettable 实例属性 fullName, 它是一个字符串类型。

这里有一个结构体的例子,它采用并符合了 FullyNamed 协议:
<pre><code>
struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
</code></pre>
这个例子定义了一个结构体 Person, 它表示一个指定名字的人。它规定,采用 FullyNamed 协议作为实现的第一行的部分。

Person 每个实例都只有一个存储属性 fullName, 它们是字符串类型。这个匹配了 FullyNamed 协议的唯一需求, 说明 Person 正确遵守了这个协议。 (如果协议要求没有实现,Swift 会报编译期错误)

这里有个更复杂的类, 它也是采用并遵守了 FullyNamed 协议:
<pre><code>
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
</code></pre>
这个类把fullName 属性实现为一个只读计算属性。 每个Starship 类实例存储一个强制名和一个可选的前缀。如果前缀存在,fullName 属性就使用它。放在 name 前,为 starship 创建一个完整的名字。

# 方法需求

协议可以要求符合类型实现特定的实例方法和类型方法。这些方法写在协议定义里面,跟普通实例方法和类型方法写法一致。但是没有花括号或者方法体。允许有可变参数, 遵守普通方法的规则限制。不过,协议定义中的方法参数不能指定默认值。

像类型属性需求一样, 定义在协议里的类型方法需要在前面加上static关键字:
<pre><code>
protocol SomeProtocol {
    static func someTypeMethod()
}
</code></pre>
下面的例子,定义了一个协议,里面有一个实例方法:
<pre><code>
protocol RandomNumberGenerator {
    func random() -> Double
}
</code></pre>
这个协议, RandomNumberGenerator, 要求任何符合类型必须有一个实例方法 random, 这个方法调用后会返回一个浮点值。 尽管它不是协议指定的部分, 它假设这个值会从0.0 到 1.0 (但是不包括)

RandomNumberGenerator 协议不会假设每个随机数怎么产生—它简单要求生成器提供一个标准方法来产生新的随机数。

这里实现了一个类,它采用并遵守了 RandomNumberGenerator 协议。这个类实现了一个伪随机数算法,线性同余生成器:
<pre><code>
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// 打印 "Here's a random number: 0.37464991998171"
print("And another one: \(generator.random())")
// 打印 "And another one: 0.729023776863283"
</code></pre>
# 变异方法需求

对于方法来说,有时候需要改变或者编译它所属的实例。对于值类型的实例方法 (结构体和枚举),可以在func关键字前加上 mutating 关键字来表明,允许这个方法改变它所属的实例和这个实例的所有属性。

如果你定义了一个协议实例方法,想要改变采用这个协议的任意类型的实例, 在协议定义里,在方法前标记上 mutating 关键字。 这让结构体和枚举可以采用这个协议并且满足方法需求。

备注

如果你把协议实例方法需求标记为 mutating, 那么在为类实现该方法的时候,就不需要写上 mutating 关键字。mutating 关键字只是用在结构体和枚举上。

下面的例子定义了一个协议 Togglable, 它只定义了一个实例方法需求 toggle. 就像它名字提示的, toggle() 方法会触发或者改变符合类型的状态。通常是修改类型的某个属性。

toggle() 方法用 mutating 关键字标记,作为Togglable 协议定义的一部分。表示被调用时,希望改变符合类型实例的状态:
<pre><code>
protocol Togglable {
    mutating func toggle()
}
</code></pre>
如果你为一个结构体或者枚举实现这个协议, 通过实现标记为mutating 的toggle()方法,这个结构体或者枚举就可以符合这个协议了。

下面的例子定义了一个枚举 OnOffSwitch. 这个枚举开关有两个状态, 用枚举分支 on 和 off表示。枚举开关实现标记为 mutating, 为了匹配 Togglable 协议的需求:
<pre><code>
enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch is now equal to .on
</code></pre>
# 构造器需求

协议可以要求符合类型实现指定的构造器。协议定义中的构造器和普通构造器的写法是一样的, 但是没有花括号和构造体:
<pre><code>
protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>
# 类实现协议构造器需求

你可以在符合协议的类中,把协议构造器实现成指定构造器或者便利构造器。在这两种情况下, 你必须用required 修饰符来标记构造器的实现:
<pre><code>
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
</code></pre>
使用required 修饰符确保你在所有符合协议的子类上,提供一个显式或者继承的构造器需求实现, 它们也遵守这个协议。

备注

如果符合协议的类标记了final修饰符,你就不需要用required标记协议构造器的实现,因为final 类不能子类化。

如果一个子类重写了超类的指定构造器, 然也实现了协议的构造器需求, 这个构造器就要同时标记required 和 override的修饰符:
<pre><code>
protocol SomeProtocol {
    init()
}

class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}

class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
</code></pre>
# 失败构造器需求

协议可以为符合类型定义失败构造器。

符合类型的失败或者非失败构造器可以满足协议的失败构造器需求。而一个非失败构造器需求,只能用一个非失败构造器或者一个隐式拆包失败构造器才能满足。

# 协议作为类型

协议本身不实现任何功能。 尽管如此, 你创建的协议在代码中依然是完全成熟的类型。

因为协议是一个类型, 只要其他类型允许,你可以在很多地方使用它。包括:

在函数,方法或者构造器中作为参数类型或者返回类型
作为一个常量,变量或者属性类型
作为数组,字典或者其他容器中项目的类型
备注

因为协议是类型, 它们的名字开始是一个大写字母 (例如 FullyNamed 和 RandomNumberGenerator) ,和Swift 中其他类型名字很匹配 (例如 Int, String, 和 Double).

这里有一个协议作为类型使用的例子:
<pre><code>
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>
这个例子定义了一个新类 Dice, 它在棋盘游戏里代表一个n面的骰子。 Dice 实例有一个整数属性 sides, 它表示骰子有多少面,然后还有一个属性 generator, 它用来产生一个随机数作为骰子的值。

generator 属性是 RandomNumberGenerator 类型。因此, 你可以用任何采用RandomNumberGenerator协议的类型来设置它。 你赋值给这个属性的实例无需其他, 主要这个实例采用RandomNumberGenerator 协议即可。

Dice 也有一个构造器, 来设置它的初始状态。这个构造器有一个参数 generator, 它也是 RandomNumberGenerator 类型。在初始化新的Dice实例时,你可以传入任何符合类型的值作为这个参数。

Dice 还提供了一个实例方法, roll, 它返回骰子的值。这个方法调用了生成器的 random() 方法来创建一个0.0到1.0的随机数。 然后使用随机数来生成一个正确的值。因为生成器采用了 RandomNumberGenerator, 它会保证有一个random() 方法可以调用。

这里展示Dice类如何产生一个6面的骰子, 它使用一个LinearCongruentialGenerator 实例作为随机数生成器:
<pre><code>
var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
</code></pre>
# 委托

委托是一种设计模式, 让类或者结构体可以把自己的一些责任委托给其他类型的实例。这个设计模式通过定义协议来实现,这个协议封装了委托的责任。符合类型确保提供委托的功能。委托可以用来响应特定的行为, 或者无需知道潜在资源类型,即可从资源获取数据。

下面的例子定义了两个协议, 用来使用基于骰子的棋盘游戏:
<pre><code>
protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}
</code></pre>
DiceGame 协议可以被任何包含骰子的游戏采用。DiceGameDelegate 协议可以被任何跟踪DiceGame过程的类型采用。

这里是有一个前面控制流中介绍过的蛇与梯子的游戏。这个版本使用一个 Dice 实例来摇骰子; 采用了 DiceGame 协议; 然后通知DiceGameDelegate 游戏的进程:
<pre><code>
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
</code></pre>

<p>这个版本的游戏包装成一个类 SnakesAndLadders, 它采用了 DiceGame 协议。它提供了一个 gettable dice 属性和一个 play() 方法来遵守这个协议。(dice 属性声明为常量,因为它在初始化后就不需要变化, 协议只要求它是 gettable.)</p>
<p>蛇与梯子游戏的棋盘在构造器 init() 里设置。游戏的所有逻辑都搬到协议的play 方法里, 它使用协议的 required dice 属性来提供骰子值。</p>
<p>注意 delegate 属性定义为可选的 DiceGameDelegate, 因为委托不要求必须玩游戏。因为它是一个可选类型, delegate属性自动初始化为nil. 之后, 这个游戏实例会有一个选项来设置这个属性为一个固定的代理。</p>
<p>DiceGameDelegate 提供了三个方法来跟踪游戏的过程。 这三个方法已经合并进 play()方法中。在新游戏开始时会调用, 新一轮开始, 或者游戏结束。</p>
<p>由于delegate 属性是一个可选的DiceGameDelegate, play()在代理上调用一个方法时, 它会使用可选链接。如果 delegate  属性为nil, 这些调用会失败而不会发生错误。如果 delegate 属性非nil, 代理方法会被调用, 然后传入SnakesAndLadders 实例作为一个参数。</p>
<p>下面例子展示了一个类 DiceGameTracker, 它采用了 DiceGameDelegate 协议:</p>
<pre><code>
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}
</code></pre>
DiceGameTracker 实现了所有 DiceGameDelegate 协议要求的方法。它用三个方法来跟踪游戏玩了几轮。它在游戏开始时重置 numberOfTurns 属性的值为0, 在每次游戏开始的时候加1, 然后在游戏结束后打印出游戏的总轮数。

gameDidStart(_:) 函数使用了game 参数来打印一些游戏介绍的信息。game 参数类型是 DiceGame, 而不是 SnakesAndLadders,  gameDidStart(_:) 可以访问和使用, 作为DiceGame 协议部分被实现的方法和属性。不过, 这个方法仍然可以使用类型转换来查询潜在实例的类型。在这个例子里, 它会判断有些是否是一个SnakesAndLadders 实例, 然后打印一条对应的信息。

gameDidStart(_:) 方法也会访问game参数的 dice属性。因为已经知道 game 遵守了DiceGame 协议, 它可以保证有一个 dice 属性, 所以 gameDidStart(_:) 方法也可以访问和打印dice 的 sides 属性, 而不用管正在玩什么类型的游戏。

这里是 DiceGameTracker 的行为:
<pre><code>
let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
</code></pre>
# 给扩展添加协议

你可以扩展一个已存在的类型来采用和遵守一个新的协议, 即使你无法访问已存在类型的源代码。扩展可以给已存在的类型添加新属性,方法和下标, 因此可以添加协议要求的任何需求。

备注

当在扩展里给一个实例类型添加协议时, 这个实例就会自动采用和遵守这个协议。

例如, 这个协议 TextRepresentable, 任何可以表示为文本的类型都可以实现。这可能是自我的描述或者当前状态的文本版本:
<pre><code>
protocol TextRepresentable {
    var textualDescription: String { get }
}
</code></pre>
早前的 Dice 类可以扩展成采用和遵守 TextRepresentable 协议:
<pre><code>
extension Dice: TextRepresentable {
    var textualDescription: String {
        return "A \(sides)-sided dice"
    }
}
</code></pre>
扩展采用新协议的方式跟原来Dice提供的实现一样。协议名写在类型名后,用冒号隔开, 协议需求的所有实现都写在扩展的花括号中。

所以 Dice 实例都可以认为是 TextRepresentable:
<pre><code>
let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
print(d12.textualDescription)
// 打印 "A 12-sided dice"
</code></pre>
类似的, SnakesAndLadders 也可以扩展成采用和遵守TextRepresentable协议:
<pre><code>
extension SnakesAndLadders: TextRepresentable {
    var textualDescription: String {
        return "A game of Snakes and Ladders with \(finalSquare) squares"
    }
}
print(game.textualDescription)
// 打印 "A game of Snakes and Ladders with 25 squares"
</code></pre>
# 用扩展声明协议

如果一个类型符合了协议的所有需求, 但是尚未声明它采用这个协议, 你可以用一个空的扩展,让它采用这个协议:
<pre><code>
struct Hamster {
    var name: String
    var textualDescription: String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}
</code></pre>
现在需要TextRepresentable 类型的地方都可以使用 Hamster 实例:
<pre><code>
let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
print(somethingTextRepresentable.textualDescription)
// 打印 "A hamster named Simon"
</code></pre>
备注

仅仅满足协议的需求,类型还不会自动采用这个协议。必须显式声明它们采用了这个协议。

# 协议类型集合

一个协议可以用作一个类型,存储在诸如数组或者字典的集合中。下面的例子创建了一组 TextRepresentable:
<pre><code>
let things: [TextRepresentable] = [game, d12, simonTheHamster]
</code></pre>
现在可以遍历数组中的所有项目, 然后打印每一项的文字描述:
<pre><code>
for thing in things {
    print(thing.textualDescription)
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</code></pre>
注意 thing 常量的类型是 TextRepresentable. 不是 Dice, 或者 DiceGame, 或者 Hamster类型, 尽管背后是这些类型。 由于它是 TextRepresentable 类型, 它又一个 textualDescription 属性, 通过循环每次访问thing.textualDescription 是安全的。

# 协议继承

一个协议可以继承一个或多个其他协议,在继承的需求顶层还可以添加更多的需求。协议继承的语法和类继承的语法很相似, 但是可以选择列出多个继承协议, 然后用逗号分开:
<pre><code>
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // protocol definition goes here
}
</code></pre>
这里有一个协议的例子,它继承了上面的 TextRepresentable 协议:
<pre><code>
protocol PrettyTextRepresentable: TextRepresentable {
    var prettyTextualDescription: String { get }
}
</code></pre>
这个例子定义了一个新协议, PrettyTextRepresentable, 它继承自 TextRepresentable. 任何采用 PrettyTextRepresentable 协议的都必须满足TextRepresentable 强制要求的所有需求, 然后加上PrettyTextRepresentable 强制要求的额外需求。在这个例子里, PrettyTextRepresentable 只添加了一个需求, 提供了一个 gettable 属性 prettyTextualDescription 来返回一个字符串。

SnakesAndLadders 类可以扩展成采用和遵守 PrettyTextRepresentable 协议:
<pre><code>
extension SnakesAndLadders: PrettyTextRepresentable {
    var prettyTextualDescription: String {
        var output = textualDescription + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder > 0:
                output += "▲ "
            case let snake where snake < 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
</code></pre>
这个扩展表明它采用了 PrettyTextRepresentable 协议,然后为SnakesAndLadders类型提供了prettyTextualDescription属性的实现。任何是 PrettyTextRepresentable 类型的也是 TextRepresentable 类型, 因此 prettyTextualDescription 实现的开始就是访问TextRepresentable的属性 textualDescription,用它作为输出字符串的开始部分。它往后面添加一个冒号和一个换行符, 然后使用它作为文本的开始。然后它遍历棋盘方格数组的项目, 然后把代表每个方格的几何形状添加到最后:

如果方格的值大于0, 它是梯子的底, 用 ▲表示。
如果方格的值小于0, 它是蛇的头, 用 ▼表示。
否则, 方格的值等于 0, 这是一个空方格, 用 ○ 表示。
现在 prettyTextualDescription 属性可以用来为SnakesAndLadders实例打印一条文本描述:
<pre><code>
print(game.prettyTextualDescription)
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</code></pre>
# 只用于类的协议

通过添加一个class关键字到一个协议继承列表,你可以限制协议只被类采用 (不是结构体也不是枚举)。class关键字应该总是出现在协议继承列表的第一个, 在任何继承协议之前:
<pre><code>
protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // class-only protocol definition goes here
}
</code></pre>
上面的例子里, SomeClassOnlyProtocol 只能被类采用。如果让结构体或者枚举来采用这个协议,会报一个编译期错误。

备注

当协议需求定义的行为假设或者要求符合类型拥有引用语义而非值语义的时候，要使用只用于类的协议。

# 协议组合

一次要求一个类型符合多个协议是有用的。使用一个协议组合,你可以把多个协议合并到一个需求。协议组合的样式是 SomeProtocol & AnotherProtocol. 你可以列出尽可能多的协议, 用 (&)分开。

下面的例子把两个协议 Named 和 Aged,合并到一个协议组合需求.作为一个函数参数:
<pre><code>
protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named & Aged) {
    print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(to: birthdayPerson)
// 打印 "Happy birthday, Malcolm, you're 21!"
</code></pre>
这个例子定义了一个协议 Named, 需要一个 gettable 字符串属性 name. 同时它也定义了另外一个协议 Aged,需要一个的 gettable 整型属性 age. 这个两个协议都被一个结构体 Person 采用。

这个例子还定义了一个函数 wishHappyBirthday(to:), celebrator 参数类型是 Named & Aged, 意思是 “任何遵守 Named 和 Aged 协议的类型” 它不关心传入的类型是什么, 只要它遵守这两个协议的要求。

这个例子然后创建了一个新的 Person 实例 birthdayPerson, 然后把这个新实例传入 wishHappyBirthday(to:) 函数。因为 Person 遵守两个协议, 这是一个有效的调用, wishHappyBirthday(to:) 函数可以打印生日祝福。

备注

协议组合没有定义一个新的,永久的协议类型。相反, 它们只是定义了一个本地临时的协议,用来合并组合中所有协议的需求。

# 判断协议一致性

你可以使用在类型转换中介绍的 is 和 as 操作符来判断协议的一致性, 并且转换成指定的协议。判断和转换协议跟判断和转换类型的语法完全一致:

如果一个实例符合一个协议, is 操作符返回 true,反之返回 false.
向下转换操作符 as? 会返回协议类型的一个可选值, 如果这个实例不符合该协议,这个值是 nil.
向下转换操作符 as! 强制转换成这个协议,如果转换失败会触发一个运行时错误。
下面的例子定义了一个协议 HasArea, 只有一个gettable 要求的浮点型属性 area:
<pre><code>
protocol HasArea {
    var area: Double { get }
}
</code></pre>
这里有两个类, Circle 和 Country, 它们都符合 HasArea 协议:
<pre><code>
class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
</code></pre>
Circle 类把 area 属性要求实现成了一个计算属性, 它基于一个存储属性 radius. Country 类直接把 area 属性需求实现成了一个存储属性。两个类都准确的符合了 HasArea 协议。

这里有一个类 Animal, 它不符合 HasArea 协议:
<pre><code>
class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
</code></pre>
Circle, Country 和 Animal 类没有共享的基类。不过, 它们都是类, 所以三个类型的实例都快要用来初始化数组,这类数组存储AnyObject类型的值:
<pre><code>
let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
</code></pre>
objects 数组用三个字面量来初始化,包括半径为2的 Circle 实例; 用英国表面积初始化的 Country 实例; 有四条腿的 Animal 实例。

现在可以遍历objects 数组, 可以判断数组里的每一项,看看它们是否符合 HasArea 协议:
<pre><code>
for object in objects {
    if let objectWithArea = object as? HasArea {
        print("Area is \(objectWithArea.area)")
    } else {
        print("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>
只要数组中的对象符合 HasArea 协议, as? 操作符返回的可选值会使用可选绑定拆包到一个常量 objectWithArea.  objectWithArea 常量是 HasArea类型, 所以它的 area 属性可以访问和安全的打印。

注意,潜在的对象没有被转换过程改变。它们依然是一个 Circle, 一个 Country 和一个 Animal. 不过, 在它们被存为 objectWithArea 常量的时候, 它们只是 HasArea 类型, 所有只有它们的 area 属性才能被访问。

# 可选协议需求

你可以为协议定义可选需求, 符合协议的类型不用去实现这些需求。协议定义中,通过前置 optional 修饰符来实现这些需求。可选需求是可用的,这样你就可以写代码和 Objective-C 交互。协议和可选需求都要用 @objc 属性来标记。注意, @objc 协议只能被继承自 Objective-C 的类或者 @objc 类采用。不能被结构体和枚举采用。

当你在可选需求中使用方法或者属性时, 它的类型自动成为可选。例如, 方法 (Int) -> String 会变成 ((Int) -> String)?. 整个函数都被可选包括,不仅仅是返回值。

可选协议需求可以用可选链接来调用, 来说明符合协议的类型不实现这些需求的可能性。调用可选方法的时候,通过在方法名后面写上问号来判断它是否实现, 例如  someOptionalMethod?(someArgument). 

下面的例子定义了一个整型计数类 Counter, 它用一个外部数据源来提供增长数。这个数据源在 CounterDataSource 协议里定义, 它有两个可选需求:
<pre><code>
@objc protocol CounterDataSource {
    @objc optional func increment(forCount count: Int) -> Int
    @objc optional var fixedIncrement: Int { get }
}
</code></pre>
CounterDataSource 协议定义了一个可选方法需求 increment(forCount:) 和一个可选属性需求 fixedIncrement. 这些需求为外部数据源定义了两个不同方法,来为Counter 实例提供一个合适的增长数。

备注

严格来说, 你可以写一个符合CounterDataSource协议的自定义类,却不用实现它的需求。它们都是可选的。

下面定义的Counter 类, 有一个CounterDataSource?类型的可选的 dataSource 属性:
<pre><code>
class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.increment?(forCount: count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>
Counter 在一个变量属性count中存储当前值。同时定义了一个方法increment, 每次方法调用时,它就会增加count属性的值。

increment() 方法通过数据源的increment(forCount:)方法实现,先尝试去获取一个增长数。increment() 方法使用可选链接尝试调用 increment(forCount:), 然后把当前值传入作为参数。

注意,这里有两层可选链接。首先, dataSource 可能为nil, 所以它后面有个问号,来表明如果dataSource 不是nil,就可以调用 increment(forCount:). 其次, 即使 dataSource 存在, 也不能保证它实现了increment(forCount:), 因为它是一个可选需求。在这里, increment(forCount:) 没有实现的可能性也是用可选链接处理的。只有 increment(forCount:) 方法存在,它才会被调用—就是说, 它不为nil. 这就是为什么 increment(forCount:)名字后也有一个问号的原因。

由于上述两种原因的任意一个,调用 increment(forCount:) 都有可能会失败, 所以调用返回一个可选整型值。尽管 increment(forCount:) 在CounterDataSource 中定义的返回值是非可选的,这个也会发生。尽管有两个可选链接操作, 一个接着一个, 结果依然包在一个可选项中。

调用完 increment(forCount:), 返回的可选整型值会拆包到一个常量 amount, 使用可选绑定的方式。如果可选整型值的确包含一个值—就是说, 如果委托和方法都存在, 方法返回一个值—拆包得到的数量会加到存储属性count 上, 然后增长完成。

如果不能从increment(forCount:)方法获取到值—或者是因为 dataSource 为nil, 或者数据源没有实现 increment(forCount:)—然后 increment() 方法尝试从数据源的 fixedIncrement 属性获取值。fixedIncrement 属性也是一个可选的需求, 所以它的值是一个可选的整型值。尽管 fixedIncrement 定义时是一个非可选的属性。

这里有个 CounterDataSource 协议的简单实现,在这里数据源返回一个常量值3,每当它被查询的时候。它通过实现fixedIncrement 属性需求来实现这点:
<pre><code>
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    print(counter.count)
}
// 3
// 6
// 9
// 12
</code></pre>
上面的代码创建了一个新的 Counter 实例; 然后把数据源设置成新的 ThreeSource 实例; 然后调用 increment() 方法四次。 如预料的一样, 每次increment()调用, count 属性都会增加。

这里有一个更复杂的数据源 TowardsZeroSource, 它让 Counter 实例从当前值向上或者向下往0靠近:
<pre><code>
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -> Int {
        if count == 0 {
            return 0
        } else if count < 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>
TowardsZeroSource 类实现了来自CounterDataSource协议的可选方法 increment(forCount:), 同时使用 count 参数值来判断往哪个方向计数。如果 count 已经为0, 方法返回0,表明无需继续计算。

你可以用一个 TowardsZeroSource 实例配合存在的 Counter 实例来计数从-4 到 0. 一旦计数到了0, 计数停止:
<pre><code>
counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    print(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</code></pre>
# 协议扩展

协议可以给符合的类型扩展方法和属性的实现。这让你可以在协议本身定义行为, 而不是在每个类型的个体或者在一个全局函数。

例如, RandomNumberGenerator 协议能够扩展提供一个 randomBool() 方法, 它用必须的 random() 方法结果来返回一个随机的布尔值:
<pre><code>
extension RandomNumberGenerator {
    func randomBool() -> Bool {
        return random() > 0.5
    }
}
</code></pre>
通过在协议上创建一个扩展, 所有符合类型无需额外改变即可自动获取这个方法的实现。
<pre><code>
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// 打印 "Here's a random number: 0.37464991998171"
print("And here's a random Boolean: \(generator.randomBool())")
// 打印 "And here's a random Boolean: true"
</code></pre>
# 提供默认实现

你可以用协议扩展给协议需求的任何方法和计算属性提供一个默认实现。如果符合类型提供了必须的方法和属性的实现, 这个实现会替换扩展提供的实现。

备注

扩展提供的有默认实现的协议需求和可选协议需求是不同的。尽管符合类型没有必要提供任意一种实现, 带有默认实现的需求可以不用可选链接来调用。

例如, PrettyTextRepresentable 协议, 它继承 TextRepresentable 协议,可以提供prettyTextualDescription 属性的默认实现,然后简单返回访问textualDescription属性的结果:
<pre><code>
extension PrettyTextRepresentable  {
    var prettyTextualDescription: String {
        return textualDescription
    }
}
</code></pre>
# 给协议扩展添加限制

当你定义了一个协议扩展, 你可以指定限制,符合类型在扩展的方法和属性可用前,必须满足这些限制。在协议名后面用where子句写上限制。

例如, 你可以给Collection 协议定义一个扩展, 它可以用于任何元素符合 TextRepresentable 协议的集合类型。
<pre><code>
extension Collection where Iterator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}
</code></pre>
通过把集合里的每个元素的文本描述连接在一起, textualDescription 属性返回整个集合的文本描述, 然后用方括号括起来。

考虑前面的结构体 Hamster, 它符合 TextRepresentable 协议, 然后是一个 Hamster 值的数组:
<pre><code>
let murrayTheHamster = Hamster(name: "Murray")
let morganTheHamster = Hamster(name: "Morgan")
let mauriceTheHamster = Hamster(name: "Maurice")
let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]
</code></pre>
因为数组符合 Collection 协议,并且数组的元素符合 TextRepresentable 协议, 所以数组可以用 textualDescription 属性获取它内容的文本表示:
<pre><code>
print(hamsters.textualDescription)
// 打印 "[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]"
</code></pre>
备注

如果一个符合类型满足了多个限制表达式的要求, Swift 会使用对应特定限制的实现。
# 泛型
泛型代码让你可以写出灵活,可重用的函数和类型,它们可以使用任何类型,受你定义的需求的约束。你可以写出代码,避免重复而且可以用一个清晰抽象的方式来表达它的意图。

泛型是Swift中最有力的特征之一, 而且大部分Swift的标准库是用泛型代码建立的。事实上, 在整个语言教程中，你一直在使用泛型,尽管你没有意识到这点。例如, Swift 的数组和字典类型都是泛型集合。 你可以创建一个整数数组,一个字符串数组,甚至是Swift允许创建的任何类型的数组。相似的, 你可以创建字典来保存任何指定类型的值, 什么类型并没有限制。

# 泛型解决的问题

这里有一个标准的非泛型的函数 swapTwoInts(_:_:), 用来交换两个整数值:
<pre><code>
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>
这个函数用了输入输出参数来交换a和b的值。

swapTwoInts(_:_:) 函数把b的原始值交换到a, a的原始值到b. 你可以调用这个函数来交换两个整型变量中的值:
<pre><code>
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 打印 "someInt is now 107, and anotherInt is now 3"
</code></pre>
swapTwoInts(_:_:) 函数是有用的, 不过只能用于整数。如果你想交换两个字符串, 或者两个浮点数, 你就要写更多的函数, 比如swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 函数:
<pre><code>
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>
你可能注意到了,swapTwoInts(_:_:), swapTwoStrings(_:_:), 和 swapTwoDoubles(_:_:) 的函数体是一样的。唯一不同的是它们接受的值的类型 (Int, String, 和 Double).

写一个可以交换任何类型值的函数,可能更有用和灵活。泛型代码让你可以写出这种函数。(这些函数的泛型版本会在下面定义。)

备注

在所有三个函数中, 重要的是a和b的类型要一样。如果a和b的类型不一样, 就不可能交换它们两个的值。 Swift 是一门类型安全的语言, 不允许把一个字符串和浮点数进行交换。如果这样做,会报一个编译期错误。

# 泛型函数

泛型函数可以使用任何类型。这里有一个上面 swapTwoInts(_:_:)函数的泛型版本 swapTwoValues(_:_:):
<pre><code>
func swapTwoValues<t>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</t></code></pre>
swapTwoValues(_:_:) 函数体和 swapTwoInts(_:_:) 函数体是一样的。不过, swapTwoValues(_:_:) 函数第一行跟swapTwoInts(_:_:) 稍微有点不一样。下面是第一行的比较:
<pre><code>
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<t>(_ a: inout T, _ b: inout T)
</t></code></pre>
泛型版本的函数用了一个占位符类型名(这里叫T) ,而不是使用实际的类型名 (比如 Int, String, 或者 Double). 这个占位符类型名不说T是到底是什么, 但是它表明a和b是同样的类型 T, 无论T表示什么。每次swapTwoValues(_:_:)函数调用的时候,再决定T是什么类型。

其他的不同是泛型函数名后面跟着一个T包括在尖括号中 (<t>). 括号告诉 Swift ,T 在 swapTwoValues(_:_:) 函数定义中是一个占位符类型名。因为 T 是一个占位符, Swift 不能找到真正的类型 T.

现在可以像调用swapTwoInts一样调用 swapTwoValues(_:_:) 函数, 不过你可以传入两个任何类型的值, 只要两个值的类型是一样的。每次调用 swapTwoValues(_:_:), T的类型会从传入的值的类型推断出来。

下面两个例子里, T 分别推断为整型和字符串类型:
<pre><code>
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>
备注

上面定义的 swapTwoValues(_:_:) 函数是受到Swift 标准库函数swap的启发。它可以在你的应用里直接使用。如果你需要 swapTwoValues(_:_:) 函数的功能, 你可以使用 Swift 已存在的 swap(_:_:) 函数而不用自己重新实现。

# 类型参数

上面的 swapTwoValues(_:_:) 例子, 占位符类型 T 是类型参数的例子。类型参数指定和命名一个占位符类型, 直接写在函数名的后面, 在一对尖括号里面 (例如 <t>).

只要你指定了一个类型参数, 你就可以用它来定义一个函数的参数类型 (例如 swapTwoValues(_:_:) 函数里的a和b), 或者作为函数的返回值类型, 或者在函数体中用作一个类型注释。每种情况下, 函数调用时,类型参数会被真实的类型替换。

你可以在尖括号里写上多个类型参数,来提供更多的类型参数。用逗号分开就行。

# 命名类型参数

在大多数情况下, 类型参数有描述性的名字, 例如 Dictionary<key, value=""> 中的Key 和 Value , Array<element>里的Element, 它会告诉读者类型参数和泛型类型或者所在函数的关系。不过, 当它们之间没有一个有意义的关系时, 通常做法是用单个字母来给它们命名,比如 T, U, 和 V, 比如上面 swapTwoValues(_:_:) 函数中的T。

备注

用驼峰式方法给参数类型命名来表明它们是一个占位符类型,而不是一个值。(例如 T 和 MyTypeParameter).

# 泛型类型

除了泛型函数, Swift 也可以定义泛型类型。它们是可以使用任何类型的类,结构体和枚举。跟数组和字典有着相似的方式。

这部分内容展示如何写一个泛型集合 Stack. 栈是有序集合, 跟数组类似, 但是操作更加严格。数组允许任何位置的项的插入和移除。栈只允许在集合尾部添加 (压栈)。类似的, 栈只允许项目从集合尾部移除 (出栈)。

备注

UINavigationController 使用栈来模拟在导航层次中的视图控制器。调用 UINavigationController 的 pushViewController(_:animated:) 方法在导航栈上添加一个视图控制器, 调用 popViewControllerAnimated(_:) 方法从导航栈上移除一个视图控制器。如果你要一个后进先出的方式来管理集合,栈可以派上用场。

下面的图展示了栈的压栈和出栈的行为:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png">
</div>
当前栈上有三个值。第四个值添加到栈顶。现在栈内有四个值, 最近的值在最上面。
栈顶的值被移除或者出栈。弹出一个值后, 栈内现在再次是三个值。
这里有个非泛型版本的栈, 针对的是整型值的情况:
<pre><code>
struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
</code></pre>
这个结构体使用数组属性items来保存栈内的值。IntStack 提供了两个方法, push 和 pop, 用来压栈和出栈。这两个方法都是 mutating, 因为它们要改变结构体的 items 数组。

IntStack 类型只能用于整数, 不过。如果能定义一个泛型栈类可能会更有用, 它可以管理任何类型值。

Here’s a generic version of the same code:
<pre><code>
struct Stack<element> {
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
</element></code></pre>
注意,事实上泛型版本的栈和非泛型的版本很像, 只不过有一个类型参数 Element 取代了实际类型 Int. 这个类型名写在结构体名的后面,放在一对尖括号里面(<element>).

Element 是一个占位符的名字。这个未来类型可以在结构体定义中作为元素使用。在这种情况下, Element 在三个地方用作占位符:

创建一个属性items, 它是用Element 类型值来初始化的空数组。
指定 push(_:) 方法有一个参数 item, 类型是 Element
指定 pop() 方法的返回值,类型是 Element
因为它是一个泛型类型, Stack可以用来创建Swift中任何有效的类型的栈, 跟字典和数组的用法类似。

在方括号里写上栈存储类型来创建一个新的 Stack 实例。例如, 创建一个字符串的栈, 这样写 Stack<string>():
<pre><code>
var stackOfStrings = Stack<string>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 这个栈现在有4个字符串
</string></code></pre>
下面是压入四个值之后stackOfStrings 变化:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png">
</div>
从栈中移除一个值并且返回栈顶的值, "cuatro":
<pre><code>
let fromTheTop = stackOfStrings.pop()
// fromTheTop 等于 "cuatro", 现在栈内有3个字符串
</code></pre>
下面的弹出一个值后栈的变化:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png">
</div>
# 扩展泛型类型

当你扩展一个泛型类型, 你不需要在扩展定义中提供一个类型参数列表。相反, 原类型定义的类型参数列表可以在扩展内部使用, 并且,使用原类型类型参数名在原来的定义中调用类型参数。

下面的例子扩展了泛型 Stack 类型,添加了一个只读计算属性 topItem, 它返回栈顶元素,而且不用弹出这个元素:
<pre><code>
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>
topItem 属性返回可选的Element 类型值。如果栈是空的, topItem 返回nil; 如果栈非空, topItem 返回items数组最后一个值。

注意,这个扩展没有定义类型参数列表。相反, Stack 类型已存在的类型参数名, Element, 在扩展内部使用来表示topItem 是一个可选类型。

计算属性topItem 现在可以使用 Stack 实例来访问栈顶的元素,而不用去移除它:
<pre><code>
if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// 打印 "The top item on the stack is tres."
</code></pre>
# 类型限制

swapTwoValues(_:_:) 函数和 Stack 类型可以使用任意类型。不过, 有时候对使用泛型函数和类型的类型使用限制是有用的。 类型限制指定一个类型参数必须继承自一个类,或者符合一个协议或者协议组合。

例如, Swift的字典类型对可以用作键的类型进行了限制, 字典的键类型必须是可哈希的。就是说, 它必须提供一个方法让自己独一无二。 字典需要键可哈希,为了判断特定键是否包含了一个值。如果没有这个要求, 字典就不能判断是否可以对一个键插入或者修改一个值。也不能通过给定的键找到一个值。

字典的键类型,这个需求是类型限制强制的。它规定键类型必须符合 Hashable 协议, 它定义在Swift 标准库中。Swift 的所有基本类型默认都是可哈希的。

创建泛型类型时,你可以定义自己的类型限制。这些限制提供泛型编程大部分能力。诸如哈希特性类型的抽象概念,依据的是它们概念性的特征而不是它们的显式类型。

# 可续限制语法

通过在类型参数名后放置一个单独的类或者协议,然后用冒号分开,来写类型限制。泛型函数的类型限制的基本语法显示如下:
<pre><code>
func someFunction<t: someclass,="" u:="" someprotocol="">(someT: T, someU: U) {
    // function body goes here
}
</t:></code></pre>
上面的假想函数有两个参数。第一个类型参数, T, 类型限制是要求T是 SomeClass 的子类。第二个类型参数, U, 类型限制是要求U符合 SomeProtocol 协议。

# 类型限制的行为

这里有一个非泛型的函数findIndex(ofString:in:), 它有一个查找的字符串值和待查找的字符串数组。findIndex(ofString:in:) 函数返回一个可选的整数值。它是数组中第一个匹配字符串的索引, 如果找不到就返回nil:
<pre><code>
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>
findIndex(ofString:in:) 函数可以用来在字符串数组查找一个字符串:
<pre><code>
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findIndex(ofString: "llama", in: strings) {
    print("The index of llama is \(foundIndex)")
}
// 打印 "The index of llama is 2"
</code></pre>
这种查找字符串的方式只对字符串有用, 不过。 你可以写一个泛型函数来处理其他类型。

这里有一个你期待的泛型版本的 findIndex(ofString:in:)函数, 叫 findIndex(of:in:). 注意,函数返回值仍然是 Int?, 因为函数返回的是可选的索引值, 不是来自数组的可选值。 不过这个函数不能编译, 原因在这个例子后面再解释:
<pre><code>
func findIndex<t>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</t></code></pre>
上面的函数不能编译。问题在于等号判断, “if value == valueToFind”. 不是所有在Swift中的类型都可以用等号进行比较的。如果你创建自己的类或者结构体来表示一个复杂的数据模型, 这个类或者结构体‘等于’的意思不是Swift能够理解的。因为这个原因, 它不能保证这个代码对各种可能的T类型都有效, 当你尝试编译这个代码的时候,就会报错。

不过,没有任何损失。Swift 标准库定义了一个协议 Equatable, 它要求符合类型实现等于和不等于,来比较这个类型的任意两个值。所有 Swift 的标准类型都自动支持这个协议。

任何可以比较的类型都可以安全的使用 findIndex(of:in:) 函数, 因为它保证支持等于运算符。为了说明这个事实, 在你定义函数时,你可以在类型参数定义的时候写一个Equatable类型限制:
<pre><code>
func findIndex<t: equatable="">(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</t:></code></pre>
findIndex(of:in:) 的参数类型写作 T: Equatable, 意思是 “符合Equatable 协议的任意 T 类型。”

限制 findIndex(of:in:) 函数编译成功了,然后可以使用任意可以比较的类型, 例如 Double 或者 String:
<pre><code>
let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"])
// stringIndex is an optional Int containing a value of 2
</code></pre>
# 关联类型

当定义一个协议的时候, 有时候声明一个或者多个关联类型是很有用的。一个关联类型给一个类型提供一个占位符名。关联类型使用的实际类型只要协议被采用才会指定。关联类型使用associatedtype 关键字来指定。

# 关联类型的行为

这里有个Container协议的例子, 它声明了一个关联类型 ItemType:
<pre><code>
protocol Container {
    associatedtype ItemType
    mutating func append(_ item: ItemType)
    var count: Int { get }
    subscript(i: Int) -> ItemType { get }
}
</code></pre>
Container 协议定义了任何容器必须提供的三个必须的能力:

它必须要可以用append(_:)方法给容器添加新项目。
它必须可以通过count属性访问容器中项目的数量。
它必须可以通过下标运算获取到容器的每一项。
这个协议没有指定怎么存储项目或者它允许的类型。这个协议只是指定了任何符合类型要提供的三个功能。一个符合类型可以提供额外的功能, 只要它满足三个必须要求。

任何符合 Container 协议的类型必须能够指定它存储值的类型。特别是, 它必须确保只有正确的类型才可以添加到容器, 它必须清楚下标返回的项目的类型。

为了定义这三个必须要求, Container 协议需要一个方法去调用容器将要装载的元素类型, 不用知道特定容器类型是什么。Container 协议需要指定,传入append(_:) 方法的值必须和容器里的元素类型一样。容器下标返回的值的类型也要和容器里的元素类型一样。

为了实现这点, Container 协议定义了一个关联类型 ItemType, 写作 associatedtype ItemType. 协议没有定义 ItemType是什么—这个留给符合类型来提供。 尽管如此, ItemType 别名提供了一种方式来调用容器里的元素类型, 为了使用 append(_:) 方法和下标定义了一个类型。以确保任何容器期望的行为被执行。

这里是早前非泛型版本的 IntStack 类型, 采用和符合了 Container 协议:
<pre><code>
struct IntStack: Container {
    // original IntStack implementation
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Int {
        return items[i]
    }
}
</code></pre>
IntStack 类型实现了 Container 协议要求的三个功能。

此外, IntStack 指定,为了实现 Container, 关联 ItemType 使用Int类型。typealias ItemType = Int 定义,为Container 协议的实现,把抽象类型转换为实际的Int类型。

由于 Swift 的类型推断, 实际上你不需要声明ItemType 为Int. 因为 IntStack 符合 Container 协议所有的要求, Swift 可以推断使用的关联类型 ItemType, 只要简单查找 append(_:) 方法的参数类型和下标的返回类型。事实上, 如果你删除上面的 typealias ItemType = Int, 一切都正常, 因为它知道什么类型用于 ItemType.

你也可以让你泛型版本的 Stack 类型来符合 Container 协议:
<pre><code>
struct Stack<element>: Container {
    // original Stack<element> implementation
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Element {
        return items[i]
    }
}
</element></element></code></pre>
这一次, 类型参数 Element 用作 append(_:) 方法的参数类型和下标的返回类型。Swift 可以推断 Element 是关联类型, 在特定容器用作ItemType.

# 扩展存在的类型去指定关联类型

你可以扩展存在的类型去符合一个协议。这个包含带有关联类型的协议。

Swift 的数组类型已经提供了append(_:)方法, 一个count 属性, 和一个带有索引获取元素的下标。这三个能力满足 Container 协议的要求。这个意味着你可以扩展数组来符合 Container 协议。使用空扩展即可实现这个:
<pre><code>
extension Array: Container {}
</code></pre>
数组存在的 append(_:) 方法和下标让 Swift 可以推断使用ItemType的关联类型, 和上面的泛型 Stack 类型一样。扩展定义后, 你可以把数组当成 Container 使用。

# 泛型 Where 子句

类型限制, 让你在使用泛型函数或者类型时,可以在类型参数上定义需求。

给关联类型定义需求也是有用的。可以通过定义一个泛型where子句实现。 一个泛型wheare子句,让你可以要求关联类型必须符合一个协议, 或者特定类型参数和关联类型必须一样。一个泛型where子句以where关键字开始, 后面是关联类型的限制或者是类型和关联类型的相等关系。泛型where子句写在类型或者函数体花括号的前面。

下面的例子定义了一个泛型函数 allItemsMatch, 用来判断两个容器实例是否有相同顺序的相同元素。这个函数返回一个布尔值,如果所有元素都满足条件就返回 true 否则返回 false.

待比较的两个容器不需要是相同类型, 但是它们要有相同类型的元素。通过类型限制的组合跟一个泛型where子句来表示这第一点:
<pre><code>
func allItemsMatch<c1: container,="" c2:="" container="">
    (_ someContainer: C1, _ anotherContainer: C2) -> Bool
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {

        // Check that both containers contain the same number of items.
        if someContainer.count != anotherContainer.count {
            return false
        }

        // Check each pair of items to see if they are equivalent.
        for i in 0..<somecontainer.count {="" if="" somecontainer[i]="" !="anotherContainer[i]" return="" false="" }="" all="" items="" match,="" so="" true.="" true="" <="" code=""></somecontainer.count></c1:></code></pre>
这个函数有两个参数 someContainer 和 anotherContainer. someContainer 参数类型是 C1, anotherContainer 参数类型是 C2.  C1 和 C2 是两个容器类型的类型参数,在函数调用的时候确定实际类型。

函数的两个类型参数要求如下:

C1 必须符合 Container 协议 (写作 C1: Container).
C2 也必须符合 Container 协议 (写作 C2: Container).
C1 的 ItemType 必须和C2的 ItemType 一样 (写作 C1.ItemType == C2.ItemType).
C1的 ItemType 必须符合 Equatable 协议 (写作 C1.ItemType: Equatable).
第一第二个要求定义在函数的类型参数列表里, 第三第四的要求定义在函数的泛型where子句中。

这些要求的意思是:

someContainer 是类型为C1的容器。
anotherContainer 是类型为C2的容器。
someContainer 和 anotherContainer 包含类型相同的元素。
someContainer 中的元素可以用不等于判断,看它们是否彼此不同。
第三第四个要求合并意思是, anotherContainer中的元素也可以用不等于判断, 因为它和someContainer 有着相同类型的元素。

allItemsMatch(_:_:) 函数的这些要求使得它可以用来比较两个容器, 即使它们是不同的容器类型。

allItemsMatch(_:_:) 函数一开始判断两个容器是否含有相同数量的元素。如果它们包含的元素的个数不一样, 它们就无法比较,函数返回false.

这个判断满足后, 函数使用for-in循环和半开区间运算符遍历someContainer中所有的元素。对于每个元素来说, 函数判断someContainer 的元素是否不等于anotherContainer 中对应的元素。如果两个元素不同, 说明两个容器不一样, 函数返回 false.

如果循环结束没有发现不匹配, 说明这两个容器是匹配的, 函数返回true.

Here’s how the allItemsMatch(_:_:) function looks in action:
<pre><code>
var stackOfStrings = Stack<string>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    print("All items match.")
} else {
    print("Not all items match.")
}
// 打印 "All items match."
</string></code></pre>
上面的例子创建了一个 Stack 实例来保存字符串, 然后把三个字符串压入栈。这个例子同时也创建了一个数组实例,它用和栈内容一样的字面量来初始化。尽管栈和数组是不同的类型, 不过它们都符合 Container 协议, 然后都包含相同类型的值。所以使用这两个容器作为参数,来调用 allItemsMatch(_:_:) 函数。在上面的例子里, allItemsMatch(_:_:) 函数正确的显示出两个容器中的所有元素都是匹配的。

# 访问控制
访问控制可以让限制其他资源文件和模块访问你的代码块。这个特性可以确保你隐藏代码实现的细节。然后指定一个首选的接口,通过它可以访问和使用代码。

你可以针对单个类型指定访问级别 (类, 结构体和枚举), 像属于这些类型的属性,方法,构造器和下标一样。协议可以限制到特定的上下文, 全局常量,变量和函数也可以。

除了提供多个级别的访问控制, 通过为特殊场景提供默认访问级别, Swift 减少指定显式访问控制级别的需要。事实上, 如果你写的是单一目的的应用, 你根本不需要指定显式访问控制级别。

备注

你的代码大部分可以使用访问控制 (属性, 类型, 函数等) ,它们被作为 “entities” 在下面部分引用, 为了简洁。

# 模块和源文件

Swift 的访问控制模型基于模块和源文件的概念。

一个模块是单独的代码分发单元—作为单独单元构建和传输的框架或者程序, 可以用Swift 的import 关键字被其他模块引入。 

在Swift里,用Xcode 构建的每个目标都被作为单独的模块。 (例如应用的bundle或者框架)。如果你把代码组合成一个标准的独立框架—通过多个应用封装和重用这个代码—当它引入和用于一个应用时, 框架里定义的所有都会是独立模块的一部分。或者当它用在其他框架里的时候。

Swift里的源文件指的是模块中的源代码文件。尽管通常做法是在不同的源文件中定义独立的类型。一个单独的源文件可以定义多个类型,函数等等。

# 访问级别

Swift 为你的代码实体提供了五个不同的访问级别。这些访问级别和实体所在的源文件相关。同时也和源文件所属模块相关。

Open 访问和 public 访问让实体可以在任何定义它们的模块的源文件中使用, 也可以在引入该定义模块是其他模块的源文件中使用。当框架指定了pulic接口时,你就可以使用 open 或者 public 访问。open 和 pulic访问的不同下面会描述。
Internal 访问让实体可以在任何定义它们的模块的源文件中使用, 但是不能在该模块之外的源文件里使用。当定义一个应用的内部结构体或者框架的内部结构体时,你可以使用internal 访问。
私有文件访问只允许实体在自己定义的源文件中使用。使用私有文件访问隐藏了某个功能的实现细节。
私有访问限制实体在封闭声明时使用。当某个功能实现细节用在单独声明时,使用私有访问来隐藏这些细节。
Open 是最高级别的访问权限, 私有访问是最低级别的访问权限。

Open 访问只适用于类和类的成员, 它跟public 访问不同之处如下:

带有public访问权限的类, 或者任何更严格的访问级别, 只能在它们定义的模块里子类化。
带有public访问权限的类成员, 或者任何更严格的访问级别, 只能在它们定义的模块里,被子类重写。
Open 类可以在它们定义的模块中被子类化, 引入该模块的其他任意模块也可以。
Open 类可以在它们定义的模块中被子类重写, 引入该模块的其他任意模块也可以。
让一个类显式open表明, 你可以考虑到了来自其他模块的代码影响,这个模块使用这个类作为一个子类。你也相应的设计了自己的类的代码。

# 访问级别的指导原则

Swift 中的访问级别遵守统一的指导原则: 实体不可以定义成另一种低级别的实体。

# 例如:

一个 public 变量不能定义成internal, file-private, 或者 private 类型, 因为这个类型不能像pulic变量一样到处使用。
一个函数不能有比它的参数类型和返回类型更高的访问级别。因为函数不能用在它的组合类型不适用于周围代码的地方。

# 默认访问级别

如果你没有指定显式的访问级别,所有的代码中的实体会有一个默认的内部访问级别。这样做的结果是, 大多数情况下,你都不需要指定一个显式的访问级别。

# 单目标应用的访问级别

在你写一个单目标的应用的时候, 你的程序代码通常自包含在应用里,不需要给模块外部使用。默认的内部访问级别已经满足要求。因此, 你无需指定一个自定义的访问级别。不过你可能想把部分代码标记成 file private 或者 private,为了因此内部实现细节。

# 框架访问级别

当你开发一个框架的时候, 把对外的接口标记为 open 或者 public,这样它就可以被其他模块看到和访问, 比如引入这个框架的应用。 对外公开的接口是框架的API.

备注

框架的所有内部实现细节依然可以使用默认的内部访问级别, 如果想对框架内部其他代码隐藏实现细节,可以标记为 private 或者 file. 如果你想让它成为框架的API,你就需要把实体标记为 open 或者 public.

# 单元测试目标的访问级别

当你用单元测试目标写应用的时候, 你的代码需要对这个模块可用,为了能够测试。默认情况下, 只有标记为 open 或者 public 的实体才可以被其他模块访问。不过, 如果你使用@testable属性为产品模块标记引入声明并且使用可测试编译产品模块,单元测试目标可以访问任意内部实体。

# 访问控制语法

通过在实体前放置 open, public, internal, fileprivate, 或者 privateDefine 修饰符来给实体定义访问级别:
<pre><code>
public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}
</code></pre>
除非另有说明, 默认访问级别都是内部的。也就说说 SomeInternalClass 和 someInternalConstant 即使不写访问级别修饰符, 它们依然有内部访问级别:
<pre><code>
class SomeInternalClass {}              // implicitly internal
let someInternalConstant = 0            // implicitly internal
</code></pre>
# 自定义类型

如果你想给一个自定义类型指定显式的访问级别, 在定义类型的时候指定。在访问级别允许的地方,新类型可以随便使用。例如, 如果你定义了一个 file-private 的类, 这个类只能用作属性的类型,函数的参数或者返回类型, 而且只能在类定义的源文件中。

一个类型的访问控制级别同样影响这个类型成员的默认访问级别 (它的属性,方法,构造器和下标)。如果类型的访问级别是 private 或者 file private, 它的成员的默认访问级别也将是 private 或者 file private. 如果类型的访问级别是 internal 或者 public, 它的成员的默认访问级别将会是 internal.

重要

一个 public 类型默认有 internal 成员, 而不是public 成员。如果你要成员也是 public, 你必须显式标记。这个可以保证发布的API是你想要发布的, 避免内部使用的代码作为API发布的错误。
<pre><code>
public class SomePublicClass {                  // explicitly public class
    public var somePublicProperty = 0            // explicitly public class member
    var someInternalProperty = 0                 // implicitly internal class member
    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member
    private func somePrivateMethod() {}          // explicitly private class member
}

class SomeInternalClass {                       // implicitly internal class
    var someInternalProperty = 0                 // implicitly internal class member
    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member
    private func somePrivateMethod() {}          // explicitly private class member
}

fileprivate class SomeFilePrivateClass {        // explicitly file-private class
    func someFilePrivateMethod() {}              // implicitly file-private class member
    private func somePrivateMethod() {}          // explicitly private class member
}

private class SomePrivateClass {                // explicitly private class
    func somePrivateMethod() {}                  // implicitly private class member
}
</code></pre>
# 元组类型

元组类型的访问级别是元组里类型中最严格的那个。例如, 如果你用两个不同的类型组成一个元组, 一个用 internal 访问,另外一个用 private 访问, 那么元组的访问级别会是 private.

备注

元组不像类,结构体和函数那样有独立的定义方式。一个元组类型的访问级别在定义时自动推断,不需要显式指定。

# 函数类型

函数的访问级别要计算参数和返回类型中最严格的。如果函数计算的访问级别不符合上下文的默认情况,你就要在定义函数时显式指定。

下面的例子定义了一个全局函数 someFunction(), 没有提供一个特定的访问级别修饰符。你可能希望函数有默认的 “internal”的访问级别, 但是情况不是这样。事实上, 下面的写法,someFunction() 将不能编译:
<pre><code>
func someFunction() -> (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre>
函数的返回值是由两个自定义类组合成的元组。一个类定义成 “internal”, 另外一个类定义成 “private”. 因为, 元组类型的访问级别是 “private” .

因为这个函数的返回类型是 private, 为了函数声明的有效性,你必须标记整个函数的访问级别是 private modifier:
<pre><code>
private func someFunction() -> (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre>
用public或者internal 修饰符标记 someFunction() 是无效的, 使用默认的internal也没有用, 因为函数的 public 或者 internal 用户可能没有权限访问用在函数返回类型的私有类。

# 枚举类型

枚举的每个case 都会自动获得和枚举一样的访问级别。你不能给单独的case指定访问级别

在下面的例子里, CompassPoint 枚举有一个显式的访问级别 “public”. 枚举的 cases north, south, east, 和 west 的访问级别因此也是 “public”:
<pre><code>
public enum CompassPoint {
    case north
    case south
    case east
    case west
}
</code></pre>
# Raw 值和关联类型

枚举中所有 raw 值和管理类型用到的类型访问级别至少要和枚举一样高。如果枚举访问级别是internal,raw 值的访问级别就不能是private.

# 嵌套类型

在private中定义的嵌套类型访问级别自动为 private. 在 file-private 中定义的嵌套类型访问级别自动为 file private. 在public或者internal中定义的嵌套类型访问级别自动为 internal. 如果想让在public 中定义的嵌套类型成为public, 你必须显式声明。

# 子类化

你可以子类化任何可以在当前上下文中访问中的类。子类的访问级别不能高过超类—例如, 不能给internal超类写一个public的子类。

除此之外, 你可以重写在特定上下文可见的类成员 (方法,属性,构造器和下标)。

重写的类成员比超类更容易访问。在下面的例子里, A 是一个 public 类,有一个 file-private 方法 someMethod(). B 是A的子类, 访问级别是 “internal”. 尽管如此, B 提供了一个重写的 someMethod(),它的访问级别是 “internal”, 比超类版本的方法级别要高:
<pre><code>
public class A {
    fileprivate func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {}
}
</code></pre>
甚至,子类成员可以调用超类成员,即使超类成员的访问级别低于子类成员, 只要访问发生在允许访问的上下文中:
<pre><code>
public class A {
    fileprivate func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
</code></pre>
因为超类 A 和子类 B 在同一个源文件里定义, B 的 someMethod()方法可以有效调用 super.someMethod().

# 常量,变量,属性和下标

一个常量,变量,属性或属性不能比它的类型更 public. 用private类型来写一个public属性是无效的。相似的, 一个下标不能比它的索引和返回类型更public.

如果一个常量,变量,属性或者下标使用 private 类型, 这个常量,变量,属性或者下标也必须标记为 private:
<pre><code>
private var privateInstance = SomePrivateClass()
</code></pre>
# Getters 和 Setters

常量,变量,属性和下标的Getters 和 setters 自动和它们所属的常量,变量,属性和下标的访问的级别一样。

你可以给 setter 比对应getter 更低的访问级别, 来限制变量,属性或者下标读写的范围。通过写 fileprivate(set), private(set), 或者 internal(set)来指定访问级别。

备注

这个规则适用于存储属性和计算属性。尽管你没有为一个存储属性写显式的 getter 和 setter, Swift 仍然会合成一个隐式的 getter 和 setter, 用来访问存储属性的备份存储。用 fileprivate(set), private(set), 和 internal(set) 来改变这个合成setter的访问级别, 跟计算属性的显式setter使用的方法完全一样。

下面的例子定义了一个结构体 TrackedString, 用来跟踪一个字符串属性改变的次数:
<pre><code>
struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
}
</code></pre>
TrackedString 结构体定义了一个存储字符串属性 value, 初始值为空。这个结构体同时定义了存储整型属性 numberOfEdits, 它用来跟踪value被改变的次数。通过在value属性上使用didSet属性观察者来实现跟踪。每次value属性设置新值的时候,它就把 numberOfEdits 值加1.

TrackedString 结构体和 value 属性没有显式提供访问级别修饰符, 所以它们默认的访问级别是 internal. 不过, numberOfEdits 属性的访问级别标记为 private(set),表明这个属性的 getter的访问级别仍然是 internal, 但是这个属性只能在结构体实现的代码里使用 setter. 这使得 TrackedString 可以在内部修改 numberOfEdits 属性, 但是也表示这个属性对于外部代码来说是只读的—包括 TrackedString 的扩展。

如果你创建一个 TrackedString 实例然后修改它的字符串 value 值几次, 你会看到 numberOfEdits 属性值随着变化次数一起更新:
<pre><code>
var stringToEdit = TrackedString()
stringToEdit.value = "This string will be tracked."
stringToEdit.value += " This edit will increment numberOfEdits."
stringToEdit.value += " So will this one."
print("The number of edits is \(stringToEdit.numberOfEdits)")
// 打印 "The number of edits is 3"
</code></pre>
尽管你可以在其他源文件查询 numberOfEdits 属性的当前值, 但是你不能进行修改。这个限制保护结构体编辑跟踪功能的实现细节。
如果需要,你可以给getter和setter方法指定显式的访问级别。下面的例子把TrackedString 定义成public.因此结构体的成员默认的访问级别是 internal. 你可以设置 numberOfEdits 属性的 getter 是 public的, 它的属性 setter 是 private的, 通过合并 public 和 private(set) 的访问修饰符:
<pre><code>
public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
    public init() {}
}
</code></pre>
# 构造器

自定义构造器可以指定一个访问级别,这个级别小于或者等于它构造的类型。唯一的区别是必须的构造器。一个必须构造器访问级别必须跟它所属的类一致。

跟函数和方法参数一样, 构造器的参数类型不能比构造器拥有的访问级别更加私有。

# 默认构造器

就像默认构造器中描述的那样, Swift 会自动为所有结构体或者基类提供一个没有参数的默认构造器,这些结构体或者基类给所有属性提供了默认值,但是没有提供任何的构造器。

默认构造器的访问级别和它要构造的类型是一样的, 除非这个类型定义为 public. 对于定义为public的类型来说, 默认构造器访问级别是 internal. 在其他模块使用时,如果你想用无参数的构造器来构造 public 类型, 你必须显式定义一个 public 无参数构造器。

# 结构体类型的默认成员构造器

如果结构体的存储属性是private的,结构体的默认成员构造器就是 private的。同样的, 如果结构体任意一个存储属性是file private, 构造器也是 file private. 否则, 构造器的访问级别是 internal.

和上面的默认构造器一样, 在其他模块使用时, 如果你想用一个成员构造器来构造一个 public 类型的话, 你必须提供一个public成员构造器。

# 协议

如果你想要给一个协议类型指定一个显式的访问级别, 就在协议定义的时候这么做。这个可以让你创建协议, 这个协议只能在某些允许访问的上下文中采用。

协议定义中每个需求的访问级别和协议的访问级别是一样的。你不能把需求设置成协议不支持的访问级别。这可以保证采用协议的类型可以看见所有的需求。

备注

如果你定义了一个 public 协议, 协议的需求实现时要求一个 public 访问级别。这个行为不同于其他类型, public 类型定义意味着类型成员的访问级别是 internal.

# 协议继承

如果定义了一个新协议,它继承自一个存在的协议, 新协议的访问级别最多和继承协议的级别一样。例如, 已存在的协议访问级别是internal, 你写的新协议却是是 public.

# 协议一致性

一个类型可以符合一个访问级别比自己低的协议。例如, 你可以定义一个 public 类型用在其他模块里。如果它符合一个 internal 协议,就只能用在 internal 协议的定义模块内。

一个类型符合某个协议的上下文,访问级别是这个类型和协议中最小的一个。如果一个类型是 public, 但是协议是 internal, 这个类型的一致性协议也是 internal.

一个类型符合一个协议或者扩展符合一个协议,你必须确保类型对协议需求的实现,至少和类型的一致性协议有一样的访问级别。例如, 如果一个public 类型符合一个 internal, 这个类型实现的协议需求必须是 “internal”.

备注

在 Swift 里, 跟在 Objective-C里一样, 协议一致性是全局的—不可能在同样的程序里,类型以两种不同的方式来符合一个协议。

# 扩展

你可以在任何访问权限的上下文中扩展一个类,结构体或者枚举。扩展中添加的类型成员和被扩展类型中声明的类型成员有着一样的访问级别。如果你扩展一个 public 或者 internal 类型, 你添加的任何类型成员默认访问级别是 internal. 如果你扩展一个 file-private 类型, 你添加的所有类型成员的访问级别都是file private. 如果你扩展一个 private 类型, 你添加的任何类型成员访问级别都是 private.

另外, 你可以用显式访问级别修饰符来标记一个扩展,来为定义在扩展里的所有的成员设置一个新的默认访问属性。单个类型成员的扩展里依然可以重写这些新的默认级别。 

# 使用扩展添加协议一致性

如果你用扩展来添加协议一致性,你就不能为扩展提供一个显式的访问级别修饰符。相反, 协议自己的访问级别,通常用来为在扩展中实现的协议需求提供默认访问级别。

# 泛型

泛型类型和泛型函数的访问级别, 是它们自身的访问级别和它们的类型参数的任何类型限制的访问级别之间最小的那个。 

# 类型别名

你定义的所有类型别名,因为访问控制的目的,会被看做是不同的类型。一个类型别名的访问级别小于或者等于这个类型。例如, 一个private 类型的别名可以是一个 private, file-private, internal, public, 或者 open type的别名, 但是一个 public 类型别名不能是一个 internal, file-private, 或者 private 类型的别名。

#备注

这个规则也适用于用来满足协议一致性的关联类型的类型别名。

# 高级运算符
除了基本运算符之外, Swift 提供了一些高级运算符来进行更复杂的值操作。包括位和位移运算符。

跟C的算术运算符不同, Swift 的算术运算符默认不会溢出。溢出会被捕获和报错。 选择溢出行为, 使用 Swift 的溢出算术运算符, 例如溢出加运算符 (&+). 所有溢出算术运算符都是以 (&)开始。

当你定义结构体,类和枚举的时候, 为这些自定义类型实现自己的标准Swift运算符是很有用的。Swift 让提供这些实现变得容易,并且能精确决定每种类型的行为。

你不会被限定在预置运算符上。Swift 给你足够的自由,用自定义的优先级和指定值,来定义你自己的中缀,前缀,后缀和赋值运算符。这些运算符的用法和预置运算符一样, 你甚至可以扩展已存在的类型来支持自定义的运算符。

# 位运算符

位运算符可以操作数据结构里的单个数据位。它们通常用于低级别编程, 例如图形编程和设备驱动编写。使用外部资源数据时,位运算符也很有用, 例如编解码数据。

Swift 支持C中所有的位运算符, 描述如下。

# 位 NOT 运算符

位 NOT 运算符 (~) 把所有位转换成一个数:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseNOT_2x.png">
</div>
位 NOT 运算符是一个前缀运算符, 直接出现在操作数的前面, 没有空格:
<pre><code>
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // 等于 11110000
</code></pre>
UInt8 整数有8位,可以存储0到255之间的任何值。这个例子用二进制值00001111来初始化一个 UInt8 整数, 它的前四位全是0,后四位全是1. 它等于十进制的 15.

位 NOT 运算符用来创建一个新常量 invertedBits, 它等于 initialBits, 不过所有位都是反转的。0变成1, 1变成0.  invertedBits 的值是 11110000, 它等于十进制的 240.

# 位 AND 运算符

位 AND 运算符 (&) 合并两个数的位。它返回一个新的数组,如果两个输入数的位都是1,这个新数的位才是1:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseAND_2x.png">
</div>
在上面的例子里, firstSixBits 和 lastSixBits 中间四位都是 1. 位 AND 运算符合并它们变成 00111100, 它等于十进制的 60:
<pre><code>
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits & lastSixBits  // 等于 00111100
</code></pre>
# 位 OR 运算符

位 OR 运算符 (|) 比较两个数的位。如果两个数任意一个数位为1,这个运算符返回的数位就是1:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseOR_2x.png">
</div>
在上面的例子里, someBits 和 moreBits 不同位设置为 1. 位 OR 运算符合并它们变成 11111110, 它等于一个无符号十进制254:
<pre><code>
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // 等于 11111110
</code></pre>
# 位 XOR 运算符

位 XOR 运算符, 或者 “异或运算符” (^), 比较两个数的位。如果两个数位不同返回1,如果相同则返回0:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseXOR_2x.png">
</div>
<pre><code>
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // 等于 00010001
</code></pre>
# 左右移位运算符

左移位运算符 (<<) 和右移位运算符="" (="">>) 往左或者往右移动数位, 规则如下。

左移位和右移位实际上是乘以或者除以2. 左移一个整数1位相当于乘以2, 而右移一个整数1位相当于除以2.

# 无符号整数移动

无符号整数位移表现如下:

左移或者右移请求数量的位。
超出整数存储范围的移位被舍弃。
左移或者右移后,缺失的位用0填充。
这个方法叫逻辑移位。

下面这个图展示了 11111111 << 1 和 11111111 >> 1 的结果。蓝色数字是要移动的, 灰色数字是要舍弃的, 橙色的0是填充的:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png">
</div>
下面是位移动在Swift 代码里的表现:
<pre><code>
let shiftBits: UInt8 = 4   // 00000100 in binary
shiftBits << 1             // 00001000
shiftBits << 2             // 00010000
shiftBits << 5             // 10000000
shiftBits << 6             // 00000000
shiftBits >> 2             // 00000001
</code></pre>
你可以使用位移动在其他数据类型里进行编解码:
<pre><code>
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16    // redComponent 是 0xCC, 或者 204
let greenComponent = (pink & 0x00FF00) >> 8   // greenComponent 是 0x66, 或者 102
let blueComponent = pink & 0x0000FF           // blueComponent 是 0x99, 或者 153
</code></pre>
这个例子使用了一个 UInt32 类型的常量 pink 来保存粉色的CSS颜色值。CSS 颜色值 #CC6699 十六进制形式写作 0xCC6699. 经过位移 AND (&)和右移运算符（>>）操作, 这个颜色会被分解为 red (CC), green (66), 和 blue (99) .

红色部分通过把数字 0xCC6699 和 0xFF0000进行位AND获取。 0xFF0000 中的0 “掩藏”了 0xCC6699的第二个和第三个字节, 导致 6699 被忽略,只留下 0xCC0000 的结果。

然后把这个数字向右移动16位 (>> 16). 十六进制数字每对字母使用8位, 所以向右移动16位把 0xCC0000 转化为 0x0000CC. 它等于 0xCC, 它的十进制值是 204.

类似的, 绿色部分通过把数字 0xCC6699 和 0x00FF00进行位AND获取, 它的输出值是 0x006600. 然后把输出值向右移动8位 0x66, 它的十进制值是 102.

最后, 蓝色部分通过把数字 0xCC6699 和 0x0000FF进行位AND获取, 它的输出值是 0x000099. 它不需要向右移动, 因为 0x000099 已经等于 0x99, 它的十进制值是 153.

# 有符号整数移动

有符号整数的移动比无符号的要复杂, 因为有符号整数是用二进制表示的(为了简单,下面的例子用8位有符号整数展示, 不过这个原则适用于任何大小的有符号整数。)

有符号整数使用第一个数位来表示正负 (标志位)。 0表示正数, 1表示负数。

剩余位用来存储实际的值。正数的存储和无符号整数的方式是一样的, 从0往上数。这里是4在Int8中的数位的形式:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png">
</div>
标志位是 0 (意思是正数), 7个数值位正好是数字 4, 用二进制符号表示。

负数存储是不同的。它们存储的值是绝对值减去2的n次方。这里n是数值位的数字。一个8位数有7个数值位, 所以2的7次方, 或者 128.

这里是-4在Int8中数位的形式 -4:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png">
</div>
这次符号位是 1 (意思是负数), 七位数值位值是 124 (128 - 4):
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFourValue_2x.png">
</div>
负数编码是一个二进制补码表示。这似乎不是负数的常见表示方法, 但是它有几个优点。

首先, 你可以把-4加-1, 可以进行8位的简单二进制加法 (包括标志位), 完成后舍弃不符合8位的:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png">
</div>
其次, 二进制补码表示让你可以像正数那样移动负数的数位。向左移动后依然会翻倍, 向右移动后会减半。为了实现这个, 当有符号整数向右移动时,使用额外的规则: 当你向右移动有符号整数时, 和无符号整数规则一样, 但是左边空出来的位要用标志位填充, 而不是0.
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png">
</div>
这个行为保证有符号整数向右移动后,有相同的标志位。 也就是算术移位。

由于正负数存储的特殊方式, 向右移动它们接近于0. 移动过程中保持标志位不变,意味着负数在接近0过程中依然是负数。

# 溢出运算符

如果你尝试向一个整数常数或者变量插入无法保存的值, 默认情况下, Swift 会报错而不是允许无效值的创建。当你使用过大或者过小值的时候,这个规则可以提供额外的安全性。

例如, Int16 整数范围是 -32768 到 32767. 尝试存储超过这个范围的数字会导致错误:
<pre><code>
var potentialOverflow = Int16.max
// potentialOverflow equals 32767, which is the maximum value an Int16 can hold
potentialOverflow += 1
// 这个会报错
</code></pre>
当值变的过大或者过小的时候,提供错误处理,在给边界值条件编码时,会更加灵活。

不过, 当你特别想要一个溢出条件来截断可用位数的时候, 你可以选择这个行为而不是触发一个错误。Swift 提供了三个算术溢出运算符,来为整数计算选择溢出行为。这些运算符都以(&)开始:

溢出加 (&+)
溢出减 (&-)
溢出乘 (&*)
# 值溢出

负数和整数都可以溢出。

这里有一个例子,展示当一个无符号整数在正数方向溢出时,会发生什么, 使用的是溢出加运算符 (&+):
<pre><code>
var unsignedOverflow = UInt8.max
// unsignedOverflow 等于 255, 它是UInt8可以保存的最大值
unsignedOverflow = unsignedOverflow &+ 1
// unsignedOverflow 现在等于 0
</code></pre>
变量 unsignedOverflow 使用UInt8 的最大值初始化nt8 (255, 或者 11111111). 然后使用溢出加运算符加1. 这个让它的二进制表示正好超过UInt8可以保存的最大值,这个导致了溢出, 如下表所示。溢出加之后这个值00000000依然在UInt8的界限内。
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png">
</div>
相似的事情会发生在无符号数向负数方向的溢出上。下面是使用了溢出减运算符的例子:
<pre><code>
var unsignedOverflow = UInt8.min
// unsignedOverflow 等于 0, 是UInt8可以保存的最小值
unsignedOverflow = unsignedOverflow &- 1
// unsignedOverflow 现在等于 255
</code></pre>
UInt8可以保存的最小值是0, 或者二进制 00000000. 如果使用溢出减运算符减1, 这个数字会溢出变成 11111111, 或者十进制 255 .
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png">
</div>
溢出也会发生在有符号整数。有符号整数的加减法以位形式执行, 标志位也参与加减。
<pre><code>
var signedOverflow = Int8.min
// signedOverflow 等于 -128, 是Int8可以保存的最小值
signedOverflow = signedOverflow &- 1
// signedOverflow 现在等于 127
</code></pre>
Int8保存的最小值是 -128, 或者二进制 10000000. 使用溢出减减1,结果是 01111111, 它会切换标志位然后得正数 127, 它是Int8可以保存的最大正数值。
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png">
</div>
对于有符号和无符号整数来说, 向正数方向溢出会回到最小值, 向负数方向溢出会回到最大值。

# 优先级和关联性

运算符优先级给一些运算符提供更高的优先级; 这些运算符首先起作用。

运算符关联性确定相同优先级的运算符分组的行为—或者从左边分组, 或者从右边分组。可以这样考虑 “它们关联左边的表达式,” 或者 “它们关联右边的表达式。”

在使用复合表达式计算时,考虑每个运算符的优先级和关联性非常重要。例如, 运算符优先级解释了为什么下面的表达式结果是 17.
<pre><code>
2 + 3 % 4 * 5
// this equals 17
</code></pre>
如果从左到右严格读, 你可能期望表达式按照如下执行:

2 加 3 等于 5
5 除以 4 取余为 1
1 乘以 5 等于 5
不过, 实际结果是 17, 而不是 5. 高优先级的运算符比低优先级运算符先执行。在 Swift 中, 和 C 一样, 取余运算符 (%) 和乘法运算符 (*) 比加法运算符有更高的优先级 (+). 结果就是, 它们都比加法先执行。

不过, 取余和乘法运算符优先级是相同的。为了解决准确的执行顺序, 你也需要考虑它们的关联性。取余和乘法运算符都是关联它们左边的表达式。把它想象为从左边开始,在它们的表达式部分加了一个隐式的括号:
<pre><code>
2 + ((3 % 4) * 5)
(3 % 4) 是 3, 这个等于:

2 + (3 * 5)
(3 * 5) 是 15, 这个等于:

2 + 15
计算结果是 17.
</code></pre>

<p>要查看完整的 Swift 运算符优先级和关联性规则的列表, 参见表达式部分。更多表达式, 参见 Swift 标准库运算符参考。</p>
<p>备注</p>
<p>Swift 的运算符优先级和关联性,比 C 和 Objective-C 中的更加简单和可预测。不过, 这个意味着它们和基于C语言的语言有所不同。在移植代码到 Swift 时,谨慎的确保运算符行为要和你想的一样。</p>
<h1 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h1><p>类和结构体可以为已存在的运算符提供自己的实现。这就是运算符的重载。 </p>
<p>下面的例子展示如何给一个自定义的结构体,实现一个算术加法运算符(+). 算术加法运算符是一个二目运算符,因为它操作两个目标。因为它在两个目标之间,它又是一个中缀运算符。 </p>
<p>下面的例子为一个二维位置向量(x, y)定义了一个 Vector2D 结构体, 后面是一个运算符方法的定义,这个方法把两个 Vector2D 结构体实例进行相加:</p>
<p><pre><code><br>struct Vector2D {<br>    var x = 0.0, y = 0.0<br>}</code></pre></p>
<p>extension Vector2D {<br>    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: left.x + right.x, y: left.y + right.y)<br>    }<br>}<br><br>这个运算符方法定义为Vector2D 的类型方法, 方法名符合重载的(+)运算符。因为加法不是向量本来的行为, 所以这个类型方法定义在结构体的扩展中,而不是主结构中。因为算术加法运算符是二目运算符, 这个运算符方法接受两个Vector2D 类型的参数,然后返回Vector2D 类型的值。</p>
<p>在这个实现里, 输入参数名 left 和 right 表示 Vector2D 实例在 + 运算符的左右两侧。这个方法返回了一个新的 Vector2D 实例, 它的 x 和 y 属性是左右实例 x 和 y 之和。</p>
<p>这个类型方法可以在两个 Vector2D 实例中用作中缀运算符:</p>
<p><pre><code><br>let vector = Vector2D(x: 3.0, y: 1.0)<br>let anotherVector = Vector2D(x: 2.0, y: 4.0)<br>let combinedVector = vector + anotherVector<br>// combinedVector 是一个 Vector2D 实例,值是 (5.0, 5.0)<br></code></pre><br>这个例子把向量 (3.0, 1.0) 和 (2.0, 4.0) 相加得到向量 (5.0, 5.0), 如下图所示。</p>
<p><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/vectorAddition_2x.png"><br></div></p>
<h1 id="前缀和后缀运算符"><a href="#前缀和后缀运算符" class="headerlink" title="前缀和后缀运算符"></a>前缀和后缀运算符</h1><p>上面的例子展示了一个中缀运算符的自定义实现。类和结构体也可以提供标准一元运算符的实现。一元运算符只操作一个目标。如果它在目标前面就是前缀运算符 (例如 -a) ,如果在目标后面就是后缀运算符 (例如 b!).</p>
<p>定义运算符方法的时候,在 func 关键字前写上前后缀修饰符,就可以定义前后缀一元运算符:</p>
<p><pre><code><br>extension Vector2D {<br>    static prefix func - (vector: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: -vector.x, y: -vector.y)<br>    }<br>}<br></code></pre><br>上面的例子给Vector2D 实例实现了一元-运算符。一元-运算符是一个前缀运算符, 所以这个方法使用了前缀修饰符。</p>
<p>对于简单的数值, 一元-运算符把正数变成负数,反之亦然。Vector2D 实例的实现就是对 x 和 y 同时进行操作:</p>
<p><pre><code><br>let positive = Vector2D(x: 3.0, y: 4.0)<br>let negative = -positive<br>// negative is a Vector2D instance with values of (-3.0, -4.0)<br>let alsoPositive = -negative<br>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)<br></code></pre></p>
<h1 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h1><p>复合赋值运算符把=与其他运算合并。例如, 加法赋值运算符合并了加法和赋值到一个单独的操作中。把复合赋值运算符的左边输入参数标记为 inout, 因为这个参数值会在方法内修改。</p>
<p>下面的例子为Vector2D 实例实现了一个加法赋值运算符:</p>
<p><pre><code><br>extension Vector2D {<br>    static func += (left: inout Vector2D, right: Vector2D) {<br>        left = left + right<br>    }<br>}<br></code></pre><br>因为加法运算符早已定义, 这里你不需要替换加法部分。替代的是, 加法赋值运算符方法采用了已经存在的加法运算符方法, 然后把左右值相加赋值给左值:</p>
<p><pre><code><br>var original = Vector2D(x: 1.0, y: 2.0)<br>let vectorToAdd = Vector2D(x: 3.0, y: 4.0)<br>original += vectorToAdd<br>// original now has values of (4.0, 6.0)<br></code></pre><br>备注</p>
<p>不可能重载默认的赋值运算符(=). 只有复合赋值运算符可以重载。相似的, 三元条件运算符 (a ? b : c) 也不能重载。</p>
<h1 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h1><p>自定义的类和结构体没有默认的等式运算符的实现, 也就是(==) 和 (!=). Swift 猜不出来你的自定义类型是否有资格 “等于”, 因为这取决于这些类型在你代码里扮演的角色。</p>
<p>使用等式运算符来判断自定类型的相等, 像其他中缀运算符方法一样提供它的实现即可:</p>
<p><pre><code><br>extension Vector2D {<br>    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {<br>        return (left.x == right.x) &amp;&amp; (left.y == right.y)<br>    }<br>    static func != (left: Vector2D, right: Vector2D) -&gt; Bool {<br>        return !(left == right)<br>    }<br>}<br></code></pre><br>上面的例子实现了“等于” 运算符 (==)来判断两个Vector2D 实例是否有相同值。在 Vector2D 的上下文中, 认为相等就是 “两个实例的x和y值都一样”, 这个就是运算符实现的逻辑。这个例子同时实现了 “不等于” 运算符 (!=), 它只是简单返回了 “等于”的想法结果。</p>
<p>现在你可以使用这些运算符来判断两个 Vector2D 实例是否相等:</p>
<p><pre><code><br>let twoThree = Vector2D(x: 2.0, y: 3.0)<br>let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)<br>if twoThree == anotherTwoThree {<br>    print(“These two vectors are equivalent.”)<br>}<br>// 打印 “These two vectors are equivalent.”<br></code></pre></p>
<h1 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h1><p>除了 Swift 提供的标准运算符,你也可以声明和实现自定义的运算符。</p>
<p>使用 operator 关键字, 用 prefix, infix 或者 postfix标记,新的运算符会定义在全局:</p>
<p><pre><code><br>prefix operator +++<br></code></pre><br>上面的例子定义了一个新的前缀运算符 +++. 这个运算符在Swift中不存在任何意义, 所以在下面使用Vector2D 实例的上下文中,给出了自定义的含义。这个例子的目的是, +++ 是一个新的“前缀双倍” 运算符。它双倍 Vector2D 实例的x和y值, 它使用早前定义的加法赋值运算符,把自己加给自己。为了实现 +++ 运算符, 给Vector2D 添加如下的类型方法 +++:<br><br>extension Vector2D {<br>    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {<br>        vector += vector<br>        return vector<br>    }<br>}</p>
<p>var toBeDoubled = Vector2D(x: 1.0, y: 4.0)<br>let afterDoubling = +++toBeDoubled<br>// toBeDoubled now has values of (2.0, 8.0)<br>// afterDoubling also has values of (2.0, 8.0)<br></p>
<h1 id="自定义中缀运算符的优先级"><a href="#自定义中缀运算符的优先级" class="headerlink" title="自定义中缀运算符的优先级"></a>自定义中缀运算符的优先级</h1><p>自定义中缀运算符每个都属于一个优先级集。一个优先级集指定一个运算符相对于其他中缀运算符的优先级, 也就是运算符的关联性。 </p>
<p>没有显式加入优先级集的自定义中缀运算符,会被给予一个默认的优先级集。它的优先级比三目条件运算符要高。</p>
<p>下面的例子定义了一个新的自定义的中缀运算符 +-, 它属于优先级集 AdditionPrecedence:</p>
<p><pre><code><br>infix operator +-: AdditionPrecedence<br>extension Vector2D {<br>    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: left.x + right.x, y: left.y - right.y)<br>    }<br>}<br>let firstVector = Vector2D(x: 1.0, y: 2.0)<br>let secondVector = Vector2D(x: 3.0, y: 4.0)<br>let plusMinusVector = firstVector +- secondVector<br>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)<br></code></pre><br>这个运算符把两个向量的x值相加, 然后把第二个向量的两个y值相减。因为它实际上是一个 “加法的” 运算符, 它跟其他加法中缀运算符,例如 + 和 - , 有相同的优先级集。</p>
<p>备注</p>
<p>定义一个前缀或者后缀运算符的时候,你不要指定优先级。不过, 如果你在相同的操作数上使用前缀和后缀运算符, 后缀运算符会首先发生作用。</p>
</)></string></element></element></key,></t></t></key,></b)></=></=>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XCode 8 新特性</title>
    <link href="http://yoursite.com/2016/09/21/XCode-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/21/XCode-8-新特性/</id>
    <published>2016-09-21T00:56:17.000Z</published>
    <updated>2016-09-21T02:56:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xcode-8"><a href="#Xcode-8" class="headerlink" title="Xcode 8"></a>Xcode 8</h1><p>Xcode 8 包含了创建 <em>iPhone, iPad, Mac, Apple Watch, and Apple TV </em> 应用你所需要的的一切。 这是最快的IDE版本, 新的编辑器扩展特性使你可以完全定制你的编码习惯。 新的运行时问题提醒你内存泄露引起的隐藏bug, 一个新的 <em>Memory Debugger</em> 深入你的对象图形。 Swift 3 包含了更自然一致的 API 命名, 你可以在iPad上尝试新的 Playgrounds 应用程序。</p>
<div style="text-align:center"><br><img src="http://a3.qpic.cn/psb?/V13UfvND3TZFZo/RNcaIoqMXSQ7nCoBRioXM8W7CL0bYZ*kQLUL3LHhsw0!/b/dPgAAAAAAAAA&bo=IAPeAQAAAAADB94!&rf=viewer_4" width="500" height="300"><br></div>



<h1 id="更快的Interface-Builder"><a href="#更快的Interface-Builder" class="headerlink" title="更快的Interface Builder"></a>更快的Interface Builder</h1><p><em>Interface Builder</em> 重新设计了画布, 让你能更快的工作和有更多的控制权。 任何苹果设备都可以看到实时精确的程序预览。 当你在不同设备间快速切换为<em>size classes</em> 定制UI时, 你会看到相同的界面。 拖动放缩非常快, 甚至当你完全缩小鸟瞰故事板视图时还可以编辑你的界面。</p>
<div style="text-align:center"><br><img src="http://a1.qpic.cn/psb?/V13UfvND3TZFZo/z99xQxqCq4XHoOHAb*asuoJ7SBPNlgG3Vu2CaEkKprs!/b/dK4AAAAAAAAA&bo=IAPSAQAAAAADB9I!&rf=viewer_4" width="500" height="300"><br></div>

<h1 id="编辑器扩展"><a href="#编辑器扩展" class="headerlink" title="编辑器扩展"></a>编辑器扩展</h1><p>新的 Xcode 源编辑器扩展让你可以定制编码习惯。 使用扩展在你的编辑器文字区导航, 选择, 修改, 转换代码。 绑定你最喜欢的扩展到快捷键, 让格式化工作易如反掌。 Xcode 包含了一个新的模板，让你可以轻松创建编辑器扩展并在Mac应用商店发布, 或者用你的开发者账号签名扩展然后在线分享。 因为扩展是独立进程运行的,  所以Xcode 会很安全稳定。</p>
<p></p><p>新的 Xcode 8 编辑器还包括下面一些特性:</p><p></p>
<ol><br><li><code>San Francisco Mono 字体的新主题</code></li><br><li><code>自动生成快速帮助文档</code></li><br><li><code>高亮显示当前行</code> </li><br><li><code>Swift 代码里的图片和颜色值</code></li><br><li><code>图片名代码补全</code></li><br></ol>

<div style="text-align:center"><br><img src="http://a4.qpic.cn/psb?/V13UfvND3TZFZo/AB*sU2gRXg7wXjFzf.VS0cpYirSYVpJ1PI7m.18VQZo!/m/dP8AAAAAAAAA&bo=qwChAAAAAAADByg!&rf=photolist" width="150" height="150"><br></div>

<h1 id="Swift-3"><a href="#Swift-3" class="headerlink" title="Swift 3"></a>Swift 3</h1><p>Swift 3 是创新编程语言的首次重大发布， 对 <em>Swift.org</em> 社区开发者完全开放。 这个版本基于一个新的API命名指导文档统一了核心API的命名规则，这让书写  Swift 代码更加自然。 <code>Core Graphics</code> 和 <code>Grand Central Dispatch</code> 这些流行的系统API 更有表现力，与 Swift 更加协调。 你可以在<em>iPad Playgrounds</em> 应用程序里体验 Swift 3 。</p>
<h1 id="运行时问题"><a href="#运行时问题" class="headerlink" title="运行时问题"></a>运行时问题</h1><p>运行程序时，新特性报告的问题是 Xcode 自动识别的, 捕获那些难以发现的bug，这些bug通常难以发现直到应用到了用户手中。 新的 <em>Thread Sanitizer </em>用于竞态数据变化和其他线程相关的bug。 监测UI约束问题使用最新的 <em>View Debugger</em>，它具有更高的保真度和视觉精度, 在新的 <em>Memory Debugger</em> 跟踪内存泄露.</p>
<div style="text-align:center"><br><img src="http://a2.qpic.cn/psb?/V13UfvND3TZFZo/cf4dXQphPBVKKEWM7x58NOpuMKHlDJ*WxB2rwMOn*p8!/m/dK0AAAAAAAAA&bo=IAPdAQAAAAADB90!&rf=photolist" width="500" height="300"><br></div>

<h1 id="容易和强大的签名"><a href="#容易和强大的签名" class="headerlink" title="容易和强大的签名"></a>容易和强大的签名</h1><p>设备设置和代码签名极大的简化了, 你需要的时候提供更多的控制。 新的自动管理代码签名会生成你需要正确配置的所有东西。 只需选择你的开发团队，其他 Xcode 帮你做了。 你可以手动配置一切。 如果你遇见问题, 改进的错误信息和日志可以在 <em>Report Navigator</em> 查看。 如果你有多台 Mac 电脑, Xcode 会自动为每台 Mac 生成一个唯一的开发证书。</p>
<p>在你的苹果设备上开发和运行您的应用程序和进入Xcode的偏好设置输入Apple ID一样容易。苹果开发者账号不是必需的。</p>
<p>Provisioning Profile 文件选取，已经从Buiid Settings移动到了General中,Buiid Settings中已经标识了 Deprecated。</p>
<div style="text-align:center"><br><img src="http://cc.cocimg.com/api/uploads/20160615/1465977531625569.jpg" width="400" height="300"><br></div><br><div style="text-align:center"><br><img src="http://cc.cocimg.com/api/uploads/20160615/1465977537567515.jpg" width="600" height="300"><br></div>

<p>使用Xcode 8创建新项目的时候，会让你选择开发者团队为了自动生成对应的证书。</p>
<p>在新老项目的<em>General</em>中也可以对签名进行设置,勾选自动管理证书(可选的)，Xcode 会自动替你生成调试证书和描述问题，证书与描述文件有效期为6天，避免了大量的垃圾冗余证书占用问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Xcode-8&quot;&gt;&lt;a href=&quot;#Xcode-8&quot; class=&quot;headerlink&quot; title=&quot;Xcode 8&quot;&gt;&lt;/a&gt;Xcode 8&lt;/h1&gt;&lt;p&gt;Xcode 8 包含了创建 &lt;em&gt;iPhone, iPad, Mac, Apple Watch, 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CALayer开发指南</title>
    <link href="http://yoursite.com/2016/09/19/CALayer%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2016/09/19/CALayer开发指南/</id>
    <published>2016-09-19T07:16:18.000Z</published>
    <updated>2016-10-28T05:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<html lang="en-US" class="no-js windows"><br><br><link rel="stylesheet" id="wpsqt-main-css" href="https://cdn3.raywenderlich.com/wp-content/plugins/wp-survey-and-quiz-tool/css/main.css?ver=4.5.2" type="text/css" media="all"><br><link rel="stylesheet" id="style-main-css" href="https://cdn4.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1471520796" type="text/css" media="all"><br><br><div id="attachment_114189" style="width: 260px" class="wp-caption alignright"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot-316x320.png" width="316" height="320" class="alignright size-medium wp-image-91873" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot-316x320.png 316w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot-494x500.png 494w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot-32x32.png 32w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot-64x64.png 64w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot-96x96.png 96w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/LayersScreenshot.png 608w" sizes="(max-width: 316px) 100vw, 316px"></div><br><br><p>也许你知道, 你在iOS程序上看到的一切都是视图。 有按钮视图, 列表视图, 滑块视图, 甚至是包含其他视图的父视图。</p><br><p>不过你可能不知道,每个视图都由一个叫做图层的类支持 – 一个特定的 CALayer 。 </p><br><p>通过这篇文章, 你会了解 CALayer 是什么, 如何工作的。 你还会看到10个用 CALayers 实现的炫酷效果, 比如几何图形, 渐变, 甚至是粒子系统。</p><br><p>这篇文章假设你会用Swift开发iOS应用程序, 包括用故事板构造界面。 </p><br><br><h2>开始</h2><br><p>理解图层到底是什么的最容易的方法就是看他们怎么运行。 所以让我们从头创建一个简单的工程来玩转图层。</p><br><p>准备好写代码了吗? 不错! 启动 Xcode 并且:</p><br><ol><br><li>从菜单选择 <em>File\New\Project&#8230;</em> . </li><br><li>从对话框中选择 <em>iOS\Application\Single View Application</em> . </li><br><li>点击 <em>Next</em>, 输入 <em>CALayerPlayground</em> 作为产品名,输入机构名和标识符。 </li><br><li>选择 <em>Swift</em>作为开发语言同时选择  <em>Universal</em> . </li><br><li>不要选中 <em>Core Data</em> , 然后点击 <em>Next</em>. </li><br><li>给你的工程找个好位置 (我把工程放在一个叫 Source 的用户文件夹), 然后点击 <em>Create</em>.</li><br><p>好了, 现在文件创建好了,下一步是创建一个视图:</p><br><li>在 Project navigator, 选择 <em>Main.storyboard</em>. </li><br><li>从菜单中选择 <em>View\Assistant Editor\Show Assistant Editor</em> , 如果没有显示出来就选择 <em>View\Utilities\Show Object Library</em> . </li><br><li>也可以选择 <em>Editor\Canvas\Show Bounds Rectangles</em>, 这样你会看到将要加入scene的视图边界轮廓。 </li><br><li>从 Object library 中, 拖一个视图到 View Controller Scene. 选中它, 去 Size inspector (<em>View\Utilities\Show Size Inspector</em>)设置 <em>x</em> 和 <em>y</em> 为 <em>150</em> , <em>width</em> 和 <em>height</em> 为 <em>300</em>. </li><br><li>保持视图选中, 点击自动布局工具条上的 <em>Align</em> 按钮 (故事板右下方) 选中 <em>Horizontal Center in Container</em> 和 <em>Vertical Center in Container</em>, 两个值都设为 <em>0</em>, 然后点击 <em>Add 2 Constraints</em>. </li><br><li>点击 <em>Pin</em> 按钮, 选中 <em>Width</em> 和 <em>Height</em>, 确保两个值都设成 <em>300</em>, 点击 <em>Add 2 Constraints</em>.</li><br></ol><br><p>最后, 按住control拖住在 <em>ViewController.swift</em> 创建的视图, 拖到 <code>viewDidLoad()</code> 方法上面。 弹出提示给出的outlet 名字是 <em>viewForLayer</em>. 你的 Xcode 看起来是这样:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateOutlet.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateOutlet-700x215.png" width="700" height="215" class="aligncenter size-large wp-image-90649" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateOutlet-700x215.png 700w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateOutlet-480x147.png 480w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateOutlet.png 1404w" sizes="(max-width: 700px) 100vw, 700px"></a></p><br><p>点击 <em>Connect</em> 创建 outlet. </p><br><p>用下面的代码替换 <em>ViewController.swift</em> 的内容:</p><br><br><div class="wp_codebox"><table><tr id="p904881"><td class="code" id="p90488code1"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> ViewController<span style="color: #002200;">:</span> <span style="color: #400080;">UIViewController</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  @IBOutlet weak <span style="color: #a61390;">var</span> viewForLayer<span style="color: #002200;">:</span> <span style="color: #400080;">UIView</span><span style="color: #002200;">!</span><br>&nbsp;<br>  <span style="color: #a61390;">var</span> l<span style="color: #002200;">:</span> <span style="color: #400080;">CALayer</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> viewForLayer.layer<br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    setUpLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">func</span> setUpLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    l.backgroundColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.blueColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>    l.borderWidth <span style="color: #002200;">=</span> <span style="color: #2400d9;">100.0</span><br>    l.borderColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.redColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>    l.shadowOpacity <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.7</span><br>    l.shadowRadius <span style="color: #002200;">=</span> <span style="color: #2400d9;">10.0</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>正如前面提到的, 每个视图都有一个图层, 你可以用 <code>yourView.layer</code> 获取这个图层。 这个代码首先做的是创建一个计算属性”l” (小写的 L) 来访问 <code>viewForLayer</code> 的图层, 这个可以节省你写后续代码的敲击。 </p><br><p> <code>setUpLayer</code> 负责给图层设置一些属性; 阴影, 蓝色的背景, 红色大边框。 稍后你会了解更多 <code>setUpLayer()</code> , 不过先编译运行模拟器来查看你的自定义图层 (我选的是 <em>iPhone 6</em>) :</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-1.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-1-179x320.png" width="179" height="320" class="aligncenter size-medium wp-image-90653 bordered" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-1-179x320.png 179w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-1-281x500.png 281w" sizes="(max-width: 179px) 100vw, 179px"></a></p><br><p>几行代码的效果很酷吧,  因为每个视图背后都有图层, 你可以在程序 <i>任意</i> 视图中做这些。 我们来仔细看一下。</p><br><h2>基本的 CALayer 属性</h2><br><p>CALayer 有几个属让你可以自定义它的外观。 回想一下你前面做过的:</p><br><ul><br><li>背景色从无到蓝色<br></li><li>把边框宽度从0改成100<br></li><li>把边框色从黑色变成红色<br></li><li>最后, 改变阴影透明度的值到0.7; 这会产生阴影效果, 你可以进一步把它的阴影半径从3改成10。</li><br></ul><br><p>CALayer 仅有几个属性可以设置。 我们再试两个。 在<code>setUpLayer()</code> 下添加下面几行代码:</p><br><br><div class="wp_codebox"><table><tr id="p904882"><td class="code" id="p90488code2"><pre class="swift" style="font-family:monospace;">l.contents <span style="color: #002200;">=</span> <span style="color: #400080;">UIImage</span><span style="color: #002200;">&#40;</span>named<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;star&quot;</span><span style="color: #002200;">&#41;</span>?.CGImage<br>l.contentsGravity <span style="color: #002200;">=</span> kCAGravityCenter</pre></td></tr></table></div><br><br><p> <code>contents</code> 属性允许你给图层内容设置图片, 所以这里你给它设了图片叫 &#8220;star&#8221;. 对于这个工作, 你要先把图片加到你的工程里,  <a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/star.png" title="Star image" download="star.png" target="_blank" rel="external">下载我做的星星图片</a> 然后添加到你的工程里。</p><br><p>编译运行程序, 欣赏一会这件艺术品: </p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-2.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-2-179x320.png" width="179" height="320" class="aligncenter size-medium wp-image-90655 bordered" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-2-179x320.png 179w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-2-281x500.png 281w" sizes="(max-width: 179px) 100vw, 179px"></a></p><br><p>注意星星是如何居中的 &#8211; 这是你因为把 <code>contentsGravity</code> 属性设置成了 <code>kCAGravityCenter</code>. 如你所愿, 你可以改变它的重心为上, 右上, 右, 右下, 下,左下, 左和左上。 </p><br><h2>改变图层的外观</h2><br><p>仅仅为了好玩, 我们添加一些手势来操作图层的外观。 在 Xcode 里, 拖一个点击手势到 <code>viewForLayer</code> . 仅供参考, 添加点击手势应该是这个样子的:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/Xcode-AddTapGestureRecognizer.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/Xcode-AddTapGestureRecognizer-700x478.png" width="700" height="478" class="aligncenter size-large wp-image-90656" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/Xcode-AddTapGestureRecognizer-700x478.png 700w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/Xcode-AddTapGestureRecognizer-468x320.png 468w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/Xcode-AddTapGestureRecognizer.png 1109w" sizes="(max-width: 700px) 100vw, 700px"></a></p><br><div class="note"><br><p><em>备注</em>: 如果你不熟悉手势, 可以查看 <a href="http://www.raywenderlich.com/76020/using-uigesturerecognizer-with-swift-tutorial" title="Using UIGestureRecognizer with Swift" target="_blank" rel="external"> Using UIGestureRecognizer with Swift</a>. </p><br></div><br><p>重复步骤添加一个捏合手势到 <code>viewForLayer</code> .</p><br><p>然后按住 control拖动每个手势到<em>ViewController.swift</em>, 一个接着一个, 把它们放<code>setUpLayer()</code> 和类的大括号之间。 </p><br><p>在弹出框里, 把连接按钮改成 <em>Action</em> 命名点击手势名为 <code>tapGestureRecognized</code> , 捏合手势名为 <code>pinchGestureRecognized</code>. 例如:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateAction.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateAction-700x253.png" width="700" height="253" class="aligncenter size-large wp-image-90658" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateAction-700x253.png 700w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateAction-480x173.png 480w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/Xcode-CreateAction.png 1102w" sizes="(max-width: 700px) 100vw, 700px"></a></p><br><p>修改 <code>tapGestureRecognized(_:)</code> 像这样:</p><br><br><div class="wp_codebox"><table><tr id="p904883"><td class="code" id="p90488code3"><pre class="swift" style="font-family:monospace;">@IBAction <span style="color: #a61390;">func</span> tapGestureRecognized<span style="color: #002200;">&#40;</span>sender<span style="color: #002200;">:</span> <span style="color: #400080;">UITapGestureRecognizer</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  l.shadowOpacity <span style="color: #002200;">=</span> l.shadowOpacity <span style="color: #002200;">==</span> <span style="color: #2400d9;">0.7</span> ? <span style="color: #2400d9;">0.0</span> <span style="color: #002200;">:</span> <span style="color: #2400d9;">0.7</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>这是告诉 <code>viewForLayer</code> 点击时在0.7和0的阴影不透明度之间切换图层的阴影。 </p><br><p>你说的这个视图? 重写 CALayer&#8217;的 <code>hitTest(<em>:)</em></code> 方法也可以实现, 实际上在文章的后面你会看到这个方法。 不过这里是上面方法的逻辑:  hit testing 是图层唯一可以做的, 因为它不响应手势。 这就是为什么你要在视图上添加手势T。 </p><br><p>现在修改 <code>pinchGestureRecognized(:)</code> 像这样:</p><br><br><div class="wp_codebox"><table><tr id="p904884"><td class="code" id="p90488code4"><pre class="swift" style="font-family:monospace;">@IBAction <span style="color: #a61390;">func</span> pinchGestureRecognized<span style="color: #002200;">&#40;</span>sender<span style="color: #002200;">:</span> UIPinchGestureRecognizer<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">let</span> offset<span style="color: #002200;">:</span> <span style="color: #400080;">CGFloat</span> <span style="color: #002200;">=</span> sender.scale &lt; <span style="color: #2400d9;">1</span> ? <span style="color: #2400d9;">5.0</span> <span style="color: #002200;">:</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">5.0</span><br>  <span style="color: #a61390;">let</span> oldFrame <span style="color: #002200;">=</span> l.frame<br>  <span style="color: #a61390;">let</span> oldOrigin <span style="color: #002200;">=</span> oldFrame.origin<br>  <span style="color: #a61390;">let</span> newOrigin <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> oldOrigin.x <span style="color: #002200;">+</span> offset, y<span style="color: #002200;">:</span> oldOrigin.y <span style="color: #002200;">+</span> offset<span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> newSize <span style="color: #002200;">=</span> <span style="color: #400080;">CGSize</span><span style="color: #002200;">&#40;</span>width<span style="color: #002200;">:</span> oldFrame.width <span style="color: #002200;">+</span> <span style="color: #002200;">&#40;</span>offset <span style="color: #002200;"><em></em></span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span>, height<span style="color: #002200;">:</span> oldFrame.height <span style="color: #002200;">+</span> <span style="color: #002200;">&#40;</span>offset <span style="color: #002200;"></span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> newFrame <span style="color: #002200;">=</span> <span style="color: #400080;">CGRect</span><span style="color: #002200;">&#40;</span>origin<span style="color: #002200;">:</span> newOrigin, size<span style="color: #002200;">:</span> newSize<span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">if</span> newFrame.width &gt;<span style="color: #002200;">=</span> <span style="color: #2400d9;">100.0</span> <span style="color: #002200;">&amp;&amp;</span> newFrame.width &lt;<span style="color: #002200;">=</span> <span style="color: #2400d9;">300.0</span> <span style="color: #002200;">&#123;</span><br>    l.borderWidth <span style="color: #002200;">-=</span> offset<br>    l.cornerRadius <span style="color: #002200;">+=</span> <span style="color: #002200;">&#40;</span>offset <span style="color: #002200;">/</span> <span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span><br>    l.frame <span style="color: #002200;">=</span> newFrame<br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>你在这里基于用户捏合创建了正负偏移量, 然后调整图层区域的尺寸,边框的宽度和圆角半径。 </p><br><p>图层的圆角半径默认为0, 是个90度圆角的标准矩形。 增加半径创建圆角。 想把正方形变成圆吗? 把圆角半径设置为宽度的一半就可以了。 </p><br><p>注意,调整圆角半径并不会裁剪图层的内容 (星星图片) 除非图层的 <code>masksToBounds</code> 属性设置成 <code>true</code>.</p><br><p>编译运行, 试着单击和捏合视图:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-3.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-3-179x320.png" width="179" height="320" class="aligncenter size-medium wp-image-90661 bordered" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-3-179x320.png 179w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CALayerPlayground-3-281x500.png 281w" sizes="(max-width: 179px) 100vw, 179px"></a></p><br><p>嗨, 慢慢打磨,你可以成为一个不错的头像制造商! :]</p><br><h2>伟大的 CALayer 之旅</h2><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2015/01/CaLayerTour-e1421621716326.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/01/CaLayerTour-e1421621716326.png" width="441" height="423" class="aligncenter size-full wp-image-93973" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/01/CaLayerTour-e1421621716326.png 441w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/01/CaLayerTour-e1421621716326-334x320.png 334w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/01/CaLayerTour-e1421621716326-32x32.png 32w" sizes="(max-width: 441px) 100vw, 441px"></a> </p><br><p>CALayer 已经多了一些属性和方法, 以及一些拥有特定属性和方法的子类。 </p><br><p>对于剩下的文章, 你会需要下面的:</p><br><ul><br><li><a href="http://bit.ly/AppStoreLayerPlayer" title="Layer Player on App Store" target="_blank">The Layer Player App</a></li><br><li><a href="http://bit.ly/LayerPlayer" title="Layer Player at GitHub" target="_blank">The Layer Player Source Code</a></li><br></ul><br><p>这个程序包含10种不同 CALayers 的示例, 这些示例你会在文章里学到。 这是10个示例的预览:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerTourScenes.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayerTourScenes-700x415.png" width="700" height="415" class="aligncenter size-large wp-image-92164 bordered" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CALayerTourScenes-700x415.png 700w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CALayerTourScenes-480x284.png 480w" sizes="(max-width: 700px) 100vw, 700px"></a></p><br><p>通过下面的例子, 我建议你在 CALayer 程序中玩玩,选择性的看一些源码。 剩余的文章你不需要编码, 坐下来阅读吧 :]</p><br><p>这里有一些很棒的示例你可以添加不同类型 CALayers 到你的工程。 希望你喜欢!</p><br><h2>示例1: CALayer</h2><br><p>你已经看过一个使用 CALayer 的示例, 并且设置了一些属性。 </p><br><p>这里有一些关于 CALayers 的事我还没有提及:</p><br><ul><br><li><em>图层可以有子图层</em>. 就像视图有子视图, 图层也有子图层。 你可以用这个实现一些炫酷的效果!</li><br><li><em>图层属性是动画的</em>. 当你改变一个图层的属性时, 默认它会随着时间产生动画。 你也可以按照自己的时机定制动画。</li><br><li><em>图层是轻量级的</em>. 图层比视图轻量级, 因此它们可以帮你实现更好的效果。</li><br><li><em>图层有很多有用的属性.</em> 你已经看到一些了, 不过让我们再看一些!</li><br></ul><br><p>如你早前看到的, 图层有很多有用的属性。 让我浏览完整的 CALayer 属性列表 &#8211; 一些你没有看过的但是很便捷的!</p><br><br><div class="wp_codebox"><table><tr id="p904885"><td class="code" id="p90488code5"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// 1</span><br><span style="color: #a61390;">let</span> layer <span style="color: #002200;">=</span> <span style="color: #400080;">CALayer</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>layer.frame <span style="color: #002200;">=</span> someView.bounds<br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 2</span><br>layer.contents <span style="color: #002200;">=</span> <span style="color: #400080;">UIImage</span><span style="color: #002200;">&#40;</span>named<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;star&quot;</span><span style="color: #002200;">&#41;</span>?.CGImage<br>layer.contentsGravity <span style="color: #002200;">=</span> kCAGravityCenter<br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 3</span><br>layer.magnificationFilter <span style="color: #002200;">=</span> kCAFilterLinear<br>layer.geometryFlipped <span style="color: #002200;">=</span> <span style="color: #a61390;">false</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 4</span><br>layer.backgroundColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span><span style="color: #002200;">&#40;</span>red<span style="color: #002200;">:</span> <span style="color: #2400d9;">11</span><span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">86</span><span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">14</span><span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, alpha<span style="color: #002200;">:</span> <span style="color: #2400d9;">1.0</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>layer.opacity <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>layer.hidden <span style="color: #002200;">=</span> <span style="color: #a61390;">false</span><br>layer.masksToBounds <span style="color: #002200;">=</span> <span style="color: #a61390;">false</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 5</span><br>layer.cornerRadius <span style="color: #002200;">=</span> <span style="color: #2400d9;">100.0</span><br>layer.borderWidth <span style="color: #002200;">=</span> <span style="color: #2400d9;">12.0</span><br>layer.borderColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.whiteColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 6</span><br>layer.shadowOpacity <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.75</span><br>layer.shadowOffset <span style="color: #002200;">=</span> <span style="color: #400080;">CGSize</span><span style="color: #002200;">&#40;</span>width<span style="color: #002200;">:</span> <span style="color: #2400d9;">0</span>, height<span style="color: #002200;">:</span> <span style="color: #2400d9;">3</span><span style="color: #002200;">&#41;</span><br>layer.shadowRadius <span style="color: #002200;">=</span> <span style="color: #2400d9;">3.0</span><br>someView.layer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span></pre></td></tr></table></div><br><br><p>在上面的代码里:</p><br><ol><br><li>创建一个 CALayer 实例并把他设置成 <code>someView</code> 的边界.</li><br><li>给图层设置一张图片作为内容并居中。 注意用下面的图片数据  (<code>CGImage</code>) 赋值. </li><br><li>通过<code>contentsGravity</code>放大图片时使用过滤器, 可以同时改变大小 (resize, resize aspect, and resize aspect fill) 和 位置 (center, top, top-right, right, etc.). </li><br><p>前面的变化没有动画效果, 如果 <code>geometryFlipped</code> 没有设置成 <code>true</code>, 几何位置和阴影会是颠倒的。继续: </p><br><li>你设置了背景色是蕾最喜欢的绿色阴影 :] 并且让图层变的不透明可见。 同时, 你让视图不要遮挡它的内容, 意思是如果它的尺寸小于它的内容 (星星图), 图片不会被裁剪。 </li><br><li>图层的圆角半径设成宽度的一半可以创造圆形边框的视觉效果; 注意图层颜色用 Quartz 颜色赋值 (<code>CGColor</code>).</li><br><li>创建阴影同时设置 <code>shouldRasterize</code> 为 <code>true</code> (下面讨论), 然后把图层添加到视图结构。</li><br></ol><br><p>这是运行结果:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayer-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-90712" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-250x250.png 250w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-320x320.png 320w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-500x500.png 500w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-32x32.png 32w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-64x64.png 64w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-96x96.png 96w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer-128x128.png 128w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CALayer.png 800w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>CALayer 有两个额外的属性可以提高性能: <code>shouldRasterize</code> 和 <code>drawsAsynchronously</code>. </p><br><p><code>shouldRasterize</code> 默认是 <code>false</code> , 当被设置成 <code>true</code> 它可以提升性能高, 因为图层内容只需要渲染一次就够了。 对于在屏幕上展示动画而又不需要改变外观的对象来说这是完美的。 </p><br><p><code>drawsAsynchronously</code> 是 <code>shouldRasterize</code> 相反的一种属性。 它的值默认也是 <code>false</code> . 把它设置成 <code>true</code> ,在内容必须重复绘制时能提升性能, 比如当你使用发射器图层不断渲染动画颗粒的时候。) </p><br><div class="note"><br><p><em>一个警告</em>: 把图层的 <code>shouldRasterize</code> 或者 <code>drawsAsynchronously</code> 值设置成true 之前要考虑清楚它的影响。 比较值为真假时候的性能,这样你会明白是否需要开启这些特性去提升性能。 如果滥用, 性能可能会急剧下降。<br></p></div><br><p>现在暂时转移注意力到 Layer Player. 它包含可以操作CALayer 属性的很多控件:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CALayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91212 bordered" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CALayer_5.5-180x320.png 180w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CALayer_5.5-281x500.png 281w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CALayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><p>玩玩这些控件; 这是感受 CALayer 可以做什么的一种很好的方式!</p><br><div class="note"><em>备注:</em> 图层不是响应链的一部分,所以它不能响应触碰或者视图那种手势, 就像你在 CALayerPlayground 示例中看到的那样。 <p></p><br><p>不过, 你可以敲击测试它们, 你会在 CATransformLayer 中看到示例代码。 你也可以往图层添加自定义动画, 这些动画会在 CAReplicatorLayer 中看到。</p></div><br><h2>示例2: CAScrollLayer</h2><br><p>CAScrollLayer 显示滚动图层的一部分。 它很基础,不能响应用户的触摸甚至不能确定滚动图层的边界, 所以它可以无限做类似防止滚出边界这种很酷的事! :] </p><br><p>UIScrollView 不用 CAScrollLayer 来做这件事, 取而代之的直接改变它的图层边界。 </p><br><p>用 CAScrollLayer 可以做的是设置它的滚动模式为水平或者垂直, 你可以编程让它滚动到特定的位置或区域:</p><br><br><div class="wp_codebox"><table><tr id="p904886"><td class="code" id="p90488code6"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// In ScrollingView.swift</span><br><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> ScrollingView<span style="color: #002200;">:</span> <span style="color: #400080;">UIView</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">class</span> <span style="color: #a61390;">func</span> layerClass<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; AnyClass <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> CAScrollLayer.<span style="color: #a61390;">self</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// In CAScrollLayerViewController.swift</span><br><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> CAScrollLayerViewController<span style="color: #002200;">:</span> <span style="color: #400080;">UIViewController</span> <span style="color: #002200;">&#123;</span><br>  @IBOutlet weak <span style="color: #a61390;">var</span> scrollingView<span style="color: #002200;">:</span> ScrollingView<span style="color: #002200;">!</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">var</span> scrollingViewLayer<span style="color: #002200;">:</span> CAScrollLayer <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> scrollingView.layer <span style="color: #a61390;">as</span> CAScrollLayer<br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #11740a; font-style: italic;">// 3</span><br>    scrollingViewLayer.scrollMode <span style="color: #002200;">=</span> kCAScrollBoth<br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  @IBAction <span style="color: #a61390;">func</span> tapRecognized<span style="color: #002200;">&#40;</span>sender<span style="color: #002200;">:</span> <span style="color: #400080;">UITapGestureRecognizer</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #11740a; font-style: italic;">// 4</span><br>    <span style="color: #a61390;">var</span> newPoint <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> <span style="color: #2400d9;">250</span>, y<span style="color: #002200;">:</span> <span style="color: #2400d9;">250</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #400080;">UIView</span>.animateWithDuration<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.3</span>, delay<span style="color: #002200;">:</span> <span style="color: #2400d9;">0</span>, options<span style="color: #002200;">:</span> .CurveEaseInOut, animations<span style="color: #002200;">:</span> <span style="color: #002200;">&#123;</span><br>      <span style="color: #002200;">&#91;</span>unowned <span style="color: #a61390;">self</span><span style="color: #002200;">&#93;</span> <span style="color: #a61390;">in</span><br>      <span style="color: #a61390;">self</span>.scrollingViewLayer.scrollToPoint<span style="color: #002200;">&#40;</span>newPoint<span style="color: #002200;">&#41;</span><br>      <span style="color: #002200;">&#125;</span>, completion<span style="color: #002200;">:</span> <span style="color: #a61390;">nil</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>上面的代码:</p><br><ol><br><li>自定义 <code>UIView</code> 子类通过重写 <code>layerClass()</code> 来返回 <code>CAScrollLayer</code>; 这是创建一个新图层并且添加它作为一个子图层的一种选择, 就像示例做的一样。 </li><br><li>一个计算属性用来组织和自定义视图滚动图层的工作。</li><br><li>滚动设置为支持水平和垂直。 </li><br><li>当一个点击被识别后, 新的位置被创建, 滚动图层在一个 <code>UIView</code> 动画中滚动到那个位置。 备注: <code>scrollToPoint(<em>:)</em></code> 和 <code>scrollToRect(:)</code> 不会自动发生动画。 </li><br></ol><br><p>案例学习: 一个ScrollingView 实例, 它包含一个图片视图,这个视图的图片比滚动视图的边界还大。 当你执行上面的代码并单击视图, 可能是这样:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAScrollLayer.gif" width="250" height="250" class="aligncenter size-full wp-image-90738" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAScrollLayer.gif 250w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAScrollLayer-32x32.gif 32w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAScrollLayer-64x64.gif 64w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAScrollLayer-96x96.gif 96w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAScrollLayer-128x128.gif 128w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>Layer Player 包含很多锁定水平和垂直滚动的控件。 </p><br><p>有一些经验规则决定用或不用 CAScrollLayer:</p><br><ul><br><li><em>如果只是想要轻量级并且需要编程实现滚动</em>: 考虑使用 CAScrollLayer.</li><br><li><em>如果你想让用户滚动</em>: 最好用 UIScrollView. 想了解更多, 查看 <a href="http://www.raywenderlich.com/93104/video-tutorial-swift-scroll-view-school-part-0-introduction" target="_blank" rel="external">18-part video tutorial series</a> .</li><br><li><em>如果你在滚动一个很大的图</em>: 考虑使用 CATiledLayer (更多信息在下面)。</li><br></ul><br><h2>示例3: CATextLayer</h2><br><p>CATextLayer 提供简单快速的纯文本或者属性字符串渲染。 不像 UILabel, CATextLayer 没有指定的 UIFont, 只有 CTFontRef 或 CGFontRef. </p><br><p>下面这块代码一样, 像动态变化一样去操作字体，字体大小，颜色，对齐方式，包围和截断:</p><br><br><div class="wp_codebox"><table><tr id="p904887"><td class="code" id="p90488code7"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// 1</span><br><span style="color: #a61390;">let</span> textLayer <span style="color: #002200;">=</span> CATextLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>textLayer.frame <span style="color: #002200;">=</span> someView.bounds<br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 2</span><br><span style="color: #a61390;">var</span> string <span style="color: #002200;">=</span> <span style="color: #bf1d1a;">&quot;&quot;</span><br><span style="color: #a61390;">for</span> _ <span style="color: #a61390;">in</span> <span style="color: #2400d9;">1</span>…20 <span style="color: #002200;">&#123;</span><br>  string <span style="color: #002200;">+=</span> <span style="color: #bf1d1a;">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit congue dictum. &quot;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br>textLayer.string <span style="color: #002200;">=</span> string<br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 3</span><br><span style="color: #a61390;">let</span> fontName<span style="color: #002200;">:</span> CFStringRef <span style="color: #002200;">=</span> <span style="color: #bf1d1a;">&quot;Noteworthy-Light&quot;</span><br>textLayer.font <span style="color: #002200;">=</span> CTFontCreateWithName<span style="color: #002200;">&#40;</span>fontName, fontSize, <span style="color: #a61390;">nil</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 4</span><br>textLayer.foregroundColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.darkGrayColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>textLayer.wrapped <span style="color: #002200;">=</span> <span style="color: #a61390;">true</span><br>textLayer.alignmentMode <span style="color: #002200;">=</span> kCAAlignmentLeft<br>textLayer.contentsScale <span style="color: #002200;">=</span> UIScreen.mainScreen<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.scale<br>someView.layer.addSublayer<span style="color: #002200;">&#40;</span>textLayer<span style="color: #002200;">&#41;</span></pre></td></tr></table></div><br><br><p>解释上面的代码:</p><br><ol><br><li>创建一个 CATextLayer 实例并把它的区域设置成<code>someView</code>的区域。 </li><br><li>创建一个重复的字符串并把它设置到文字层。 </li><br><li>创建一个字体并把设置到文字层。 </li><br><li>设置文字层包围和左对齐, (你可以选择设成 natural, right, center 和 justified.),  <code>contentsScale</code> 设置成跟随屏幕, 然后把图层添加到视图层级中。</li><br></ol><br><p>所有图层类, 不仅仅是 CATextLayer, 默认按照1倍因子渲染。 连接到视图的时候, 图层按照当前屏幕自动设置 <code>contentsScale</code> 合适的比例。 手动创建的图层需要显示设置 <code>contentsScale</code> , 否则缩放比例是1，你在视网膜屏幕看到的是模糊的文字。</p><br><p>如果添加到正方形的 <code>someView</code>, 创建的文字图层会像下面这样:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-90750" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-250x250.png 250w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-320x320.png 320w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-500x500.png 500w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-32x32.png 32w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-64x64.png 64w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-96x96.png 96w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-128x128.png 128w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer.png 800w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>你可以玩玩截断设置, 当你想用省略号切断文本的时候它表现很好。 默认没有设置截断，当然你可以设置成首部截断，末尾截断和中间截断:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-MiddleTruncation.png.png" width="250" height="26" class="aligncenter size-full wp-image-90764"></p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-StartTruncation.png.png" width="250" height="26" class="aligncenter size-full wp-image-90765"></p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer-EndTruncation.png" width="250" height="26" class="aligncenter size-full wp-image-90763"></p><br><p>Layer Player 有很多控件来改变 CATextLayer 的属性:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91214 bordered" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer_5.5-180x320.png 180w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer_5.5-281x500.png 281w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATextLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><h2>示例4: AVPlayerLayer</h2><br><p>AVPlayerLayer 向 AVFoundation 添加了一个图层。 它拥有一个 AVPlayer 来播放 AV 媒体文件 (AVPlayerItems). 这里有个创建 AVPlayerLayer 的例子:</p><br><br><div class="wp_codebox"><table><tr id="p904888"><td class="code" id="p90488code8"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  <span style="color: #a61390;">let</span> playerLayer <span style="color: #002200;">=</span> AVPlayerLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  playerLayer.frame <span style="color: #002200;">=</span> someView.bounds<br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">let</span> url <span style="color: #002200;">=</span> <span style="color: #400080;">NSBundle</span>.mainBundle<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.URLForResource<span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;someVideo&quot;</span>, withExtension<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;m4v&quot;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> player <span style="color: #002200;">=</span> AVPlayer<span style="color: #002200;">&#40;</span>URL<span style="color: #002200;">:</span> url<span style="color: #002200;">&#41;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 3</span><br>  player.actionAtItemEnd <span style="color: #002200;">=</span> .None<br>  playerLayer.player <span style="color: #002200;">=</span> player<br>  someView.layer.addSublayer<span style="color: #002200;">&#40;</span>playerLayer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 4</span><br>  <span style="color: #400080;">NSNotificationCenter</span>.defaultCenter<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.addObserver<span style="color: #002200;">&#40;</span><span style="color: #a61390;">self</span>, selector<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;playerDidReachEndNotificationHandler:&quot;</span>, name<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;AVPlayerItemDidPlayToEndTimeNotification&quot;</span>, object<span style="color: #002200;">:</span> player.currentItem<span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #a61390;">deinit</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #400080;">NSNotificationCenter</span>.defaultCenter<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.removeObserver<span style="color: #002200;">&#40;</span><span style="color: #a61390;">self</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 5</span><br>@IBAction <span style="color: #a61390;">func</span> playButtonTapped<span style="color: #002200;">&#40;</span>sender<span style="color: #002200;">:</span> <span style="color: #400080;">UIButton</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">if</span> playButton.titleLabel?.text <span style="color: #002200;">==</span> <span style="color: #bf1d1a;">&quot;Play&quot;</span> <span style="color: #002200;">&#123;</span><br>    player.play<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    playButton.setTitle<span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Pause&quot;</span>, forState<span style="color: #002200;">:</span> .Normal<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span> <span style="color: #a61390;">else</span> <span style="color: #002200;">&#123;</span><br>    player.pause<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    playButton.setTitle<span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Play&quot;</span>, forState<span style="color: #002200;">:</span> .Normal<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  updatePlayButtonTitle<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  updateRateSegmentedControl<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 6</span><br><span style="color: #a61390;">func</span> playerDidReachEndNotificationHandler<span style="color: #002200;">&#40;</span>notification<span style="color: #002200;">:</span> <span style="color: #400080;">NSNotification</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">let</span> playerItem <span style="color: #002200;">=</span> notification.object <span style="color: #a61390;">as</span> AVPlayerItem<br>  playerItem.seekToTime<span style="color: #002200;">&#40;</span>kCMTimeZero<span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>分解上面的代码:</p><br><ol><br><li>创建新的播放器图层并设置它的区域。</li><br><li>用 AV 库创建一个播放器。 </li><br><li>告诉播放器播放完成前什么都不做; 添加附加选项，包括暂停，切换到下一首。 </li><br><li>给 AVPlayer 注册播放结束的通知 (在 deinit 移除通知)。 </li><br><li>当播放按钮被点击, 它会触发控件去播放歌曲并设置按钮的标题。</li><br></ol><br><p>注意这只是一个简单的示例帮助你开始。 在真实的项目里, 以按钮文字为中心是不可取的。</p><br><p>AVPlayerLayer 和 上面创建的 AVPlayer 视觉表现为 AVPlayerItem 实例的第一帧, 像这样:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/AVPlayerItem.png" width="250" height="141" class="aligncenter size-full wp-image-91221"></p><br><p>AVPlayerLayer 有两个附加的属性:</p><br><ul><br><li><code>videoGravity</code> 设置视频显示大小。 </li><br><li><code>readyForDisplay</code> 检测视频是否准备好播放。 </li><br></ul><br><p><code>AVPlayer</code>, 另一方面, 只有很少的附加属性和方法。 有一个要注意的是 <code>rate</code>, 包含从 0 到 1的回放速率。 零代表暂停，1代表正常速率播放视频 (1倍速)。 </p><br><p>然而, 设置 <code>rate</code> 也会指示回放按照这个速度开始。 换种说法, 调用 <code>pause()</code> 和 设置 <code>rate</code> 为 0 效果是一样的, 跟调用 <code>play()</code> 和把 <code>rate</code> 设置成 1是一回事</p><br><p>那么快进，慢镜或者反向播放呢? AVPlayerLayer 也已经包含。 设置 <code>rate</code> 比1大就等于要求播放器以这个倍数的速率开始播放, 例如, 设置 <code>rate</code> 为 2 意味着双倍速。 </p><br><p>你可能会想, 把 <code>rate</code> 设置成负数就会指示播放器按照对应的倍速开始倒着播放。 </p><br><p>当比正常倍速更快回放前 (快进), 不管怎样, AVPlayerItem 实例会调用适当的方法来验证它可以以这个速度回放: </p><br><ul><br><li><code>canPlayFastForward()</code> 针对比 1 大的情况</li><br><li><code>canPlaySlowForward()</code> 针对 0 和 1 之间的情况</li><br><li><code>canPlayReverse()</code> 针对 -1</li><br><li><code>canPlaySlowReverse()</code> 针对 -1 和 0 之间的情况</li><br><li><code>canPlayFastReverse()</code> 针对小于 -1 的情况 </li><br></ul><br><p>大多数视频都可以各种快进, 但是很少有可以倒着播放的。 Layer Player 也包含回放控件:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/AVLayerPlayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/AVLayerPlayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91216 bordered" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/AVLayerPlayer_5.5-180x320.png 180w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/AVLayerPlayer_5.5-281x500.png 281w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/AVLayerPlayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><h2>示例5: CAGradientLayer</h2><br><p>CAGradientLayer 使得混合两种或多种颜色变得容易, 这样尤其适合做背景。 要配置它, 你要指定 CGColors 数组, 也要指定 <code>startPoint</code> 和 <code>endPoint</code> 来指定梯度图层哪里开始和结束。 </p><br><p>记住, <code>startPoint</code> 和 <code>endPoint</code> 不是明确的点。 相反, 他们在单元坐标空间定义然后在绘制时映射到图层边界。 换句话说,  x 值为1表示这个点在图层的右边界, y 值为1表示这个点在图层的底边界。 </p><br><p>CAGradientLayer 有个 <code>type</code> 属性, 尽管 <code>kCAGradientLayerAxial</code> 是唯一的选项, 它通过数组中的颜色进行线性转换。 </p><br><p>这意味着如果你在 <code>startPoint</code> 和 <code>endPoint</code> 之间绘制一条线 (A), 渐变沿着一条虚拟的线 (B) 发生，这条线垂直于 A, 所有沿着 B 的点都是同样的颜色:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/AxialGradientLayerType.gif" width="300" class="aligncenter size-full wp-image-91240"></p><br><p>或者, 你可以用0和1之间的数组控制 <code>locations</code> 属性，指定相对停止的位置，在这里梯度图层应该使用 <code>colors</code> 数组里的下一个颜色。 </p><br><p>如果未指定，默认停止位置是均匀分布的。 如果 <code>locations</code> 被设置, 那么它的的数量必须匹配 <code>colors</code> 的数量, 否则坏事要发生。 :[</p><br><p>这里有一个创建梯度图层的例子:</p><br><br><div class="wp_codebox"><table><tr id="p904889"><td class="code" id="p90488code9"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">let</span> gradientLayer <span style="color: #002200;">=</span> CAGradientLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>gradientLayer.frame <span style="color: #002200;">=</span> someView.bounds<br>gradientLayer.colors <span style="color: #002200;">=</span> <span style="color: #002200;">&#91;</span>cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">209.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">0.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span>,<br>  cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">255.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">102.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">34.0</span><span style="color: #002200;">&#41;</span>,<br>  cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">255.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">218.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">33.0</span><span style="color: #002200;">&#41;</span>,<br>  cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">51.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">221.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span>,<br>  cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">17.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">51.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">204.0</span><span style="color: #002200;">&#41;</span>,<br>  cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">34.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">0.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">102.0</span><span style="color: #002200;">&#41;</span>,<br>  cgColorForRed<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">51.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">0.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">68.0</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#93;</span><br>gradientLayer.startPoint <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> <span style="color: #2400d9;">0</span>, y<span style="color: #002200;">:</span> <span style="color: #2400d9;">0</span><span style="color: #002200;">&#41;</span><br>gradientLayer.endPoint <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> <span style="color: #2400d9;">0</span>, y<span style="color: #002200;">:</span> <span style="color: #2400d9;">1</span><span style="color: #002200;">&#41;</span><br>someView.layer.addSublayer<span style="color: #002200;">&#40;</span>gradientLayer<span style="color: #002200;">&#41;</span><br>&nbsp;<br><span style="color: #a61390;">func</span> cgColorForRed<span style="color: #002200;">&#40;</span>red<span style="color: #002200;">:</span> <span style="color: #400080;">CGFloat</span>, green<span style="color: #002200;">:</span> <span style="color: #400080;">CGFloat</span>, blue<span style="color: #002200;">:</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #a61390;">AnyObject</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">return</span> <span style="color: #400080;">UIColor</span><span style="color: #002200;">&#40;</span>red<span style="color: #002200;">:</span> red<span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, green<span style="color: #002200;">:</span> green<span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, blue<span style="color: #002200;">:</span> blue<span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, alpha<span style="color: #002200;">:</span> <span style="color: #2400d9;">1.0</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span> <span style="color: #a61390;">as</span> <span style="color: #a61390;">AnyObject</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>上面的代码, 你创建了一个梯度图层, 区域跟 <code>someView</code> 边界相匹配, 赋值了一个颜色数组, 设置了开始结束的坐标点, 并且把梯度图层添加到视图层级。 效果如下:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-91248 bordered" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-250x250.png 250w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-320x320.png 320w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-500x500.png 500w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-32x32.png 32w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-64x64.png 64w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-96x96.png 96w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer-128x128.png 128w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer.png 609w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>色彩缤纷! 下一步, 你要编一个蝴蝶的程序，然后飞出app，来到你的面前。 :]</p><br><p>Layer Player 提供控件来改变起始位置，颜色和位置:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91244 bordered" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer_5.5-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer_5.5-281x500.png 281w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAGradientLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><h2>示例6: CAReplicatorLayer</h2><br><p>CAReplicatorLayer 复制图层指定的次数, 用来创建一些很酷的效果。 </p><br><p>每个图层拷贝都有自己的颜色和定位改变, 并且它的绘制可以推迟到给所有的复制器图层一个动画效果。 深度可以保存给复制器图层一个3D效果。 这里是一个例子:</p><br><br><div class="wp_codebox"><table><tr id="p9048810"><td class="code" id="p90488code10"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// 1</span><br><span style="color: #a61390;">let</span> replicatorLayer <span style="color: #002200;">=</span> CAReplicatorLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>replicatorLayer.frame <span style="color: #002200;">=</span> someView.bounds<br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 2</span><br>replicatorLayer.instanceCount <span style="color: #002200;">=</span> <span style="color: #2400d9;">30</span><br>replicatorLayer.instanceDelay <span style="color: #002200;">=</span> CFTimeInterval<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">1</span> <span style="color: #002200;">/</span> <span style="color: #2400d9;">30.0</span><span style="color: #002200;">&#41;</span><br>replicatorLayer.preservesDepth <span style="color: #002200;">=</span> <span style="color: #a61390;">false</span><br>replicatorLayer.instanceColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.whiteColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 3</span><br>replicatorLayer.instanceRedOffset <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>replicatorLayer.instanceGreenOffset <span style="color: #002200;">=</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">0.5</span><br>replicatorLayer.instanceBlueOffset <span style="color: #002200;">=</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">0.5</span><br>replicatorLayer.instanceAlphaOffset <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 4</span><br><span style="color: #a61390;">let</span> angle <span style="color: #002200;">=</span> <span style="color: #a61390;">Float</span><span style="color: #002200;">&#40;</span>M_PI <span style="color: #002200;"><em></em></span> <span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> <span style="color: #2400d9;">30</span><br>replicatorLayer.instanceTransform <span style="color: #002200;">=</span> CATransform3DMakeRotation<span style="color: #002200;">&#40;</span><span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>angle<span style="color: #002200;">&#41;</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">1.0</span><span style="color: #002200;">&#41;</span><br>someView.layer.addSublayer<span style="color: #002200;">&#40;</span>replicatorLayer<span style="color: #002200;">&#41;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 5</span><br><span style="color: #a61390;">let</span> instanceLayer <span style="color: #002200;">=</span> <span style="color: #400080;">CALayer</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #a61390;">let</span> layerWidth<span style="color: #002200;">:</span> <span style="color: #400080;">CGFloat</span> <span style="color: #002200;">=</span> <span style="color: #2400d9;">10.0</span><br><span style="color: #a61390;">let</span> midX <span style="color: #002200;">=</span> CGRectGetMidX<span style="color: #002200;">&#40;</span>someView.bounds<span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span> layerWidth <span style="color: #002200;">/</span> <span style="color: #2400d9;">2.0</span><br>instanceLayer.frame <span style="color: #002200;">=</span> <span style="color: #400080;">CGRect</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> midX, y<span style="color: #002200;">:</span> <span style="color: #2400d9;">0.0</span>, width<span style="color: #002200;">:</span> layerWidth, height<span style="color: #002200;">:</span> layerWidth <span style="color: #002200;"></span> <span style="color: #2400d9;">3.0</span><span style="color: #002200;">&#41;</span><br>instanceLayer.backgroundColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.whiteColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>replicatorLayer.addSublayer<span style="color: #002200;">&#40;</span>instanceLayer<span style="color: #002200;">&#41;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 6</span><br><span style="color: #a61390;">let</span> fadeAnimation <span style="color: #002200;">=</span> <span style="color: #400080;">CABasicAnimation</span><span style="color: #002200;">&#40;</span>keyPath<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;opacity&quot;</span><span style="color: #002200;">&#41;</span><br>fadeAnimation.fromValue <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>fadeAnimation.toValue <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>fadeAnimation.duration <span style="color: #002200;">=</span> <span style="color: #2400d9;">1</span><br>fadeAnimation.repeatCount <span style="color: #002200;">=</span> <span style="color: #a61390;">Float</span><span style="color: #002200;">&#40;</span><span style="color: #a61390;">Int</span>.<span style="color: #a61390;">max</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// 7</span><br>instanceLayer.opacity <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>instanceLayer.addAnimation<span style="color: #002200;">&#40;</span>fadeAnimation, forKey<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;FadeAnimation&quot;</span><span style="color: #002200;">&#41;</span></pre></td></tr></table></div><br><br><p>上面的代码做了下面这些事:</p><br><ol><br><li>创建一个 CAReplicatorLayer 实例并且把区域设成 <code>someView</code> 的边界。 </li><br><li>设置复制器图层拷贝数 (<code>instanceCount</code>) 并且推迟绘制。设置复制器图层为 2D (<code>preservesDepth = false</code>) 同时设置它的实例颜色为白色。 </li><br><li>给连续的重复实例添加红绿蓝颜色值偏移量。 默认值都是0, 在所有实例有效保留颜色值。 然而, 这种情况下, 实例颜色最初设置为白色, 以为意味着红绿蓝都是 1.0 。 所以, 设置红色为 0 同时绿蓝偏移值为负数可以突出红色调。 同样的, 把alpha 偏移量设置到连续重复图层的 alpha 。 </li><br><li>创建一个变换实现圆形旋转。 </li><br><li>为复制器图层创建一个实例图层同时设置区域， 第一个实例会在中心 x 和  <code>someView</code>区域的顶部绘制。 这块代码同时设置实例的颜色，然后把实例图层添加到复制器图层。 </li><br><li>产生一个淡入淡出的动画，透明度从 1 到 0 。 </li><br><li>设置实例图层不透明度为0， 那么它就是透明的，直到每个实例被绘制，同时它的颜色和 alpha 值被设置。</li><br></ol><br><p>代码执行结果结果如下:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer.gif" width="250" height="250" class="aligncenter size-full wp-image-91334" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer.gif 250w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer-32x32.gif 32w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer-64x64.gif 64w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer-96x96.gif 96w, https://cdn3.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer-128x128.gif 128w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>Layer Player 包含了控件去操作大多的属性:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91349 bordered" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer_5.5-180x320.png 180w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer_5.5-281x500.png 281w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CAReplicatorLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><h2>示例7: CATiledLayer</h2><br><p>CATiledLayer 以瓷砖形式异步绘制图层内容。 对于大图或者内容很多你每次只需要看很小一块，这很有用, 因为你可以开始看你的内容而不是一次性把它们加入内存。</p><br><p>有个两个方式来处理绘制。 一种是重写 UIView ，使用 CATiledLayer 重复绘制瓷砖来填满视图的背景, 像这样:</p><br><br><div class="wp_codebox"><table><tr id="p9048811"><td class="code" id="p90488code11"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// In ViewController.swift</span><br><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> ViewController<span style="color: #002200;">:</span> <span style="color: #400080;">UIViewController</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  @IBOutlet weak <span style="color: #a61390;">var</span> tiledBackgroundView<span style="color: #002200;">:</span> TiledBackgroundView<span style="color: #002200;">!</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #11740a; font-style: italic;">// In TiledBackgroundView.swift</span><br><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> TiledBackgroundView<span style="color: #002200;">:</span> <span style="color: #400080;">UIView</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  <span style="color: #a61390;">let</span> sideLength <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span><span style="color: #2400d9;">50.0</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">class</span> <span style="color: #a61390;">func</span> layerClass<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; AnyClass <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> CATiledLayer.<span style="color: #a61390;">self</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 3</span><br>  required <span style="color: #a61390;">init</span><span style="color: #002200;">&#40;</span>coder aDecoder<span style="color: #002200;">:</span> <span style="color: #400080;">NSCoder</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.<span style="color: #a61390;">init</span><span style="color: #002200;">&#40;</span>coder<span style="color: #002200;">:</span> aDecoder<span style="color: #002200;">&#41;</span><br>    srand48<span style="color: #002200;">&#40;</span><span style="color: #a61390;">Int</span><span style="color: #002200;">&#40;</span><span style="color: #400080;">NSDate</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.timeIntervalSince1970<span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> layer <span style="color: #002200;">=</span> <span style="color: #a61390;">self</span>.layer <span style="color: #a61390;">as</span> CATiledLayer<br>    <span style="color: #a61390;">let</span> scale <span style="color: #002200;">=</span> UIScreen.mainScreen<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.scale<br>    layer.contentsScale <span style="color: #002200;">=</span> scale<br>    layer.tileSize <span style="color: #002200;">=</span> <span style="color: #400080;">CGSize</span><span style="color: #002200;">&#40;</span>width<span style="color: #002200;">:</span> sideLength <span style="color: #002200;"><em></em></span> scale, height<span style="color: #002200;">:</span> sideLength <span style="color: #002200;"></span> scale<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 4</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> drawRect<span style="color: #002200;">&#40;</span>rect<span style="color: #002200;">:</span> <span style="color: #400080;">CGRect</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">let</span> context <span style="color: #002200;">=</span> <span style="color: #400080;">UIGraphicsGetCurrentContext</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">var</span> red <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>drand48<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">var</span> green <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>drand48<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">var</span> blue <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>drand48<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    CGContextSetRGBFillColor<span style="color: #002200;">&#40;</span>context, red, green, blue, <span style="color: #2400d9;">1.0</span><span style="color: #002200;">&#41;</span><br>    CGContextFillRect<span style="color: #002200;">&#40;</span>context, rect<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>代码解释:</p><br><ol><br><li><code>tiledBackgroundView</code> 放置在 (150, 150) ，宽高都是 300. </li><br><li><code>layerClass()</code> 重写，视图图层被创建为 CATiledLayer 的实例。 </li><br><li><code>rand48()</code> 方法用来产生随机颜色用在 <code>drawRect()</code> 里。 然后扩展图层内容 (转换为 CATiledLayer) 来匹配屏幕的尺寸，接着设置大小。 </li><br><li>重写 <code>drawRect()</code> 来用随机颜色填充视图。</li><br></ol><br><p>最后, 上面的代码绘制了一个 6&#215;6 随机色的瓷砖, 像这样:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-91465" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-250x250.png 250w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-320x320.png 320w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-32x32.png 32w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-64x64.png 64w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-96x96.png 96w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer-128x128.png 128w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer.png 451w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>Layer Player 在瓷砖背景图上绘制了一条路径来详细说明这个用法:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91469 bordered" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer_5.5-180x320.png 180w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer_5.5-281x500.png 281w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><p>上面截图的星星在放大显示时会变的模糊不清:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-91473" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-250x250.png 250w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-320x320.png 320w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-32x32.png 32w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-64x64.png 64w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-96x96.png 96w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry-128x128.png 128w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomedBlurry.png 374w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>模糊度是细节色阶的结果，这个是图层维护的。 CATiledLayer 有两个属性 <code>levelsOfDetail</code> 和 <code>levelsOfDetailBias</code>. </p><br><p><code>levelsOfDetail</code>, 如它名字所说, 是图层维护的细节色阶数。 默认为0, 并且每次提升色阶会按以前色阶的一半的分辨率缓存。 <code>levelsOfDetail</code> 最大值是最低细节色阶至少是一个像素。 </p><br><p><code>levelsOfDetailBias</code>, 换种说法, 是图层缓存的 <i>magnified</i> 细节色阶的数量。 默认为0, 意味着没有额外的放大的色阶被缓存, 并且每次提升色阶将会按照先前色阶分辨率的两倍缓存。 </p><br><p>例如, 把上面模糊的瓷砖图层的 <code>levelsOfDetailBias</code> 值增加到 5，将会导致缓存色阶按照 2x, 4x, 8x, 16x 和 32x 放大, 缩放效果如下:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-91475" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-250x250.png 250w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-320x320.png 320w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-32x32.png 32w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-64x64.png 64w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-96x96.png 96w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed-128x128.png 128w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/CATiledLayerZoomed.png 374w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>很酷, 是不是? 不过等一等，还有更酷的! </p><br><p>Layer Player 包含了一个图形扩展，文件叫 <a href="https://github.com/scotteg/LayerPlayer/blob/master/LayerPlayer/UIImage%2BTileCutter.swift" title="UIImage+TileCutter.swift" target="_blank">UIImage+TileCutter.swift</a>. 辅导团队成员 <a href="http://www.raywenderlich.com/u/nicklockwood" title="Nick Lockwood" target="_blank" rel="external">Nick Lockwood</a> 为他的终端app改造了这个代码, 这个在他的书里提供了, <i>iOS Core Animation: Advanced Techniques</i>. </p><br><p>它的工作就是把源图像分成若干指定大小的方形图块, 根据每块图的行列位置命名; 例如, windingRoad_6_2.png 在 7列， 3行 (索引从0开始):</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/windingRoad.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/windingRoad-480x300.png" width="480" height="300" class="aligncenter size-medium wp-image-91653" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/windingRoad-480x300.png 480w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/windingRoad-700x437.png 700w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/windingRoad.png 1200w" sizes="(max-width: 480px) 100vw, 480px"></a></p><br><p>给这些图块放置位置, 自定义一个 UIView 子类可以用来绘制这些图块:</p><br><br><div class="wp_codebox"><table><tr id="p9048812"><td class="code" id="p90488code12"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> TilingViewForImage<span style="color: #002200;">:</span> <span style="color: #400080;">UIView</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  <span style="color: #a61390;">let</span> sideLength <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span><span style="color: #2400d9;">640.0</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> fileName <span style="color: #002200;">=</span> <span style="color: #bf1d1a;">&quot;windingRoad&quot;</span><br>  <span style="color: #a61390;">let</span> cachesPath <span style="color: #002200;">=</span> NSSearchPathForDirectoriesInDomains<span style="color: #002200;">&#40;</span>.CachesDirectory, .UserDomainMask, <span style="color: #a61390;">true</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#91;</span><span style="color: #2400d9;">0</span><span style="color: #002200;">&#93;</span> <span style="color: #a61390;">as</span> <span style="color: #a61390;">String</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">class</span> <span style="color: #a61390;">func</span> layerClass<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; AnyClass <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> CATiledLayer.<span style="color: #a61390;">self</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 3</span><br>  required <span style="color: #a61390;">init</span><span style="color: #002200;">&#40;</span>coder aDecoder<span style="color: #002200;">:</span> <span style="color: #400080;">NSCoder</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.<span style="color: #a61390;">init</span><span style="color: #002200;">&#40;</span>coder<span style="color: #002200;">:</span> aDecoder<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> layer <span style="color: #002200;">=</span> <span style="color: #a61390;">self</span>.layer <span style="color: #a61390;">as</span> CATiledLayer<br>    layer.tileSize <span style="color: #002200;">=</span> <span style="color: #400080;">CGSize</span><span style="color: #002200;">&#40;</span>width<span style="color: #002200;">:</span> sideLength, height<span style="color: #002200;">:</span> sideLength<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 4</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> drawRect<span style="color: #002200;">&#40;</span>rect<span style="color: #002200;">:</span> <span style="color: #400080;">CGRect</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">let</span> firstColumn <span style="color: #002200;">=</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#40;</span>CGRectGetMinX<span style="color: #002200;">&#40;</span>rect<span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> sideLength<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> lastColumn <span style="color: #002200;">=</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#40;</span>CGRectGetMaxX<span style="color: #002200;">&#40;</span>rect<span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> sideLength<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> firstRow <span style="color: #002200;">=</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#40;</span>CGRectGetMinY<span style="color: #002200;">&#40;</span>rect<span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> sideLength<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> lastRow <span style="color: #002200;">=</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#40;</span>CGRectGetMaxY<span style="color: #002200;">&#40;</span>rect<span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> sideLength<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    <span style="color: #a61390;">for</span> row <span style="color: #a61390;">in</span> firstRow…lastRow <span style="color: #002200;">&#123;</span><br>      <span style="color: #a61390;">for</span> column <span style="color: #a61390;">in</span> firstColumn…lastColumn <span style="color: #002200;">&#123;</span><br>        <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> tile <span style="color: #002200;">=</span> imageForTileAtColumn<span style="color: #002200;">&#40;</span>column, row<span style="color: #002200;">:</span> row<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>          <span style="color: #a61390;">let</span> x <span style="color: #002200;">=</span> sideLength <span style="color: #002200;"><em></em></span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>column<span style="color: #002200;">&#41;</span><br>          <span style="color: #a61390;">let</span> y <span style="color: #002200;">=</span> sideLength <span style="color: #002200;"></span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>row<span style="color: #002200;">&#41;</span><br>          <span style="color: #a61390;">let</span> point <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> x, y<span style="color: #002200;">:</span> y<span style="color: #002200;">&#41;</span><br>          <span style="color: #a61390;">let</span> size <span style="color: #002200;">=</span> <span style="color: #400080;">CGSize</span><span style="color: #002200;">&#40;</span>width<span style="color: #002200;">:</span> sideLength, height<span style="color: #002200;">:</span> sideLength<span style="color: #002200;">&#41;</span><br>          <span style="color: #a61390;">var</span> tileRect <span style="color: #002200;">=</span> <span style="color: #400080;">CGRect</span><span style="color: #002200;">&#40;</span>origin<span style="color: #002200;">:</span> point, size<span style="color: #002200;">:</span> size<span style="color: #002200;">&#41;</span><br>          tileRect <span style="color: #002200;">=</span> CGRectIntersection<span style="color: #002200;">&#40;</span>bounds, tileRect<span style="color: #002200;">&#41;</span><br>          tile.drawInRect<span style="color: #002200;">&#40;</span>tileRect<span style="color: #002200;">&#41;</span><br>        <span style="color: #002200;">&#125;</span><br>      <span style="color: #002200;">&#125;</span><br>    <span style="color: #002200;">&#125;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">func</span> imageForTileAtColumn<span style="color: #002200;">&#40;</span>column<span style="color: #002200;">:</span> <span style="color: #a61390;">Int</span>, row<span style="color: #002200;">:</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #400080;">UIImage</span>? <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">let</span> filePath <span style="color: #002200;">=</span> <span style="color: #bf1d1a;">&quot;<span style="color: #2400d9;">(</span>cachesPath)/<span style="color: #2400d9;">(</span>fileName)<em><span style="color: #2400d9;">(</span>column)</em><span style="color: #2400d9;">(</span>row)&quot;</span><br>    <span style="color: #a61390;">return</span> <span style="color: #400080;">UIImage</span><span style="color: #002200;">&#40;</span>contentsOfFile<span style="color: #002200;">:</span> filePath<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>上面的代码:</p><br><ol><br><li>为图块侧边长度创建属性, 再用图片文件名和缓存目录路径创建，后者是 TileCutter 扩展保存图块的地方。 saves tiles. </li><br><li>重写 <code>layerClass()</code> 返回 CATiledLayer. </li><br><li>实现  <code>init(_:)</code>, 在视图图层, 转换为图块图层并设置图块大小。 注意没有必要让 <code>contentsScale</code> 匹配屏幕大小, 因为你直接使用视图的支持图层与创建一个新的图层并且作为子图层添加进去。 </li><br><li>重写 <code>drawRect()</code> ，根据你行列位置绘制每个图块。</li><br></ol><br><p>然后子类型的视图, 和原始图像大小，可以加入滚动视图:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/XcodeTilingViewForImageStoryboard.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/XcodeTilingViewForImageStoryboard-480x286.png" width="480" height="286" class="aligncenter size-medium wp-image-91656" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/XcodeTilingViewForImageStoryboard-480x286.png 480w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/XcodeTilingViewForImageStoryboard-700x417.png 700w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/XcodeTilingViewForImageStoryboard.png 1235w" sizes="(max-width: 480px) 100vw, 480px"></a></p><br><p>就这样, 你现在有了黄油一样滑动大图的手感 (5120 x 3200 ), 感谢 CATiledLayer:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledImageLayer.gif" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATiledImageLayer.gif" width="332" height="500" class="aligncenter size-full wp-image-91663"></a></p><br><p>如你所见，上面的动画, 存在显著的变形当我们快速滚动的时候。 最小化这种影响可以使用更小的图块 (上述例子使用图块是 640 x 640) 然后创建一个CATiledLayer 的子类然后重写 <code>fadeDuration()</code>，让它返回 0:</p><br><br><div class="wp_codebox"><table><tr id="p9048813"><td class="code" id="p90488code13"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">class</span> TiledLayer<span style="color: #002200;">:</span> CATiledLayer <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">class</span> <span style="color: #a61390;">func</span> fadeDuration<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; CFTimeInterval <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> <span style="color: #2400d9;">0.0</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><h2>示例8: CAShapeLayer</h2><br><p>CAShapeLayer 使用可扩展的矢量路径去绘制, 这比使用图片要快很多。其他好处是你不用提供 @2x and @3x 尺寸的图片了。 爽!</p><br><p>此外, 在你处理定制线的粗细，颜色, dashing, 线的合并，都有很多属性, 如果线闭合成一个封闭区域, 并且这个区域需要填充某种颜色。 下面是个例子:</p><br><br><div class="wp_codebox"><table><tr id="p9048814"><td class="code" id="p90488code14"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> ViewController<span style="color: #002200;">:</span> <span style="color: #400080;">UIViewController</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  @IBOutlet weak <span style="color: #a61390;">var</span> someView<span style="color: #002200;">:</span> <span style="color: #400080;">UIView</span><span style="color: #002200;">!</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  <span style="color: #a61390;">let</span> rwColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span><span style="color: #002200;">&#40;</span>red<span style="color: #002200;">:</span> <span style="color: #2400d9;">11</span><span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, green<span style="color: #002200;">:</span> <span style="color: #2400d9;">86</span><span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, blue<span style="color: #002200;">:</span> <span style="color: #2400d9;">14</span><span style="color: #002200;">/</span><span style="color: #2400d9;">255.0</span>, alpha<span style="color: #002200;">:</span> <span style="color: #2400d9;">1.0</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> rwPath <span style="color: #002200;">=</span> <span style="color: #400080;">UIBezierPath</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> rwLayer <span style="color: #002200;">=</span> CAShapeLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">func</span> setUpRWPath<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    rwPath.moveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.22</span>, <span style="color: #2400d9;">124.79</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addLineToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.22</span>, <span style="color: #2400d9;">249.57</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addLineToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">124.89</span>, <span style="color: #2400d9;">249.57</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addLineToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">249.57</span>, <span style="color: #2400d9;">249.57</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addLineToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">249.57</span>, <span style="color: #2400d9;">143.79</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">249.37</span>, <span style="color: #2400d9;">38.25</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">249.57</span>, <span style="color: #2400d9;">85.64</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">249.47</span>, <span style="color: #2400d9;">38.15</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">206.47</span>, <span style="color: #2400d9;">112.47</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">249.27</span>, <span style="color: #2400d9;">38.35</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">229.94</span>, <span style="color: #2400d9;">71.76</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">163.46</span>, <span style="color: #2400d9;">186.84</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">182.99</span>, <span style="color: #2400d9;">153.19</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">163.61</span>, <span style="color: #2400d9;">186.65</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">146.17</span>, <span style="color: #2400d9;">156.99</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">163.27</span>, <span style="color: #2400d9;">187.03</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">155.48</span>, <span style="color: #2400d9;">173.59</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">128.79</span>, <span style="color: #2400d9;">127.08</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">136.82</span>, <span style="color: #2400d9;">140.43</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">129.03</span>, <span style="color: #2400d9;">126.94</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">109.31</span>, <span style="color: #2400d9;">157.77</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">128.59</span>, <span style="color: #2400d9;">127.18</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">119.83</span>, <span style="color: #2400d9;">141.01</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">89.83</span>, <span style="color: #2400d9;">187.86</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">98.79</span>, <span style="color: #2400d9;">174.52</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">90.02</span>, <span style="color: #2400d9;">188.06</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">56.52</span>, <span style="color: #2400d9;">108.28</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">89.24</span>, <span style="color: #2400d9;">187.23</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">56.56</span>, <span style="color: #2400d9;">109.11</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">64.02</span>, <span style="color: #2400d9;">102.25</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">56.47</span>, <span style="color: #2400d9;">107.75</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">59.24</span>, <span style="color: #2400d9;">105.56</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">101.42</span>, <span style="color: #2400d9;">67.57</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">81.99</span>, <span style="color: #2400d9;">89.78</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">93.92</span>, <span style="color: #2400d9;">78.72</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">108.38</span>, <span style="color: #2400d9;">30.65</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">110.28</span>, <span style="color: #2400d9;">54.47</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">113.01</span>, <span style="color: #2400d9;">39.96</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addCurveToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">10.35</span>, <span style="color: #2400d9;">0.41</span><span style="color: #002200;">&#41;</span>, controlPoint1<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">99.66</span>, <span style="color: #2400d9;">13.17</span><span style="color: #002200;">&#41;</span>, controlPoint2<span style="color: #002200;">:</span> CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">64.11</span>, <span style="color: #2400d9;">2.16</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addLineToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.22</span>, <span style="color: #2400d9;">0.07</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.addLineToPoint<span style="color: #002200;">&#40;</span>CGPointMake<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.22</span>, <span style="color: #2400d9;">124.79</span><span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    rwPath.closePath<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 3</span><br>  <span style="color: #a61390;">func</span> setUpRWLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    rwLayer.path <span style="color: #002200;">=</span> rwPath.CGPath<br>    rwLayer.fillColor <span style="color: #002200;">=</span> rwColor.<span style="color: #400080;">CGColor</span><br>    rwLayer.fillRule <span style="color: #002200;">=</span> kCAFillRuleNonZero<br>    rwLayer.lineCap <span style="color: #002200;">=</span> kCALineCapButt<br>    rwLayer.lineDashPattern <span style="color: #002200;">=</span> <span style="color: #a61390;">nil</span><br>    rwLayer.lineDashPhase <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>    rwLayer.lineJoin <span style="color: #002200;">=</span> kCALineJoinMiter<br>    rwLayer.lineWidth <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>    rwLayer.miterLimit <span style="color: #002200;">=</span> <span style="color: #2400d9;">10.0</span><br>    rwLayer.strokeColor <span style="color: #002200;">=</span> rwColor.<span style="color: #400080;">CGColor</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>    <span style="color: #11740a; font-style: italic;">// 4</span><br>    setUpRWPath<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    setUpRWLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    someView.layer.addSublayer<span style="color: #002200;">&#40;</span>rwLayer<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>代码讲解:</p><br><ol><br><li>创建颜色, 路径, 和形状图层对象。</li><br><li>绘制形状图层的路径。 如果你不想写样板代码, 取出 <a href="http://www.paintcodeapp.com" target="_blank" rel="external">PaintCode</a>; 它通过控件或者输入存在的矢量图或者psd文件来生成代码。 </li><br><li>建立形状图层。 路径设置成第二部绘制的路径的 CGPath , 填充颜色为第一步创建的颜色的 CGColor , 填充规则显示设置成非零默认值。<br><ul><br><li>其他唯一选项是奇偶数, 对于这个形状来说，没有交叉路径，填充规则没有太大区别。 </li><br><li>非零规则数 left-to-right 路径 +1 ， right-to-left 路径 -1; 它合计所有路径值，如果总数大于 0 , 它用这些路径填充这些形状。 </li><br><li>本质上, 非零填充形状内部所有点。 </li><br><li>奇偶规则计算构成图形 <i>交叉路径</i> 的总数，并且，如果技术是奇数, 形状被填充。 这绝对是一张图胜过一千个单词。 </li><br><p>构成五边形的奇偶图表交叉路径数目是偶数, 因此五角星没有被填充, 构成三角形的交叉路径数是奇数, 所以三角形被填充了。<br><br><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayerFillRules.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayerFillRules-480x256.png" width="480" height="256" class="aligncenter size-medium wp-image-91890" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayerFillRules-480x256.png 480w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayerFillRules.png 676w" sizes="(max-width: 480px) 100vw, 480px"></a></p></ul></li><br><li>调用路径绘制和图层建立的代码, 然后把图层添加到视图层级中。 </li><br></ol><br><p>这个代码绘制了 raywenderlich.com 的标志图:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-91840" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-250x250.png 250w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-320x320.png 320w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-32x32.png 32w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-64x64.png 64w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-96x96.png 96w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo-128x128.png 128w, https://cdn5.raywenderlich.com/wp-content/uploads/2014/12/RayWenderlichLogo.png 377w" sizes="(max-width: 250px) 100vw, 250px"></a></p><br><p>假使你很好奇想知道在 <a href="http://www.paintcodeapp.com" target="_blank" rel="external">PaintCode</a> 中这个绘制看起来是:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/PaintCodeRayWenderlichLogo.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/PaintCodeRayWenderlichLogo-480x265.png" width="480" height="265" class="aligncenter size-medium wp-image-91841" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/PaintCodeRayWenderlichLogo-480x265.png 480w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/PaintCodeRayWenderlichLogo-700x387.png 700w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/PaintCodeRayWenderlichLogo.png 1280w" sizes="(max-width: 480px) 100vw, 480px"></a></p><br><p>Layer Player 包含很多控件去操作 CAShapeLayer 的多数属性:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91843 bordered" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayer_5.5-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayer_5.5-281x500.png 281w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CAShapeLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><div class="note"><br><p><em>备注</em>: 你可能注意到我们跳过了 Layer Player 应用上的下一个示例。 这是因为 CAEAGLLayer 被 CAMetalLayer 淘汰了, 后者跟着 Metal 框架一起在 iOS 8 发布。 你可以在 <a href="http://www.raywenderlich.com/77488/ios-8-metal-tutorial-swift-getting-started" title="iOS 8 Metal Tutorial with Swift: Getting Started" target="_blank" rel="external">这里</a> 找到很棒的 CAMetalLayer 辅导材料。</p><br></div><br><h2>示例9: CATransformLayer</h2><br><p>CATransformLayer 处理 3D 结构很便捷。 它实际上是子图层的容器, 每个子图层都有自己的变换和不透明变化, 不过, 它会忽略其他渲染图层属性的变化, 比如 边框宽度和颜色。 </p><br><p>你不能直接对变换图层做点击测试, 因为它没有 2D 的坐标空间去匹配触摸点, 不过, 可以对独立的子图层做点击测试。 这儿是例子:</p><br><br><div class="wp_codebox"><table><tr id="p9048815"><td class="code" id="p90488code15"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> ViewController<span style="color: #002200;">:</span> <span style="color: #400080;">UIViewController</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  @IBOutlet weak <span style="color: #a61390;">var</span> someView<span style="color: #002200;">:</span> <span style="color: #400080;">UIView</span><span style="color: #002200;">!</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  <span style="color: #a61390;">let</span> sideLength <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span><span style="color: #2400d9;">160.0</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> redColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.redColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> orangeColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.orangeColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> yellowColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.yellowColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> greenColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.greenColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> blueColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.blueColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> purpleColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.purpleColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">var</span> transformLayer <span style="color: #002200;">=</span> CATransformLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">func</span> setUpTransformLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">var</span> layer <span style="color: #002200;">=</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>redColor<span style="color: #002200;">&#41;</span><br>    transformLayer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    layer <span style="color: #002200;">=</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>orangeColor<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">var</span> transform <span style="color: #002200;">=</span> CATransform3DMakeTranslation<span style="color: #002200;">&#40;</span>sideLength <span style="color: #002200;">/</span> <span style="color: #2400d9;">2.0</span>, <span style="color: #2400d9;">0.0</span>, sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DRotate<span style="color: #002200;">&#40;</span>transform, degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">90.0</span><span style="color: #002200;">&#41;</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">1.0</span>, <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span><br>    layer.transform <span style="color: #002200;">=</span> transform<br>    transformLayer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    layer <span style="color: #002200;">=</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>yellowColor<span style="color: #002200;">&#41;</span><br>    layer.transform <span style="color: #002200;">=</span> CATransform3DMakeTranslation<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #002200;">-</span>sideLength<span style="color: #002200;">&#41;</span><br>    transformLayer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    layer <span style="color: #002200;">=</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>greenColor<span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DMakeTranslation<span style="color: #002200;">&#40;</span>sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span>, <span style="color: #2400d9;">0.0</span>, sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DRotate<span style="color: #002200;">&#40;</span>transform, degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">90.0</span><span style="color: #002200;">&#41;</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">1.0</span>, <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span><br>    layer.transform <span style="color: #002200;">=</span> transform<br>    transformLayer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    layer <span style="color: #002200;">=</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>blueColor<span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DMakeTranslation<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.0</span>, sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span>, sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DRotate<span style="color: #002200;">&#40;</span>transform, degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">90.0</span><span style="color: #002200;">&#41;</span>, <span style="color: #2400d9;">1.0</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span><br>    layer.transform <span style="color: #002200;">=</span> transform<br>    transformLayer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    layer <span style="color: #002200;">=</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>purpleColor<span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DMakeTranslation<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.0</span>, sideLength <span style="color: #002200;">/</span> <span style="color: #2400d9;">2.0</span>, sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><span style="color: #002200;">&#41;</span><br>    transform <span style="color: #002200;">=</span> CATransform3DRotate<span style="color: #002200;">&#40;</span>transform, degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">90.0</span><span style="color: #002200;">&#41;</span>, <span style="color: #2400d9;">1.0</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span><br>    layer.transform <span style="color: #002200;">=</span> transform<br>    transformLayer.addSublayer<span style="color: #002200;">&#40;</span>layer<span style="color: #002200;">&#41;</span><br>&nbsp;<br>    transformLayer.anchorPointZ <span style="color: #002200;">=</span> sideLength <span style="color: #002200;">/</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">2.0</span><br>    applyRotationForXOffset<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">16.0</span>, yOffset<span style="color: #002200;">:</span> <span style="color: #2400d9;">16.0</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 3</span><br>  <span style="color: #a61390;">func</span> sideLayerWithColor<span style="color: #002200;">&#40;</span>color<span style="color: #002200;">:</span> <span style="color: #400080;">UIColor</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #400080;">CALayer</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">let</span> layer <span style="color: #002200;">=</span> <span style="color: #400080;">CALayer</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    layer.frame <span style="color: #002200;">=</span> <span style="color: #400080;">CGRect</span><span style="color: #002200;">&#40;</span>origin<span style="color: #002200;">:</span> CGPointZero, size<span style="color: #002200;">:</span> <span style="color: #400080;">CGSize</span><span style="color: #002200;">&#40;</span>width<span style="color: #002200;">:</span> sideLength, height<span style="color: #002200;">:</span> sideLength<span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    layer.position <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> CGRectGetMidX<span style="color: #002200;">&#40;</span>someView.bounds<span style="color: #002200;">&#41;</span>, y<span style="color: #002200;">:</span> CGRectGetMidY<span style="color: #002200;">&#40;</span>someView.bounds<span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>    layer.backgroundColor <span style="color: #002200;">=</span> color.<span style="color: #400080;">CGColor</span><br>    <span style="color: #a61390;">return</span> layer<br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">func</span> degreesToRadians<span style="color: #002200;">&#40;</span>degrees<span style="color: #002200;">:</span> <span style="color: #a61390;">Double</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #400080;">CGFloat</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>degrees <span style="color: #002200;"><em></em></span> M_PI <span style="color: #002200;">/</span> <span style="color: #2400d9;">180.0</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 4</span><br>  <span style="color: #a61390;">func</span> applyRotationForXOffset<span style="color: #002200;">&#40;</span>xOffset<span style="color: #002200;">:</span> <span style="color: #a61390;">Double</span>, yOffset<span style="color: #002200;">:</span> <span style="color: #a61390;">Double</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">let</span> totalOffset <span style="color: #002200;">=</span> sqrt<span style="color: #002200;">&#40;</span>xOffset <span style="color: #002200;"></span> xOffset <span style="color: #002200;">+</span> yOffset <span style="color: #002200;"><em></em></span> yOffset<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> totalRotation <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>totalOffset <span style="color: #002200;"></span> M_PI <span style="color: #002200;">/</span> <span style="color: #2400d9;">180.0</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> xRotationalFactor <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>totalOffset<span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> totalRotation<br>    <span style="color: #a61390;">let</span> yRotationalFactor <span style="color: #002200;">=</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>totalOffset<span style="color: #002200;">&#41;</span> <span style="color: #002200;">/</span> totalRotation<br>    <span style="color: #a61390;">let</span> currentTransform <span style="color: #002200;">=</span> CATransform3DTranslate<span style="color: #002200;">&#40;</span>transformLayer.sublayerTransform, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">0.0</span>, <span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">let</span> rotationTransform <span style="color: #002200;">=</span> CATransform3DRotate<span style="color: #002200;">&#40;</span>transformLayer.sublayerTransform, totalRotation,<br>      xRotationalFactor <span style="color: #002200;"><em></em></span> currentTransform.m12 <span style="color: #002200;">-</span> yRotationalFactor <span style="color: #002200;"></span> currentTransform.m11,<br>      xRotationalFactor <span style="color: #002200;"><em></em></span> currentTransform.m22 <span style="color: #002200;">-</span> yRotationalFactor <span style="color: #002200;"></span> currentTransform.m21,<br>      xRotationalFactor <span style="color: #002200;"><em></em></span> currentTransform.m32 <span style="color: #002200;">-</span> yRotationalFactor <span style="color: #002200;"></span> currentTransform.m31<span style="color: #002200;">&#41;</span><br>    transformLayer.sublayerTransform <span style="color: #002200;">=</span> rotationTransform<br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 5</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> touchesBegan<span style="color: #002200;">&#40;</span>touches<span style="color: #002200;">:</span> <span style="color: #400080;">NSSet</span>, withEvent event<span style="color: #002200;">:</span> <span style="color: #400080;">UIEvent</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> location <span style="color: #002200;">=</span> touches.anyObject<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>?.locationInView<span style="color: #002200;">&#40;</span>someView<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>      <span style="color: #a61390;">for</span> layer <span style="color: #a61390;">in</span> transformLayer.sublayers <span style="color: #002200;">&#123;</span><br>        <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> hitLayer <span style="color: #002200;">=</span> layer.hitTest<span style="color: #002200;">&#40;</span>location<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>          <span style="color: #a61390;">println</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Transform layer tapped!&quot;</span><span style="color: #002200;">&#41;</span><br>          break<br>        <span style="color: #002200;">&#125;</span><br>      <span style="color: #002200;">&#125;</span><br>    <span style="color: #002200;">&#125;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>    <span style="color: #11740a; font-style: italic;">// 6</span><br>    setUpTransformLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    someView.layer.addSublayer<span style="color: #002200;">&#40;</span>transformLayer<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>上面的代码做了以下的事:</p><br><ol><br><li>创建边长属性, 正方体各边的颜色, 和变换图层。 </li><br><li>通过创建, 旋转和添加每个面到变换图层来构建正方体。 然后它会设置变换图层的z轴锚点，旋转正方体然后添加到视图层级中。 </li><br><li>创建辅助代码，用指定颜色来创建正方体的每个面, 然后把角度转换为弧度。 为什么用弧度? 简单来说，因为我发现用角度比用弧度更直观。 </li><br><li>基于 x 和 y 偏移来使用旋转。 注意这个代码变换设置为 <code>sublayerTransform</code>, 这会应用到变换图层的子图层。 </li><br><li>通过变换图层的子图层来观察触摸和循环。 这部分点击测试每个图层，一旦检测到点击立即中断测试, 因为没有必要去测试剩余的图层。 </li><br><li>建立转换图层并把它添加到视图层级中。</li><br></ol><br><div class="note"><br><p><em>备注</em>: 这些 <code>currentTransform.m##</code> 是什么鬼? 我很高兴你问到这个问题。 这些都是 CATransform3D 的属性， 表示矩阵的元素, 这个矩阵由一个行列矩形数组构成。<br></p><br><p>想要学习更多用在本例的矩阵变换, 可以下载 <a href="https://github.com/jrturton/3DTransformFun" title="3DTransform Fun" target="_blank">3DTransformFun project</a> , 这是由辅导小组成员 <a href="http://www.raywenderlich.com/u/jrturton" title="Rich Turton" target="_blank" rel="external">Rich Turton</a> 提供， 还有这个 <a href="https://github.com/mpospese/EnterTheMatrix" title="Enter The Matrix" target="_blank">Enter The Matrix project</a> 由 Mark Pospesel 提供。<br></p><br></div><br><p>运行上面的代码，用一个 250 x 250 的视图 <code>someView</code> 会有下面的结果:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer-250x250.png" width="250" height="250" class="aligncenter size-thumbnail wp-image-91859" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer-250x250.png 250w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer-32x32.png 32w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer-64x64.png 64w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer-96x96.png 96w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer-128x128.png 128w, https://cdn4.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer.png 306w" sizes="(max-width: 250px) 100vw, 250px"></p><br><p>现在, 尝试一些东西: 点击正方体任何地方, &#8220;Transform layer tapped!&#8221; 都会被打印到控制台。 </p><br><p>Layer Player 包含开关去切换每一个子图层的不透明度,  <a href="http://bill.dudney.net/roller/objc/entry/trackball_3d_transforms_made_easy" title="TrackBall - 3D transforms made easy" target="_blank">TrackBall utility from Bill Dudney</a>, <a href="https://github.com/scotteg/TrackBall" title="Swift port of Bill Dudney's original TrackBall Objective-C source code" target="_blank">ported to Swift</a>, 这些使得基于用户手势应用 3D 变换更加简单:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-91862 bordered" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer_5.5-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer_5.5-281x500.png 281w, https://cdn2.raywenderlich.com/wp-content/uploads/2014/12/CATransformLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><h2>示例10: CAEmitterLayer</h2><br><p>CAEmitterLayer 渲染 CAEmitterCell 实例的动态颗粒。CAEmitterLayer 和 CAEmitterCell 都有属性可以去改变渲染的速率, 尺寸, 形状, 颜色, 速度, 生命周期和其他更多。 实例如下:</p><br><br><div class="wp_codebox"><table><tr id="p9048816"><td class="code" id="p90488code16"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">import</span> UIKit<br>&nbsp;<br><span style="color: #a61390;">class</span> ViewController<span style="color: #002200;">:</span> <span style="color: #400080;">UIViewController</span> <span style="color: #002200;">&#123;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 1</span><br>  <span style="color: #a61390;">let</span> emitterLayer <span style="color: #002200;">=</span> CAEmitterLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> emitterCell <span style="color: #002200;">=</span> CAEmitterCell<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 2</span><br>  <span style="color: #a61390;">func</span> setUpEmitterLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    emitterLayer.frame <span style="color: #002200;">=</span> view.bounds<br>    emitterLayer.seed <span style="color: #002200;">=</span> UInt32<span style="color: #002200;">&#40;</span><span style="color: #400080;">NSDate</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.timeIntervalSince1970<span style="color: #002200;">&#41;</span><br>    emitterLayer.renderMode <span style="color: #002200;">=</span> kCAEmitterLayerAdditive<br>    emitterLayer.drawsAsynchronously <span style="color: #002200;">=</span> <span style="color: #a61390;">true</span><br>    setEmitterPosition<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 3</span><br>  <span style="color: #a61390;">func</span> setUpEmitterCell<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    emitterCell.contents <span style="color: #002200;">=</span> <span style="color: #400080;">UIImage</span><span style="color: #002200;">&#40;</span>named<span style="color: #002200;">:</span> <span style="color: #bf1d1a;">&quot;smallStar&quot;</span><span style="color: #002200;">&#41;</span>?.CGImage<br>&nbsp;<br>    emitterCell.velocity <span style="color: #002200;">=</span> <span style="color: #2400d9;">50.0</span><br>    emitterCell.velocityRange <span style="color: #002200;">=</span> <span style="color: #2400d9;">500.0</span><br>&nbsp;<br>    emitterCell.color <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.blackColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span>.<span style="color: #400080;">CGColor</span><br>    emitterCell.redRange <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>    emitterCell.greenRange <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>    emitterCell.blueRange <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>    emitterCell.alphaRange <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>    emitterCell.redSpeed <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>    emitterCell.greenSpeed <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>    emitterCell.blueSpeed <span style="color: #002200;">=</span> <span style="color: #2400d9;">0.0</span><br>    emitterCell.alphaSpeed <span style="color: #002200;">=</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">0.5</span><br>&nbsp;<br>    <span style="color: #a61390;">let</span> zeroDegreesInRadians <span style="color: #002200;">=</span> degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.0</span><span style="color: #002200;">&#41;</span><br>    emitterCell.spin <span style="color: #002200;">=</span> degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">130.0</span><span style="color: #002200;">&#41;</span><br>    emitterCell.spinRange <span style="color: #002200;">=</span> zeroDegreesInRadians<br>    emitterCell.emissionRange <span style="color: #002200;">=</span> degreesToRadians<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">360.0</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>    emitterCell.lifetime <span style="color: #002200;">=</span> <span style="color: #2400d9;">1.0</span><br>    emitterCell.birthRate <span style="color: #002200;">=</span> <span style="color: #2400d9;">250.0</span><br>    emitterCell.xAcceleration <span style="color: #002200;">=</span> <span style="color: #002200;">-</span><span style="color: #2400d9;">800.0</span><br>    emitterCell.yAcceleration <span style="color: #002200;">=</span> <span style="color: #2400d9;">1000.0</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 4</span><br>  <span style="color: #a61390;">func</span> setEmitterPosition<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    emitterLayer.emitterPosition <span style="color: #002200;">=</span> <span style="color: #400080;">CGPoint</span><span style="color: #002200;">&#40;</span>x<span style="color: #002200;">:</span> CGRectGetMidX<span style="color: #002200;">&#40;</span>view.bounds<span style="color: #002200;">&#41;</span>, y<span style="color: #002200;">:</span> CGRectGetMidY<span style="color: #002200;">&#40;</span>view.bounds<span style="color: #002200;">&#41;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">func</span> degreesToRadians<span style="color: #002200;">&#40;</span>degrees<span style="color: #002200;">:</span> <span style="color: #a61390;">Double</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #400080;">CGFloat</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> <span style="color: #400080;">CGFloat</span><span style="color: #002200;">&#40;</span>degrees <span style="color: #002200;">*</span> M_PI <span style="color: #002200;">/</span> <span style="color: #2400d9;">180.0</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>&nbsp;<br>    <span style="color: #11740a; font-style: italic;">// 5</span><br>    setUpEmitterLayer<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    setUpEmitterCell<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>    emitterLayer.emitterCells <span style="color: #002200;">=</span> <span style="color: #002200;">&#91;</span>emitterCell<span style="color: #002200;">&#93;</span><br>    view.layer.addSublayer<span style="color: #002200;">&#40;</span>emitterLayer<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  <span style="color: #11740a; font-style: italic;">// 6</span><br>  <span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> traitCollectionDidChange<span style="color: #002200;">&#40;</span>previousTraitCollection<span style="color: #002200;">:</span> UITraitCollection?<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    setEmitterPosition<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br><br><p>上面的代码做了下面的事情:</p><br><ol><br><li>创建发射器图层和单元格。<br></li><li>通过如下方式建立发射器图层:<br><ul><br><li>为图层随机送产生器提供种子，产生器会为图层的发射器单元格随机生成某种属性, 比如速度。 下面的注释会做进一步解释。 </li><br><li>在上面图层的背景色和边框上渲染发射器单元, 使用命令由 <code>renderMode</code> 指定。<br><div class="note"><br><p><em>备注</em>:  目前苹果的文档错误的指出, 这个属性值定义在 Emitter Modes 下。 而实际上, renderMode 的值定义在 Emitter Render Order 下。 默认值是无序的, 额外的选项包括 oldest first, oldest last, back to front 和 additive. </p><br></div><br></li><br><li>把 <code>drawsAsynchronously</code> 设置成 <code>true</code>, 这个可以提升性能, 因为发射器图层必须连续重绘发射单元。 </li><br><li>下一步, 发射位置通过辅助方法设置- 注释4了解更多。 这是好例子去学习如何把 <code>drawsAsynchronously</code> 设置成 <code>true</code> , 这会提升性能并使动画更平顺。</li><br></ul><br></li><li>这块做了很多事!<br><ul><br><li>给发射单元设置图片作为内容 (这个图片在 Layer Player 工程里可以用)。 </li><br><li>然后指定了初始速度和最大方差 (<code>velocityRange</code>); 发射图层使用上述的种子创建一个随机数生成器，这个发射器在 (初始值 +/- 范围值) 之内生成随机数。 随机发生在 <em>Range</em> 结尾的任何属性上。</li><br><li>颜色设置成黑色, 允许方差 (下面讨论) 从默认白色改变, 白色会产生明亮的颗粒。 </li><br><li>接下来设置一系列颜色, 对 <code>velocityRange</code> 使用相同的随机化, 这个时候为每个颜色指定方差的范围。 种子值在单元生命周期控制每个颜色的变化速度。 </li><br><li>下一步, 第三块代码指出怎样围绕一个循环的圆锥体发射单元格。 更多细节: 它设置了发射单元的旋转速度和发射范围。 此外, 发射范围决定发射单元如何围绕圆锥体发射, 这个值定义在 <code>emissionRange</code> , 用弧度指定。<br></li><li>设置单元格生命周期为 1 秒。 这个属性默认值是 0, 所以如果你不显示的设置这个值, 单元格永远不会出现! 对 <code>birthRate</code> (每秒) 也是一样; 默认值也是 0, 因此这个值必须设置成某个整数来保证单元格会出现。<br></li><li>最后, 单元 x 和 y 加速被设置; 这些值影响颗粒发射的视觉角度。</li><br></ul><br></li><li>把角度转换为弧度, 把发射单元位置设置到视图的中心。<br></li><li>建立发射图层和单元, 然后把单元格添加到图层,再把图层加到视图层级中。<br></li></ol><br><p>爽! 我知道这个信息量太大, 不过你坚韧灵活。</p><br><p>代码运行结果提醒我这些 <a href="https://www.youtube.com/watch?v=oT0JWGPXnTg" title="Sean Hayes - The More You Know Commercial" target="_blank">The More You Know</a> 商业广告:</p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAEmitterLayer2.gif" width="350" height="242" class="aligncenter size-full wp-image-92125"></p><br><p>Layer Player 包含控件来调整所有上面提到的属性, 还多了几个:</p><br><p><a href="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAEmitterLayer_5.5.png" target="_blank" rel="external"><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/CAEmitterLayer_5.5-180x320.png" width="180" height="320" class="aligncenter size-medium wp-image-92127 bordered" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CAEmitterLayer_5.5-180x320.png 180w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CAEmitterLayer_5.5-281x500.png 281w, https://cdn1.raywenderlich.com/wp-content/uploads/2014/12/CAEmitterLayer_5.5.png 1242w" sizes="(max-width: 180px) 100vw, 180px"></a></p><br><p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/12/victorious-e1419192669236.png" width="147" height="300" class="alignright size-full wp-image-92137"></p><br><br><br></html>
]]></content>
    
    <summary type="html">
    
      &lt;html lang=&quot;en-US&quot; class=&quot;no-js windows&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;link rel=&quot;stylesheet&quot; id=&quot;wpsqt-main-css&quot; href=&quot;https://cdn3.raywenderlich.com/wp-content/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIStackView 使用指南</title>
    <link href="http://yoursite.com/2016/09/14/UIStackView-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2016/09/14/UIStackView-使用指南/</id>
    <published>2016-09-14T07:14:17.000Z</published>
    <updated>2016-09-19T08:38:23.000Z</updated>
    
    <content type="html"><![CDATA[<p></p>
<p><link rel="stylesheet" id="wpsqt-main-css" href="https://cdn3.raywenderlich.com/wp-content/plugins/wp-survey-and-quiz-tool/css/main.css?ver=4.5.2" type="text/css" media="all"></p>
<p><link rel="stylesheet" id="style-main-css" href="https://cdn4.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1471520796" type="text/css" media="all"></p>
<link rel="stylesheet" id="contact-form-7-css" href="https://cdn1.raywenderlich.com/wp-content/plugins/contact-form-7/includes/css/styles.css?ver=4.4.1" type="text/css" media="all">

<div id="attachment_114189" style="width: 260px" class="wp-caption alignright"><img class="wp-image-114189 size-thumbnail" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-250x250.jpg" width="250" height="250" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-250x250.jpg 250w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-320x320.jpg 320w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView.jpg 500w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-32x32.jpg 32w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-64x64.jpg 64w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-96x96.jpg 96w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/iOS9_feast_UIStackView-128x128.jpg 128w" sizes="(max-width: 250px) 100vw, 250px"><p class="wp-caption-text">你肯定想知道在使用堆栈视图前是怎么挺过来的!</p></div><br><p>我们都遇见过。 有个需要动态增删视图的新需求, 也需要重新定位临近视图。</p><br><p>你用什么方法? 你通过在故事板添加outlets来约束实现激活或者去激活这些视图? 或者用第三方库? 或者根据复杂度你会在代码实现。</p><br><p>现在介绍 <code>UIStackView</code>,  Stack 视图提供了一种方式去水平或者垂直布局一组视图。 通过配置一些简单的属性例如对齐方式,分布方式,间隔, 你可以在可用空间里定义包含的视图该如何调整布局。</p><br><br><h2>开始</h2><br><p>这篇 UIStackView 指导, 你会工作在一个叫<em>Vacation Spots</em>的程序. 这是个简单的程序，向你展示一系列的地方，让你远离当下一切。</p><br><p>现在先别打包行囊, 因为有一些问题你要用堆栈视图来修复, 肯定比你用 Auto Layout简单的多。</p><br><p>先下载 <a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip" target="_blank" rel="external">开始工程</a> 在 <em>iPhone 6 Simulator</em>上运行。 你会看你一堆你可以去旅行的地方。</p><br><p><img class="aligncenter size-large wp-image-114555 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/01-table-view-is-now-correct_750x1334-281x500.png" width="281" height="500" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/01-table-view-is-now-correct_750x1334-281x500.png 281w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/01-table-view-is-now-correct_750x1334-180x320.png 180w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/01-table-view-is-now-correct_750x1334.png 750w" sizes="(max-width: 281px) 100vw, 281px"></p><br><p>点击 <em>London</em> 单元可以查看伦敦的详情。</p><br><p>扫一眼, 这个界面看起来还okay, 但是有一些问题。</p><br><ol start="1"><br><li>看一下位于界面底部的按钮行。 他们之间现在是固定间距的位置, 所以他们没有适配屏幕的宽度。 为了看到问题, <em>Command-left</em> 旋转屏幕看看。</li><br></ol><br><p><img class="aligncenter size-medium wp-image-114556 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750-480x270.png" width="480" height="270" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750-480x270.png 480w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750-700x394.png 700w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750-266x151.png 266w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/02-issues-visible-in-landscape-view_1334x750.png 1334w" sizes="(max-width: 480px) 100vw, 480px"></p><br><ol start="2"><br><li>点击靠近 <em>WEATHER</em> 的 <em>Hide</em> 按钮. 它可以隐藏文字, 可是它不能复位位于它下面的区域, 留下了一块空白。</li><br></ol><br><p><img class="aligncenter size-large wp-image-114557 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/03-hide-weather-issue_750x1334-281x500.png" width="281" height="500" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/03-hide-weather-issue_750x1334-281x500.png 281w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/03-hide-weather-issue_750x1334-180x320.png 180w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/03-hide-weather-issue_750x1334.png 750w" sizes="(max-width: 281px) 100vw, 281px"></p><br><ol start="3"><br><li>区域顺序可以调整。 <em>what to see</em> 区域刚好位于 <em>why visit</em> 下方可能更合逻辑, 而是不是有个 <em>weather</em> 在两者中间。</li><br><li>横屏的时候,底面的按钮组太靠近页面边界了。 减少不同区域的间距可能会比较好 – 仅在横屏模式下。</li><br></ol><br><p>既然有了改进的想法, 是时候研究工程了。</p><br><p>打开 <em>Main.storyboard</em> 看一下 <em>Spot Info View Controller</em> scene。 有一些颜色在你的堆栈视图。</p><br><p><img class="aligncenter size-large wp-image-114558 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/04-colorful-scene-in-storyboard_504x636-396x500.png" width="396" height="500" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/04-colorful-scene-in-storyboard_504x636-396x500.png 396w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/04-colorful-scene-in-storyboard_504x636-254x320.png 254w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/04-colorful-scene-in-storyboard_504x636.png 504w" sizes="(max-width: 396px) 100vw, 396px"></p><br><p>这些标签和按钮设置了太多的背景色,在运行时将要被清除。 在这个故事板, 他们只是用来视觉展示如何通过改变属性值影响内嵌视图的frame。</p><br><p>你现在不需要做这些, 但是如果你想在运行时看到这些背景色,可以在 <code>SpotInfoViewController</code>里放开<code>viewDidLoad()</code>下面的代码。</p><br><br><div class="wp_codebox"><table><tr id="p1145521"><td class="code" id="p114552code1"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// Clear background colors from labels and buttons</span><br><span style="color: #a61390;">for</span> view <span style="color: #a61390;">in</span> backgroundColoredViews <span style="color: #002200;">&#123;</span><br>  view.backgroundColor <span style="color: #002200;">=</span> <span style="color: #400080;">UIColor</span>.clearColor<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>同时, 任何outlet-connected的标签都设置成他们关联的outlet名字。 这个比较容易区分哪个标签运行时更新了文字。 例如,  <em>&lt;</em><em>whyVisitLabel&gt;</em> 关联到:</p>

<div class="wp_codebox"><table><tr id="p1145522"><td class="code" id="p114552code2"><pre class="swift" style="font-family:monospace;">@IBOutlet weak <span style="color: #a61390;">var</span> whyVisitLabel<span style="color: #002200;">:</span> <span style="color: #400080;">UILabel</span><span style="color: #002200;">!</span></pre></td></tr></table></div>

<p>另外需要注意的是故事板里的scenes 不是默认的 600 x 600。</p><br><p>Size classes 仍然可以用, 但是初始的导航控制器已经设置成 <em>iPhone 4-inch</em> ,在 <em>Attributes inspector</em>的<em>Simulated Metrics</em> 区域。 这个仅仅为了跟故事板配合使用更容易一些; simulated metrics 属性不影响运行 — 视图会根据不同设备自动调整尺寸。</p><br><p><img class="aligncenter size-full wp-image-114559 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/05-simulated-metrics-iphone-4-inch_639x173.png" width="639" height="173" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/05-simulated-metrics-iphone-4-inch_639x173.png 639w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/05-simulated-metrics-iphone-4-inch_639x173-480x130.png 480w" sizes="(max-width: 639px) 100vw, 639px"></p><br><h2>你的第一个堆栈视图</h2><br><p>使用堆栈视图首先要修复的问题是底部按钮行的间距。一个堆栈视图可以沿着坐标轴用很多方式分布他的视图, 其中之一就是使视图之间有相等的间距。</p><br><p>幸运的是, 在一个新堆栈视图中嵌入视图并不复杂。 首先, 选中 <em>Spot Info View Controller</em>下面的所有按钮, <em>clicking</em> 一个, 然后 <em>Command-click</em> 其他两个:</p><br><p><img class="aligncenter size-full wp-image-114560 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/06-select-bottom-row-of-buttons_420x80.png" width="420" height="80"></p><br><p>如果大纲视图尚未打开, 在故事板画布的左下方通过 <em>Show Document Outline</em> 按钮打开:</p><br><p><img class="aligncenter size-full wp-image-114561 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/07-document-outline-button_120x40.png" width="120" height="40"></p><br><p>在大纲视图中验证3个按钮是否都已经选中:</p><br><p><img class="aligncenter size-full wp-image-114562 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/08-verify-button-selection_360x90.png" width="360" height="90"></p><br><p>如果没有完全选中, 你可以用 <em>Command-click</em> 在大纲视图中选中它们。</p><br><p>选好后, 点击故事板画布右下方自动布局工具条下的<em>Stack</em> 按钮:</p><br><p><img class="aligncenter size-full wp-image-114563 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/09-stack_button_outlined_148x52.png" width="148" height="52"></p><br><p>所有的按钮会嵌入一个新的堆栈视图:</p><br><p><img class="aligncenter size-full wp-image-114564 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/10-bottom-row-is-now-in-stack-view_640x100.png" width="640" height="100" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/10-bottom-row-is-now-in-stack-view_640x100.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/10-bottom-row-is-now-in-stack-view_640x100-480x75.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>现在所有按钮都是齐平的 – 稍后你可以调整它们。</p><br><p>虽然堆栈视图负责按钮的位置, 你还是需要添加约束来约定堆栈视图自身的位置。</p><br><p>当你在堆栈视图嵌入一个视图后, 它与其他视图的约束就被移除了。比如, 之前在一个堆栈视图嵌入的按钮组, <em>Submit Rating</em> 按钮的顶部和<em>Rating</em>标签的底部有一个垂直的间距约束:</p><br><p><img class="aligncenter size-full wp-image-114565 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/11-prior-constraint_420x90.png" width="420" height="90"></p><br><p>点击 <em>Submit Rating</em> 按钮可以看到它已经没有任何约束了:</p><br><p><img class="aligncenter size-full wp-image-114566 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/12-no-more-constraints_400x80.png" width="400" height="80"></p><br><p>另外一个验证约束被移除的方式是查看 <em>Size inspector</em> (⌥⌘5):</p><br><p><img class="aligncenter size-full wp-image-114567 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/13-check-size-inspector_640x80.png" width="640" height="80" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/13-check-size-inspector_640x80.png 640w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/13-check-size-inspector_640x80-480x60.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>为了添加堆栈视图自身位置的约束, 首先你要选中它。 如果内嵌视图充满了堆栈视图,想在故事板中想选中它有点棘手。</p><br><p>简单的方法是在大纲视图中选中它:</p><br><p><img class="aligncenter size-full wp-image-114568 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/14-stack-view-document-outline-selection_660x80.png" width="660" height="80" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/14-stack-view-document-outline-selection_660x80.png 660w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/14-stack-view-document-outline-selection_660x80-480x58.png 480w" sizes="(max-width: 660px) 100vw, 660px"></p><br><p>另外一个方法是按住 <em>Shift</em> 和 <em>Right-click</em> 选中堆栈视图中的任何视图, 或者按住 <em>Control-Shift-click</em> ,如果你使用的是触摸板。 在你点击的地方,会显示视图层级的菜单, 你可以很容易在菜单中选中堆栈视图 。</p><br><p>现在, 使用<em>Shift-Right-click</em> 方法来选中它:</p><br><p><img class="aligncenter size-full wp-image-114569 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/15-select-stack-view-in-view-hierarchy-menu_400x280.png" width="400" height="280"></p><br><p>现在, 点击自动布局工具条的 <em>Pin</em> 按钮来给它添加约束:</p><br><p><img class="aligncenter size-full wp-image-114570 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/16-pin-button_142x57.png" width="142" height="57"></p><br><p>首先选中 <em>Constrain to margins</em>。 然后给堆栈视图的边界添加下面的约束:</p>

<div class="wp_codebox"><table><tr id="p1145523"><td class="code" id="p114552code3"><pre class="bash" style="font-family:monospace;">Top: <span style="color: #000000;">20</span>, Leading: <span style="color: #000000;">0</span>, Trailing: <span style="color: #000000;">0</span>, Bottom: <span style="color: #000000;">0</span></pre></td></tr></table></div>

<p>仔细检查上下左右的约束确保 <em>I-beams</em> 是选中的。 然后点击 <em>Add 4 Constraints</em>:</p><br><p><img class="aligncenter size-full wp-image-114571 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/17-bottom-stack-view-constraints_264x364.png" width="264" height="364" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/17-bottom-stack-view-constraints_264x364.png 264w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/17-bottom-stack-view-constraints_264x364-232x320.png 232w" sizes="(max-width: 264px) 100vw, 264px"></p><br><p>现在堆栈视图尺寸是正确的了, 可是它把第一个按钮拉伸来充满了额外的空间:</p><br><p><img class="aligncenter size-full wp-image-114572 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/18-first-button-is-stretched_400x80.png" width="400" height="80"></p><br><p><code>distribution</code> 属性用来决定堆栈视图如何沿着坐标轴布局它的视图集。 现在, 它的值设为 <code>Fill</code>, 意思是所有视图沿着坐标轴填充堆栈视图 。 要达到这个目的, 堆栈视图只能拉伸一个视图来填充额外的空间, 它拉伸水平内容优先级最低的视图, 如果所有的属性是一样的, 它将拉伸第一个视图。</p><br><p>不过, 你不想他们完全充满堆栈视图 – 你希望它们之间间距相同。</p><br><p>确保堆栈视图仍然是选中的, 打开 <em>Attributes inspector</em>。 把 <em>Distribution</em> 的值从 <em>Fill</em> 改成 <em>Equal Spacing</em>:</p><br><p><img class="aligncenter size-full wp-image-114573 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/19-change-distribution-to-equal-spacing_640x148.png" width="640" height="148" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/19-change-distribution-to-equal-spacing_640x148.png 640w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/19-change-distribution-to-equal-spacing_640x148-480x111.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>现在编译运行, 点击任意单元格, 旋转模拟器 (⌘→). 你会发现底部按钮之间是相等的间距了!</p><br><p><img class="aligncenter size-medium wp-image-114574 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750-480x270.png" width="480" height="270" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750-480x270.png 480w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750-700x394.png 700w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750-266x151.png 266w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/20-now-buttons-are-equally-spaced_1334x750.png 1334w" sizes="(max-width: 480px) 100vw, 480px"></p><br><p>在没有堆栈视图的情况下要实现这个, 你需要用垫片视图, 每个按钮之间要有一个。 你还要给垫片视图添加等距间隔,还要添加大量的约束来确保垫片视图的位置是正确的。</p><br><p>大概像下面这样。 为了可见性, 垫片视图已经加上了灰色的背景:</p><br><p><img class="aligncenter size-full wp-image-114575 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/21-alternate-solution-1_346x76.png" width="346" height="76"></p><br><p>如果只是在故事板中做一次,这也不是太大的事, 但是大部门的视图是动态的。 运行时添加一个新按钮或者隐藏存在的按钮不是一个简单的工作,因为邻近的垫片视图和约束。</p><br><p>想要在堆栈视图中隐藏一个视图, 你要做的所有的事仅仅是设置视图的 <code>hidden</code> 属性为 <code>true</code> ,堆栈视图负责处理剩下的视图。 你可以用这个方法修复 <em>WEATHER</em> 标签的问题当用户隐藏下面的文字。 在把天气块加入堆栈视图后，你可以晚点处理这个。</p><br><h2>转换区域</h2><br><p>你要转换 <code>SpotInfoViewController</code> 中所有其他的区域去使用堆栈视图。 这会帮你很容易的实现剩余的工作。 下一步你将转换评级区域。</p><br><h3>评级区域</h3><br><p>在你创建的堆栈视图的上方, 选择 <em>RATING</em> 标签和靠着它的星星标签:</p><br><p><img class="aligncenter wp-image-114576 size-full bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/22-select-rating-label-and-stars-label_640x74.png" width="640" height="74" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/22-select-rating-label-and-stars-label_640x74.png 640w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/22-select-rating-label-and-stars-label_640x74-480x56.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>接着点击 <em>Stack</em> 按钮把它们嵌入堆栈视图:</p><br><p><img class="aligncenter size-full wp-image-114577 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/23-after-clicking-stack-button_640x74.png" width="640" height="74" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/23-after-clicking-stack-button_640x74.png 640w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/23-after-clicking-stack-button_640x74-480x56.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>现在点击 <em>Pin</em> 按钮. 选中 <em>Constrain to margins</em> 然后添加下面 <em>three</em> constraints:</p>

<div class="wp_codebox"><table><tr id="p1145524"><td class="code" id="p114552code4"><pre class="bash" style="font-family:monospace;">Top: <span style="color: #000000;">20</span>, Leading: <span style="color: #000000;">0</span>, Bottom: <span style="color: #000000;">20</span></pre></td></tr></table></div>

<p><img class="aligncenter size-full wp-image-114578 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/24-add-second-stack-view-constraints_264x171.png" width="264" height="171"></p><br><p>现在去 <em>Attributes inspector</em> 设置间距为 <em>8</em>:</p><br><p><img class="aligncenter size-full wp-image-114579 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/25-set-spacing-to-8_259x87.png" width="259" height="87"></p><br><p>有可能你会看到错位的视图警告并且看到类似星星标签被拉伸出视图边界的情况:</p><br><p><img class="aligncenter size-full wp-image-114580 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/26-stars-label-weirdly-stretched_640x85.png" width="640" height="85" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/26-stars-label-weirdly-stretched_640x85.png 640w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/26-stars-label-weirdly-stretched_640x85-480x64.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>有时候 Xcode会临时显示一些警告或者标识说堆栈视图位置不对, 但是在你做了一些更新之后这些警告就消失了。通常你可以忽视这些问题。</p><br><p>无论如何, 立即修复这个问题, 你可以让堆栈视图重新布局，通过移动它的区域一点然后还愿或者临时改变其中一个的布局属性。</p><br><p>为了证明这个, 改变 <em>Alignment</em> 的值从 <em>Fill</em> 到 <em>Top</em> 然后还原成 <em>Fill</em>。你会发现星星标签的位置正确了:</p><br><p><img class="aligncenter size-full wp-image-114581 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/27-change-alignment-to-top-and-back_640x85.png" width="640" height="85" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/27-change-alignment-to-top-and-back_640x85.png 640w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/27-change-alignment-to-top-and-back_640x85-480x64.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>编译运行程序去验证一切是不是跟原来一样。</p><br><h3>取消嵌入到堆栈视图</h3><br><p>在你走的太远之前, 做一些基本的“急救”训练是极好的。 有时候你发现自己不再需要一个堆栈视图, 可能因为实验, 重构或者突然的原因。</p><br><p>幸运的是, 很容从堆栈视图 <i>unembed</i> 视图。</p><br><p>首先, 选中想要移除的堆栈视图。 按住 <em>Option</em> 键同时点击 <em>Stack</em> 按钮。 点击菜单上的 <em>Unembed</em>:</p><br><p><img class="aligncenter size-full wp-image-114582 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/28-how-to-unembed_186x71.png" width="186" height="71"></p><br><p>另外一种方式是,选中堆栈视图然后从菜单中选择 <em>Editor </em><em>\</em><em> Unembed</em> 。</p><br><h3>你的第一个垂直堆栈视图</h3><br><p>现在, 你将创建你的第一个垂直堆栈视图。 选中 <em>WHY VISIT</em> 标签和下方的 <em>&lt;</em><em>whyVisitLabel&gt;</em> :</p><br><p><img class="aligncenter size-full wp-image-114583 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/29-select-why-visit-labels_640x90.png" width="640" height="90" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/29-select-why-visit-labels_640x90.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/29-select-why-visit-labels_640x90-480x68.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>Xcode 会正确的推断出这是一个基于标签位置的垂直堆栈视图。 点击 <em>Stack</em> 按钮把它们嵌入堆栈视图:</p><br><p><img class="aligncenter size-full wp-image-114584 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/30-embed-why-visit-labels_640x90.png" width="640" height="90" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/30-embed-why-visit-labels_640x90.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/30-embed-why-visit-labels_640x90-480x68.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>下面的标签以前有一个跟视图右边界的约束, 不过加入堆栈视图后背移除了。 现在, 堆栈视图没有约束, 它使用最大视图的固定宽度作为自己的宽度。</p><br><p>选中堆栈视图, 点击 <em>Pin</em> 按钮。 选中 <em>Constrain to margins</em>, 设置 <em>Top</em>, <em>Leading</em> and <em>Trailing</em> 约束为 <em>0</em>.</p><br><p>然后, 选中下部约束的下拉菜单的 <em>WEATHER (current distance = 20)</em>:</p><br><p><img class="aligncenter size-full wp-image-114585 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/31-dont-select-nearest-neighbor-constraint_463x417.png" width="463" height="417" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/31-dont-select-nearest-neighbor-constraint_463x417.png 463w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/31-dont-select-nearest-neighbor-constraint_463x417-355x320.png 355w" sizes="(max-width: 463px) 100vw, 463px"></p><br><p>默认情况, 约束显示为距离最近的相邻控件, 对 <em>Hide</em> 按钮底部约束的距离是15. 实际上你需要的约束是是它底部的 <em>WEATHER</em> 标签。</p><br><p>最后, 点击 <em>Add 4 Constraints</em>。 你会看到下面:</p><br><p><img class="aligncenter size-full wp-image-114586 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/32-why-visit-stack-view-stretched_640x90.png" width="640" height="90" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/32-why-visit-stack-view-stretched_640x90.png 640w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/32-why-visit-stack-view-stretched_640x90-480x68.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>现在你你有了一个距离视图右边界固定距离的扩充的堆栈视图。 不过, 底部标签仍然是同样的宽度。 你可以通过更新堆栈视图的 <code>alignment</code> 属性来修复这个问题。</p><br><h3>对齐属性</h3><br><p> <code>alignment</code> 属性决定堆栈视图沿着<i>垂直于</i>坐标轴的线如何布局内部的视图, 可能的值是 <code>Fill</code>, <code>Leading</code>, <code>Center</code> 和 <code>Trailing</code>.</p><br><p><i>垂直的</i> 堆栈视图的 <code>alignment</code>的值稍有不同:</p><br><p><img class="aligncenter size-full wp-image-114587" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/33-horizontal-and-vertical-alignment_594x171.png" width="594" height="171" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/33-horizontal-and-vertical-alignment_594x171.png 594w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/33-horizontal-and-vertical-alignment_594x171-480x138.png 480w" sizes="(max-width: 594px) 100vw, 594px"></p><br><p><code>.Top</code> 替换了 <code>.Leading</code>  <code>.Bottom</code> 替换了 <code>。Trailing</code>. 还有两个只有在垂直方向才有效的属性, <code>.FirstBaseline</code> 和 <code>.LastBaseline</code>.</p><br><p>选择每个值去看看对堆栈视图中标签布局的不同影响:</p><br><p><em>Fill:</em></p><br><p><img class="aligncenter size-full wp-image-114588 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/34-alignment-fill_640x64.png" width="640" height="64" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/34-alignment-fill_640x64.png 640w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/34-alignment-fill_640x64-480x48.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p><em>Leading:</em></p><br><p><img class="aligncenter size-full wp-image-114589 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/35-alignment-leading_640x64.png" width="640" height="64" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/35-alignment-leading_640x64.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/35-alignment-leading_640x64-480x48.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p><em>Center:</em></p><br><p><img class="aligncenter size-full wp-image-114590 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/36-alignment-center_640x64.png" width="640" height="64" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/36-alignment-center_640x64.png 640w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/36-alignment-center_640x64-480x48.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p><em>Trailing:</em></p><br><p><img class="aligncenter size-full wp-image-114591 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/37-alignment-trailing_640x64.png" width="640" height="64" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/37-alignment-trailing_640x64.png 640w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/37-alignment-trailing_640x64-480x48.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>测试完后, 设置 <em>Alignment</em> 属性的值为 <em>Fill</em>:</p><br><p><img class="aligncenter size-full wp-image-114592 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/38-now-select-alignment-fill_640x64.png" width="640" height="64" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/38-now-select-alignment-fill_640x64.png 640w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/38-now-select-alignment-fill_640x64-480x48.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>然后,编译运行程序来验证所有的一些看起来都很不错,并且没有出现倒退的情况。</p><br><p> <code>Fill</code> 意味着你想所有的视图按照垂直于坐标轴的方向完全充满堆栈视图。 这个使得 <em>WHY VISIT</em> 标签也会扩展到右边界。</p><br><p>不过,如果你仅仅希望底下的标签扩展到边界?</p><br><p>暂时, 因为两个标签背景都是透明的,所有没有关系, 不过转换天气区域的时候就有问题了。</p><br><p>你将学会如何用额外的堆栈视图实现这个功能。</p><br><h3>转换 &#8220;what to see&#8221; 区域</h3><br><p>这部分和前一个很相似, 所以介绍很简要。</p><br><ol start="1"><br><li>首先, 选中 <em>WHAT TO SEE</em> 标签和下方的 <em>&lt;</em><em>whatToSeeLabel&gt;</em> 标签。</li><br><li>点击 <em>Stack</em> 按钮。</li><br><li>点击 <em>Pin</em> 按钮。</li><br><li>选中 <em>Constrain to margins</em>, 添加下面 <em>四个</em> 约束:</li><br></ol><br><br><div class="wp_codebox"><table><tr id="p1145525"><td class="code" id="p114552code5"><pre class="bash" style="font-family:monospace;">Top: <span style="color: #000000;">20</span>, Leading: <span style="color: #000000;">0</span>, Trailing: <span style="color: #000000;">0</span>, Bottom: <span style="color: #000000;">20</span></pre></td></tr></table></div><br><br><ol start="5"><br><li>设置堆栈视图的 <em>Alignment</em> 为 <em>Fill</em>.</li><br></ol><br><p>你的故事板现在看起来是这样:</p><br><p><img class="aligncenter size-full wp-image-114593 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/39-after-what-to-see-section_640x308.png" width="640" height="308" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/39-after-what-to-see-section_640x308.png 640w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/39-after-what-to-see-section_640x308-480x231.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>编译运行程序去验证一切看起来依然一样。</p><br><p>现在留给你的只有 <em>weather</em> 区域了。</p><br><h2>转换天气区域</h2><br><p> <em>weather</em> 区域因为包含<em>Hide</em>按钮显得比其他区域复杂一些。</p><br><p>可以采用的一个方法是,创建一个内嵌的堆栈视图,把 <em>WEATHER</em> 标签和 <em>Hide</em> 按钮嵌入一个水平堆栈视图, 然后把这个水平堆栈视图和 <em>&lt;</em><em>weatherInfoLabel&gt;</em> 嵌入一个垂直堆栈视图。</p><br><p>它看起来是这个样子:</p><br><p><img class="aligncenter size-full wp-image-114594 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/40-weather-stack-in-stack_640x92.png" width="640" height="92" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/40-weather-stack-in-stack_640x92.png 640w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/40-weather-stack-in-stack_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>注意 <em>WEATHER</em> 标签已经把高度扩展和 <em>Hide</em> 按钮一样了。 这个不太理想,因为这将使<em>WEATHER</em>标签的基线和下方的文字存在空白。</p><br><p>记得 <code>alignment</code> 表示垂直于堆栈视图的位置。 所以, 你可以设置 <code>alignment</code> 为 <em>Bottom</em>:</p><br><p><img class="aligncenter size-full wp-image-114595 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/41-weather-stack-in-stack-alignment-bottom_640x92.png" width="640" height="92" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/41-weather-stack-in-stack-alignment-bottom_640x92.png 640w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/41-weather-stack-in-stack-alignment-bottom_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>不过你应该不想<em>Hide</em> 按钮的高度决定堆栈视图的高度。</p><br><p>实际上你要采用的方法是让 <em>Hide</em> 按钮 <i>不在</i>  <em>weather</em> 区域的堆栈视图中, 或者不在任何堆栈视图里。</p><br><p>它依然是顶层视图的子视图, 你在它跟 <em>WEATHER</em> 标签间添加约束 — 天气标签依然在堆栈视图里。 这是正确的, 你在堆栈视图外的按钮和堆栈视图内的标签间添加约束!</p><br><p>选择 <em>WEATHER</em> 标签和下方的 <em>&lt;</em><em>weatherInfoLabel&gt;</em> 标签:</p><br><p><img class="aligncenter size-full wp-image-114596 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/42-select-weather-and-info-label_640x92.png" width="640" height="92" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/42-select-weather-and-info-label_640x92.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/42-select-weather-and-info-label_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>点击 <em>Stack</em> 按钮:</p><br><p><img class="aligncenter size-full wp-image-114597 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/43-weather-click-stack-button_640x92.png" width="640" height="92" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/43-weather-click-stack-button_640x92.png 640w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/43-weather-click-stack-button_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>点击 <em>Pin</em> 按钮, 选中 <em>Constrain to margins</em> 并且添加下面的 <em>四个</em> 约束:</p>

<div class="wp_codebox"><table><tr id="p1145526"><td class="code" id="p114552code6"><pre class="bash" style="font-family:monospace;">Top: <span style="color: #000000;">20</span>, Leading: <span style="color: #000000;">0</span>, Trailing: <span style="color: #000000;">0</span>, Bottom: <span style="color: #000000;">20</span></pre></td></tr></table></div>

<p>设置堆栈视图的 <em>Alignment</em> 为 <em>Fill</em>:</p><br><p><img class="aligncenter size-full wp-image-114598 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/44-weather-alignment-fill_640x92.png" width="640" height="92" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/44-weather-alignment-fill_640x92.png 640w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/44-weather-alignment-fill_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>你需要在 <em>Hide</em> 按钮的左侧和 <em>WEATHER</em> 标签的右侧添加约束, 所以让 <em>WEATHER</em> 标签充满堆栈视图是无法起效果的。</p><br><p>不过, 你 <i>想</i> 让底面的 <em>&lt;</em><em>weatherInfoLabel&gt;</em> 标签填充视图。</p><br><p>你可以把 <em>WEATHER</em> 标签嵌入堆栈视图来实现这个。 记住垂直堆栈视图的 <code>alignment</code>可以设置成  <code>.Leading</code>, 如果堆栈视图拉伸超过实际宽度, 他包含的视图仍然是左对齐的。</p><br><p>通过大纲视图或者使用<em>Control-Shift-click</em>方法选中 <em>WEATHER</em> 标签:</p><br><p><img class="aligncenter size-full wp-image-114599 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/45-select-just-the-weather-label_640x92.png" width="640" height="92" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/45-select-just-the-weather-label_640x92.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/45-select-just-the-weather-label_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>点击 <em>Stack</em> 按钮:</p><br><p><img class="aligncenter size-full wp-image-114600 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/46-weather-in-horizontal-stack_640x92.png" width="640" height="92" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/46-weather-in-horizontal-stack_640x92.png 640w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/46-weather-in-horizontal-stack_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>设置 <em>Alignment</em> 为 <em>Leading</em>, 确保 <em>Axis</em> 设置为 <em>Vertical</em>:</p><br><p><img class="aligncenter size-full wp-image-114601 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/47-vertical-and-leading_640x92.png" width="640" height="92" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/47-vertical-and-leading_640x92.png 640w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/47-vertical-and-leading_640x92-480x69.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>完美! 外部堆栈视图可以拉伸内部堆栈视图去填充宽度,而内部堆栈视图的标签可以保持原始的宽度!</p><br><p>编译运行。 为什么<em>Hide</em> 按钮跑到文字中间去了?</p><br><p><img class="aligncenter wp-image-114602 size-medium bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/48-hide-label-incorrect-position_750x573-419x320.png" width="419" height="320" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/48-hide-label-incorrect-position_750x573-419x320.png 419w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/48-hide-label-incorrect-position_750x573-654x500.png 654w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/48-hide-label-incorrect-position_750x573.png 750w" sizes="(max-width: 419px) 100vw, 419px"></p><br><p>这是因为你把 <em>WEATHER</em> 标签嵌入堆栈视图, 所有它与 <em>Hide</em> 按钮之间的约束就被移除了。</p><br><p>添加从 <em>Hide</em> 按钮到 <em>WEATHER</em> 标签的<em>Control-drag</em>约束:</p><br><p><img class="aligncenter size-full wp-image-114603 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/49-drag-to-weather-label_380x94.png" width="380" height="94"></p><br><p>按住 <em>Shift</em> 选择多项, 选择 <em>Horizontal Spacing</em> 和 <em>Baseline</em>。 然后点击 <em>Add Constraints</em>:</p><br><p><img class="aligncenter size-full wp-image-114604 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/50-add-multiple-constraints_380x224.png" width="380" height="224"></p><br><p>编译运行。 <em>Hide</em> 按钮的位置现在应该正确了, 因为设置成隐藏的标签内嵌在一个堆栈视图, 按下 <em>Hide</em> 隐藏了这个标签, 同时调整下面的视图 — 无需手动调整任何约束。</p><br><p><img class="aligncenter size-medium wp-image-114605 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732-328x320.png" width="328" height="320" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732-328x320.png 328w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732-512x500.png 512w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732-32x32.png 32w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/51-hide-button-works_750x732.png 750w" sizes="(max-width: 328px) 100vw, 328px"></p><br><p>既然所有的区域都有自己的堆栈视图了, 你将他们所有都嵌入一个外部堆栈视图, 这将使得最后的两个任务微不足道。</p><br><h3>顶层堆栈视图</h3><br><p>在大纲视图中<em>Command-click</em> 去选取所有五个顶层堆栈视图:</p><br><p><img class="aligncenter size-full wp-image-114606 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/52-select-all-stack-views-in-outline_640x260.png" width="640" height="260" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/52-select-all-stack-views-in-outline_640x260.png 640w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/52-select-all-stack-views-in-outline_640x260-480x195.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>点击 <em>Stack</em> 按钮:</p><br><p><img class="aligncenter size-full wp-image-114607 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/53-stack-all-the-views_640x185.png" width="640" height="185" srcset="https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/53-stack-all-the-views_640x185.png 640w, https://cdn3.raywenderlich.com/wp-content/uploads/2015/09/53-stack-all-the-views_640x185-480x139.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>点击 <em>Pin</em> 按钮, 选中 <em>Constrain to margins</em> 添加 <em>0</em> 给所有边界。 接着设置 <em>Spacing</em> 为 <em>20</em>  <em>Alignment</em> 为 <em>Fill</em>。 你的故事板现在看起来是这样:</p><br><p><img class="aligncenter size-full wp-image-114608 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" width="640" height="300" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/54-set-the-spacing-to-20-and-alignment-to-fill_640x300-480x225.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>编译运行:</p><br><p><img class="aligncenter size-medium wp-image-114609 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/55-hide-button-lost-again_750x487-480x312.png" width="480" height="312" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/55-hide-button-lost-again_750x487-480x312.png 480w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/55-hide-button-lost-again_750x487-700x455.png 700w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/55-hide-button-lost-again_750x487.png 750w" sizes="(max-width: 480px) 100vw, 480px"></p><br><p>我擦! 好像隐藏按钮又失去了约束。没有关系, 像以前一样重新添加约束就可以了。</p><br><p><em>Control-drag</em> 从 <em>Hide</em> 按钮到 <em>WEATHER</em> 标签, 按住 <em>Shift</em>, 选择 <em>Horizontal Spacing</em> 和 <em>Baseline</em>. 然后点击 <em>Add Constraints</em>:</p><br><p><img class="aligncenter size-full wp-image-114610 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/56-add-constraints-to-button-again_380x223.png" width="380" height="223"></p><br><p>编译运行。 <em>Hide</em> 按钮的位置现在正确了。</p><br><h3>重定位视图</h3><br><p>既然所有的区域都在顶层堆栈视图, 你要修改 <em>what to see</em> 区域的位置让它位于 <em>weather</em> 区域的上方。</p><br><p>在大纲视图中选择 <em>中间的堆栈视图</em> 然后 <em>拖动它到</em> 第一个和第二个视图之间。</p><br><div class="note"><em>备注:</em> 保持鼠标指针稍微位于堆栈视图的左侧，这样它就还是外部堆栈视图 <i>子视图</i>。 小蓝圈应该位于两个堆栈视图的左侧边界而不是右侧:</div><br><p><img class="aligncenter size-full wp-image-114611 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/57-drag-and-drop-to-reposition-section_639x130.png" width="639" height="130" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/57-drag-and-drop-to-reposition-section_639x130.png 639w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/57-drag-and-drop-to-reposition-section_639x130-480x98.png 480w" sizes="(max-width: 639px) 100vw, 639px"></p><br><p>现在 <em>weather</em> 区域从上面数是第三个, 但是因为 <em>Hide</em> 按钮不是堆栈视图的一部分,所以他的区域是不对的。</p><br><p>点击 <em>Hide</em> 按钮选中它:</p><br><p><img class="aligncenter size-full wp-image-114612 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/58-hide-button-not-moved_640x130.png" width="640" height="130" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/58-hide-button-not-moved_640x130.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/58-hide-button-not-moved_640x130-480x98.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>接着点击 <em>Resolve Auto Layout Issues</em> 三角形按钮, 点击 <em>Update Frames</em>:</p><br><p><img class="aligncenter size-full wp-image-114613 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/59-resolve-auto-layout-issues_356x269.png" width="356" height="269"></p><br><p> <em>Hide</em> 按钮将会返回到正确的位置:</p><br><p><img class="aligncenter size-full wp-image-114614 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/60-hide-button-back-to-correct-position_640x130.png" width="640" height="130" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/60-hide-button-back-to-correct-position_640x130.png 640w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/60-hide-button-back-to-correct-position_640x130-480x98.png 480w" sizes="(max-width: 640px) 100vw, 640px"></p><br><p>当然, 用自动布局重定位视图,重新添加约束都已经不是最困难的事了, 但是这个不感觉这么好?</p><br><h3>基于配置的Size class</h3><br><p>最后, 你可以把注意力放在遗留的一个问题上了。 横屏模式下, 垂直空间非常稀少, 所以你想这些区域靠的更近一点。 要实现这点, 当垂直的 size class 是 compact的时候,你要设置顶层堆栈视图的间距为 <em>10</em> 而不是 <em>20</em> 。</p><br><p>选择顶层堆栈视图, 点击靠近 <em>Spacing</em>的小 <em>+</em> 按钮:</p><br><p><img class="aligncenter size-full wp-image-114615 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/61-select-plus-button_260x120.png" width="260" height="120"></p><br><p>选择 <em>Any Width</em> &gt; <em>Compact Height</em>:</p><br><p><img class="aligncenter size-full wp-image-114616 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/62-anywidth-compact-height_403x108.png" width="403" height="108"></p><br><p>在新的 <em>wAny hC</em> 区域设置 <em>Spacing</em> 为 <em>10</em> :</p><br><p><img class="aligncenter size-full wp-image-114617 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/63-set-spacing-to-10_260x160.png" width="260" height="160"></p><br><p>编译运行。 竖屏模式间距应该保持不变。 旋转模拟器 (⌘←) 可以看到区域之间的间距减小了，而且按钮距离底部都有了充足的空间:</p><br><p><img class="aligncenter size-medium wp-image-114618 bordered" src="http://www.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750-480x270.png" width="480" height="270" srcset="https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750-480x270.png 480w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750-700x394.png 700w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750-266x151.png 266w, https://cdn1.raywenderlich.com/wp-content/uploads/2015/09/64-spacing-in-iphone-landscape_1334x750.png 1334w" sizes="(max-width: 480px) 100vw, 480px"></p><br><p>如果你没有添加一个顶层的堆栈视图, 你仍然 <i>可以</i> 分五个区域用 size classes 来设置四个约束的每一个垂直间距为10, 只是这个没有在一个简单的地方设置容易?</p><br><p>你有时间去做更好的事, 比如动画!</p><br><h2>动画</h2><br><p>现在, 显示和隐藏天气详情有点突兀。 你可以添加一些动画让这种转换显得平顺一些。</p><br><p>堆栈视图完全适用UIView 动画引擎。 这就意味动画显示/隐藏排列好的视图, 和<i>在</i>动画块内切换 <code>hidden</code> 属性一样简单。</p><br><p>该写一些代码了! 打开 <em>SpotInfoViewController.swift</em> 看一眼 <code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>.</p><br><p>你会看见这行代码在方法的尾部:</p>

<div class="wp_codebox"><table><tr id="p1145527"><td class="code" id="p114552code7"><pre class="swift" style="font-family:monospace;">weatherInfoLabel.hidden <span style="color: #002200;">=</span> shouldHideWeatherInfo</pre></td></tr></table></div>

<p>用下面的代码替换它:</p>

<div class="wp_codebox"><table><tr id="p1145528"><td class="code" id="p114552code8"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">if</span> animated <span style="color: #002200;">&#123;</span><br>  <span style="color: #400080;">UIView</span>.animateWithDuration<span style="color: #002200;">&#40;</span><span style="color: #2400d9;">0.3</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">self</span>.weatherInfoLabel.hidden <span style="color: #002200;">=</span> shouldHideWeatherInfo<br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span> <span style="color: #a61390;">else</span> <span style="color: #002200;">&#123;</span><br>  weatherInfoLabel.hidden <span style="color: #002200;">=</span> shouldHideWeatherInfo<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>编译运行, 点击 <em>Hide</em> 或者 <em>Show</em> 按钮。 这个动画版本是不是看起来好一些?</p><br><p>除了动画隐藏显示堆栈视图中的视图, 你也可以让堆栈视图本身有动画属性, 例如 <code>alignment</code>, <code>distribution</code>, <code>spacing</code> ,甚至是<code>axis</code>.</p>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; id=&quot;wpsqt-main-css&quot; href=&quot;https://cdn3.raywenderlich.com/wp-content/plugins/wp-survey-and-quiz-tool/css/ma
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UISearchController 使用指导</title>
    <link href="http://yoursite.com/2016/09/14/UISearchController-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AF%BC/"/>
    <id>http://yoursite.com/2016/09/14/UISearchController-使用指导/</id>
    <published>2016-09-14T00:59:02.000Z</published>
    <updated>2016-09-14T06:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Square.png" width="250" height="250" class="alignright size-thumbnail wp-image-78152"></div>

<p>如果你的程序要展示大量的数据集, 通过滚动大规模的列表会变的很慢并且令人沮丧。 既然如此，允许用户搜索特定项目就显得非常重要。 幸运的是, UIKit 包含的 <code>UISearchBar</code> 和 <code>UITableView</code>实现了无缝对接来进行快速有效的信息过滤。</p><br><p>这份<code>UISearchController</code> 指导, 你将建立一个基于标准列表的Candy 应用。 你会添加搜索的功能, 包括动态过滤, 可选的scope bar, 所有使用 <code>UISearchController</code>的方式, 都已经添加到iOS 8. 最后, 你会知道如何让你的程序更加友好并且满足用户的紧急需求。</p><br><p>预备好一些糖衣的搜索结果，继续读下去。</p><br><h2>准备开始</h2><br><p>下载演示程序在<a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/CandySearch-Starter.zip" target="_blank" rel="external">这里</a> 然后打开。 程序以导航栏的风格创建，编译项目并运行，你会看到一个空列表:</p>

<div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Starter-281x500.png" width="281" height="500" class="aligncenter size-large wp-image-113862" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Starter-281x500.png 281w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Starter-180x320.png 180w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Starter.png 750w" sizes="(max-width: 281px) 100vw, 281px"></div><br><p>回到Xcode, 文件<em>Candy.swift</em> 包含了一个用来保存你想展示的糖果信息的类。这个类有两个属性: 分类和糖果名。</p><br><p>当用户在你的app搜索某个糖果的时候, 你要引用名字属性来匹配用户的搜索关键字。 你会在文章结尾实现的Scope Bar中看到分类字符串的重要性。</p><br><h2>填充 Table View</h2><br><p>打开 <em>MasterViewController.swift</em>.  <code>candies</code> 属性负责管理用户搜索用的不同的<code>Candy</code>对象。 说到这里, 是时候创建一些 Candy了!</p><br><p>这个指导中, 你只需要创建固定数量的数据来展示search bar如何工作的; 在真正的产品级应用中, 你可能会有上千条的数据。不过无论怎样，不管程序存在上千的数据还是只有一点点数据，用到的方法都是一样的。 出色的扩展性!</p><br><p>填充你的 <code>candies</code> 数组,添加下面的代码到 <code>viewDidLoad()</code>, 代码添加在 <code>super.viewDidLoad()</code>调用后:</p><br><br><div class="wp_codebox"><table><tr id="p1137721"><td class="code" id="p113772code1"><pre class="swift" style="font-family:monospace;">candies <span style="color: #002200;">=</span> <span style="color: #002200;">&#91;</span><br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Chocolate&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Chocolate Bar&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Chocolate&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Chocolate Chip&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Chocolate&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Dark Chocolate&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Hard&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Lollipop&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Hard&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Candy Cane&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Hard&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Jaw Breaker&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Other&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Caramel&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Other&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Sour Chew&quot;</span><span style="color: #002200;">&#41;</span>,<br>  Candy<span style="color: #002200;">&#40;</span>category<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Other&quot;</span>, name<span style="color: #002200;">:</span><span style="color: #bf1d1a;">&quot;Gummi Bear&quot;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#93;</span></pre></td></tr></table></div>

<p>再次编译运行你的工程。因为table view的代理和数据源方法都已经实现了，现在你可以看见一个有数据的table view了: </p><br><div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Data-281x500.png" width="281" height="500" class="aligncenter size-large wp-image-113861" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Data-281x500.png 281w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Data-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Data.png 750w" sizes="(max-width: 281px) 100vw, 281px"></div><br><p>选择列表的一行，点击进入会展示对应糖果的详情页:</p><br><div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/darkchocolate.png" width="281" height="500" class="aligncenter size-large wp-image-115841" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/darkchocolate.png 375w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/darkchocolate-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/darkchocolate-281x500.png 281w" sizes="(max-width: 281px) 100vw, 281px"></div><br><p>这么多的糖果，这么少的时间找到你想要的! 你需要一个<code>UISearchBar</code>.</p><br><h2>UISearchController介绍</h2><br><p>如果你查看<code>UISearchController</code> 文档, 你会发现这个文档懒的令人发指。 他一点搜索工作都不做。 这个类只是提供用户预期得到的标准接口而已。</p><br><p><code>UISearchController</code> 调用代理方法告知你的应用其他地方，你的用户正在做什么。你必须自己实现所有的函数来做字符串的匹配工作。</p><br><p>虽然这看起来有点吓人, 但是写自定义的搜索功能你可以自己控制准确的返回结果。 你的用户会非常赞赏这种智能快速的搜索。</p><br><p>如果你过去用过搜索列表, 你应该熟悉<code>UISearchDisplayController</code>。 从 iOS 8开始, 这个类已经被弃用，现在开始使用 <code>UISearchController</code>, 这个类简化了搜索的流程。</p><br><p>不走运的是, 写这篇文章的时候, Interface Builder 还不支持 <code>UISearchController</code>, 因此你要自己手动创建你的UI。</p><br><p>在 <em>MasterViewController.swift</em>, 添加一个新的属性:</p>

<div class="wp_codebox"><table><tr id="p1137722"><td class="code" id="p113772code2"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">let</span> searchController <span style="color: #002200;">=</span> UISearchController<span style="color: #002200;">&#40;</span>searchResultsController<span style="color: #002200;">:</span> <span style="color: #a61390;">nil</span><span style="color: #002200;">&#41;</span></pre></td></tr></table></div>

<p>通过初始化 <code>UISearchController</code> 不带 <code>searchResultsController</code>, 告诉搜索页面你要用相同的搜索视图来展示搜索结果。如果你在这里用不同的视图控制器，那搜索结果就展示在替代的视图里。</p><br><p>下一步, 你需要给你的搜索视图控制器配置一些参数。还是在 <em>MasterViewController.swift</em>里面, 在 <code>viewDidLoad()</code>后面添加如下代码:</p>

<div class="wp_codebox"><table><tr id="p1137723"><td class="code" id="p113772code3"><pre class="swift" style="font-family:monospace;">  searchController.searchResultsUpdater <span style="color: #002200;">=</span> <span style="color: #a61390;">self</span><br>  searchController.dimsBackgroundDuringPresentation <span style="color: #002200;">=</span> <span style="color: #a61390;">false</span><br>  definesPresentationContext <span style="color: #002200;">=</span> <span style="color: #a61390;">true</span><br>  tableView.tableHeaderView <span style="color: #002200;">=</span> searchController.searchBar</pre></td></tr></table></div>

<p>这儿是你添加代码的说明:</p><br><ol><br><li><code>searchResultsUpdater</code> 是 <code>UISearchController</code>的属性遵守 <code>UISearchResultsUpdating</code>协议。 当<code>UISearchBar</code>中输入的文字改变时，该协议会通知你的类. 过会你就会在你的类实现这个协议的。</li><br><li>默认情况下, <code>UISearchController</code>出现时视图会黯淡下来。 当你使用别的视图控制器作为<code>searchResultsController</code>时会很有用. 这个情况下, 你已经设置当前视图来显示结果，因此你不希望视图是黯淡的。</li><br><li>通过在视图控制器设置<code>definesPresentationContext</code> 为 <code>true</code>, 当<code>UISearchController</code> 处于激活状态是，确保用户在导航到别的页面后,搜索条不会继续留在屏幕上。</li><br><li>最后, 添加 <code>searchBar</code> 到列表的 <code>tableHeaderView</code>。记住 Interface Builder 还不兼容<code>UISearchController</code>, 这个很必要。</li><br></ol><br><h3>UISearchResultsUpdating 和 Filtering</h3><br><p>建立好搜索控制之后, 你需要做一些编码工作来让它工作。 首先, 在<code>MasterViewController</code>顶部附近添加下面的属性:</p>

<div class="wp_codebox"><table><tr id="p1137724"><td class="code" id="p113772code4"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">var</span> filteredCandies <span style="color: #002200;">=</span> <span style="color: #002200;">&#91;</span>Candy<span style="color: #002200;">&#93;</span><span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span></pre></td></tr></table></div>

<p>这个属性用例保存用户正在搜索的糖果。 下一步, 添加下面的辅助方法到 <code>MasterViewController</code>:</p>

<div class="wp_codebox"><table><tr id="p1137725"><td class="code" id="p113772code5"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> filterContentForSearchText<span style="color: #002200;">&#40;</span>searchText<span style="color: #002200;">:</span> <span style="color: #a61390;">String</span>, scope<span style="color: #002200;">:</span> <span style="color: #a61390;">String</span> <span style="color: #002200;">=</span> <span style="color: #bf1d1a;">&quot;All&quot;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  filteredCandies <span style="color: #002200;">=</span> candies.<span style="color: #a61390;">filter</span> <span style="color: #002200;">&#123;</span> candy <span style="color: #a61390;">in</span><br>    <span style="color: #a61390;">return</span> candy.name.lowercaseString.containsString<span style="color: #002200;">&#40;</span>searchText.lowercaseString<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  tableView.reloadData<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>这个方法会通过<code>searchText</code>过滤<code>candies</code> 数据并把结果放进你刚刚添加的 <code>filteredCandies</code> 数组。现在不用担心<code>scope</code> 这个参数, 文章后面你会用到它。</p><br><p>为了让<code>MasterViewController</code> 响应搜索条, 还需要实现 <code>UISearchResultsUpdating</code>. 打开 <em>MasterViewController.swift</em> 添加下面的类扩展方法, 在 <code>MasterViewController</code> 主体外:</p>

<div class="wp_codebox"><table><tr id="p1137726"><td class="code" id="p113772code6"><pre class="swift" style="font-family:monospace;">extension MasterViewController<span style="color: #002200;">:</span> UISearchResultsUpdating <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">func</span> updateSearchResultsForSearchController<span style="color: #002200;">&#40;</span>searchController<span style="color: #002200;">:</span> UISearchController<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    filterContentForSearchText<span style="color: #002200;">&#40;</span>searchController.searchBar.text<span style="color: #002200;">!</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p> <code>updateSearchResultsForSearchController(<em>:)</em></code> 方法是唯一需要去实现的，用来遵守<code>UISearchResultsUpdating</code> 协议。</p><br><p>现在, 每当用户在搜索条添加或者移除文字的时候, <code>UISearchController</code> 都会通过这个方法通知 <code>MasterViewController</code> 。 这个方法只是通过当前搜索条中的文字简单调用一个帮手方法(你刚刚定义的)</p><br><p><code>filter()</code> 需要一个闭包类型 <code>(candy: Candy) -&gt; Bool</code>. 然后循环便利数组中的所有元素, 然后调用闭包, 为每个元素传入这个文字。</p><br><p>你可以用这个方法判定某个糖果是否是需要展示给用户的结果的其中一个。 要做到这点, 如果当前的糖果包含在过滤数组中你需要返回 <code>true</code> , 如果不是就返回 <code>false</code> 。</p><br><p>为了确定这个, <code>containsString(:)</code> 用来检测这个糖果的名字是不是包含 <code>searchText</code>. 但是在比较前, 你需要把两个字符串转换成全小写的字符串，用 <code>lowercaseString</code> 方法。 </p><br><div class="note"><em>备注:</em> 大部分时间, 当执行搜索的时候通过比较两个字符串的小写，我们可以轻易返回大小写不敏感的比较，用户并不用烦心大小写的问题。 现在, 你输入 &#8220;Chocolate&#8221; 或者 &#8220;chocolate&#8221; 任何一个都会返回匹配的糖果。 是不是很有用?! :]</div><br><p>编译并允许程序; 你会发现列表上面现在有了Search Bar 。</p><br><p>可是, 如果你输入搜索文字你会发现依然看不到任何过滤的结果。 要给什么? 这个很简单，因为你还没有写任何的代码去告诉列表如何使用过滤结果。</p><br><p>回到 <em>MasterViewController.swift</em>, 替换 <code>tableView(_:numberOfRowsInSection:)</code> 用下面的代码 :</p>

<div class="wp_codebox"><table><tr id="p1137727"><td class="code" id="p113772code7"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> tableView<span style="color: #002200;">&#40;</span>tableView<span style="color: #002200;">:</span> <span style="color: #400080;">UITableView</span>, numberOfRowsInSection section<span style="color: #002200;">:</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #a61390;">Int</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">if</span> searchController.active <span style="color: #002200;">&amp;&amp;</span> searchController.searchBar.text <span style="color: #002200;">!=</span> <span style="color: #bf1d1a;">&quot;&quot;</span> <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">return</span> filteredCandies.<span style="color: #a61390;">count</span><br>  <span style="color: #002200;">&#125;</span><br>  <span style="color: #a61390;">return</span> candies.<span style="color: #a61390;">count</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>这儿变化不大, 你只是简单判断用户是否在搜索, 然后用过滤的结果或者正常的糖果来做数据源。</p><br><p>下一步, 替换 <code>tableView(_:cellForRowAtIndexPath:)</code> 用:</p>

<div class="wp_codebox"><table><tr id="p1137728"><td class="code" id="p113772code8"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> tableView<span style="color: #002200;">&#40;</span>tableView<span style="color: #002200;">:</span> <span style="color: #400080;">UITableView</span>, cellForRowAtIndexPath indexPath<span style="color: #002200;">:</span> <span style="color: #400080;">NSIndexPath</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #400080;">UITableViewCell</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">let</span> cell <span style="color: #002200;">=</span> tableView.dequeueReusableCellWithIdentifier<span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Cell&quot;</span>, forIndexPath<span style="color: #002200;">:</span> indexPath<span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">let</span> candy<span style="color: #002200;">:</span> Candy<br>  <span style="color: #a61390;">if</span> searchController.active <span style="color: #002200;">&amp;&amp;</span> searchController.searchBar.text <span style="color: #002200;">!=</span> <span style="color: #bf1d1a;">&quot;&quot;</span> <span style="color: #002200;">&#123;</span><br>    candy <span style="color: #002200;">=</span> filteredCandies<span style="color: #002200;">&#91;</span>indexPath.row<span style="color: #002200;">&#93;</span><br>  <span style="color: #002200;">&#125;</span> <span style="color: #a61390;">else</span> <span style="color: #002200;">&#123;</span><br>    candy <span style="color: #002200;">=</span> candies<span style="color: #002200;">&#91;</span>indexPath.row<span style="color: #002200;">&#93;</span><br>  <span style="color: #002200;">&#125;</span><br>  cell.textLabel?.text <span style="color: #002200;">=</span> candy.name<br>  cell.detailTextLabel?.text <span style="color: #002200;">=</span> candy.category<br>  <span style="color: #a61390;">return</span> cell<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>两个方法现在都会调用 <code>searchController</code>的属性<code>active</code> 来判断显示哪个数组。 </p><br><p>当用户点击 Search Bar的搜索区域时, <code>active</code> 会自动设置为 <code>true</code>. 如果搜索控制器是激活的, 你会看到用户是否在输入文字。 如果他们输入了, <code>filteredCandies</code> 数组会返回数据. 否则, 返回所有的数据。</p><br><p>回想一下, 搜索控制器自动处理展示和隐藏结果, 所以你的所有代码必须根据控制器的状态和用户是否输入来提供正确的数据 (过滤的或者未过滤的) 。</p><br><div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/ragecomic.png" width="651" height="481" class="aligncenter size-full wp-image-114198" srcset="https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/ragecomic.png 651w, https://cdn4.raywenderlich.com/wp-content/uploads/2015/09/ragecomic-433x320.png 433w" sizes="(max-width: 651px) 100vw, 651px"></div><br><p>编译并允许程序。 你已经得到一个可以运行的过滤列表行的 Search Bar。 好耶! </p><br><div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-281x500.png" width="281" height="500" class="aligncenter size-large wp-image-113864" srcset="https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-281x500.png 281w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-180x320.png 180w, https://cdn5.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter.png 750w" sizes="(max-width: 281px) 100vw, 281px"></div><br><p>玩一会这个程序看看能不能搜到各种糖果。</p><br><p>存在不止一个问题。当你选择搜索列表的一行, 你可能注意到了详情页展示的是错误的糖果! 是时候修复这个问题了。</p><br><h2>给详情页传递数据</h2><br><p>当传递信息给详情页时, 你要确保控制器知道用户在使用哪个内容: 是整个列表还是搜索的结果。 还是在 <em>MasterViewController.swift</em>, 在 <code>prepareForSegue(_:sender:)</code>里, 找到下面的代码:</p>

<div class="wp_codebox"><table><tr id="p1137729"><td class="code" id="p113772code9"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">let</span> candy <span style="color: #002200;">=</span> candies<span style="color: #002200;">&#91;</span>indexPath.row<span style="color: #002200;">&#93;</span></pre></td></tr></table></div>

<p>替换成下面的代码:</p>

<div class="wp_codebox"><table><tr id="p11377210"><td class="code" id="p113772code10"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">let</span> candy<span style="color: #002200;">:</span> Candy<br><span style="color: #a61390;">if</span> searchController.active <span style="color: #002200;">&amp;&amp;</span> searchController.searchBar.text <span style="color: #002200;">!=</span> <span style="color: #bf1d1a;">&quot;&quot;</span> <span style="color: #002200;">&#123;</span><br>  candy <span style="color: #002200;">=</span> filteredCandies<span style="color: #002200;">&#91;</span>indexPath.row<span style="color: #002200;">&#93;</span><br><span style="color: #002200;">&#125;</span> <span style="color: #a61390;">else</span> <span style="color: #002200;">&#123;</span><br>  candy <span style="color: #002200;">=</span> candies<span style="color: #002200;">&#91;</span>indexPath.row<span style="color: #002200;">&#93;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>你在这里做了 <code>tableView(<em>:numberOfRowsInSection:)</em></code> 和 <code>tableView(:cellForRowAtIndexPath:)</code> 相同的判断, 不过现在，你给详情页提供了合适的糖果对象当你执行segue的时候。</p><br><p>此时编译并允许程序，看看导航到正确的详情页是多少轻松，无论是从主界面还是搜索页面。 </p><br><div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/CandySearch-DetailView-281x500.png" width="281" height="500" class="aligncenter size-large wp-image-114436" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/CandySearch-DetailView-281x500.png 281w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/CandySearch-DetailView-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/CandySearch-DetailView.png 750w" sizes="(max-width: 281px) 100vw, 281px"></div><br><h2>创建一个 Scope Bar 来过滤结果</h2><br><p>如果你想提供给用户其他的方式来过滤结果, 你可以添加一个 <em>Scope Bar</em> 结合你的搜索条通过分类来过滤项目。 这些分类是你在创建糖果数组时指定给 <code>Candy</code> 对象的: <em>Chocolate</em>, <em>Hard</em>, and <em>其他</em> 。</p><br><p>首先, 你要先在<code>MasterViewController</code>创建一个scope bar. 这个scope bar是个分段控件，可以通过特定范围来缩小搜索。 一个scope就是你定义的那样。 这里他是一个糖果的分类, 不过scopes也可以是类型, 范围, 或者其他完全不同的东西。</p><br><p>使用scope bar和实现一个额外的代理方法一样容易。</p><br><p>在 <em>MasterViewController.swift</em>, 你要添加另一个扩展，需要遵守 <code>UISearchBarDelegate</code>协议. 在 <code>UISearchResultsUpdating</code> 后面添加扩展方法:</p>

<div class="wp_codebox"><table><tr id="p11377211"><td class="code" id="p113772code11"><pre class="swift" style="font-family:monospace;">extension MasterViewController<span style="color: #002200;">:</span> <span style="color: #2a6f76;">UISearchBarDelegate</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">func</span> searchBar<span style="color: #002200;">&#40;</span>searchBar<span style="color: #002200;">:</span> <span style="color: #400080;">UISearchBar</span>, selectedScopeButtonIndexDidChange selectedScope<span style="color: #002200;">:</span> <span style="color: #a61390;">Int</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    filterContentForSearchText<span style="color: #002200;">&#40;</span>searchBar.text<span style="color: #002200;">!</span>, scope<span style="color: #002200;">:</span> searchBar.scopeButtonTitles<span style="color: #002200;">!</span><span style="color: #002200;">&#91;</span>selectedScope<span style="color: #002200;">&#93;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>这个代理方法在用户切换scope时候调用. 当方法执行时, 你想要重做过滤, 就要调用<code>filterContentForSearchText(<em>:scope:)</em></code> 用新的scope。</p><br><p>现在修改 <code>filterContentForSearchText(:scope:)</code> 来获取提供给账户的scope:</p>

<div class="wp_codebox"><table><tr id="p11377212"><td class="code" id="p113772code12"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> filterContentForSearchText<span style="color: #002200;">&#40;</span>searchText<span style="color: #002200;">:</span> <span style="color: #a61390;">String</span>, scope<span style="color: #002200;">:</span> <span style="color: #a61390;">String</span> <span style="color: #002200;">=</span> <span style="color: #bf1d1a;">&quot;All&quot;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  filteredCandies <span style="color: #002200;">=</span> candies.<span style="color: #a61390;">filter</span> <span style="color: #002200;">&#123;</span> candy <span style="color: #a61390;">in</span><br>    <span style="color: #a61390;">let</span> categoryMatch <span style="color: #002200;">=</span> <span style="color: #002200;">&#40;</span>scope <span style="color: #002200;">==</span> <span style="color: #bf1d1a;">&quot;All&quot;</span><span style="color: #002200;">&#41;</span> || <span style="color: #002200;">&#40;</span>candy.category <span style="color: #002200;">==</span> scope<span style="color: #002200;">&#41;</span><br>    <span style="color: #a61390;">return</span>  categoryMatch <span style="color: #002200;">&amp;&amp;</span> candy.name.lowercaseString.containsString<span style="color: #002200;">&#40;</span>searchText.lowercaseString<span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>&nbsp;<br>  tableView.reloadData<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>这个方法判断提供的scope是 &#8220;All&#8221; 还是匹配糖果的分类。 只有这样测试糖果名才知道是否将它加入 <code>filteredCandies</code>.</p><br><p>你快搞定了, 不过scope过滤机制还不能完全工作。你需要修改 <code>updateSearchResultsForSearchController(_:)</code> , 在第一个类扩展方法中，你用来传递当前选择的scope的:</p>

<div class="wp_codebox"><table><tr id="p11377213"><td class="code" id="p113772code13"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> updateSearchResultsForSearchController<span style="color: #002200;">&#40;</span>searchController<span style="color: #002200;">:</span> UISearchController<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">let</span> searchBar <span style="color: #002200;">=</span> searchController.searchBar<br>  <span style="color: #a61390;">let</span> scope <span style="color: #002200;">=</span> searchBar.scopeButtonTitles<span style="color: #002200;">!</span><span style="color: #002200;">&#91;</span>searchBar.selectedScopeButtonIndex<span style="color: #002200;">&#93;</span><br>  filterContentForSearchText<span style="color: #002200;">&#40;</span>searchController.searchBar.text<span style="color: #002200;">!</span>, scope<span style="color: #002200;">:</span> scope<span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div>

<p>还剩个问题, 用户还看不到scope bar ! 来添加scope bar, 导航到 <em>MasterViewController.swift</em>, 在<code>viewDidLoad()</code>创建搜索控制器之后, 添加下面的代码:</p>

<div class="wp_codebox"><table><tr id="p11377214"><td class="code" id="p113772code14"><pre class="swift" style="font-family:monospace;">searchController.searchBar.scopeButtonTitles <span style="color: #002200;">=</span> <span style="color: #002200;">&#91;</span><span style="color: #bf1d1a;">&quot;All&quot;</span>, <span style="color: #bf1d1a;">&quot;Chocolate&quot;</span>, <span style="color: #bf1d1a;">&quot;Hard&quot;</span>, <span style="color: #bf1d1a;">&quot;Other&quot;</span><span style="color: #002200;">&#93;</span><br>searchController.searchBar.delegate <span style="color: #002200;">=</span> <span style="color: #a61390;">self</span></pre></td></tr></table></div>

<p></p><p>这个会在搜索条下面添加一个scope bar, 并且带有你指定的糖果分类。 同时包含用来忽略糖果分类的 <em>&#8220;All&#8221;</em> 。</p><p></p>
<p></p><p>现在, 当你输入的时候, 选择的scope按钮会和搜索文字一起使用。 </p><p></p>
<p></p><p>编译运行程序。 试着输入一些搜索文字, 同时改变scope。</p><p></p>
<div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-with-Scope-281x500.png" width="281" height="500" class="aligncenter size-large wp-image-113863" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-with-Scope-281x500.png 281w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-with-Scope-180x320.png 180w, https://cdn2.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Filter-with-Scope.png 750w" sizes="(max-width: 281px) 100vw, 281px"></div><br><p>输入 &#8220;caramel&#8221; scope 设置为 All。它出现在列表里, 如果你把scope换成Chocolate, &#8220;caramel&#8221; 消失了。 因为它不是巧克力。</p><br><h2>从这里去哪里呢?</h2><br><p>恭喜 &#8211; 你现在有了一个可以直接在主列表搜索的程序。 这里是 <a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/CandySearch.zip" target="_blank" rel="external">可下载的简单工程</a> 含有上面所有的代码。</p><br><p>列表视图在各种程序里运用, 提供搜索选项是个好的触摸功能。 <code>UISearchBar</code> 和 <code>UISearchController</code>, iOS 提供了大部分的功能，你没有理由不用这个功能。 在大量列表中执行搜索是用户希望含有的功能; 一旦他们发现没有这个功能，他们会不高兴的。</p><br><div align="center"><img src="http://www.raywenderlich.com/wp-content/uploads/2012/07/nosearchfunction.jpg" width="400" height="361" class="size-full wp-image-19061" srcset="https://cdn2.raywenderlich.com/wp-content/uploads/2012/07/nosearchfunction.jpg 400w, https://cdn2.raywenderlich.com/wp-content/uploads/2012/07/nosearchfunction-250x225.jpg 250w, https://cdn2.raywenderlich.com/wp-content/uploads/2012/07/nosearchfunction-354x320.jpg 354w" sizes="(max-width: 400px) 100vw, 400px"></div>


]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.raywenderlich.com/wp-content/uploads/2015/09/UISearchController-Square.png&quot; width=&quot;250&quot; height=&quot;250
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目结束后的一些思考</title>
    <link href="http://yoursite.com/2016/09/08/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9D%9F%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2016/09/08/项目结束后的一些思考/</id>
    <published>2016-09-08T08:42:51.000Z</published>
    <updated>2016-09-12T08:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>为什么项目又延期了？ ——–来自市场的愤怒 </p>
</blockquote>
<p>为什么项目又延期了呢？</p>
<div style="text-align:center"><br><img src="http://img306.ph.126.net/Xk7NwVjqPUtaYlY6u2m2GQ==/3852829481215481010.jpg"><br></div>

<p>从项目立项到发布，一般项目的生命周期都是如上图所示，任何一个环节出现问题，都会增加工时的消耗</p>
<p>开源中国社区 <a href="http://www.oschina.net/question/565065_86309" title="百度" target="_blank" rel="external">软件开发流程</a> 说的很详细了，我只说说自己的一些看法和见解。</p>
<h1 id="关于知识的储备"><a href="#关于知识的储备" class="headerlink" title="关于知识的储备"></a>关于知识的储备</h1><div><br><p>笔者曾经参与多个iOS项目的开发，大大小小的项目都经历，实话说，极少有项目可以按时交付，即使连最基本的问题清零都做不到，基本都需要加班加点，到最后还是会遗留一些解决不了的问题。<br></p><br><p>新人越多的项目越容易出问题，当新人逐渐变成老司机的时候，无论是代码质量还是项目进度都变的靠谱多了。现代开发虽然引入了很多提高工作效率的工具和方法，但是人的能力还是占主导地位，人的知识储备在此就显得尤为重要了。<br></p><br><p>对新人的培养必须区别于学校，培养其主动学习能力才是进步之石，作为领导或者开发组长，应该根据员工的特点为其引路，创造学习的环境和条件，而不是将任务分配完了就不管了。在我经历的项目中，发现大多数的新人做了很多重复性的工作，在很长的时期里机械的做事，根本没有机会成长，他们现在或者变成老油条或者继续做着简单的工作，在新的毕业生涌入的潮流中，彻底的沉下去了。<br><br></p></div>

<div style="text-align:center"><br><img src="http://photocdn.sohu.com/20150811/mp26839099_1439275236239_1_th.jpeg" width="280" height="300"><br></div>

<h1 id="关于责任心"><a href="#关于责任心" class="headerlink" title="关于责任心"></a>关于责任心</h1><div><br><p>责任心这个东西应该是个后天的东西，因此在新人面试的时候，怎么在短短几十分钟内辨别面试者的责任心，是需要经验和一些运气的。如果等到新人进组和接手开发任务的时候，再去辨别就有点晚了。<br></p><br><p>有责任心的员工自主性相对较强，对自己的工作进度和质量都有着高度的要求，轻易不会表现沮丧和得过且过，接手的功能和任务都会认真对待，即使能力一时不足，也会通过不断的学习和填坑来完成，并不断总结，最终他开发的功能一般都会有个比较好的结果。<br></p><br></div>

<h1 id="关于工作方式"><a href="#关于工作方式" class="headerlink" title="关于工作方式"></a>关于工作方式</h1><div><br><p>成功者都有一套自己的工作方式，普通人也有自己的工作方式，不同之处是高效和低效的区别。软件开发是体力和脑力劳动的结合，其中脑力劳动占据了主导地位，善于用脑的工程师是一般都掌握一套可以提高工作效率的工具和工作方式。<br></p><br><p>我个人认为提高工作效率的方式就是总结归纳改进，但是至于如何总结归纳改进则看情况而定。在我经历过的大大小小数十个项目中，多数的工程师变的平庸了，走向卓越的工程师非常稀少。这些人现在遍布在不同的公司，担任着重要的职务，甚至有些人已经创业成功，晋级到了富人阶层。<br></p><br></div>

<div style="text-align:center"><br><img src="http://img5.imgtn.bdimg.com/it/u=2981119672,2990184737&fm=21&gp=0.jpg" width="400" height="300"><br></div>

<h1 id="关于总结"><a href="#关于总结" class="headerlink" title="关于总结"></a>关于总结</h1><div><br><p>项目总结很重要也很必要，至少我是这么认为的。很多重复发生的错误和事故都是因为没及时总结造成的，这简直是犯罪。作为项目管理者，不能指望所有的工程师都会及时总结经验，汲取教训，更不会主动去帮别人总结。<br><br>人的惰性是天性，勤奋的人都是养成习惯才勤奋的，作为管理者要让工程师养成总结的习惯，而不是让他们自己去发挥主观能动性。参与总结的人越多，工程师越是放松，越能说出真实的想法，并付诸行动。<br><br>我开总结会，一般从三个方面来进行，一是自身的不足和改进，二是项目的不足和改进，三是公司提供的资源是否到位。一般来说，前面两点大部分的工程师都能讲出几条不足和改进意见，唯独第三条不知为什么要考虑这个因素。我的观点是，项目不是独立的，研发和测试只是产品生命周期的一个阶段，公司的很多部门都会对研发工作产生影响，很多工程师看不到这点。学会与各个部门打交道，不止是领导层的工作，也是工程师需要具备的能力。<br></p><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为什么项目又延期了？ ——–来自市场的愤怒 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么项目又延期了呢？&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img306.ph.12
    
    </summary>
    
    
  </entry>
  
</feed>
