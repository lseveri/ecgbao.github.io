
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Using Swift with Cocoa and Objective-C (Swift 3.0.1) | 跳跳魔王的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="跳跳魔王">
    

    
    <meta name="description" content="基本构建Swift 被设计成可以与 Cocoa 和 Objective-C无缝兼容。你可以在 Swift 中使用 Objective-C APIs, 也可以在 Objective-C 中使用Swift APIs. 这让 Swift 可以方便容易的移植到你的开发流程里。
这个教程覆盖了 Swift 和 Objective-C 兼容性的三个主要方面, 你在开发Coca 应用时可以使用:
互用性: 让">
<meta property="og:type" content="article">
<meta property="og:title" content="Using Swift with Cocoa and Objective-C (Swift 3.0.1)">
<meta property="og:url" content="http://yoursite.com/2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/index.html">
<meta property="og:site_name" content="跳跳魔王的博客">
<meta property="og:description" content="基本构建Swift 被设计成可以与 Cocoa 和 Objective-C无缝兼容。你可以在 Swift 中使用 Objective-C APIs, 也可以在 Objective-C 中使用Swift APIs. 这让 Swift 可以方便容易的移植到你的开发流程里。
这个教程覆盖了 Swift 和 Objective-C 兼容性的三个主要方面, 你在开发Coca 应用时可以使用:
互用性: 让">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png">
<meta property="og:image" content="http://a1.qpic.cn/psb?/V13UfvND3TZFZo/9jHnlruMgcZ3mMDBe1nUle9hmi4KluzHwU2gd8AKnLM!/b/dN4AAAAAAAAA&bo=qwKeAAAAAAADBxU!&rf=viewer_4">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/DAG_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/bridgingheader_2x.png">
<meta property="og:updated_time" content="2017-01-20T03:20:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Using Swift with Cocoa and Objective-C (Swift 3.0.1)">
<meta name="twitter:description" content="基本构建Swift 被设计成可以与 Cocoa 和 Objective-C无缝兼容。你可以在 Swift 中使用 Objective-C APIs, 也可以在 Objective-C 中使用Swift APIs. 这让 Swift 可以方便容易的移植到你的开发流程里。
这个教程覆盖了 Swift 和 Objective-C 兼容性的三个主要方面, 你在开发Coca 应用时可以使用:
互用性: 让">
<meta name="twitter:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png">

    
    <link rel="alternative" href="/atom.xml" title="跳跳魔王的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="跳跳魔王的博客">跳跳魔王的博客</a></h1>
				<h2 class="blog-motto">每天进步一点点</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/" title="Using Swift with Cocoa and Objective-C (Swift 3.0.1)" itemprop="url">Using Swift with Cocoa and Objective-C (Swift 3.0.1)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="跳跳魔王" target="_blank" itemprop="author">跳跳魔王</a>
		
  <p class="article-time">
    <time datetime="2017-01-13T05:29:42.000Z" itemprop="datePublished"> 发表于 2017-01-13</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本构建"><span class="toc-number">1.</span> <span class="toc-text">基本构建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#建立你的-Swift-环境"><span class="toc-number">2.</span> <span class="toc-text">建立你的 Swift 环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Requiring-Dynamic-Dispatch"><span class="toc-number">3.</span> <span class="toc-text">Requiring Dynamic Dispatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#选择器"><span class="toc-number">4.</span> <span class="toc-text">选择器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不安全的-Objective-C-方法调用"><span class="toc-number">5.</span> <span class="toc-text">不安全的 Objective-C 方法调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#键和键的路径"><span class="toc-number">6.</span> <span class="toc-text">键和键的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-和-Objective-C-在相同的工程"><span class="toc-number">7.</span> <span class="toc-text">Swift 和 Objective-C 在相同的工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#混合匹配概述"><span class="toc-number">8.</span> <span class="toc-text">混合匹配概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从相同应用Target内部导入代码"><span class="toc-number">9.</span> <span class="toc-text">从相同应用Target内部导入代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#向-Swift-导入-Objective-C"><span class="toc-number">10.</span> <span class="toc-text">向 Swift 导入 Objective-C</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#向-Objective-C-导入-Swift"><span class="toc-number">11.</span> <span class="toc-text">向 Objective-C 导入 Swift</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在-Objective-C-中使用-Swift"><span class="toc-number">12.</span> <span class="toc-text">在 Objective-C 中使用 Swift</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#声明一个-Swift-错误类型用于-Objective-C"><span class="toc-number">13.</span> <span class="toc-text">声明一个 Swift 错误类型用于 Objective-C</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为-Objective-C-接口重写-Swift-名"><span class="toc-number">14.</span> <span class="toc-text">为 Objective-C 接口重写 Swift 名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的工厂方法"><span class="toc-number">15.</span> <span class="toc-text">类的工厂方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">16.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#让-Objective-C-接口在-Swift-中可用"><span class="toc-number">17.</span> <span class="toc-text">让 Objective-C 接口在 Swift 中可用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Naming-Your-Product-Module"><span class="toc-number">18.</span> <span class="toc-text">Naming Your Product Module</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Troubleshooting-Tips-and-Reminders"><span class="toc-number">19.</span> <span class="toc-text">Troubleshooting Tips and Reminders</span></a></li></ol>
		
		</div>
		
		<h1 id="基本构建"><a href="#基本构建" class="headerlink" title="基本构建"></a>基本构建</h1><p>Swift 被设计成可以与 Cocoa 和 Objective-C无缝兼容。你可以在 Swift 中使用 Objective-C APIs, 也可以在 Objective-C 中使用Swift APIs. 这让 Swift 可以方便容易的移植到你的开发流程里。</p>
<p>这个教程覆盖了 Swift 和 Objective-C 兼容性的三个主要方面, 你在开发Coca 应用时可以使用:</p>
<ul><br><li><em>互用性</em>: 让 Swift 和 Objective-C 的代码互动, 允许你在 Objective-C 中使用 Swift 的类。在写 Swift 代码时可以采用熟悉的 Cocoa 类, 模式, 和实践。</li><br><li><em>混合匹配</em>: 允许你创建包括 Swift 和 Objective-C 文件的混合语言的应用。</li><br><li><em>移植</em>: 从 Objective-C 代码到 Swift 很容易, 用最新的 Swift 特性替换你的 Objective-C 应用的部分代码成为可能。</li><br></ul>

<p>在你开始学习这些新特性之前, 你需要了解怎么建立一个 Swift 环境, 这个环境里你可以访问 Cocoa 系统框架。</p>
<h1 id="建立你的-Swift-环境"><a href="#建立你的-Swift-环境" class="headerlink" title="建立你的 Swift 环境"></a>建立你的 Swift 环境</h1><p>开始尝试用 Swift 开发 Cocoa 应用, 从Xcode提供的模板创建一个新的 Swift.</p>
<p class="para"><br>  <strong>在Xcode中创建一个 Swift 工程</strong><br></p><br><li>选择 File &gt; New &gt; Project &gt; (iOS, watchOS, tvOS, <em>或者</em> macOS) &gt; Application &gt; <em>你选择模板</em>。</li><br><li>点击 Language 弹出菜单选择 Swift.</li><br><br> <img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png" alt="" width="680" height="485"><br><br>一个 Swift 工程的结构和 Objective-C 工程的结构基本一样, 一个重要的区别是: Swift 没有头文件。在实现和接口之间, 没有显式的描述—所有关于类,函数,或者常量的信息都在一个单独的 .swift 文件里。<br><br>这里, 你现在可以开始在应用代理中写 Swift 代码,或者通过File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, or macOS) &gt; Source &gt; Swift 创建新的 Swift 源文件。<br><br># 要求<br>使用 Swift 3.0 创建应用要求 Xcode 8.0 或以上, 下面是基本SDK要求:<br><img src="http://a1.qpic.cn/psb?/V13UfvND3TZFZo/9jHnlruMgcZ3mMDBe1nUle9hmi4KluzHwU2gd8AKnLM!/b/dN4AAAAAAAAA&bo=qwKeAAAAAAADBxU!&rf=viewer_4" alt="" width="600" height="150"><br><br>Swift 编译器和 Xcode 要求部署目标最低是 iOS 7 或者 macOS 10.9. 设置更早的部署目标会导致构建失败。<br><p class="aside-title">备注<br>    </p><br>        <p class="para">命令行的可执行文件要在它们  <code class="code-voice">@rpath</code>下找到Swift库。 如果你打算用命令行输出一个 Swift 可执行文件, 你也要输送 Swift 动态库。来自Xcode 的 Swift 可执行文件有运行静态连接。<br>        </p><br># 了解 Swift 导入过程<br>建立好 Xcode 工程后, 你可以导入任意 Cocoa 或者 Cocoa Touch 的框架,然后在 Swift 中使用 Objective-C.<br><br>任何 Objective-C 框架或者 C 库支持的模块都可以导入 Swift. 这包括所有的 Objective-C 系统框架—例如 Foundation, UIKit, 和 SpriteKit—同样,一般 C 库也是支持的。例如, 为了使用 Foundation APIs, 在文件最上面添加下面的导入语句:<br> <pre><code><br>      <code> import Foundation </code><br> </code></pre><br><br>有了这个导入语句, 现在 Swift 文件可以访问所有的 Foundation 类,协议,方法,属性和常量。<br><br>导入过程很直接。 Objective-C 框架在头文件提供 APIs. 在 Swift 里, 这些头文件被编译成 Objective-C 模块, 它们被导入 Swift 作为 Swift APIs. 这个导入过程决定了 Objective-C 中声明的函数,类,方法和类型在 Swift中以什么样的代码显示。对于函数和方法来说, 这个过程影响它们的参数类型和返回值。对于类型来说, 导入过程有下面的影响:<br><br><li>重映射某种 Objective-C 类型到 Swift 中的同等类型, 例如 <code class="code-voice">id</code> to <code class="code-voice">Any</code></li><br><li>重映射某种 Objective-C 内置类型到 Swift 中的替代类型, 例如 <code class="code-voice">NSString</code> to <code class="code-voice">String</code></li><br><li>重映射某种 Objective-C 概念去匹配 Swift 中的概念, 例如指针变成可选项。</li><br><br><br><aside class="aside"><br>    <p class="aside-title">备注<br>    </p><br>        <p class="para">你不能向 Swift 直接导入 C++ 代码。替代方式是, 创建一个 Objective-C 或者 C 包装器。<br>        </p><br>  </aside><br>向Objective-C 中导入 Swift 和 向 Swift 中导入 Objective-C 很像。 Swift 提供它的 APIs—例如从一个框架—作为 Swift 模块。与这些 Swift 模块产生 Objective-C 头文件。这些头文件提供可以映射回Objective-C的 APIs. 有些 Swift APIs 不能映射回 Objective-C ,它们语言特性不适合 Objective-C.<br><br># 跟 Objective-C APIs 交互<br><br>互用性是指在 Swift 和 Objective-C 两个方向的能力, 让你在一种语言里访问和使用另外一种语言。当你把 Swift 迁移到你的开发流程时, 要先理解怎么利用互用性来重定义,改进写 Cocoa 应用的方法。<br><br>互用性一个重要部分是, 让你在写 Swift 代码时可以使用 Objective-C APIs. 在导入一个 Objective-C 框架后, 你可以用它来实例化类,然后用原生 Swift 语法与之交互。<br><br># 初始化<br>为了在Swift中实例化一个 Objective-C 类, 你可以调用一个 Swift 语法的构造器。<br><br>Objective-C 构造器以 init, 或者 initWith 开始: 如果构造器有一个或者更多的参数。当一个 Objective-C 构造器被 Swift 导入时, init 前缀变成一个 init 关键字,来表明这个方法是一个 Swift 构造器。如果这个构造器有一个参数, With 会被删除, 剩余部分会相应划分成命名参数。<br><br>看一下下面的 Objective-C 构造器声明:<br><pre><code><br>- (instancetype)init;<br>- (instancetype)initWithFrame:(CGRect)frame<br>                        style:(UITableViewStyle)style;<br></code></pre><br>下面是等价的 Swift 构造器声明:<br><pre><code><br>init() { /<em> … </em>/ }<br>init(frame: CGRect, style: UITableViewStyle) { /<em> … </em>/ }<br></code></pre><br>Objective-C 和 Swift 语法的不同之处是所有实例化对象更明显。<br><br>在 Objective-C 中, 你会这么做:<br><pre><code><br>UITableView <em>myTableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];<br></em></code></pre><br>在 Swift, 你可以这么做:<br><pre><code><br>let myTableView: UITableView = UITableView(frame: CGRectZero, style: .Grouped)<br></code></pre><br>你无需调用 alloc; Swift 替你处理了。同时可以看到, “init” 也没有出现。<br><br>在赋值给一个常量或者变量的时候,你可以指定一个显式的类型, 或者你可以忽略这个类型, 让 Swift 自己从构造器推断。<br><pre><code><br>let myTextField = UITextField(frame: CGRect(x: 0.0, y: 0.0, width: 200.0, height: 40.0))<br></code></pre><br>这些 UITableView 和 UITextField 你在 Objective-C 构造的对象, 在这里都是一样的。你可以像在 Objective-C 中一样使用它们, 访问各自类型中定义的属性和方法。<br><br># 类工厂方法和便利构造器<br>考虑到一致性和简单性, Objective-C 类工厂方法在 Swift 中会作为便利构造器使用。这让它们可以像构造器一样使用。<br><br>例如, 你在 Objective-C 中这样调用工厂方法:<br><pre><code><br>UIColor color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];<br></code></pre><br>而在 Swift 中, 可以这样调用:<br><pre><code><br>let color = UIColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0)<br></code></pre><br># 可失败的构造<br>在 Objective-C 中, 构造器直接返回它们构造的对象。为了告诉调用者构造失败, Objective-C 构造器会返回 nil. 在 Swift 中, 这个模式被构建成一个语言特性,叫可失败的构造。<br><br>许多系统框架的 Objective-C 构造器可以表示构造是否失败。你可以用nullability 注释表明这些构造器能否失败, 它们在 Nullability and Optionals 中描述。它们或者被导入成 init(…)—构造不会失败—或者 init?(…)—构造可以失败。因此, Objective-C 构造器被导入成 init!(…).<br><br>例如, 如果所提供的路径不存在一张图片的话, the UIImage(contentsOfFile:) 构造器就会失败。如果构造成功, 你可以用可选绑定来拆包一个可失败构造器的结果。<br><br><pre><code><br>if let image = UIImage(contentsOfFile: “MyImage.png”) {<br>    // loaded the image successfully<br>} else {<br>    // could not load the image<br>}<br></code></pre><br># 访问属性<br>用 @property语法声明的 Objective-C 属性用以下方式导入 Swift:<br><ul><br><li>带有非空属性的属性 (<code>nonnull</code>, <code>nullable</code>, 和 <code>null_resettable</code>) 以可选或者非可选类型导入 Swift, 它们在 Nullability and Optionals 中描述。</li><br><li>带有 <code>readonly</code> 的属性导入 Swift ,作为计算属性,有一个 getter ({ <code>get</code> }).</li><br><li>带有 <code>weak</code> 的属性导入 Swift,用 <code>weak</code> 关键字标记 (<code>weak var</code>).</li><br><li>带有自由属性的属性,而不是 <code>weak</code> (意思是, <code>assign</code>, <code>copy</code>, <code>strong</code>, 或者 <code>unsafe_unretained</code>) 以适当的存储属性导入 Swift.</li><br><li>带有 <code>class</code> 的属性作为类型属性导入 Swift.</li><br><li>原子属性 (<code>atomic</code> 和 <code>nonatomic</code>) 没有对应的 Swift 属性声明, 不过在Swift访问这些导入属性时, Objective-C 实现的原子性会保留。</li><br><li>访问器属性 (<code>getter=</code> 和 <code>setter=</code>) 在 Swift 中忽略。</li><br></ul><br><br>在 Swift 中访问 Objective-C 对象属性使用点语法, 使用属性名不带括号。<br><br>例如, 你可以用下面的代码设置一个 UITextField  对象的textColor 和 text 属性:<br><pre><code><br>myTextField.textColor = UIColor.darkGray<br>myTextField.text = “Hello world”<br></code></pre><br>返回一个值并且不带参数的 Objective-C 方法可以像 Objective-C 属性那样用点语法调用。不过, 它们导入 Swift 会变成实例方法, 因为只有 Objective-C @property 声明的会作为属性导入 Swift. 方法的导入和调用在 Working with Methods（使用方法） 中描述。<br><br># 使用方法<br>通过点语法在 Swift 中调用 Objective-C 方法。<br><br>当 Objective-C 方法导入 Swift 时, Objective-C 选择器的第一部分成为方法名,并且出现在括号前。第一个参数直接出现在括号内, 没有名字。选择器的剩余部分对应参数名,出现在括号内。所有选择器部分要求在调用位置。<br><br>例如, 鉴于在 Objective-C 中你这样做:<br><pre><code><br>[myTableView insertSubview:mySubview atIndex:2];<br></code></pre><br>在 Swift 中, 你可以这样做:<br><pre><code><br>myTableView.insertSubview(mySubview, at: 2)<br></code></pre><br>如果你调用无参数的方法, 你仍然需要带上括号。<br><pre><code><br>myTableView.layoutIfNeeded()<br></code></pre><br># id 兼容性<br>Objective-C 的 id 类型作为 Any 类型导入 Swift。 在编译和运行期, 当一个 Swift 值或者对象作为 id 参数传给Objective-C 时, 编译器会引入一个通用的桥接转换操作。当 id 值作为 Any 类型导入 Swift, 运行期自动处理桥接到类引用或者 Swift 值类型。<br><pre><code><br>var x: Any = “hello” as String<br>x as? String   // String with value “hello”<br>x as? NSString // NSString with value “hello”<br><br>x = “goodbye” as NSString<br>x as? String   // String with value “goodbye”<br>x as? NSString // NSString with value “goodbye”<br></code></pre><br><br># 向下转换 Any<br>当使用Any类型的对象时, 这里潜在的类型可以知道或者有理由确定, 通常把这些对象向下转换成更具体的类型。不过, 由于 Any 类型可以引用任意类型, 向下转换不能保证一定成功。<br><br>你可以使用条件类型转换运算符 (as?), 它可以返回一个你想转换类型的的可选值:<br><pre><code><br>let userDefaults = UserDefaults.standard<br>let lastRefreshDate = userDefaults.object(forKey: “LastRefreshDate”) // lastRefreshDate is of type Any?<br>if let date = lastRefreshDate as? Date {<br>    print(“(date.timeIntervalSinceReferenceDate)”)<br>}<br></code></pre><br>如果你确定对象的类型, 你可以用强制转换运算符 (as!).<br><pre><code><br>let myDate = lastRefreshDate as! Date<br>let timeInterval = myDate.timeIntervalSinceReferenceDate<br></code></pre><br>不过, 如果强制转换失败了, 会触发一个运行时的错误:<br><pre><code><br>let myDate = lastRefreshDate as! String // Error<br></code></pre><br><br># 动态方法查找<br>Swift 也有一个 <code>AnyObject</code> 类型, 它代表某种类型的对象,这个对象拥有动态查找任意 <code>@objc</code> 方法的能力。 这样你就可以写出灵活的无类型访问 Objective-C APIs, 这些APIs 返回 id 值。<br><br>例如, 你可以把任意类类型的对象赋值给一个 <code>AnyObject</code> 类型的常量或者变量, 再把一个变量赋值给一个不同类型的变量。你也可以调用任意 Objective-C 方法, 访问一个 <code>AnyObject</code> 值的一个属性,而不用转换成更具体的类类型。<br><pre><code><br>var myObject: AnyObject = UITableViewCell()<br>myObject = NSDate()<br>let futureDate = myObject.addingTimeInterval(10)<br>let timeSinceNow = myObject.timeIntervalSinceNow<br></code></pre><br><br># 无法辨识的选择器和可选链<br>因为一个 <code>AnyObject</code> 的具体值直到运行时才知晓, 因此可能无意中写出不安全的代码。在 Swift 中,同 Objective-C 一样, 尝试调用一个不存在的方法, 也会触发一个无法辨识的选择器的错误。<br><br>例如, 下面的代码没有编译警告, 但是会触发运行时错误:<br><pre><code><br>myObject.character(at: 5)<br>// crash, myObject doesn’t respond to that method<br></code></pre><br>Swift 使用可选项来防范这种不安全的行为。当你在 AnyObject 类型值上调用方法的时候, 这个方法的调用行为就像是一个隐式拆包可选项。 你可以使用相同的可选链接语法, 你会在协议中的可选方法里使用, 调用 <code>AnyObject</code> 的方法。<br><br>例如, 下面的代码, 第一行和第二行代码不会执行, 因为 <code>count</code> 熟悉和 <code>character(at:)</code> 方法在 <code>NSDate</code> 对象中不存在。<code>myCount</code> 常量可以推断出是一个可选的整型, 并且值为 <code>nil</code>. 你也可以使用 <code>if–let</code> 语句去有条件拆包一个方法的结果, 这个方法对象可能不会响应, 下面三行显示。<br><pre><code><br>// myObject has AnyObject type and NSDate value<br>let myCount = myObject.count<br>// myCount has Int? type and nil value<br>let myChar = myObject.character?(at: 5)<br>// myChar has unichar? type and nil value<br>if let fifthCharacter = myObject.character?(at: 5) {<br>    print(“Found (fifthCharacter) at index 5”)<br>}<br>// 条件分支没有执行<br></code></pre><br>备注<br><br>尽管,在调用 <code>AnyObject</code> 类型的方法时, Swift 没有要求强制拆包, 它可以作为一个防范非预期行为的手段。<br># 为空性和可选项<br>在 Objective-C 里面, 使用原始指针调用对象有可能是 <code>NULL</code> (在 Objective-C 中是<code>nil</code>). 在 Swift 中, 所有的值—包括结构体和对象引用—都是保证非空的。表达一个值可以缺失的方法是, 把这个值的类型包进一个可选项类型。当你需要表示这个值缺失的时候, 你可以使用<code>nil</code>.<br><br>Objective-C 可以用为空性注释来指定一个参数类型, 属性类型, 或者返回值, 是一个 <code>NULL</code> 或者 <code>nil</code> 值。单个类型声明可以使用 <code>_Nullable</code> 和 <code>_Nonnull</code> 注释, 单个属性声明可以用 <code>nullable</code>, <code>nonnull</code> 和 <code>null_resettable</code>, 或者整个区域都可以用 <code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code> 宏标记为空性。如果一个类型没有提供为空性, Swift 无法区分可选项和非可选项的引用, 然后会以一个隐式拆包可选项来导入。<br><br><ul><br><li>类型声明成可以为空, 或者用一个 <code>_Nonnull</code> 注释或者在一个授权区域, 作为一个非可选项导入 Swift.</li><br><li>使用一个 <code>_Nullable</code> 注释声明类型成可以为空, 作为一个可选项导入 Swift.</li><br><li>没有为空性注释的类型,作为一个隐式拆包可选项导入 Swift.</li><br></ul><br><br>例如, 下面的 Objective-C 声明:<br><pre><code><br>@property (nullable) id nullableProperty;<br>@property (nonnull) id nonNullProperty;<br>@property id unannotatedProperty;<br>NS_ASSUME_NONNULL_BEGIN<br>- (id)returnsNonNullValue;<br>- (void)takesNonNullParameter:(id)value;<br>NS_ASSUME_NONNULL_END<br>- (nullable id)returnsNullableValue;<br>- (void)takesNullableParameter:(nullable id)value;<br>- (id)returnsUnannotatedValue;<br>- (void)takesUnannotatedParameter:(id)value;<br></code></pre><br><br>这里是导入 Swift后的样子:<br><pre><code><br>var nullableProperty: Any?<br>var nonNullProperty: Any<br>var unannotatedProperty: Any!<br>func returnsNonNullValue() -&gt; Any<br>func takesNonNullParameter(value: Any)<br>func returnsNullableValue() -&gt; Any?<br>func takesNullableParameter(value: Any?)<br>func returnsUnannotatedValue() -&gt; Any!<br>func takesUnannotatedParameter(value: Any!)<br></code></pre><br>大多数的 Objective-C 系统框架, 包括 Foundation, 已经提供了为空性的注释, 允许你以一个惯用和类型安全的方式使用值。<br><br># 非空对象的桥接可选项<br>Swift 向非空 Objective-C 对象的桥接可选值, 根据可选项是否包含一个潜在值来决定。如果可选项为 nil, Swift 把这个nil值桥接成NSNull 实例。因此, Swift 用拆包值来桥接可选项。<br><br>下面的代码展示了 String? 实例怎么怎么根据它们的值桥接到 Objective-C.<br><pre><code><br>@implementation OptionalBridging<br>+ (void)logSomeValue:(nonnull id)valueFromSwift {<br>    if ([valueFromSwift isKindOfClass: [NSNull class]]) {<br>        os_log(OS_LOG_DEFAULT, “Received an NSNull value.”);<br>    } else {<br>        os_log(OS_LOG<em>DEFAULT, “%s”, [valueFromSwift UTF8String]);<br>    }<br>}<br>@end<br></em></code></pre><br>因为 valueFromSwift 参数类型是 id, 它导入 Swift 会作为 Any类型。不过, 因为在 Any 不常用时, 传入一个可选项。传入 logSomeValue(:) 类方法的可选项显式转换为 Any 类型, 这个会去掉编译器的警告。<br><pre><code><br>let someValue: String? = “Bridge me, please.”<br>let nilValue: String? = nil<br>OptionalBridging.logSomeValue(someValue as Any)  // Bridge me, please.<br>OptionalBridging.logSomeValue(nilValue as Any)   // Received an NSNull value.<br></code></pre><br># 协议资格的类<br>Objective-C 的协议资格的类作为类型值导入 Swift. 例如, 给出下面的 Objective-C 方法,在一个特定类执行一个操作:<br><pre><code><br>- (void)doSomethingForClass:(Class\<nscoding>)codingClass;<br></nscoding></code></pre><br>这里是 Swift 怎么导入它:<br><pre><code><br>func doSomething(for codingClass: NSCoding.Type)<br></code></pre><br><br># 轻量级泛型<br>使用轻量级泛型参数化的 Objective-C 类型,带有保留内容类型的信息导入 Swift. 例如, 下面的 Objective-C 属性声明:<br><pre><code><br>@property NSArray\<nsdate *=""> <em>dates;<br>@property NSCache\&lt;NSObject </em>, id\<nsdiscardablecontent>&gt; <em>cachedData;<br>@property NSDictionary \&lt;NSString </em>, NSArray\<nslocale *="">&gt; <em>supportedLocales;<br></em></nslocale></nsdiscardablecontent></nsdate></code></pre><br>导入 Swift 后:<br><pre><code><br>var dates: [Date]<br>var cachedData: NSCache<anyobject, nsdiscardablecontent=""><br>var supportedLocales: [String: [Locale]]<br></anyobject,></code></pre><br>用 Objective-C 写的参数化的类, 作为一个带有相同数量类型参数的泛型类导入 Swift. 所有 Swift导入后的 Objective-C 泛型参数都有一个类型限制, 要求这个类型是一个 class (T: Any). 如果 Objective-C 泛型参数化指定了一个类的资质, 那么导入到 Swift 类有一个限制, 那就是要求这个类型是这个指定类的子类。 如果 Objective-C 泛型参数化指定了一个协议资质, 那么导入到 Swift 的类有一个限制, 那就是要求这个类型符合这个协议。对于一个未指定的 Objective-C 类型, Swift 为导入的类类型限制推断泛型参数。例如, 下面给出的 Objective-C 类和分类声明:<br><pre><code><br>@interface List\<t: id\<nscopying="">&gt; : NSObject<br>- (List\<t> )listByAppendingItemsInList:(List\<t> <em>)otherList;<br>@end<br>@interface ListContainer : NSObject<br>- (List\&lt;NSValue </em>&gt; <em>)listOfValues;<br>@end<br>@interface ListContainer (ObjectList)<br>- (List </em>)listOfObjects;<br>@end<br></t></t></t:></code></pre><br>下面的导入 Swift后的:<br><pre><code><br>class List\<t: nscopying=""> : NSObject {<br>    func listByAppendingItemsInList(otherList: List\<t>) -&gt; List\<t><br>}<br>class ListContainer : NSObject {<br>    func listOfValues() -&gt; List\<nsvalue><br>}<br>extension ListContainer {<br>    func listOfObjects() -&gt; List\<nscopying><br>}<br></nscopying></nsvalue></t></t></t:></code></pre><br><br># 扩展<br>Swift 的扩展和 Objective-C 的分类很像。扩展是增加现有类,结构体和枚举的行为, Objective-C 也包括这些。你可以给系统框架类型或者自定义类型定义扩展。简单导入对应模块, 然后像在 Objective-C 中一样, 用相同的名字调用类,结构体和枚举。<br><br>例如, 你可以扩展 UIBezierPath 类, 基于一个提供的边长和起始点, 然后用等边三角形创建一个贝塞尔路径。<br><pre><code><br>extension UIBezierPath {<br>    convenience init(triangleSideLength: CGFloat, origin: CGPoint) {<br>        self.init()<br>        let squareRoot = CGFloat(sqrt(3.0))<br>        let altitude = (squareRoot <em> triangleSideLength) / 2<br>        move(to: origin)<br>        addLine(to: CGPoint(x: origin.x + triangleSideLength, y: origin.y))<br>        addLine(to: CGPoint(x: origin.x + triangleSideLength / 2, y: origin.y + altitude))<br>        close()<br>    }<br>}<br></em></code></pre><br>你可以用扩展添加属性 (包括类和静态属性)。不过, 这些属性必须可以计算; 扩展不能给类,结构体或者枚举添加存储属性。<br><br>下面的例子给 CGRect 扩展了一个 area 计算属性:<br><pre><code><br>extension CGRect {<br>    var area: CGFloat {<br>        return width  height<br>    }<br>}<br>let rect = CGRect(x: 0.0, y: 0.0, width: 10.0, height: 50.0)<br>let area = rect.area<br></code></pre><br>你可以给一个类扩展协议,而不用子类化。如果协议定义在 Swift 中, 你还可以向结构体或者枚举添加。<br><br>你不可以用扩展来覆盖 Objective-C 类型已有的方法和属性。<br><br># 闭包<br>Objective-C 块作为闭包自动导入 Swift, 用 Objective-C 块的调用约定, 标记为 <code>@convention(block)</code> 属性。例如, 下面是一个 Objective-C 块变量:<br><pre><code><br>void (^completionBlock)(NSData <em>) = ^(NSData </em>data) {<br>   // …<br>}<br></code></pre><br>下面是 Swift 的版本:<br><pre><code><br>let completionBlock: (Data) -&gt; Void = { data in<br>    // …<br>}<br></code></pre><br>Swift 闭包和 Objective-C 块是兼容的, 所以你向需要块的 Objective-C 方法传入 Swift 的闭包。Swift 闭包和函数有相同的类型, 所以你甚至可以传入一个 Swift 函数名。<br><br>闭包和块一样有相似的捕获语义, 只是有一个关键地方不一样: 变量是可变的而不是拷贝的。换句话说, Objective-C 中 <code><strong>block</strong></code> 的行为是 Swift 变量的默认行为。<br><br># 捕获 self 时避免强引用循环<br>在 Objective-C 里, 如果你需要在一个块中捕获 self, 有必要去考虑内存管理的实现。<br><br>块维持对所有捕获对象的强引用, 包括 self. 如果 self 维持对块的强引用, 比如一个拷贝属性, 这会产生一个强引用循环。为了避免这个, 你可以用一个弱引用 self 来替换:<br><pre><code>
weak typeof(self) weakSelf = self;<br>self.block = ^{<br>   <strong>strong typeof(self) strongSelf = weakSelf;<br>   [strongSelf doSomething];<br>};<br></strong></code></pre><br>如同在 Objective-C 中的块, Swift 中的闭包也维持对所有捕获对象的强引用, 包括 self. 为了防止强引用循环, 你可以在闭包捕获列表里, 指定 self 为无主的:<br><pre><code><br>self.closure = { [unowned self] in<br>    self.doSomething()<br>}<br></code></pre><br><br># 对象比较<br>在 Swift 中你可以在两个对象中进行不同类型的比较。第一个, 等于 (==), 比较两个对象的内容。 第二个, 恒等于 (===), 判断常量或者变量是否引用了相同的对象实例。<br><br>Swift 提供了 == 和 === 运算符的默认实现, 对源于 NSObject 类的对象采用 Equatable 协议。== 运算符的默认实现调用了 isEqual: 方法, === 运算符的默认实现是判断指针是否相等。你不能重写来自 Objective-C 的等式运算符。<br><br>isEqual 的基本实现: NSObject 类提供, 等于判断指针的相等性。你可以重写 isEqual: 在一个子类里, 基于对象的内容而不是本身, 让 Swift 和 Objective-C APIs 决定是否相等。<br><br>备注<br><br>Swift 自动提供等式运算符的补充部分 (!= and !==). 这些不能重写。<br><br># 哈希<br>Swift 导入NSDictionary 声明, 没有为键类型指定一个类的资质, 只是作为带有键类型是 AnyHashable 的字典。类似的, 没有一个类资质对象类型声明的 NSSet, 值作为一个带有元素类型是 AnyHashable 的集合导入 Swift. 如果一个 NSDictionary 或者 NSSet 声明参数化它的键或者对象类型, 就分别用类型代替。例如, 下面是 Objective-C 的声明:<br><pre><code><br>@property NSDictionary <em>unqualifiedDictionary;<br>@property NSDictionary\&lt;NSString </em>, NSDate <em>&gt; </em>qualifiedDictionary;<br>@property NSSet <em>unqualifiedSet;<br>@property NSSet\&lt;NSString </em>&gt; *qualifiedSet;<br></code></pre><br>这里是 Swift 导入后的:<br><pre><code><br>var unqualifiedDictionary: [AnyHashable: Any]<br>var qualifiedDictionary: [String: Date]<br>var unqualifiedSet: Set\<anyhashable><br>var qualifiedSet: Set\<string><br></string></anyhashable></code></pre><br>用未指定或者id类型导入 Objective-C 声明时, Swift 会使用 AnyHashable 类型, 如果不是就作为 Any类型, 因为类型需要符合哈希协议。AnyHashable 类型从任意哈希类型隐式转换, 你可以使用 as? 和 as! 运算符, 从 AnyHashable 转换为一个更具体的类型。<br><br># Swift 类型兼容性<br>当你创建一个来自 Objective-C 类的 Swift 类, 这个类和它的成员属性,方法,下标和构造器—从 Objective-C 自动可用。它不包括 Swift-特有的特性, 列举如下:<br><ul><br><li>泛型 </li><br><li>元组 </li><br><li>没有整数原始值的枚举</li><br><li>结构体</li><br><li>顶层函数</li><br><li>全局变量</li><br><li>类型别名</li><br><li>可变类型</li><br><li>内嵌类型</li><br><li>柯里化函数</li><br></ul><br><br>Swift APIs 和 Objective-C APIs 转换规则:<br><ul><br><li>Swift 可选类型解释为 nullable.</li><br><li>Swift 非可选类型解释为 <strong>nonnull.</strong></li><br><li>Swift 常量存储属性和计算属性变成只读 Objective-C 属性。</li><br><li>Swift 变量存储属性变成读写 Objective-C 属性。</li><br><li>Swift 类型属性变成带有类属性的 Objective-C 属性。</li><br><li>Swift 类型方法变成 Objective-C 类方法。</li><br><li>Swift 构造器和实例方法变成 Objective-C 的实例方法。</li><br><li>Swift 抛出错误的方法变成带有NSError <em>*参数的 Objective-C 方法。如果 Swift 方法没有参数, AndReturnError: 添加在 Objective-C 方法名的后面, 否则添加 error:. 如果 Swift 方法没有指定返回值, 对应的 Objective-C 方法有一个布尔返回类型。如果Swift 方法返回一个非可选类型, 对应的 Objective-C 有一个可选的返回类型。</em></li><br></ul><br><br>例如, 下面是 Swift 声明:<br><br><pre><code><br>class Jukebox: NSObject {<br>    var library: Set<string><br><br>    var nowPlaying: String?<br><br>    var isCurrentlyPlaying: Bool {<br>        return nowPlaying != nil<br>    }<br><br>    class var favoritesPlaylist: [String] {<br>        // return an array of song names<br>    }<br><br>    init(songs: String…) {<br>        self.library = Set<string>(songs)<br>    }<br><br>    func playSong(named name: String) throws {<br>        // play song or throw an error if unavailable<br>    }<br>}<br></string></string></code></pre><br>下面是导入 Objective-C 后的样子:<br><pre><code><br>@interface Jukebox : NSObject<br>@property (nonatomic, strong, nonnull) NSSet&lt;NSString &gt; <em>library;<br>@property (nonatomic, copy, nullable) NSString </em>nowPlaying;<br>@property (nonatomic, readonly, getter=isCurrentlyPlaying) BOOL currentlyPlaying;<br>@property (nonatomic, class, readonly, nonnull) NSArray<nsstring *=""> <em> favoritesPlaylist;<br>- (nonnull instancetype)initWithSongs:(NSArray&lt;NSString </em>&gt; * nonnull)songs OBJC_DESIGNATED_INITIALIZER;<br>- (BOOL)playSong:(NSString <em> __nonnull)name error:(NSError </em> <strong>nullable * </strong>null_unspecified)error;<br>@end<br></nsstring></code></pre><br><br>备注:你不能在 Objective-C 里子类化 Swift 的类。<br><br># 在 Objective-C 里配置 Swift 接口<br><br>在一些情况下, 你需要仔细控制怎么把 Swift API 暴露给 Objective-C. 你可以用 @objc(name) 特性来改变一个类,属性,方法,枚举类型或者枚举分支声明的名字。<br><br>例如, 如果你的 Swift 类名包含了 Objective-C 不支持的字符, 你可以提供一个替代的名字。如果你为一个 Swift 函数提供一个 Objective-C 名, 就使用 Objective-C 选择器语法。记住在选择器部分后面的参数加上冒号 (:).<br><br><pre><code><br>@objc(Color)<br>enum Цвет: Int {<br>    @objc(Red)<br>    case Красный<br><br>    @objc(Black)<br>    case Черный<br>}<br><br>@objc(Squirrel)<br>class Белка: NSObject {<br>    @objc(color)<br>    var цвет: Цвет = .Красный<br><br>    @objc(initWithName:)<br>    init (имя: String) {<br>        // …<br>    }<br>    @objc(hideNuts:inTree:)<br>    func прячьОрехи(количество: Int, вДереве дерево: Дерево) {<br>        // …<br>    }<br>}<br></code></pre><br>在一个 Swift 类上使用 @objc(name)时, 这个类可以在 Objective-C 中使用, 没有任何命名空间。结果就是, 把一个可归档的 Objective-C 类移植到 Swift 时, 这个特性很有用。 因为归档对象在归档中存储它们的类名, 你应该使用 @objc(name) 特性来指定相同的名字作为你的 Objective-C 类, 这样的话, 老的归档可以被新的 Swift 类反归档。<br><br><p><br>备注:相反, Swift 也提供了 @nonobjc 特性, 它可以让一个 Swift 声明在 Objective-C 中无效。你可以用它来解决桥接方法的循环问题, 同时允许对被 Objective-C 导入的类的方法进行重载。如果一个 Objective-C 方法被无法在 Objective-C 里表示的 Swift 方法重写, 例如指定一个参数是变量, 这个方法必须标记为 @nonobjc.<br></p>

<h1 id="Requiring-Dynamic-Dispatch"><a href="#Requiring-Dynamic-Dispatch" class="headerlink" title="Requiring Dynamic Dispatch"></a>Requiring Dynamic Dispatch</h1><p>在 Swift APIs 被 Objective-C 运行期导入时, 不能保证属性,方法,下标或者构造器的动态调度。Swift 编译器可能仍然要去虚拟化或者内联成员访问来优化你的代码性能, 绕过 Objective-C 运行期。</p>
<p>你可以用 dynamic 修饰符来要求整个运行期的访问是动态调度的。要求动态调度很少用到。不过, 在使用例如键值观察或者 method_exchangeImplementations 运行期函数是就很有必要。它们会在运行期动态替换掉一个方法的实现。如果 Swift 编译器内部实现这个方法或者去虚拟化访问它, 这个新的实现就用不到了。</p>
<p>备注: 用 dynamic 修饰符标记的声明不能同时用 @nonobjc 特性标记。</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>在 Objective-C 中, 一个选择器是一个调用 Objective-C 方法名的类型。在 Swift 中, Objective-C 选择器用 Selector 结构体表示, 可以用 #selector 表达式构造。 要创建可以被 Objective-C 调用的方法选择器, 传入一个方法名, 例如 #selector(MyViewController.tappedButton(sender:)). 要创建一个属性的 getter 或者 setter 方法选择器, 传入属性名, 前面加上 getter: 或者 setter: 标签, 例如 #selector(getter: MyViewController.myButton).</p>
<pre><code>
import UIKit
class MyViewController: UIViewController {
    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))

    override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        let action = #selector(MyViewController.tappedButton)
        myButton.addTarget(self, action: action, forControlEvents: .touchUpInside)
    }

    func tappedButton(sender: UIButton?) {
        print("tapped button")
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
}
</code></pre>

<p>备注</p>
<p>Objective-C 方法调用可以用括号括起来, 它可以用作消除重载函数歧义的运算符, 例如 #selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void)).</p>
<h1 id="不安全的-Objective-C-方法调用"><a href="#不安全的-Objective-C-方法调用" class="headerlink" title="不安全的 Objective-C 方法调用"></a>不安全的 Objective-C 方法调用</h1><p>你可以在一个兼容的 Objective-C 对象上调用一个 Objective-C 方法, 通过一个 perform(<em>:) 方法选择器或者是它的变种。通过选择器调用方法本质上是不安全的, 因为编译器不能对结果有任何保证, 甚至不能保证对象是否可以响应这个选择器。因此, 使用这些 APIs 是强烈不鼓励的, 除非你的代码很依赖动态实现。例如, 如果你需要在接口里使用 target-action 模式来实现, 使用这些 APIs 还比较合适, 就像 NSResponder 做的那样。在大多数情况下, 把对象转换成 AnyObject, 然后使用函数调用可选链, 才更安全和方便。<br>这些方法同步执行一个选择器, 例如 perform(</em>:), 返回一个隐式拆包的可选的非托管指针, 指向一个 AnyObject 实例 (Unmanaged<anyobject>!), 因为执行选择器返回值的类型和所有权不是在编译期决定的。相反, 特别线程或者延迟执行的选择器, 例如 perform(<em>:on:with:waitUntilDone:modes:) 和 perform(</em>:with:afterDelay:), 不会返回值。</anyobject></p>
<pre><code>
let string: NSString = "Hello, Cocoa!"
let selector = #selector(NSString.lowercased(with:))
let locale = Locale.current
if let result = string.perform(selector, with: locale) {
    print(result.takeUnretainedValue())
}
// Prints "hello, cocoa!"
</code></pre>
调用一个没有指定的选择器会导致 doesNotRecognizeSelector(_:)的调用, 它默认抛出一个 NSInvalidArgumentException 的异常。

<pre><code>
let array: NSArray = ["delta", "alpha", "zulu"]

// Not a compile-time error because NSDictionary has this selector.
let selector = #selector(NSDictionary.allKeysForObject)

// Raises an exception because NSArray does not respond to this selector.
array.perform(selector)
</code></pre>

<h1 id="键和键的路径"><a href="#键和键的路径" class="headerlink" title="键和键的路径"></a>键和键的路径</h1><p>在 Objective-C 中, 一个键就是一个标示特定对象属性的字符串; 一个键路径是一个用点分开的多个键的字符串, 它指定了对象属性遍历的顺序。键和键路径经常用于键值编码 (KVC), 它是一个用字符串标识符间接访问一个对象属性和关系的机制。它们也经常用于键值观察 (KVO), 它是一种通知机制, 当其他对象的属性发生变化时, 一个对象可以获得通知。</p>
<p>在 Swift 中, 你可以用 #keyPath 表达式来产生一个编译器判断的键和键路径, 可以用于 KVC 方法,比如 value(forKey:) 和 value(forKeyPath:), 也可以用于 KVO 方法,比如 addObserver(_:forKeyPath:options:context:). #keyPath 接受链式的方法和属性调用, 例如 #keyPath(Person.bestFriend.name).</p>
<p>备注</p>
<p>#keyPath 表达式的语法和 #selector 表达式语法相似。</p>
<pre><code>
class Person: NSObject {
    var name: String
    var friends: [Person] = []
    var bestFriend: Person? = nil

    init(name: String) {
        self.name = name
    }
}

let gabrielle = Person(name: "Gabrielle")
let jim = Person(name: "Jim")
let yuanyuan = Person(name: "Yuanyuan")
gabrielle.friends = [jim, yuanyuan]
gabrielle.bestFriend = yuanyuan

#keyPath(Person.name)
// "name"
gabrielle.value(forKey: #keyPath(Person.name))
// "Gabrielle"
#keyPath(Person.bestFriend.name)
// "bestFriend.name"
gabrielle.value(forKeyPath: #keyPath(Person.bestFriend.name))
// "Yuanyuan"
#keyPath(Person.friends.name)
// "friends.name"
gabrielle.value(forKeyPath: #keyPath(Person.friends.name))
// ["Yuanyuan", "Jim"]
</code></pre>

<h1 id="Swift-和-Objective-C-在相同的工程"><a href="#Swift-和-Objective-C-在相同的工程" class="headerlink" title="Swift 和 Objective-C 在相同的工程"></a>Swift 和 Objective-C 在相同的工程</h1><p>Swift 和 Objective-C 的兼容性, 让你可以用两种语言写的文件来创建一个工程。你可以使用混合匹配的特性, 来写混合代码的应用。使用混合匹配, 你可以用最新的 Swift 的特性来实现应用的部分功能, 然后无缝合并入已有的 Objective-C 代码。</p>
<h1 id="混合匹配概述"><a href="#混合匹配概述" class="headerlink" title="混合匹配概述"></a>混合匹配概述</h1><p>Objective-C 和 Swift 文件可以在一个工程里共存, 不管这个工程原先是用哪个语言写的。你可以向现有工程添加另外一个语言的文件。这使得创建混合语言的应用和框架目标, 和用一种语言直接创建的应用流程一样。</p>
<p>使用混合语言的区别只是取决于你写的是一个应用还是一个框架。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/DAG_2x.png" alt="" width="473" height="321"></p>
<h1 id="从相同应用Target内部导入代码"><a href="#从相同应用Target内部导入代码" class="headerlink" title="从相同应用Target内部导入代码"></a>从相同应用Target内部导入代码</h1><p>如果你在写一个混合语言的应用, 你可能需要在 Swift 代码里访问 Objective-C 的代码, 同时也需要在 Objective-C 代码里访问 Swift 的代码。</p>
<h1 id="向-Swift-导入-Objective-C"><a href="#向-Swift-导入-Objective-C" class="headerlink" title="向 Swift 导入 Objective-C"></a>向 Swift 导入 Objective-C</h1><p>为了把 Objective-C 文件导入同个目标的 Swift 代码, 你要依赖一个 Objective-C 的桥接头来把这些文件暴露给 Swift. Xcode 提供了这个功能。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/Art/bridgingheader_2x.png" alt="" width="592" height="168"></p>
<p>如果你接受, Xcode 在你创建文件的时候同时创建这个头文件, 然后用产品名加上”-Bridging-Header.h”来命名。</p>
<p>或者, 你也可以自己创建这个头文件, 选择 File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, 或者 macOS) &gt; Source &gt; Header File.</p>
<p>你需要编辑这个桥接头文件, 把 Objective-C 代码暴露给 Swift 的代码。</p>
<p>在相同工程把 Objective-C 代码导入 Swift</p>
<p><ul></ul></p>
<p><li>在 Objective-C 桥接头文件中, 导入每个需要暴露给 Swift 的 Objective-C 头文件。例如:</li></p>
<pre><code>
\#import "XYZCustomCell.h"
\#import "XYZCustomView.h"
\#import "XYZCustomViewController.h"
</code></pre>
<li>在 Build Settings 中, 在 Swift Compiler - Code Generation, 确保 Objective-C Bridging Header build setting 下面有这个桥接头文件的路径。<br>
这个路径应该关联你的工程, 类似工程里的 Info.plist 路径设置。大多数情况下, 你不需要修改这个设置。</li>
桥接头文件里列出的所有 Objective-C 头文件对 Swift 都是可见的。Objective-C 功能可以用在任意 Swift 文件里, 不需要任何导入语句。 用相同的 Swift 语法使用自定义的 Objective-C 代码。
<pre><code>
let myCell = XYZCustomCell()
myCell.subtitle = "A custom cell"
</code></pre>

<h1 id="向-Objective-C-导入-Swift"><a href="#向-Objective-C-导入-Swift" class="headerlink" title="向 Objective-C 导入 Swift"></a>向 Objective-C 导入 Swift</h1><p>当你向 Objective-C 导入 Swift 代码时, 你要依赖 Xcode-产生的头文件来把这些文件暴露给 Objective-C. 这个自动产生的文件是一个 Objective-C 头文件, 它声明了 Swift 的接口。头文件的名字是你的产品名加上”-Swift.h”. </p>
<p>默认情况下, 产生的头文件, 包含的 Swift 声明的接口带有public 或者 open 修饰符。如果你的应用有一个 Objective-C 桥接头文件, 它也会包含标记为 internal 修饰符的接口。标记为 private 或者 fileprivate 修饰符的接口不会出现在头文件里。除非显式标记为 @IBAction, @IBOutlet, 否则 Private 声明不会暴露给 Objective-C, @objc 也一样。如果你的应用打开了测试, 一个单元测试目标可以访问任何带有 internal 修饰符的声明, 通过把 @testable 放在产品模块导入语句, 就像它们用 public 声明一样。</p>
<p>你不需要做什么来创建这个头文件—只要在 Objective-C 代码中导入它。注意, 头文件里的 Swift 接口包括对所有用到的 Objective-C 类型的调用。如果你在 Swift 代码里使用你自己的 Objective-C 类型, 在导入 Swift 产生的头文件到 Objective-C .m 文件之前, 确保为这些类型导入 Objective-C 头文件。</p>
<p>在相同的 target 把 Swift 代码导入 Objective-C</p>
<p><ul><li>导入 Swift 代码使用这个语法, 然后替换成对应的名字:</li></ul></p>
<pre><code>
\#import "ProductModuleName-Swift.h"
</code></pre>
包含这些输入语句的 Objective-C .m 文件就可以看见你 Swift 代码。
# 在同一个框架 Target 内部导入代码

如果你正在写一个混合语言的框架, 你可能需要互相访问对方语言的代码。
# 向 Swift 导入 Objective-C
为了导入一组 Objective-C 文件, 你需要为这个框架导入这些 Objective-C 头文件。

为了向 Swift 导入 Objective-C 代码
<ul>
<li>在 Build Settings 下, 在 Packaging, 确保 Defines Module 设置为 “Yes”.</li>
<li>在头文件里, 导入所有想要暴露给 Swift 的 Objective-C 头文件。例如:</li>
</ul>
<pre><code>
\#import \<xyz xyzcustomcell.h="">
\#import \<xyz xyzcustomview.h="">
\#import \<xyz xyzcustomviewcontroller.h="">
</xyz></xyz></xyz></code></pre>
Swift 能看到公开暴露的每个头文件。框架里的 Objective-C 文件的内容在 Swift 中自动可用使用, 不用任何输入语句。自定义的 Objective-C 代码像使用系统类一样使用相同的 Swift 语法。
<pre><code>
let myOtherCell = XYZCustomCell()
myOtherCell.subtitle = "Another custom cell"
</code></pre>
# 向 Objective-C 导入 Swift
为了把一组 Swift 文件导入 Objective-C 代码, 你不需要向头文件导入任何东西。相反, 只要导入 Xcode-产生的头文件即可。 

由于为框架生成的头文件是它公开接口的一部分, 只有标记有 public 或者 open 修饰符的才会出现在生成的头文件中。

Swift 用internal 修饰符标记的方法和属性, 以及在一个继承自 Objective-C 的类中的声明可以在运行期访问 Objective-C. 不过, 它们在编译器不能访问, 也不会出现在生成的头文件中。

为了向 Objective-C 导入 Swift 代码
<ul>
<li>在 Build Settings 下, 在 Packaging, 确保 Defines Module 设置为 “Yes”.</li>
<li>使用下面的语法, 然后替换成合适的名字:</li>
</ul>
<pre><code>
\#import \<productname productmodulename-swift.h="">
</productname></code></pre>
Objective-C .m 文件包含这些输入语句的, 都可以看见这些 Swift 代码。
# 导入外部框架
你可以导入完全用 Objective-C 写的, 完全用 Swift 代码写的, 或者两个语言混写的框架。导入外部框架的过程, 不管它是用一种还是两种语言写的, 都是一样的。当你导入一个外部框架时, 确保 Defines Module 设置为 “Yes”.

在不同 target 下, 你可以用下面的语法导入一个框架:
<pre><code>
import FrameworkName
</code></pre>
在不同 target 下, 你可以用下面的语法向 Objective-C .m 文件中导入一个框架:
<pre><code>
@import FrameworkName;
</code></pre>

<h1 id="在-Objective-C-中使用-Swift"><a href="#在-Objective-C-中使用-Swift" class="headerlink" title="在 Objective-C 中使用 Swift"></a>在 Objective-C 中使用 Swift</h1><p>导入 Swift 代码后, 用标准 Objective-C 语法来使用 Swift 类。</p>
<pre><code>
MySwiftClass *swiftObject = [[MySwiftClass alloc] init];
[swiftObject swiftMethod];
</code></pre>
一个 Swift 类必须是一个 Objective-C 类的子类, 可以在 Objective-C 中访问和使用。

# 在 Objective-C 头文件里引用 Swift 类或协议

为了避免循环引用, 不要把 Swift 代码导入 Objective-C 头文件 (.h). 替代方式是, 使用向前引用的方式。
<pre><code>
// MyObjcClass.h
@class MySwiftClass;
@protocol MySwiftProtocol;

@interface MyObjcClass : NSObject
- (MySwiftClass *)returnSwiftClassInstance;
- (id <myswiftprotocol>)returnInstanceAdoptingSwiftProtocol;
// ...
@end
</myswiftprotocol></code></pre>
类和协议的向前声明只能用于方法类型和属性声明。

# 定义一个 Objective-C 类可以采用的 Swift 协议

为了创建这种协议, 用 @objc 特性来标记协议声明。
<pre><code>
@objc public protocol MySwiftProtocol {
    func requiredMethod()
    @objc optional func optionalMethod()
}
</code></pre>
一个声明了所有构造器, 属性, 下标和方法的协议, Objective-C 类必须实现它们, 来遵守这个协议。任何可选协议需求必须用 @objc 特性标记并且要有 optional 修饰符。

# 在 Objective-C 实现里使用 Swift 协议

通过导入Xcode 生成的头文件和使用一个类的扩展, Objective-C 类可以在实现中采用一个 Swift 协议。
<pre><code>
// MyObjcClass.m
\#import "ProductModuleName-Swift.h"

@interface MyObjcClass () <myswiftprotocol>
// ...
@end

@implementation MyObjcClass
// ...
@end
</myswiftprotocol></code></pre>

<h1 id="声明一个-Swift-错误类型用于-Objective-C"><a href="#声明一个-Swift-错误类型用于-Objective-C" class="headerlink" title="声明一个 Swift 错误类型用于 Objective-C"></a>声明一个 Swift 错误类型用于 Objective-C</h1><p>Swift 枚举遵守 Error 协议并且使用 @objc 特性声明来产生一个 NS_ENUM 声明, 同时产生一个错误域的 NSString 常量。 例如, 给定下面的 Swift 枚举声明:</p>
<pre><code>
@objc public enum CustomError: Int, Error {
    case a, b, c
}
</code></pre>
下面是在生成的头文件里, 对应的 Objective-C 声明:
<pre><code>
// Project-Swift.h
typedef SWIFT_ENUM(NSInteger, CustomError) {
  CustomErrorA = 0,
  CustomErrorB = 1,
  CustomErrorC = 2,
};
static NSString * const CustomErrorDomain = @"Project.CustomError";
</code></pre>

<h1 id="为-Objective-C-接口重写-Swift-名"><a href="#为-Objective-C-接口重写-Swift-名" class="headerlink" title="为 Objective-C 接口重写 Swift 名"></a>为 Objective-C 接口重写 Swift 名</h1><p>Swift 编译器自动把 Objective-C 代码导入成 Swift 的惯例代码。Objective-C 类的工厂方法会变成 Swift 的构造器, Objective-C 枚举 cases 会被截断名字。</p>
<p>在你的代码里, 可能会有边缘cases 不能自动处理。如果你需要修改导入后的名字, 你可以使用 NS_SWIFT_NAME 宏来定制怎么导入声明。</p>
<h1 id="类的工厂方法"><a href="#类的工厂方法" class="headerlink" title="类的工厂方法"></a>类的工厂方法</h1><p>如果 Swift 编译器识别不出来一个类的工厂方法, 你可以用 NS_SWIFT_NAME 宏, 传入 Swift 的构造器签名来确保它正确的导入。例如:</p>
<pre><code>
+ (instancetype)recordWithRPM:(NSUInteger)RPM NS\_SWIFT\_NAME(init(RPM:));
</code></pre>
如果 Swift 编译器错误的把一个方法识别成一个工厂方法, 你可以用 NS\_SWIFT\_NAME 宏, 传入 Swift 的方法签名来保证它正确的导入。例如:
<pre><code>
+ (id)recordWithQuality:(double)quality NS\_SWIFT\_NAME(record(quality:));
</code></pre>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>默认情况, Swift 导入枚举会截断枚举值的前缀名。为了自定义枚举 case 的名字, 你可以用 NS_SWIFT_NAME 宏, 传入 Swift 枚举 case 名。例如:</p>
<pre><code>
typedef NS\_ENUM(NSInteger, ABCRecordSide) {
  ABCRecordSideA,
  ABCRecordSideB NS\_SWIFT\_NAME(FlipSide),
};
</code></pre>

<h1 id="让-Objective-C-接口在-Swift-中可用"><a href="#让-Objective-C-接口在-Swift-中可用" class="headerlink" title="让 Objective-C 接口在 Swift 中可用"></a>让 Objective-C 接口在 Swift 中可用</h1><p>一些 Objective-C 接口可能不适合或者不需要作为 Swift 接口暴露。为了防止一个 Objective-C 声明被导入 Swift, 使用NS_SWIFT_UNAVAILABLE 宏。</p>
<p>例如, 一个 Objective-C 类提供了一个便利构造器, 这个构造器带有键值对的可变参数, 可能会建议 Swift 用户使用字典字面量来代替:</p>
<pre><code>
+ (instancetype)collectionWithValues:(NSArray *)values forKeys:(NSArray<nscopying> *)keys NS\_SWIFT\_UNAVAILABLE("Use a dictionary literal instead");
</nscopying></code></pre>
尝试调用 +collectionWithValues:forKeys: 方法会导致一个编译错误。

# 改进 Objective-C 声明

You can use the NS\_REFINED\_FOR\_SWIFT macro on an Objective-C method declaration to provide a refined Swift interface in an extension, while keeping the original implementation available to be called from the refined interface. For instance, an Objective-C method that takes one or more pointer arguments could be refined in Swift to return a tuple of values.

Initializer methods are imported by Swift with double underscores (__) prepended to their first argument labels.
Object subscripting methods are imported by Swift as methods with double underscores (__) prepended to their base names, rather than as a Swift subscript, if either the getter or setter method is marked as NS_REFINED_FOR_SWIFT.
Other methods are imported with double underscores (__) prepended to their base names.
Given the following Objective-C declarations:
<pre><code>
@interface Color : NSObject

- (void)getRed:(nullable CGFloat *)red
         green:(nullable CGFloat *)green
          blue:(nullable CGFloat *)blue
         alpha:(nullable CGFloat *)alpha NS_REFINED_FOR_SWIFT;

@end
</code></pre>
You can provide a refined Swift interface in an extension like this:
<pre><code>
extension Color {
    var RGBA: (red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat) {
        var r: CGFloat = 0.0
        var g: CGFloat = 0.0
        var b: CGFloat = 0.0
        var a: CGFloat = 0.0
        __getRed(red: &r, green: &g, blue: &b, alpha: &a)
        return (red: r, green: g, blue: b, alpha: a)
    }
}
</code></pre>

<h1 id="Naming-Your-Product-Module"><a href="#Naming-Your-Product-Module" class="headerlink" title="Naming Your Product Module"></a>Naming Your Product Module</h1><p>The name of the Xcode-generated header for Swift code, and the name of the Objective-C bridging header that Xcode creates for you, are generated from your product module name. By default, your product module name is the same as your product name. However, if your product name has any nonalphanumeric characters, such as a period (.), they are replaced with an underscore (_) in your product module name. If the name begins with a number, the first number is replaced with an underscore.</p>
<p>You can also provide a custom name for the product module name and Xcode will use this when naming the bridging and generated headers. To do this, change the Product Module Name build setting.</p>
<p>NOTE</p>
<p>You cannot override the product module name of a framework.</p>
<h1 id="Troubleshooting-Tips-and-Reminders"><a href="#Troubleshooting-Tips-and-Reminders" class="headerlink" title="Troubleshooting Tips and Reminders"></a>Troubleshooting Tips and Reminders</h1><p>Treat your Swift and Objective-C files as the same collection of code, and watch out for naming collisions.<br>If you’re working with frameworks, make sure the Defines Module (DEFINES_MODULE) build setting under Packaging is set to “Yes”.<br>If you’re working with the Objective-C bridging header, make sure the Objective-C Bridging Header (SWIFT_OBJC_BRIDGING_HEADER) build setting under Swift Compiler - Code Generation is set to a path to the bridging header file relative to your project (for example, “MyApp/MyApp-Bridging-Header.h”).<br>Xcode uses your product module name (PRODUCT_MODULE_NAME)—not your target name (TARGET_NAME)—when naming the Objective-C bridging header and the generated header for your Swift code. For information on product module naming, see Naming Your Product Module.<br>To be accessible and usable in Objective-C, a Swift class must be a descendant of an Objective-C class or it must be marked @objc.<br>When you bring Swift code into Objective-C, remember that Objective-C won’t be able to translate certain features that are specific to Swift. For a list, see Using Swift from Objective-C.<br>If you use your own Objective-C types in your Swift code, make sure to import the Objective-C headers for those types before importing the Swift generated header into the Objective-C .m file you want to use your Swift code from.<br>Swift declarations marked with the private or fileprivate modifier do not appear in the generated header. Private declarations are not exposed to Objective-C unless they are explicitly marked with @IBAction, @IBOutlet, or @objc as well.<br>For app targets, declarations marked with the internal modifier appear in the generated header if the app target has an Objective-C bridging header.<br>For framework targets, only declarations with the public or open modifier appear in the generated header. You can still use Swift methods and properties that are marked with the internal modifier from within the Objective-C part of your framework, as long they are declared within a class that inherits from an Objective-C class. For more information on access-level modifiers, see Access Control in The Swift Programming Language (Swift 3.0.1).</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/" data-title="Using Swift with Cocoa and Objective-C (Swift 3.0.1) | 跳跳魔王的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/12/22/苹果Background-Modes/"  title="苹果Background Modes">
 <strong>下一篇：</strong><br/> 
 <span>苹果Background Modes
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/" data-title="Using Swift with Cocoa and Objective-C (Swift 3.0.1)" data-url="http://yoursite.com/2017/01/13/Using-Swift-with-Cocoa-and-Objective-C-Swift-3-0-1/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本构建"><span class="toc-number">1.</span> <span class="toc-text">基本构建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#建立你的-Swift-环境"><span class="toc-number">2.</span> <span class="toc-text">建立你的 Swift 环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Requiring-Dynamic-Dispatch"><span class="toc-number">3.</span> <span class="toc-text">Requiring Dynamic Dispatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#选择器"><span class="toc-number">4.</span> <span class="toc-text">选择器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不安全的-Objective-C-方法调用"><span class="toc-number">5.</span> <span class="toc-text">不安全的 Objective-C 方法调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#键和键的路径"><span class="toc-number">6.</span> <span class="toc-text">键和键的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-和-Objective-C-在相同的工程"><span class="toc-number">7.</span> <span class="toc-text">Swift 和 Objective-C 在相同的工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#混合匹配概述"><span class="toc-number">8.</span> <span class="toc-text">混合匹配概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从相同应用Target内部导入代码"><span class="toc-number">9.</span> <span class="toc-text">从相同应用Target内部导入代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#向-Swift-导入-Objective-C"><span class="toc-number">10.</span> <span class="toc-text">向 Swift 导入 Objective-C</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#向-Objective-C-导入-Swift"><span class="toc-number">11.</span> <span class="toc-text">向 Objective-C 导入 Swift</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在-Objective-C-中使用-Swift"><span class="toc-number">12.</span> <span class="toc-text">在 Objective-C 中使用 Swift</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#声明一个-Swift-错误类型用于-Objective-C"><span class="toc-number">13.</span> <span class="toc-text">声明一个 Swift 错误类型用于 Objective-C</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为-Objective-C-接口重写-Swift-名"><span class="toc-number">14.</span> <span class="toc-text">为 Objective-C 接口重写 Swift 名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的工厂方法"><span class="toc-number">15.</span> <span class="toc-text">类的工厂方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">16.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#让-Objective-C-接口在-Swift-中可用"><span class="toc-number">17.</span> <span class="toc-text">让 Objective-C 接口在 Swift 中可用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Naming-Your-Product-Module"><span class="toc-number">18.</span> <span class="toc-text">Naming Your Product Module</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Troubleshooting-Tips-and-Reminders"><span class="toc-number">19.</span> <span class="toc-text">Troubleshooting Tips and Reminders</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mhealth365.cn/" target="_blank" title="一款温暖的心电监测设备">熙健-掌上心电</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m an iOS engineer <br/>
			Hala Madrid</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2779746325" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="跳跳魔王">跳跳魔王</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ecgbao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
