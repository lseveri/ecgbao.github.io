
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="跳跳魔王">
    

    
    <meta name="description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 编程语言（Swift 3.0.1）">
<meta property="og:url" content="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/index.html">
<meta property="og:site_name" content="跳跳魔王的博客">
<meta property="og:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">
<meta property="og:updated_time" content="2016-11-01T07:13:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 编程语言（Swift 3.0.1）">
<meta name="twitter:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta name="twitter:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">

    
    <link rel="alternative" href="/atom.xml" title="跳跳魔王的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="跳跳魔王的博客">跳跳魔王的博客</a></h1>
				<h2 class="blog-motto">每天进步一点点</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/28/Swift-编程语言（Swift-3-0-1）/" title="Swift 编程语言（Swift 3.0.1）" itemprop="url">Swift 编程语言（Swift 3.0.1）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="跳跳魔王" target="_blank" itemprop="author">跳跳魔王</a>
		
  <p class="article-time">
    <time datetime="2016-10-28T05:54:48.000Z" itemprop="datePublished"> 发表于 2016-10-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三元条件运算符"><span class="toc-number">33.</span> <span class="toc-text">三元条件运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nil-联合运算符"><span class="toc-number">34.</span> <span class="toc-text">Nil-联合运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#范围运算符"><span class="toc-number">35.</span> <span class="toc-text">范围运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭合区间运算符"><span class="toc-number">36.</span> <span class="toc-text">闭合区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#半开区间运算符"><span class="toc-number">37.</span> <span class="toc-text">半开区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">38.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">39.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">40.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">41.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">42.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">43.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">45.</span> <span class="toc-text">字符串字面量</span></a></li></ol>
		
		</div>
		
		<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。</p>
<p>基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dictionary。</p>
<p>跟C类似，Swift 通过变量名来存取值。Swift 还大量使用常量，这里的常量比C的常量更加强大。常量使用贯穿Swift，用来让代码更加安全和容易推断，特别是在你不想变量值发生改变的时候。</p>
<p>除了基本类型，Swift 还引进了objective-C中没有的高级类型，比如元组。元组让你可以创建和传递多值。你可以在一个函数里返回元组来作为一个单独的混合值。</p>
<p>Swift 还引进了可选类型，用来处理缺值的情况。可选的意思是‘这里有一个值，它等于x’ 或者‘这里没有任何值’。用可选值跟objective-C里使用nil指针有点像，不过可选类型可以服务任何类型，不仅仅是类类型。可选类型不仅仅安全而且更容易表达意思，它是Swift最重要特性里的核心特性。</p>
<p>Swift是一门类型安全的语言，这也就意味着这门语言可以让你更清晰的知道代码使用的值类型。如果你的代码需要一个String，类型安全会保护你不至于传递一个Int类型。同样，类型安全也会保护你，让你不会把非可选类型传递给需要可选类型的代码块。类型安全让你在开发阶段尽快发现问题，修复错误。</p>
<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>常量和变量是一个有特定类型的值，带有一个名字。常量值一旦确定就不能改变，变量在可用随时改变其值。</p>
<p>定义常量和变量<br>常量和变量必须要在使用前定义，常量使用let关键字，变量使用var关键字。下面是一个例子来展示如何使用常量和变量，这个例子是跟踪用户尝试的登录次数。</p>
<p><code>let maximumNumberOfLoginAttempts = 10<br>var currentLoginAttempt = 0</code><br>这段代码可以这样解读：<br>定义个常量maximumNumberOfLoginAttempts，给它一个值10.然后定义一个变量currentLoginAttempt，给它一个值0.<br>在这个例子里，最大登录次数定义为一个常量，因为最大登录数不会改变。当前登录数定义为变量，因为这个值随着用户的登录尝试会逐渐增长。<br>你也可以定义多个常量或变量在一行，用逗号分开即可：<br><code>var x = 0.0, y = 0.0, z = 0.0</code></p>
<p>类型注释<br>当定义常量或者变量的时候，你可以提供一个类型注释，这样可以更清楚的知道存储类型是什么。在变量名或者常量名后面加一个冒号，然后一个空格，然后是要使用的类型。</p>
<p>这个例子为变量welcomeMessage提供一个类型解释，来说明这个变量可以存储String值：<br><code>var welcomeMessage: String</code><br>这段代码可以理解为：<br>定义个变量叫welcomeMessage，它的类型是String。<br>welcomeMessage变量现在可以存储任何的字符串：<br><code>welcomeMessage = “Hello”</code><br>你可以在一行定义多个相关的相同类型的变量，用逗号分开，然后再最后加上类型注释：<br><code>var red, green, blue: Double</code></p>
<p>常量和变量命名<br>常量和变量命名可以包含几乎任何的字符，包括Unicode字符：<br><code>let π = 3.14159<br>let 你好 = “你好世界”<br>let 🐶🐮 = “dogcow”</code><br>常量和变量命名不能包含空格字符，数学符号，箭头，私有（无效）的Unicode字符码，或者-等。也不能以数字开始，虽然数字可以出现在名字里的任何地方。</p>
<p>一旦你给常量或者变量确定了类型，你就不能用同样的名字来重定义它们，或者改变他们存储的值类型。你也不能把常量改为变量，或者把变量变成常量。</p>
<p>你可以把常量的值改变成同样类型的其他的值。这个例子里，变量friendlyWelcome的值从”Hello!” 变成 “Bonjour!”:<br><code>var friendlyWelcome = “Hello!”<br>friendlyWelcome = “Bonjour!”<br>// friendlyWelcome is now “Bonjour!”</code><br>与变量不同，常量值一旦确定就不能再改变。如果尝试改变编译器会报错：<br><code>let languageName = “Swift”<br>languageName = “Swift++”<br>// This is a compile-time error: languageName cannot be changed.<br></code><br>打印常量和变量<br>你可以使用print(<em>:separator:terminator:)函数打印常量或者变量的当前值：<br><code>print(friendlyWelcome)<br>// Prints “Bonjour!”</code><br>print(</em>:separator:terminator:)是一个全局函数，可以打印一个或者多个值。在XCode里，例如，print(_:separator:terminator:)打印结果会出现在控制台里。separator 和 terminator 参数都有默认值, 所以你可以忽略他们。 默认的, 这个函数打印完会加上换行符。 如果不想打印后换行, 传入一个空字符串作为终止—例如, print(someValue, terminator: “”)</p>
<p>Swift 使用 string interpolation 在长字符串里插入常量或者变量名, 同时会提示 Swift 去用当前的常量值活变量值来替换它。 用括号包含名字，然后在前面加上反斜杠:</p>
<p><code>print(“The current value of friendlyWelcome is (friendlyWelcome)”)<br>// Prints “The current value of friendlyWelcome is Bonjour!”</code></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在代码中，把注释加到不执行的文本，作为一个备注或者提醒。代码编译的时候，注释会被编译器忽略。<br>Swift注释和C语言注释很像，不在赘述。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>跟其他语言不同，Swift不要求在每条语句后写分号（；），不过，在一行写很多语句的时候，还是需要带上分号的：<br><code>let cat = “🐱”; print(cat)<br>// Prints “🐱”<br></code></p>
<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><p>Integers 意思是整个数字没有小数，比如 42 和 -23，整数要么是 signed（负数，0，正数） 要么是 unsigned（正数或者0）</p>
<p>Swift提供8，16，32 和 64位的有符号和无符号的整数。这些整数类型和C语言很像，8位的无符号的整数是UInt8，32位的有符号正数是Int32.</p>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><p>你可以用min 和max属性来获取每个整数类型的最小值和最大值：<br><code>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8<br>let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8</code></p>
<h1 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h1><p>大多数情况下，你不需要指定整数的位数。Swift提供了额外的整数类型Int，这个和当前平台的本地字数一样：<br>32位机器，Int等于Int32<br>64位机器，Int等于Int64<br>除非你要用规定大小的整数，否则，一般只要用Int就可以了。</p>
<h1 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h1><p>Swift也提供了无符号的整形，UInt，这个和当前平台的本地字数也是一样的：<br>32位机器，UInt等于UInt32<br>64位机器，UInt等于UInt64</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>Floating-point 是带有小数部分的数字，比如 3.14159，0.1和-273.15.<br>浮点数类型比整数类型表达更多的值域，比存在Int中的值更大或者更小。Swift提供了两个有符号的浮点数类型：<br>Double 表示64位的浮点数。<br>Float 表示32位的浮点数。</p>
<h1 id="类型安全与推断"><a href="#类型安全与推断" class="headerlink" title="类型安全与推断"></a>类型安全与推断</h1><p>Swift是类型安全的语音。类型安全的语言鼓励你清楚知道自己代码使用的值的类型。如果你的代码需要String类型，那么你就不要传递Int给它。</p>
<p>因为Swift是类型安全的，在编译代码的时候type checks会执行来标记不匹配的类型错误。这让你可以尽可能早的发现代码中的错误。</p>
<p>类型检查帮你避免使用不同类型的时候犯错，然而，这并不意味你必须给所有的常量和变量指定类型。你不需要指定类型，Swift使用type inference来推断合适的类型。类型推断使得编译器可以在编译代码的时候自动推断表达式的类型，只是通过简单的检查你提供的值。</p>
<p>因为有类型推断，Swift 对类型声明要求的比其他语言要少的多。常量和变量依然要显示输入，但是大部分指定类型的工作都已经帮你做了。</p>
<p>类型推断在给常量或者变量赋初值的时候尤为有用。这个发生在你声明常量或者变量，并给他们指定literal value（字面量）的时候。所谓的字面量就是指直接出现在你的源码中的值，比如下面例子里的 42 和 3.14159</p>
<p>例如，如果你给一个新常量指定一个字面量是42， Swift就会推断你想要这个常量的类型是Int， 因为你给他初始化一个数字：<br><code>let meaningOfLife = 42<br>// meaningOfLife is inferred to be of type Int</code><br>同样，你也不需要给浮点数指定类型，Swift会推断说你想要一个Double：<br><code>let pi = 3.14159<br>// pi is inferred to be of type Double</code><br>Swift在推断浮点数的时候总是选择Double而不是Float<br>如果你合并整数和浮点数在一个表达式中，Double类型将会被推断出来：<br><code>let anotherPi = 3 + 0.14159<br>// anotherPi is also inferred to be of type Double</code></p>
<h1 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h1><p>整数字面量这可以写：<br>十进制数字，没有前缀<br>二进制数字，用0b做前缀<br>八进制数字，用0o做前缀<br>十六进制数字，用0x做前缀<br>下面所有整数字面量值都是17：<br><code>let decimalInteger = 17<br>let binaryInteger = 0b10001       // 17 in binary notation<br>let octalInteger = 0o21           // 17 in octal notation<br>let hexadecimalInteger = 0x11     // 17 in hexadecimal notation</code></p>
<p>浮点数字面量可以是十进制或者十六进制。在十进制点的两边都必须有数字。十进制浮点数也有个可选的exponent，用大小写e标明；十六进制浮点数也有exponent，用大小写的p标明。</p>
<p>用 exp 指数表示十进制数, 基础数字乘以 10exp:<br>1.25e2 意思是 1.25 x 102, 或者是 125.0.<br>1.25e-2 意思是 1.25 x 10-2, 或者是 0.0125.<br>用 exp 指数表示十六进制数, 基础数字乘以 2exp:</p>
<p>0xFp2 意思是 15 x 22, 或者是 60.0.<br>0xFp-2 意思是 15 x 2-2, 或者是 3.75.<br>下面所有这些浮点数字面量十进制数都是 12.1875:<br><code>let decimalDouble = 12.1875<br>let exponentDouble = 1.21875e1<br>let hexadecimalDouble = 0xC.3p0</code></p>
<h1 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h1><p>在你的代码中使用Int做为一般用途的整形常量和变量，尽快知道他们是非负数的。日常开发使用默认整形类型意味着整形变量和常量立即可以使用，而且它们匹配整形字面量的推断类型。</p>
<p>特别指定的工作才会使用其他的整形类型，因为指定大小的整形类型需要额外的开销。日常开发中，使用指定大小的类型帮助捕获特定值的溢出，同时记录被使用的数据。</p>
<h1 id="整形转换"><a href="#整形转换" class="headerlink" title="整形转换"></a>整形转换</h1><p>不同数值类型，存储在常量或变量中的数值范围是不同的。一个Int8常量或者变量可以存储 -128 到 127， UInt8 常量或者变量能存储 0 到 255 之间的数值。如果数值不适合指定大小的整形类型，编译后会报错。</p>
<p><code>let cannotBeNegative: UInt8 = -1<br>// UInt8 cannot store negative numbers, and so this will report an error<br>let tooBig: Int8 = Int8.max + 1<br>// Int8 cannot store a number larger than its maximum value,<br>// and so this will also report an error</code></p>
<p>为了转换一个特定数值类型，先用一个存在的值初始化一个新的想要类型的新数值。下面的例子，常量twoThousand的类型是UInt16， 而常量one的类型是UInt8.他们不能直接相加，因为类型不同。取而代之的是，这个例子调用UInt16（one）来创建一个新的Uint16，并用one初始化它，并在原来的位置使用这个值：</p>
<p><code>let twoThousand: UInt16 = 2_000<br>let one: UInt8 = 1<br>let twoThousandAndOne = twoThousand + UInt16(one)</code></p>
<p>因为加好两边的值类型都是UInt16，所以加法是进行的。输出常量推断是UInt16，因为它是两个UInt16值的和。</p>
<p>SomeType(ofInitialValue) 默认调用Swift类型的初始化函数，然后传递一个初始值。这个语句之前，UInt16有一个初始化器接受一个UInt8的值，所以这个初始化器就用存在的UInt8 创建了一个新的UInt16.这里你不能随便传入类型-必须传入UInt16初始化器接受的值。</p>
<h1 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h1><p>整数和浮点数之间的转换必须是显示的：<br><code>let three = 3<br>let pointOneFourOneFiveNine = 0.14159<br>let pi = Double(three) + pointOneFourOneFiveNine<br>// pi equals 3.14159, and is inferred to be of type Double</code></p>
<p>这里，常量three用来创建新的Double数值，现在加号两边的类型是一样的，所以可以相加。如果没有这里的转换，加法是不允许的。</p>
<p>浮点数转整数也必须是显示进行的。一个整形可以用Double 或者 Float的值来初始化：</p>
<p><code>let integerPi = Int(pi)<br>// integerPi equals 3, and is inferred to be of type Int</code><br>用这种方式初始化一个新的整形数值，浮点数会被截断。意思就是 4.75 会变成 4， -3.9会变成-3.</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>type aliases 为已知类型定一个别名。定义类型别名使用typealias关键字。</p>
<p>类型别名在你想通过名字调用一个已知类型的时候很有用，这种名字在上下文中更合适，比如使用指定大小的外部数据时：<br><code>typealias AudioSample = UInt16</code><br>定义好类型别名后，你可以在任何使用原名的地方使用它：<br><code>var maxAmplitudeFound = AudioSample.min<br>// maxAmplitudeFound is now 0</code><br>这里，AudioSample就是UInt16的别名。因为是别名，调用AudioSample.min实际上就是调用UInt16.min，这给maxAmplitudeFound变量提供一个初始值0.</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>Swift有个一基础布尔类型， 叫做 Bool。布尔值用作逻辑调用，因为它只能是true或者false。Swift提供了两个布尔常量值，true和falseL<br><code>let orangesAreOrange = true<br>let turnipsAreDelicious = false</code></p>
<p>orangesAreOrange 和 turnipsAreDelicious 的类型被推断是Bool。同上面的Int 和 Double 一样，你不需要声明常量或者变量为Bool</p>
<p>布尔值在if 语句这种条件语句中尤其有用：<br><code>if turnipsAreDelicious {<br>    print(“Mmm, tasty turnips!”)<br>} else {<br>    print(“Eww, turnips are horrible.”)<br>}<br>// Prints “Eww, turnips are horrible.”</code></p>
<p>Swift 类型安全防止非布尔值被替换成布尔值。下面的例子报一个编译错误：</p>
<p><code>let i = 1<br>if i {<br>    // this example will not compile, and will report an error<br>}</code></p>
<p>替代的例子如下：<br><code>let i = 1<br>if i == 1 {<br>    // this example will compile successfully<br>}</code></p>
<p>i==1比较的结果是Boo类型，所以第二个例子通过了类型检查。</p>
<p>和其他类型安全例子一样，这个方法避免了突发的错误，确保特别代码块推断总是清晰的。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>Tuples 包含多值到一个单独的组合值。元组里的值可以是任何类型，彼此之间可以是不同类型。</p>
<p>在这个例子中，(404, “Not Found”)是一个元组，代表Http的错误码。一个Http错误码是访问网页时网页服务器返回的特殊数值。如果你请求的网页不存在，就会返回404 Not Found的错误码。</p>
<p><code>let http404Error = (404, “Not Found”)<br>// http404Error is of type (Int, String), and equals (404, “Not Found”)</code></p>
<p>(404, “Not Found”) 元组包含了一个Int 和一个String，一个数字和一个人工可读的描述。它可以描述成一个类型为（Int, String）的元组。</p>
<p>你可以用任何变化的类型创建元组，你可以按照需要要创建不同的元组。</p>
<p>你可以分解元组到分离的常量或者变量，通常你会访问它们：</p>
<p><code>let (statusCode, statusMessage) = http404Error<br>print(“The status code is (statusCode)”)<br>// Prints “The status code is 404”<br>print(“The status message is (statusMessage)”)<br>// Prints “The status message is Not Found”</code></p>
<p>如果你只需要元组中的某些值，当你分解元组的时候可以用下划线替换忽略的部分：<br><code>let (justTheStatusCode, _) = http404Error<br>print(“The status code is (justTheStatusCode)”)<br>// Prints “The status code is 404”</code></p>
<p>或者，通过下标访问元组中单独的元素值：</p>
<p><code>print(“The status code is (http404Error.0)”)<br>// Prints “The status code is 404”<br>print(“The status message is (http404Error.1)”)<br>// Prints “The status message is Not Found”</code></p>
<p>你可以在元组定义时，给单独的原色命名：</p>
<p><code>let http200Status = (statusCode: 200, description: “OK”)</code></p>
<p>如果你在元组中命名了元素，那么，你可以在访问元素值的时候通过名字访问它们的值：</p>
<p><code>print(“The status code is (http200Status.statusCode)”)<br>// Prints “The status code is 200”<br>print(“The status message is (http200Status.description)”)<br>// Prints “The status message is OK”</code></p>
<h1 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h1><p>当一个值可能缺失的时候使用optionals。一个可选值包含两种可能：或者有一个值，你可以通过拆包访问这个值，或者根本没有值。</p>
<p>这里有一个例子，说明可选类型如何在值缺失的时候使用。Swift 的Int 类型有一个初始化器，可以把String 转换为Int 值。不过，不是每一个字符串都可以转换的。“123”可以转换为123，但是“helloworld”就不可以。</p>
<p>下面的例子使用初始化器去转换String：<br><code>let possibleNumber = “123”<br>let convertedNumber = Int(possibleNumber)<br>// convertedNumber is inferred to be of type “Int?”, or “optional Int”</code></p>
<p>因为初始化器有可能失败，所以它返回一个optional Int，而不是Int。一个可选Int写作Int？，不是Int。问号表示包含的值是可选的，意思就是它可能包含某个Int值，也可能不包含任何值。</p>
<h1 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h1><p>通过赋值nil来把可选值设置成无值状态：</p>
<p><code>var serverResponseCode: Int? = 404<br>// serverResponseCode contains an actual Int value of 404<br>serverResponseCode = nil<br>// serverResponseCode now contains no value</code></p>
<p>如果如果定义一个可选变量，但是没有提供默认值，这个变量会被自动设置为nil：<br><code>var surveyAnswer: String?<br>// surveyAnswer is automatically set to nil</code></p>
<h1 id="if语句和强制拆包"><a href="#if语句和强制拆包" class="headerlink" title="if语句和强制拆包"></a>if语句和强制拆包</h1><p>用if语句，通过与nil做比较，你可以知道一个可选项是否包含一个值，用（==）或者（！=）来做比较。如果一个可选项有值，那么它不等于ni：<br><code>if convertedNumber != nil {<br>    print(“convertedNumber contains some integer value.”)<br>}<br>// Prints “convertedNumber contains some integer value.”</code></p>
<p>一旦你确定可选项包含一个值，你可以通过在可选项的名字后面加（！）来获取它的值。这个感叹号是说：我知道这个可选项一定有值；请使用它！这就是强制拆包获取可选项的值：<br><code>if convertedNumber != nil {<br>    print(“convertedNumber has an integer value of (convertedNumber!).”)<br>}<br>// Prints “convertedNumber has an integer value of 123.”</code></p>
<h1 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h1><p>使用optional binding找出一个可选项是否包含一个值。如果这样的话，使这个值作为一个临时常量或者变量。可选绑定用if和while语句来判断可选项的值，然后提取这个值到常量或者变量，作为操作的一部分。</p>
<p>用if语句写可选绑定像下面这样：</p>
<p><code> if let constantName = someOptional {<br>    statements<br>}<br></code></p>
<p>你可以重写possibleNumber实例，通过使用可选绑定而不是强制拆包：</p>
<p><code> if let actualNumber = Int(possibleNumber) {<br>    print(“\”(possibleNumber)\” has an integer value of (actualNumber)”)<br>} else {<br>    print(“\”(possibleNumber)\” could not be converted to an integer”)<br>}<br>// Prints “”123” has an integer value of 123”</code></p>
<p>代码可以这样解释;<br>如果Int（possibleNumber）返回的可选Int包含一个值，设置一个新的常量叫actualNumber，它的值就是包含在可选项中的值。</p>
<p>如果转换成功，actualNumber 常量变的可用，执行第一个分支的语句。因为已经初始化了可选项的值，所以不需要用感叹号去拆包。</p>
<p>你可以同时使用常量和变量，如果你想操作if语句第一个分支里的actualNumber，你可能要写 if var actualNumber来替换代码，然后可选项的值会变成变量值而不是常量值。</p>
<p>你可以在单独的if语句包括尽可能多的可选绑定和布尔条件，用逗号分开即可。如果任何可选项的值为nil或者布尔条件等于false，if条件被认为是false。下面的if语句是一样的：</p>
<p><code>if let firstNumber = Int(“4”), let secondNumber = Int(“42”), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>    print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>}<br>// Prints “4 &lt; 42 &lt; 100”</code></p>
<p>if let firstNumber = Int(“4”) {<br>    if let secondNumber = Int(“42”) {<br>        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>            print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>        }<br>    }<br>}<br>// Prints “4 &lt; 42 &lt; 100”</p>
<h1 id="隐式拆包可选项"><a href="#隐式拆包可选项" class="headerlink" title="隐式拆包可选项"></a>隐式拆包可选项</h1><p>如上所述，可选项表示一个常量或者变量可以没有值。可选项可以用if语句判断是否存在值，如果不存在，可以有条件用可选绑定拆包来访问可选项的值。</p>
<p>有时候，通过程序的结构可以很清楚的知道可选项有值，然后这个值被第一次设置。这种情况，就不需要每次都判断和拆包了，因为可以安全的假设总是有值。</p>
<p>这种可选项定义为隐式拆包可选项。隐式拆包可选项的写法是，在类型后面假设感叹号而不是问号。</p>
<p>当可选项的值在首次定义后就能确定存在的事，隐式拆包可选项很有用。隐式拆包可选项主要用在类的初始化。</p>
<p>隐式拆包可选项在这种场景下，是正常可选项，但是也可以用作一个非可选项，无需每次访问都拆包。下面的例子展示了，可选字符串和隐式拆包可选项字符串作为显示String时访问它们包含的值的不同行为。</p>
<p><code>let possibleString: String? = “An optional string.”<br>let forcedString: String = possibleString! // requires an exclamation mark</code></p>
<p>let assumedString: String! = “An implicitly unwrapped optional string.”<br>let implicitString: String = assumedString // no need for an exclamation mark</p>
<p>你依然可以把隐式拆包可选项当做正常的可选项，来判断它是否包含一个值：</p>
<p><code>if assumedString != nil {<br>    print(assumedString)<br>}<br>// Prints “An implicitly unwrapped optional string.”</code></p>
<p>你可以结合可选绑定来使用隐式拆包可选项，然后在一行语句中判断和拆包它的值：</p>
<p><code>if let definiteString = assumedString {<br>    print(definiteString)<br>}<br>// Prints “An implicitly unwrapped optional string.”</code></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>使用error handling 响应程序执行中错误条件。<br>与可选项做对照，可选项用有无值来表示一个函数的成功失败，错误处理允许你检测迁走的失败原因，同时如果必要的话，会把错误传递到程序的另外一部分。</p>
<p>当函数遇到一个错误情况，它就会throws 一个错误。函数调用者可以捕获这个错并正确响应。</p>
<p><code>func canThrowAnError() throws {<br>    // this function may or may not throw an error<br>}</code></p>
<p>一个函数表明它可以通过在定义中包含throws关键词来抛出一个错误。当你调用这个可以抛出错误的函数时，你要准备try关键词。</p>
<p>Swift 自动把错误往外抛知道它被一个catch语句处理。</p>
<p><code>do {<br>    try canThrowAnError()<br>    // no error was thrown<br>} catch {<br>    // an error was thrown<br>}</code></p>
<p>do 语句创建了一个代码块，它允许错误可以传递给一个或者多个catch 项。</p>
<p>这里有一个列子，展示响应不同错误条件的错误处理方式：</p>
<p><code>func makeASandwich() throws {<br>    // …<br>}</code></p>
<p>do {<br>    try makeASandwich()<br>    eatASandwich()<br>} catch SandwichError.outOfCleanDishes {<br>    washDishes()<br>} catch SandwichError.missingIngredients(let ingredients) {<br>    buyGroceries(ingredients)<br>}</p>
<p>在这个例子里，如果没有干净的餐具可用或者任何调料确实，makeASandwich将会抛出一个错误。因为makeASandwich可以抛出错误，所以函数调用包含在try表达式。经过do语句包含处理，任何抛出的错误都会传递到catch项。</p>
<p>如果没有错误抛出，eatASandwich函数会被调用。如果一个错误抛出然后匹配SandwichError.outOfCleanDishes这个条件，那么washDishes会被调用。如果一个错误抛出然后匹配SandwichError.missingIngredients条件，那么buyGroceries会被调用</p>
<h1 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h1><p>operator 是特殊的符号或者短语，用来检查，改变，或者合并数值。比如，加号（+）用来加两个数值，比如 let = 1 + 2，逻辑与（&amp;&amp;）合并两个布尔值，比如 enteredDoorCode &amp;&amp; passedRetinaScan<br>Swift支持大部分的C语言操作符，并且提升了消除一般编码错误的能力。赋值运算符（=）不会返回一个值，用来防止错误是使用（==）。算数运算符—（+，-，*，/，%等等）监测和拒绝值溢出，为了避免值溢出造成未知的结果。你可以用Swift的溢出运算符选择值溢出行为。</p>
<p>Swift同时提供了两个范围运算符（a..&lt;b和a…b），这在C语言里没有。这些作为表达一个范围值的快捷方式。</p>
<p>这个章节介绍Swift的普通运算符。Advanced Operators 包含了Swift的高级运算符，描述如何定义你自己的运算符，然后为你自定义的类型实现标准运算符。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>运算符是一元的，二元的，或者三元的：<br>    一元运算符操作单一目标（比如-a）。一元前缀操作费直接写在目标前（比如！b），一元后缀操作费则直接出现在目标后（比如c！）。<br>    二元运算符操作两个目标（比如2+3），并且出现在两个目标的中间。<br>    三元运算符操作三个目标，跟C语言一样，Swift 只有一个三元运算符，也就是三元条件运算符（a ？b ：c）。<br>运算符作用的值是操作数。在表达式1+2里，+号是二元运算符，两个操作数分别是1和2.</p>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>assignment operator（a=b）用b的值初始化或者更新a的值。<br><code>let b = 10<br>var a = 5<br>a = b<br>// a is now equal to 10</code><br>如果赋值语句的右侧是多值的元组，它的元素可以一次分解为多个常量或者变量：</p>
<p><code>let (x, y) = (1, 2)<br>// x is equal to 1, and y is equal to 2</code><br>与C语言 和 Objective-C语言不同，Swift赋值运算符自身不返回值。下面的语句是无效的：</p>
<p><code>if x = y {<br>    // This is not valid, because x = y does not return a value.<br>}</code><br>这个特性防止=与==混淆。 让if x = y 无效, Swift 帮你避免这种错误。</p>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>Swift 对所有类型支持四种标准算术运算符:</p>
<p>加号 (+)<br>减号 (-)<br>乘号 (<em>)<br>除号 (/)<br>1 + 2       // 等于 3<br>5 - 3       // 等于 2<br>2 </em> 3       // 等于 6<br>10.0 / 2.5  // 等于 4.0<br>与C语言 和 Objective-C语言不同, Swift 算术运算符默认不允许值溢出。 你可以通过Swift溢出运算符来选择值溢出行为(例如 a &amp;+ b)。</p>
<p>加号也支持字符串连接:</p>
<p><code>“hello, “ + “world”  // 等于 “hello, world”</code></p>
<h1 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h1><p>余数运算符 (a % b) 计算a中b的倍数，并且返回余数。</p>
<p>备注</p>
<p>余数运算符 (%) 在其他语言中作为取模运算符。 不过, 在 Swift 中对负数来说, 严格来讲, 它是余数而不是一个取模运算。</p>
<p>下面演示余数运算符是如何工作的。 计算 9 % 4, 你首先算出9里有多少个4:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png"><br></div>

<p>你可以确定9里有两个4, 余数是 1 (橙色显示)。</p>
<p>在 Swift 里, 这个会写作:</p>
<p><code>9 % 4    // 等于 1</code><br>为了确定 a % b 的结果, % 运算符计算下面的方程式，然后返回余数作为输出:</p>
<p>a = (b x 倍数) + 余数</p>
<p>这里倍数是a里面b的最大倍数。</p>
<p>把 9 和 4 代入方程式值域:</p>
<p><code>9 = (4 x 2) + 1</code></p>
<p>计算负值a的余数也是用相同的方法:</p>
<p><code>-9 % 4   // 等于 -1</code><br>把 -9 和 4 代入方程式值域:</p>
<p><code>-9 = (4 x -2) + -1</code></p>
<p>活的余数 -1.</p>
<p>负值b被忽略。 意思就是 a % b 和 a % -b 结果是一样的。</p>
<h1 id="一元减法运算符"><a href="#一元减法运算符" class="headerlink" title="一元减法运算符"></a>一元减法运算符</h1><p>数值符号可以用前缀 - 连接, 也就是大家熟知的一元减法运算符:<br><code><br>let three = 3<br>let minusThree = -three       // minusThree equals -3<br>let plusThree = -minusThree   // plusThree equals 3, or “minus minus three”<br></code><br>一元减法运算符 (-) 直接放在操作数前, 没有空格。</p>
<h1 id="一元加法运算符"><a href="#一元加法运算符" class="headerlink" title="一元加法运算符"></a>一元加法运算符</h1><p>一元加法运算符 (+) 返回操作数值, 没有任何改变:<br><code><br>let minusSix = -6<br>let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6<br></code><br>尽管一元加法运算符实际上不做任何事, 你可以用它来提供对称的代码，当在代码中使用正负数的时候。</p>
<h1 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h1><p>和 C 语言相似, Swift 提供复合赋值运算符来合并赋值 (=) 和其他操作数。 一个例子就是加法赋值运算符 (+=):<br><code><br>var a = 1<br>a += 2<br>// a 现在等于 3<br></code><br>表达式 a += 2 是 a = a + 2 的快捷方式。 实际上, 加法和赋值合并进一个操作符，同时做了两件事。</p>
<p>备注</p>
<p>复合赋值运算符不返回值。 比如, 你不能这样写 let b = a += 2.</p>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>Swift 支持所有标准C语言比较运算符:</p>
<p>等于 (a == b)<br>不等于 (a != b)<br>大于 (a &gt; b)<br>小于 (a &lt; b)<br>大于等于 (a &gt;= b)<br>小于等于 (a &lt;= b)</p>
<p>备注</p>
<p>Swift 同时提供两个相等运算符 (=== and !==), 你可以用来测试两个对象引用是否引用了相同的对象实例。 更多信息参考 Classes and Structures.</p>
<p>每个比较运算符都返回一个布尔值，来表明语句是否是真的:</p>
<p>1 == 1   // 真，因为1 等于 1<br>2 != 1   // 真，因为2 不等于 1<br>2 &gt; 1    // 真，因为2 大于 1<br>1 &lt; 2    // 真，因为1 小于 2<br>1 &gt;= 1   // 真，因为1大于或者等于1<br>2 &lt;= 1   // 假，因为2不小于或者等于1<br>比较运算符通常用于条件语句, 例如if语句:<br><code><br>let name = “world”<br>if name == “world” {<br>    print(“hello, world”)<br>} else {<br>    print(“I’m sorry (name), but I don’t recognize you”)<br>}<br>// Prints “hello, world”, because name is indeed equal to “world”.<br></code><br>更多if语句, 参考 Control Flow.</p>
<p>你可以比较含有相同数量值的元组, 只要元组里的值可以比较。 例如, Int 和 String 可以比较, 意思就是 (Int, String) 可以比较。 相反, Bool 不能比较, 意思就是包含布尔值的元组不能作比较。</p>
<p>元组是从左到右做比较的, 每次一个值, 直到比较发现两个值不等为止。 这两个被比较的值, 比较的结果决定了整个元组比较的结果。 如果所有元素都相等, 那么元组就是相等的。例如:<br><code><br>(1, “zebra”) &lt; (2, “apple”)   // 真，因为1小于2; “zebra” 和 “apple” 不比较<br>(3, “apple”) &lt; (3, “bird”)    // 真，以为3等于3, “apple” 小于 “bird”<br>(4, “dog”) == (4, “dog”)      // 真，因为4等于4, “dog” 等于 “dog”<br></code><br>上面这个例子, 在第一行你可以看见从左到右比较的行为。 因为1小于2, (1, “zebra”) 被认为小于 (2, “apple”), 不用管元组里的其他值。 不管 “zebra” 是不是小于 “apple”, 因为比较已经取决于元组里的第一个元素了。 不过, 当元组第一个元素相等的时候，比较就像第二行，第三行发生的那样。</p>
<h1 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h1><p>三元条件运算符是含有三部分的特殊运算符, 样式是 <code>问题 ? 答案1 : 答案2</code>。 这是基于问题是真假对表达式之一的判断。 如果问题是真, 求 answer1 的值并返回; 否则, 求 answer2 的值并返回。</p>
<p>三元条件运算符是下面代码的简写:<br><code><br>if question {<br>    answer1<br>} else {<br>    answer2<br>}<br></code><br>这里有一个例子, 用例计算列表行高。 如果行有头部，那么行高比内容高度加50，如果没有头部，那么高度加20:<br><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight = contentHeight + (hasHeader ? 50 : 20)<br>// rowHeight is equal to 90<br></code></p>
<p><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight: Int<br>if hasHeader {<br>    rowHeight = contentHeight + 50<br>} else {<br>    rowHeight = contentHeight + 20<br>}<br>// rowHeight is equal to 90<br></code><br>第一个例子使用三元条件运算符，意味着行高可以在一行代码里正确设置, 这个比第二个例子的代码要简洁。</p>
<p>三元条件运算符提供一个简写，来决定使用两个表达式中的哪一个。 小心使用三元条件运算符。 过度使用，代码就是很难理解。 尽量避免把三元条件运算符的多个实例合并到一个符合语句。</p>
<h1 id="Nil-联合运算符"><a href="#Nil-联合运算符" class="headerlink" title="Nil-联合运算符"></a>Nil-联合运算符</h1><p>nil-联合运算符 (a ?? b) 展开一个可选项 a 如果它包含一个值的话, 或者返回一个默认值 b 如果 a 是 nil。 表达式 a 总是一个可选类型。 表达式 b 必须匹配存储在a里的值类型。</p>
<p>nil-联合运算符是下面代码的简写:</p>
<p><code>a != nil ? a! : b</code><br>上面的代码使用三元条件运算符,然后强制展开 (a!) 来获取a中的值，如果这个值不空的话, 否则返回 b 。 nil-联合运算符提供了更优雅简洁的方式来压缩这个条件判断和展开。</p>
<p>备注</p>
<p>如果值非空, b的值不会得到。 这就是人们熟知的短路估算。</p>
<p>下面的例子使用 nil-联合运算符在默认颜色名称和可选用户定义的颜色名称之间做选择:<br><code><br>let defaultColorName = “red”<br>var userDefinedColorName: String?   // 默认是 nil</code></p>
<p>var colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName 是 nil, 所以colorNameToUse 设置成默认值 “red”<br><br>userDefinedColorName 变量定义成可选的 String, 默认值是 nil. 因为 userDefinedColorName 是个可选类型, 你可以使用nil-联合运算符来获取它的值。 上面的例子, 运算符用来决定变量 colorNameToUse 的一个初始值。 因为 userDefinedColorName 是 nil,  userDefinedColorName ?? defaultColorName 表达式返回了defaultColorName 的值, 或者 “red”.</p>
<p>如果你给 userDefinedColorName 赋了一个非空的值，然后执行 nil-联合运算符再次判断, userDefinedColorName 中包含的值 就取代了默认值:<br><code><br>userDefinedColorName = “green”<br>colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName is not nil, so colorNameToUse is set to “green”<br></code></p>
<h1 id="范围运算符"><a href="#范围运算符" class="headerlink" title="范围运算符"></a>范围运算符</h1><p>Swift 有两个范围运算符, 是表达值范围的简写。</p>
<h1 id="闭合区间运算符"><a href="#闭合区间运算符" class="headerlink" title="闭合区间运算符"></a>闭合区间运算符</h1><p>闭合区间运算符 (a…b) 定义从a到b的范围, 包含a和b的值。 a的值不能比b大。</p>
<p>闭合区间运算符在范围迭代很有用，特别是你想使用所有的值的时候。例如 for-in 循环:<br><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index * 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br></code><br>更多 for-in 循环, 参考 Control Flow.</p>
<h1 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h1><p>半开区间运算符 (a..&lt;b) 定义了从a到b的范围, 但是不包含b， 之所以成为半开是因为它包含初值, 但是不包含终值。 正如闭合区间运算符, a的值不能大于b。 如果a的值等于b的值, 这个范围就会是空的。</p>
<p>半开区间在你使用类似数组这种基于零的列表时非常有用, 计算列表长度 (但是不包括) 很有帮助:<br><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>let count = names.count<br>for i in 0..<count 1="" 2="" 3="" 4="" {="" print("person="" \(i="" +="" 1)="" is="" called="" \(names[i])")="" }="" person="" anna="" alex="" brian="" jack="" <="" code=""><br>数组包含4项, 不过 0..&lt;count 只计算到3 (数组最后一项的索引), 因为是半开区间。 更多数组, 参见 Arrays.</count></code></p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>逻辑运算符改变或者合并布尔值真和假。 Swift 支持三种基于C语言的标准逻辑运算符:</p>
<p>逻辑非 (!a)<br>逻辑与 (a &amp;&amp; b)<br>逻辑或 (a || b)</p>
<h1 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h1><p>逻辑非运算符 (!a) 反转布尔值，这样真就变成假, 假变成了真。</p>
<p>逻辑非运算符是个前缀运算符, 直接写在操作数前面, 没有任何空格。 可以读作 “not a”, 下面的例子可以看到:<br><code><br>let allowedEntry = false<br>if !allowedEntry {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “ACCESS DENIED”<br></code><br>语句 if !allowedEntry 可以读作 “if not allowed entry.” 后面一行仅执行 “not allowed entry” 是 true; 也就是, if allowedEntry 是 false.</p>
<p>在这个例子中, 谨慎定义布尔常量和变量名，可以让代码具有可读性和简洁性, 同时避免双重否定或者混乱的逻辑语句。</p>
<h1 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a>逻辑与运算符</h1><p>逻辑与运算符 (a &amp;&amp; b) 创建逻辑表达式，这个表达式中两个值为真，表达式也要为真。</p>
<p>如果任何一个值为假, 表达式的结果也将是假。 事实上, 如果第一个值为假, 第二个值不会再计算, 因为它不会让所有表达式都等于真。 这就是人们熟知的短路估值。</p>
<p>这个例子有两个布尔值，只有两个值都是真的时候才允许访问:<br><code><br>let enteredDoorCode = true<br>let passedRetinaScan = false<br>if enteredDoorCode &amp;&amp; passedRetinaScan {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “ACCESS DENIED”<br></code></p>
<h1 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a>逻辑或运算符</h1><p>逻辑或运算符 (a || b) 是两个竖线组成的中间运算符。 用来创建逻辑表达式，这个表达式中只要有一个值为真，表达式的结果就是真。</p>
<p>跟上面逻辑与类似, 逻辑或使用短路估值去计算表达式。 如果逻辑或的左侧是真, 右侧就不再估值, 因为它不会改变整个表达式的结果。</p>
<p>下面的例子, 第一个布尔值 (hasDoorKey) 是假, 但是第二个布尔值 (knowsOverridePassword) 是真。 因为一个值为真, 表达式结果就是真, 所以允许访问:<br><code><br>let hasDoorKey = false<br>let knowsOverridePassword = true<br>if hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code></p>
<h1 id="合并逻辑运算符"><a href="#合并逻辑运算符" class="headerlink" title="合并逻辑运算符"></a>合并逻辑运算符</h1><p>你可以合并多个逻辑运算符来创建更长的复合表达式:<br><code><br>if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code><br>这个例子使用了多个 &amp;&amp; 和 || 运算符来创建一个更长的复合表达式。 不过, &amp;&amp; 和 || 运算符依然只能操作两个值, 所以，这实际上是三个小表达式链接起来的。 </p>
<p>备注</p>
<p>Swift 逻辑运算符 &amp;&amp; 和 || 是左联想的, 意思就是多个逻辑运算符的复合表达式，首先计算最左边的子表达式。</p>
<h1 id="显示括号"><a href="#显示括号" class="headerlink" title="显示括号"></a>显示括号</h1><p>虽然不是严格需要，但是包含括号还是有用的, 使得复杂表达式的意图很容易理解。 上述实例, 给第一部分加上括号很有用，会让它的意图很明显:<br><code><br>if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code><br>括号让第一部分作为独立可能的状态，这样在整个逻辑中就很清晰。 符合表达式的输出不变, 但是整体意图很清晰。 比起简洁，可读性是首选的。使用括号会让你的意图清晰明了。</p>
<h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><p>字符串是字符集合, 比如 “hello, world” 或者 “albatross”. Swift 字符串用 String 类型表示。 字符串内容有多种访问方法, 包括字符值的集合。</p>
<p>Swift的 String 和 Character 类型提供一个快速的, Unicode 方式来作用于你的文本。 字符串创建和操作的语法是轻量和可读的, 字面语法跟C类似。 字符串连接和使用加号运算符一样简单, 字符的可变性由选择常量还是变量来管理, 就像Swift中其他值。 你还可以使用字符串把常量,变量,字面量,和表达式插入更长的字符串, 在一个众所周知的字符串插值。 这让显示自定义字符串变得容易。</p>
<p>尽快语法简单, Swift的 String 类型是个快速, 现代化的字符串实现。 每个字符串有独立编码的 Unicode 字符组成, 提供用多种Unicode形式访问这些字符的支持。</p>
<h1 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h1><p>You can include predefined String values within your code as string literals. A string literal is a fixed sequence of textual characters surrounded by a pair of double quotes (“”).</p>
<p>Use a string literal as an initial value for a constant or variable:</p>
<p>let someString = “Some string literal value”<br>Note that Swift infers a type of String for the someString constant, because it is initialized with a string literal value.<br>Initializing an Empty String</p>
<p>To create an empty String value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new String instance with initializer syntax:</p>
<p>var emptyString = “”               // empty string literal<br>var anotherEmptyString = String()  // initializer syntax<br>// these two strings are both empty, and are equivalent to each other<br>Find out whether a String value is empty by checking its Boolean isEmpty property:</p>
<p>if emptyString.isEmpty {<br>    print(“Nothing to see here”)<br>}<br>// Prints “Nothing to see here”<br>String Mutability</p>
<p>You indicate whether a particular String can be modified (or mutated) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it cannot be modified):</p>
<p>var variableString = “Horse”<br>variableString += “ and carriage”<br>// variableString is now “Horse and carriage”</p>
<p>let constantString = “Highlander”<br>constantString += “ and another Highlander”<br>// this reports a compile-time error - a constant string cannot be modified<br>Strings Are Value Types</p>
<p>Swift’s String type is a value type. If you create a new String value, that String value is copied when it is passed to a function or method, or when it is assigned to a constant or variable. In each case, a new copy of the existing String value is created, and the new copy is passed or assigned, not the original version. Value types are described in Structures and Enumerations Are Value Types.</p>
<p>Swift’s copy-by-default String behavior ensures that when a function or method passes you a String value, it is clear that you own that exact String value, regardless of where it came from. You can be confident that the string you are passed will not be modified unless you modify it yourself.</p>
<p>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.</p>
<p>Working with Characters</p>
<p>You can access the individual Character values for a String by iterating over its characters property with a for-in loop:</p>
<p>for character in “Dog!🐶”.characters {<br>    print(character)<br>}<br>// D<br>// o<br>// g<br>// !<br>// 🐶<br>The for-in loop is described in For-In Loops.</p>
<p>Alternatively, you can create a stand-alone Character constant or variable from a single-character string literal by providing a Character type annotation:</p>
<p>let exclamationMark: Character = “!”<br>String values can be constructed by passing an array of Character values as an argument to its initializer:</p>
<p>let catCharacters: [Character] = [“C”, “a”, “t”, “!”, “🐱”]<br>let catString = String(catCharacters)<br>print(catString)<br>// Prints “Cat!🐱”<br>Concatenating Strings and Characters</p>
<p>String values can be added together (or concatenated) with the addition operator (+) to create a new String value:</p>
<p>let string1 = “hello”<br>let string2 = “ there”<br>var welcome = string1 + string2<br>// welcome now equals “hello there”<br>You can also append a String value to an existing String variable with the addition assignment operator (+=):</p>
<p>var instruction = “look over”<br>instruction += string2<br>// instruction now equals “look over there”<br>You can append a Character value to a String variable with the String type’s append() method:</p>
<p>let exclamationMark: Character = “!”<br>welcome.append(exclamationMark)<br>// welcome now equals “hello there!”<br>String Interpolation</p>
<p>String interpolation is a way to construct a new String value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash:</p>
<p>let multiplier = 3<br>let message = “(multiplier) times 2.5 is (Double(multiplier) * 2.5)”<br>// message is “3 times 2.5 is 7.5”<br>In the example above, the value of multiplier is inserted into a string literal as (multiplier). This placeholder is replaced with the actual value of multiplier when the string interpolation is evaluated to create an actual string.</p>
<p>The value of multiplier is also part of a larger expression later in the string. This expression calculates the value of Double(multiplier) <em> 2.5 and inserts the result (7.5) into the string. In this case, the expression is written as (Double(multiplier) </em> 2.5) when it is included inside the string literal.<br>Unicode</p>
<p>Unicode is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift’s String and Character types are fully Unicode-compliant, as described in this section.</p>
<p>Unicode Scalars</p>
<p>Behind the scenes, Swift’s native String type is built from Unicode scalar values. A Unicode scalar is a unique 21-bit number for a character or modifier, such as U+0061 for LATIN SMALL LETTER A (“a”), or U+1F425 for FRONT-FACING BABY CHICK (“🐥”).<br>Note that not all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment. Scalars that have been assigned to a character typically also have a name, such as LATIN SMALL LETTER A and FRONT-FACING BABY CHICK in the examples above.</p>
<p>Special Characters in String Literals</p>
<p>String literals can include the following special characters:</p>
<p>The escaped special characters \0 (null character), \ (backslash), \t (horizontal tab), \n (line feed), \r (carriage return), \” (double quote) and \’ (single quote)<br>An arbitrary Unicode scalar, written as \u{n}, where n is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point<br>The code below shows four examples of these special characters. The wiseWords constant contains two escaped double quote characters. The dollarSign, blackHeart, and sparklingHeart constants demonstrate the Unicode scalar format:</p>
<p>let wiseWords = “\”Imagination is more important than knowledge\” - Einstein”<br>// “Imagination is more important than knowledge” - Einstein<br>let dollarSign = “\u{24}”        // $,  Unicode scalar U+0024<br>let blackHeart = “\u{2665}”      // ♥,  Unicode scalar U+2665<br>let sparklingHeart = “\u{1F496}” // 💖, Unicode scalar U+1F496<br>Extended Grapheme Clusters</p>
<p>Every instance of Swift’s Character type represents a single extended grapheme cluster. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</p>
<p>Here’s an example. The letter é can be represented as the single Unicode scalar é (LATIN SMALL LETTER E WITH ACUTE, or U+00E9). However, the same letter can also be represented as a pair of scalars—a standard letter e (LATIN SMALL LETTER E, or U+0065), followed by the COMBINING ACUTE ACCENT scalar (U+0301). The COMBINING ACUTE ACCENT scalar is graphically applied to the scalar that precedes it, turning an e into an é when it is rendered by a Unicode-aware text-rendering system.</p>
<p>In both cases, the letter é is represented as a single Swift Character value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:</p>
<p>let eAcute: Character = “\u{E9}”                         // é<br>let combinedEAcute: Character = “\u{65}\u{301}”          // e followed by ́<br>// eAcute is é, combinedEAcute is é<br>Extended grapheme clusters are a flexible way to represent many complex script characters as a single Character value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single Character value in Swift:</p>
<p>let precomposed: Character = “\u{D55C}”                  // 한<br>let decomposed: Character = “\u{1112}\u{1161}\u{11AB}”   // ᄒ, ᅡ, ᆫ<br>// precomposed is 한, decomposed is 한<br>Extended grapheme clusters enable scalars for enclosing marks (such as COMBINING ENCLOSING CIRCLE, or U+20DD) to enclose other Unicode scalars as part of a single Character value:</p>
<p>let enclosedEAcute: Character = “\u{E9}\u{20DD}”<br>// enclosedEAcute is é⃝<br>Unicode scalars for regional indicator symbols can be combined in pairs to make a single Character value, such as this combination of REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA) and REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8):</p>
<p>let regionalIndicatorForUS: Character = “\u{1F1FA}\u{1F1F8}”<br>// regionalIndicatorForUS is 🇺🇸<br>Counting Characters</p>
<p>To retrieve a count of the Character values in a string, use the count property of the string’s characters property:</p>
<p>let unusualMenagerie = “Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪”<br>print(“unusualMenagerie has (unusualMenagerie.characters.count) characters”)<br>// Prints “unusualMenagerie has 40 characters”<br>Note that Swift’s use of extended grapheme clusters for Character values means that string concatenation and modification may not always affect a string’s character count.</p>
<p>For example, if you initialize a new string with the four-character word cafe, and then append a COMBINING ACUTE ACCENT (U+0301) to the end of the string, the resulting string will still have a character count of 4, with a fourth character of é, not e:</p>
<p>var word = “cafe”<br>print(“the number of characters in (word) is (word.characters.count)”)<br>// Prints “the number of characters in cafe is 4”</p>
<p>word += “\u{301}”    // COMBINING ACUTE ACCENT, U+0301</p>
<p>print(“the number of characters in (word) is (word.characters.count)”)<br>// Prints “the number of characters in café is 4”<br>Accessing and Modifying a String</p>
<p>You access and modify a string through its methods and properties, or by using subscript syntax.</p>
<p>String Indices</p>
<p>Each String value has an associated index type, String.Index, which corresponds to the position of each Character in the string.</p>
<p>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which Character is at a particular position, you must iterate over each Unicode scalar from the start or end of that String. For this reason, Swift strings cannot be indexed by integer values.</p>
<p>Use the startIndex property to access the position of the first Character of a String. The endIndex property is the position after the last character in a String. As a result, the endIndex property isn’t a valid argument to a string’s subscript. If a String is empty, startIndex and endIndex are equal.</p>
<p>You access the indices before and after a given index using the index(before:) and index(after:) methods of String. To access an index farther away from the given index, you can use the index(_:offsetBy:) method instead of calling one of these methods multiple times.</p>
<p>You can use subscript syntax to access the Character at a particular String index.</p>
<p>let greeting = “Guten Tag!”<br>greeting[greeting.startIndex]<br>// G<br>greeting[greeting.index(before: greeting.endIndex)]<br>// !<br>greeting[greeting.index(after: greeting.startIndex)]<br>// u<br>let index = greeting.index(greeting.startIndex, offsetBy: 7)<br>greeting[index]<br>// a<br>Attempting to access an index outside of a string’s range or a Character at an index outside of a string’s range will trigger a runtime error.</p>
<p>greeting[greeting.endIndex] // Error<br>greeting.index(after: greeting.endIndex) // Error<br>Use the indices property of the characters property to access all of the indices of individual characters in a string.</p>
<p>for index in greeting.characters.indices {<br>    print(“(greeting[index]) “, terminator: “”)<br>}<br>// Prints “G u t e n   T a g ! “<br>Inserting and Removing</p>
<p>To insert a single character into a string at a specified index, use the insert(_:at:) method, and to insert the contents of another string at a specified index, use the insert(contentsOf:at:) method.</p>
<p>var welcome = “hello”<br>welcome.insert(“!”, at: welcome.endIndex)<br>// welcome now equals “hello!”</p>
<p>welcome.insert(contentsOf:” there”.characters, at: welcome.index(before: welcome.endIndex))<br>// welcome now equals “hello there!”<br>To remove a single character from a string at a specified index, use the remove(at:) method, and to remove a substring at a specified range, use the removeSubrange(_:) method:</p>
<p>welcome.remove(at: welcome.index(before: welcome.endIndex))<br>// welcome now equals “hello there”</p>
<p>let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex<br>welcome.removeSubrange(range)<br>// welcome now equals “hello”<br>NOTE</p>
<p>You can use the the insert(<em>:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(</em>:) methods on any type that conforms to the RangeReplaceableCollection protocol. This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.</p>
<p>Comparing Strings</p>
<p>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</p>
<p>String and Character Equality</p>
<p>String and character equality is checked with the “equal to” operator (==) and the “not equal to” operator (!=), as described in Comparison Operators:</p>
<p>let quotation = “We’re a lot alike, you and I.”<br>let sameQuotation = “We’re a lot alike, you and I.”<br>if quotation == sameQuotation {<br>    print(“These two strings are considered equal”)<br>}<br>// Prints “These two strings are considered equal”<br>Two String values (or two Character values) are considered equal if their extended grapheme clusters are canonically equivalent. Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.</p>
<p>For example, LATIN SMALL LETTER E WITH ACUTE (U+00E9) is canonically equivalent to LATIN SMALL LETTER E (U+0065) followed by COMBINING ACUTE ACCENT (U+0301). Both of these extended grapheme clusters are valid ways to represent the character é, and so they are considered to be canonically equivalent:</p>
<p>// “Voulez-vous un café?” using LATIN SMALL LETTER E WITH ACUTE<br>let eAcuteQuestion = “Voulez-vous un caf\u{E9}?”</p>
<p>// “Voulez-vous un café?” using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT<br>let combinedEAcuteQuestion = “Voulez-vous un caf\u{65}\u{301}?”</p>
<p>if eAcuteQuestion == combinedEAcuteQuestion {<br>    print(“These two strings are considered equal”)<br>}<br>// Prints “These two strings are considered equal”<br>Conversely, LATIN CAPITAL LETTER A (U+0041, or “A”), as used in English, is not equivalent to CYRILLIC CAPITAL LETTER A (U+0410, or “А”), as used in Russian. The characters are visually similar, but do not have the same linguistic meaning:</p>
<p>let latinCapitalLetterA: Character = “\u{41}”</p>
<p>let cyrillicCapitalLetterA: Character = “\u{0410}”</p>
<p>if latinCapitalLetterA != cyrillicCapitalLetterA {<br>    print(“These two characters are not equivalent.”)<br>}<br>// Prints “These two characters are not equivalent.”<br>NOTE</p>
<p>String and character comparisons in Swift are not locale-sensitive.</p>
<p>Prefix and Suffix Equality</p>
<p>To check whether a string has a particular string prefix or suffix, call the string’s hasPrefix(<em>:) and hasSuffix(</em>:) methods, both of which take a single argument of type String and return a Boolean value.</p>
<p>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s Romeo and Juliet:</p>
<p>let romeoAndJuliet = [<br>    “Act 1 Scene 1: Verona, A public place”,<br>    “Act 1 Scene 2: Capulet’s mansion”,<br>    “Act 1 Scene 3: A room in Capulet’s mansion”,<br>    “Act 1 Scene 4: A street outside Capulet’s mansion”,<br>    “Act 1 Scene 5: The Great Hall in Capulet’s mansion”,<br>    “Act 2 Scene 1: Outside Capulet’s mansion”,<br>    “Act 2 Scene 2: Capulet’s orchard”,<br>    “Act 2 Scene 3: Outside Friar Lawrence’s cell”,<br>    “Act 2 Scene 4: A street in Verona”,<br>    “Act 2 Scene 5: Capulet’s mansion”,<br>    “Act 2 Scene 6: Friar Lawrence’s cell”<br>]<br>You can use the hasPrefix(_:) method with the romeoAndJuliet array to count the number of scenes in Act 1 of the play:</p>
<p>var act1SceneCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasPrefix(“Act 1 “) {<br>        act1SceneCount += 1<br>    }<br>}<br>print(“There are (act1SceneCount) scenes in Act 1”)<br>// Prints “There are 5 scenes in Act 1”<br>Similarly, use the hasSuffix(_:) method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</p>
<p>var mansionCount = 0<br>var cellCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasSuffix(“Capulet’s mansion”) {<br>        mansionCount += 1<br>    } else if scene.hasSuffix(“Friar Lawrence’s cell”) {<br>        cellCount += 1<br>    }<br>}<br>print(“(mansionCount) mansion scenes; (cellCount) cell scenes”)<br>// Prints “6 mansion scenes; 2 cell scenes”<br>Unicode Representations of Strings</p>
<p>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined encoding forms. Each form encodes the string in small chunks known as code units. These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</p>
<p>Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a for-in statement, to access its individual Character values as Unicode extended grapheme clusters. This process is described in Working with Characters.</p>
<p>Alternatively, access a String value in one of three other Unicode-compliant representations:</p>
<p>A collection of UTF-8 code units (accessed with the string’s utf8 property)<br>A collection of UTF-16 code units (accessed with the string’s utf16 property)<br>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s unicodeScalars property)<br>Each example below shows a different representation of the following string, which is made up of the characters D, o, g, ‼ (DOUBLE EXCLAMATION MARK, or Unicode scalar U+203C), and the 🐶 character (DOG FACE, or Unicode scalar U+1F436):</p>
<p>let dogString = “Dog‼🐶”<br>UTF-8 Representation</p>
<p>You can access a UTF-8 representation of a String by iterating over its utf8 property. This property is of type String.UTF8View, which is a collection of unsigned 8-bit (UInt8) values, one for each byte in the string’s UTF-8 representation:</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/09/21/熙健-掌上心电获千万元A轮融资/"  title="熙健-掌上心电获千万元A轮融资">
 <strong>下一篇：</strong><br/> 
 <span>熙健-掌上心电获千万元A轮融资
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1）" data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三元条件运算符"><span class="toc-number">33.</span> <span class="toc-text">三元条件运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nil-联合运算符"><span class="toc-number">34.</span> <span class="toc-text">Nil-联合运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#范围运算符"><span class="toc-number">35.</span> <span class="toc-text">范围运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭合区间运算符"><span class="toc-number">36.</span> <span class="toc-text">闭合区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#半开区间运算符"><span class="toc-number">37.</span> <span class="toc-text">半开区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">38.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">39.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">40.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">41.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">42.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">43.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">45.</span> <span class="toc-text">字符串字面量</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mhealth365.cn/" target="_blank" title="一款温暖的心电监测设备">熙健-掌上心电</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m an iOS engineer <br/>
			Hala Madrid</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2779746325" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="跳跳魔王">跳跳魔王</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ecgbao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
