
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="跳跳魔王">
    

    
    <meta name="description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 编程语言（Swift 3.0.1）">
<meta property="og:url" content="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/index.html">
<meta property="og:site_name" content="跳跳魔王的博客">
<meta property="og:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseNOT_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseAND_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseOR_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseXOR_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFourValue_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/vectorAddition_2x.png">
<meta property="og:updated_time" content="2017-02-21T07:55:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 编程语言（Swift 3.0.1）">
<meta name="twitter:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta name="twitter:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">

    
    <link rel="alternative" href="/atom.xml" title="跳跳魔王的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="跳跳魔王的博客">跳跳魔王的博客</a></h1>
				<h2 class="blog-motto">每天进步一点点</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/28/Swift-编程语言（Swift-3-0-1）/" title="Swift 编程语言（Swift 3.0.1）" itemprop="url">Swift 编程语言（Swift 3.0.1）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="跳跳魔王" target="_blank" itemprop="author">跳跳魔王</a>
		
  <p class="article-time">
    <time datetime="2016-10-28T05:54:48.000Z" itemprop="datePublished"> 发表于 2016-10-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">33.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">34.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">35.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">36.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">37.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">38.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">39.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化空字符串"><span class="toc-number">40.</span> <span class="toc-text">初始化空字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串易变性"><span class="toc-number">41.</span> <span class="toc-text">字符串易变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串是值类型"><span class="toc-number">42.</span> <span class="toc-text">字符串是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用字符"><span class="toc-number">43.</span> <span class="toc-text">使用字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">连接字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串插入"><span class="toc-number">45.</span> <span class="toc-text">字符串插入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode"><span class="toc-number">46.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量"><span class="toc-number">47.</span> <span class="toc-text">Unicode 标量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量里的特殊字符"><span class="toc-number">48.</span> <span class="toc-text">字符串字面量里的特殊字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展字形集"><span class="toc-number">49.</span> <span class="toc-text">扩展字形集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算字符"><span class="toc-number">50.</span> <span class="toc-text">计算字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字符串"><span class="toc-number">51.</span> <span class="toc-text">访问和修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串索引"><span class="toc-number">52.</span> <span class="toc-text">字符串索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入和移除"><span class="toc-number">53.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较字符串"><span class="toc-number">54.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符等式"><span class="toc-number">55.</span> <span class="toc-text">字符串和字符等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀等式"><span class="toc-number">56.</span> <span class="toc-text">前缀和后缀等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-字符串表示"><span class="toc-number">57.</span> <span class="toc-text">Unicode 字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-8-形式"><span class="toc-number">58.</span> <span class="toc-text">UTF-8 形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-16-形式"><span class="toc-number">59.</span> <span class="toc-text">UTF-16 形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量形式"><span class="toc-number">60.</span> <span class="toc-text">Unicode 标量形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类型"><span class="toc-number">61.</span> <span class="toc-text">集合类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合的不稳定性"><span class="toc-number">62.</span> <span class="toc-text">集合的不稳定性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组"><span class="toc-number">63.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组类型缩写语法"><span class="toc-number">64.</span> <span class="toc-text">数组类型缩写语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建空数组"><span class="toc-number">65.</span> <span class="toc-text">创建空数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用默认值创建数组"><span class="toc-number">66.</span> <span class="toc-text">用默认值创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过合并数组创建数组"><span class="toc-number">67.</span> <span class="toc-text">通过合并数组创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用字面量创建数组"><span class="toc-number">68.</span> <span class="toc-text">用字面量创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改数组"><span class="toc-number">69.</span> <span class="toc-text">访问和修改数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历数组"><span class="toc-number">70.</span> <span class="toc-text">遍历数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合"><span class="toc-number">71.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类型的哈希值"><span class="toc-number">72.</span> <span class="toc-text">集合类型的哈希值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类型语法"><span class="toc-number">73.</span> <span class="toc-text">集合类型语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建和初始化空集合"><span class="toc-number">74.</span> <span class="toc-text">创建和初始化空集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用数组字面量创建集合"><span class="toc-number">75.</span> <span class="toc-text">用数组字面量创建集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改集合"><span class="toc-number">76.</span> <span class="toc-text">访问和修改集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历集合"><span class="toc-number">77.</span> <span class="toc-text">遍历集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合操作"><span class="toc-number">78.</span> <span class="toc-text">集合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本集合操作"><span class="toc-number">79.</span> <span class="toc-text">基本集合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典"><span class="toc-number">80.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典类型速记语法"><span class="toc-number">81.</span> <span class="toc-text">字典类型速记语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建一个空字典"><span class="toc-number">82.</span> <span class="toc-text">创建一个空字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用字面量创建字典"><span class="toc-number">83.</span> <span class="toc-text">用字面量创建字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字典"><span class="toc-number">84.</span> <span class="toc-text">访问和修改字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历字典"><span class="toc-number">85.</span> <span class="toc-text">遍历字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#控制流"><span class="toc-number">86.</span> <span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#For-In-循环"><span class="toc-number">87.</span> <span class="toc-text">For-In 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#While-循环"><span class="toc-number">88.</span> <span class="toc-text">While 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#While"><span class="toc-number">89.</span> <span class="toc-text">While</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Repeat-While"><span class="toc-number">90.</span> <span class="toc-text">Repeat-While</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#条件语句"><span class="toc-number">91.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#If"><span class="toc-number">92.</span> <span class="toc-text">If</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Switch"><span class="toc-number">93.</span> <span class="toc-text">Switch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非隐式-Fallthrough"><span class="toc-number">94.</span> <span class="toc-text">非隐式 Fallthrough</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区间匹配"><span class="toc-number">95.</span> <span class="toc-text">区间匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组-1"><span class="toc-number">96.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值绑定"><span class="toc-number">97.</span> <span class="toc-text">值绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Where"><span class="toc-number">98.</span> <span class="toc-text">Where</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合-Cases"><span class="toc-number">99.</span> <span class="toc-text">复合 Cases</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#控制转移语句"><span class="toc-number">100.</span> <span class="toc-text">控制转移语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Continue"><span class="toc-number">101.</span> <span class="toc-text">Continue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Break"><span class="toc-number">102.</span> <span class="toc-text">Break</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Break-在循环语句"><span class="toc-number">103.</span> <span class="toc-text">Break 在循环语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Break-在Switch-语句"><span class="toc-number">104.</span> <span class="toc-text">Break 在Switch 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fallthrough"><span class="toc-number">105.</span> <span class="toc-text">Fallthrough</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标签语句"><span class="toc-number">106.</span> <span class="toc-text">标签语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尽早退出"><span class="toc-number">107.</span> <span class="toc-text">尽早退出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断-API-可用性"><span class="toc-number">108.</span> <span class="toc-text">判断 API 可用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">109.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义和调用函数"><span class="toc-number">110.</span> <span class="toc-text">定义和调用函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数和返回值"><span class="toc-number">111.</span> <span class="toc-text">函数参数和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有参数的函数"><span class="toc-number">112.</span> <span class="toc-text">没有参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个参数的函数"><span class="toc-number">113.</span> <span class="toc-text">多个参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有返回值的函数"><span class="toc-number">114.</span> <span class="toc-text">没有返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带有多返回值的函数"><span class="toc-number">115.</span> <span class="toc-text">带有多返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选元组返回类型"><span class="toc-number">116.</span> <span class="toc-text">可选元组返回类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数标签和参数名"><span class="toc-number">117.</span> <span class="toc-text">函数参数标签和参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定参数标签"><span class="toc-number">118.</span> <span class="toc-text">指定参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#省略参数标签"><span class="toc-number">119.</span> <span class="toc-text">省略参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认参数值"><span class="toc-number">120.</span> <span class="toc-text">默认参数值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可变参数"><span class="toc-number">121.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#输入输出参数"><span class="toc-number">122.</span> <span class="toc-text">输入输出参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型"><span class="toc-number">123.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用函数类型"><span class="toc-number">124.</span> <span class="toc-text">使用函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型作为参数类型"><span class="toc-number">125.</span> <span class="toc-text">函数类型作为参数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型和返回值"><span class="toc-number">126.</span> <span class="toc-text">函数类型和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套函数"><span class="toc-number">127.</span> <span class="toc-text">嵌套函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">128.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式"><span class="toc-number">129.</span> <span class="toc-text">闭包表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序函数"><span class="toc-number">130.</span> <span class="toc-text">排序函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式语法"><span class="toc-number">131.</span> <span class="toc-text">闭包表达式语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#根据上下文推断类型"><span class="toc-number">132.</span> <span class="toc-text">根据上下文推断类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从单一表达式闭包隐式返回"><span class="toc-number">133.</span> <span class="toc-text">从单一表达式闭包隐式返回</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#速记参数名"><span class="toc-number">134.</span> <span class="toc-text">速记参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符方法"><span class="toc-number">135.</span> <span class="toc-text">运算符方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾闭包"><span class="toc-number">136.</span> <span class="toc-text">尾闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#捕获值"><span class="toc-number">137.</span> <span class="toc-text">捕获值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包是引用类型"><span class="toc-number">138.</span> <span class="toc-text">闭包是引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逃逸闭包"><span class="toc-number">139.</span> <span class="toc-text">逃逸闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动闭包"><span class="toc-number">140.</span> <span class="toc-text">自动闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">141.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举语法"><span class="toc-number">142.</span> <span class="toc-text">枚举语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用Switch语句匹配枚举值"><span class="toc-number">143.</span> <span class="toc-text">用Switch语句匹配枚举值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联值"><span class="toc-number">144.</span> <span class="toc-text">关联值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原始值"><span class="toc-number">145.</span> <span class="toc-text">原始值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式赋原始值"><span class="toc-number">146.</span> <span class="toc-text">隐式赋原始值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用原始值初始化"><span class="toc-number">147.</span> <span class="toc-text">用原始值初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归枚举"><span class="toc-number">148.</span> <span class="toc-text">递归枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和结构体"><span class="toc-number">149.</span> <span class="toc-text">类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较类和结构体"><span class="toc-number">150.</span> <span class="toc-text">比较类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义语法"><span class="toc-number">151.</span> <span class="toc-text">定义语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和结构体实例"><span class="toc-number">152.</span> <span class="toc-text">类和结构体实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问属性"><span class="toc-number">153.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体类型成员初始化方法"><span class="toc-number">154.</span> <span class="toc-text">结构体类型成员初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体和枚举是值类型"><span class="toc-number">155.</span> <span class="toc-text">结构体和枚举是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类是引用类型"><span class="toc-number">156.</span> <span class="toc-text">类是引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#等号运算符"><span class="toc-number">157.</span> <span class="toc-text">等号运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指针"><span class="toc-number">158.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在类与结构体中选择"><span class="toc-number">159.</span> <span class="toc-text">在类与结构体中选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串-数组和字典的赋值和拷贝行为"><span class="toc-number">160.</span> <span class="toc-text">字符串,数组和字典的赋值和拷贝行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性"><span class="toc-number">161.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存储属性"><span class="toc-number">162.</span> <span class="toc-text">存储属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量结构体的存储属性"><span class="toc-number">163.</span> <span class="toc-text">常量结构体的存储属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#延迟存储属性"><span class="toc-number">164.</span> <span class="toc-text">延迟存储属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存储属性和实例变量"><span class="toc-number">165.</span> <span class="toc-text">存储属性和实例变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算属性"><span class="toc-number">166.</span> <span class="toc-text">计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Setter-简化声明"><span class="toc-number">167.</span> <span class="toc-text">Setter 简化声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#只读计算属性"><span class="toc-number">168.</span> <span class="toc-text">只读计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性观察者"><span class="toc-number">169.</span> <span class="toc-text">属性观察者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局变量和局部变量"><span class="toc-number">170.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型属性"><span class="toc-number">171.</span> <span class="toc-text">类型属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型属性语法"><span class="toc-number">172.</span> <span class="toc-text">类型属性语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查询和设置类型属性"><span class="toc-number">173.</span> <span class="toc-text">查询和设置类型属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法"><span class="toc-number">174.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实例方法"><span class="toc-number">175.</span> <span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#self-属性"><span class="toc-number">176.</span> <span class="toc-text">self 属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在实例方法中修改值类型"><span class="toc-number">177.</span> <span class="toc-text">在实例方法中修改值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在变异方法里赋值给self"><span class="toc-number">178.</span> <span class="toc-text">在变异方法里赋值给self</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型方法"><span class="toc-number">179.</span> <span class="toc-text">类型方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标"><span class="toc-number">180.</span> <span class="toc-text">下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标语法"><span class="toc-number">181.</span> <span class="toc-text">下标语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用下标"><span class="toc-number">182.</span> <span class="toc-text">使用下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标选项"><span class="toc-number">183.</span> <span class="toc-text">下标选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-number">184.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义一个基类"><span class="toc-number">185.</span> <span class="toc-text">定义一个基类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子类化"><span class="toc-number">186.</span> <span class="toc-text">子类化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写"><span class="toc-number">187.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问超类的方法-属性和下标"><span class="toc-number">188.</span> <span class="toc-text">访问超类的方法,属性和下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写方法"><span class="toc-number">189.</span> <span class="toc-text">重写方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写属性"><span class="toc-number">190.</span> <span class="toc-text">重写属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写属性的-Getters-和-Setters"><span class="toc-number">191.</span> <span class="toc-text">重写属性的 Getters 和 Setters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写属性观察者"><span class="toc-number">192.</span> <span class="toc-text">重写属性观察者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#防止重写"><span class="toc-number">193.</span> <span class="toc-text">防止重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化"><span class="toc-number">194.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为存储属性设置初始值"><span class="toc-number">195.</span> <span class="toc-text">为存储属性设置初始值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化方法"><span class="toc-number">196.</span> <span class="toc-text">初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认属性值"><span class="toc-number">197.</span> <span class="toc-text">默认属性值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义初始化"><span class="toc-number">198.</span> <span class="toc-text">自定义初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化参数"><span class="toc-number">199.</span> <span class="toc-text">初始化参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参数名和参数标签"><span class="toc-number">200.</span> <span class="toc-text">参数名和参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有参数标签的初始化参数"><span class="toc-number">201.</span> <span class="toc-text">没有参数标签的初始化参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选属性类型"><span class="toc-number">202.</span> <span class="toc-text">可选属性类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化时访问常量属性"><span class="toc-number">203.</span> <span class="toc-text">初始化时访问常量属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认初始化方法"><span class="toc-number">204.</span> <span class="toc-text">默认初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体类型成员初始化方法-1"><span class="toc-number">205.</span> <span class="toc-text">结构体类型成员初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值类型初始化方法代理"><span class="toc-number">206.</span> <span class="toc-text">值类型初始化方法代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类继承和初始化"><span class="toc-number">207.</span> <span class="toc-text">类继承和初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定构造器和便利构造器"><span class="toc-number">208.</span> <span class="toc-text">指定构造器和便利构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定构造器和便利构造器的语法"><span class="toc-number">209.</span> <span class="toc-text">指定构造器和便利构造器的语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的初始化代理"><span class="toc-number">210.</span> <span class="toc-text">类的初始化代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两阶段初始化"><span class="toc-number">211.</span> <span class="toc-text">两阶段初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化方法的继承和重写"><span class="toc-number">212.</span> <span class="toc-text">初始化方法的继承和重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动初始化方法的继承"><span class="toc-number">213.</span> <span class="toc-text">自动初始化方法的继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定和便利构造器的初始化"><span class="toc-number">214.</span> <span class="toc-text">指定和便利构造器的初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可失败构造器"><span class="toc-number">215.</span> <span class="toc-text">可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举的可失败构造器"><span class="toc-number">216.</span> <span class="toc-text">枚举的可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带原始值枚举的可失败构造器"><span class="toc-number">217.</span> <span class="toc-text">带原始值枚举的可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造可失败的传递"><span class="toc-number">218.</span> <span class="toc-text">构造可失败的传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写可失败构造器"><span class="toc-number">219.</span> <span class="toc-text">重写可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init-可失败构造器"><span class="toc-number">220.</span> <span class="toc-text">init! 可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#必需构造器"><span class="toc-number">221.</span> <span class="toc-text">必需构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用闭包或者函数设定默认属性值"><span class="toc-number">222.</span> <span class="toc-text">用闭包或者函数设定默认属性值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#析构器"><span class="toc-number">223.</span> <span class="toc-text">析构器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#析构器如何工作"><span class="toc-number">224.</span> <span class="toc-text">析构器如何工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#析构器的活动"><span class="toc-number">225.</span> <span class="toc-text">析构器的活动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动引用计数"><span class="toc-number">226.</span> <span class="toc-text">自动引用计数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARC-如何工作"><span class="toc-number">227.</span> <span class="toc-text">ARC 如何工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARC-的活动"><span class="toc-number">228.</span> <span class="toc-text">ARC 的活动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类实例的强引用循环"><span class="toc-number">229.</span> <span class="toc-text">类实例的强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决实例间的强引用循环"><span class="toc-number">230.</span> <span class="toc-text">解决实例间的强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#弱引用"><span class="toc-number">231.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无主引用"><span class="toc-number">232.</span> <span class="toc-text">无主引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无主引用和隐式拆包可选属性"><span class="toc-number">233.</span> <span class="toc-text">无主引用和隐式拆包可选属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包强引用循环"><span class="toc-number">234.</span> <span class="toc-text">闭包强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">235.</span> <span class="toc-text">some default text</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决闭包强引用循环"><span class="toc-number">236.</span> <span class="toc-text">解决闭包强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义捕获列表"><span class="toc-number">237.</span> <span class="toc-text">定义捕获列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#弱引用和无主引用"><span class="toc-number">238.</span> <span class="toc-text">弱引用和无主引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选链"><span class="toc-number">239.</span> <span class="toc-text">可选链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#作为强制拆包替代方案的可选链"><span class="toc-number">240.</span> <span class="toc-text">作为强制拆包替代方案的可选链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为可选链接定义模型类"><span class="toc-number">241.</span> <span class="toc-text">为可选链接定义模型类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过可选链接访问属性"><span class="toc-number">242.</span> <span class="toc-text">通过可选链接访问属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过可选链接调用方法"><span class="toc-number">243.</span> <span class="toc-text">通过可选链接调用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过可选链接访问下标"><span class="toc-number">244.</span> <span class="toc-text">通过可选链接访问下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问可选类型下标"><span class="toc-number">245.</span> <span class="toc-text">访问可选类型下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多层链接"><span class="toc-number">246.</span> <span class="toc-text">多层链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用可选返回值链接方法"><span class="toc-number">247.</span> <span class="toc-text">使用可选返回值链接方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理-1"><span class="toc-number">248.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#表示和抛出错误"><span class="toc-number">249.</span> <span class="toc-text">表示和抛出错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理错误"><span class="toc-number">250.</span> <span class="toc-text">处理错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用抛出函数传递错误"><span class="toc-number">251.</span> <span class="toc-text">用抛出函数传递错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-Do-Catch-处理错误"><span class="toc-number">252.</span> <span class="toc-text">使用 Do-Catch 处理错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#转换错误成可选值"><span class="toc-number">253.</span> <span class="toc-text">转换错误成可选值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#禁用错误传递"><span class="toc-number">254.</span> <span class="toc-text">禁用错误传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定清理行为"><span class="toc-number">255.</span> <span class="toc-text">指定清理行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型转换"><span class="toc-number">256.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为类型转换定义类层次"><span class="toc-number">257.</span> <span class="toc-text">为类型转换定义类层次</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断类型"><span class="toc-number">258.</span> <span class="toc-text">判断类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#向下转换"><span class="toc-number">259.</span> <span class="toc-text">向下转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Any-和-AnyObject的类型转换"><span class="toc-number">260.</span> <span class="toc-text">Any 和 AnyObject的类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套类型"><span class="toc-number">261.</span> <span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内嵌类型的行为"><span class="toc-number">262.</span> <span class="toc-text">内嵌类型的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调用嵌套类型"><span class="toc-number">263.</span> <span class="toc-text">调用嵌套类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展"><span class="toc-number">264.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-扩展可以"><span class="toc-number">265.</span> <span class="toc-text">Swift 扩展可以:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展语法"><span class="toc-number">266.</span> <span class="toc-text">扩展语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算属性-1"><span class="toc-number">267.</span> <span class="toc-text">计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造器"><span class="toc-number">268.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法-1"><span class="toc-number">269.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#改变实例方法"><span class="toc-number">270.</span> <span class="toc-text">改变实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标-1"><span class="toc-number">271.</span> <span class="toc-text">下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议"><span class="toc-number">272.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议语法"><span class="toc-number">273.</span> <span class="toc-text">协议语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性需求"><span class="toc-number">274.</span> <span class="toc-text">属性需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法需求"><span class="toc-number">275.</span> <span class="toc-text">方法需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变异方法需求"><span class="toc-number">276.</span> <span class="toc-text">变异方法需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造器需求"><span class="toc-number">277.</span> <span class="toc-text">构造器需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类实现协议构造器需求"><span class="toc-number">278.</span> <span class="toc-text">类实现协议构造器需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可失败构造器需求"><span class="toc-number">279.</span> <span class="toc-text">可失败构造器需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议作为类型"><span class="toc-number">280.</span> <span class="toc-text">协议作为类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#委托"><span class="toc-number">281.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#给扩展添加协议"><span class="toc-number">282.</span> <span class="toc-text">给扩展添加协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用扩展声明协议"><span class="toc-number">283.</span> <span class="toc-text">用扩展声明协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议类型集合"><span class="toc-number">284.</span> <span class="toc-text">协议类型集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议继承"><span class="toc-number">285.</span> <span class="toc-text">协议继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#只用于类的协议"><span class="toc-number">286.</span> <span class="toc-text">只用于类的协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议组合"><span class="toc-number">287.</span> <span class="toc-text">协议组合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断协议一致性"><span class="toc-number">288.</span> <span class="toc-text">判断协议一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选协议需求"><span class="toc-number">289.</span> <span class="toc-text">可选协议需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议扩展"><span class="toc-number">290.</span> <span class="toc-text">协议扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#提供默认实现"><span class="toc-number">291.</span> <span class="toc-text">提供默认实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#给协议扩展添加限制"><span class="toc-number">292.</span> <span class="toc-text">给协议扩展添加限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型"><span class="toc-number">293.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型解决的问题"><span class="toc-number">294.</span> <span class="toc-text">泛型解决的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型函数"><span class="toc-number">295.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型参数"><span class="toc-number">296.</span> <span class="toc-text">类型参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命名类型参数"><span class="toc-number">297.</span> <span class="toc-text">命名类型参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型类型"><span class="toc-number">298.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展泛型类型"><span class="toc-number">299.</span> <span class="toc-text">扩展泛型类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型限制"><span class="toc-number">300.</span> <span class="toc-text">类型限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可续限制语法"><span class="toc-number">301.</span> <span class="toc-text">可续限制语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型限制的行为"><span class="toc-number">302.</span> <span class="toc-text">类型限制的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联类型"><span class="toc-number">303.</span> <span class="toc-text">关联类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联类型的行为"><span class="toc-number">304.</span> <span class="toc-text">关联类型的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展存在的类型去指定关联类型"><span class="toc-number">305.</span> <span class="toc-text">扩展存在的类型去指定关联类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型-Where-子句"><span class="toc-number">306.</span> <span class="toc-text">泛型 Where 子句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问控制"><span class="toc-number">307.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模块和源文件"><span class="toc-number">308.</span> <span class="toc-text">模块和源文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问级别"><span class="toc-number">309.</span> <span class="toc-text">访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问级别的指导原则"><span class="toc-number">310.</span> <span class="toc-text">访问级别的指导原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例如"><span class="toc-number">311.</span> <span class="toc-text">例如:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认访问级别"><span class="toc-number">312.</span> <span class="toc-text">默认访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单目标应用的访问级别"><span class="toc-number">313.</span> <span class="toc-text">单目标应用的访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#框架访问级别"><span class="toc-number">314.</span> <span class="toc-text">框架访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单元测试目标的访问级别"><span class="toc-number">315.</span> <span class="toc-text">单元测试目标的访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问控制语法"><span class="toc-number">316.</span> <span class="toc-text">访问控制语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义类型"><span class="toc-number">317.</span> <span class="toc-text">自定义类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组类型"><span class="toc-number">318.</span> <span class="toc-text">元组类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型-1"><span class="toc-number">319.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举类型"><span class="toc-number">320.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原始值和关联类型"><span class="toc-number">321.</span> <span class="toc-text">原始值和关联类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套类型-1"><span class="toc-number">322.</span> <span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子类化-1"><span class="toc-number">323.</span> <span class="toc-text">子类化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量-变量-属性和下标"><span class="toc-number">324.</span> <span class="toc-text">常量,变量,属性和下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Getters-和-Setters"><span class="toc-number">325.</span> <span class="toc-text">Getters 和 Setters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造器-1"><span class="toc-number">326.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认构造器"><span class="toc-number">327.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体类型的默认成员构造器"><span class="toc-number">328.</span> <span class="toc-text">结构体类型的默认成员构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议-1"><span class="toc-number">329.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议继承-1"><span class="toc-number">330.</span> <span class="toc-text">协议继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议一致性"><span class="toc-number">331.</span> <span class="toc-text">协议一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展-1"><span class="toc-number">332.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用扩展添加协议一致性"><span class="toc-number">333.</span> <span class="toc-text">使用扩展添加协议一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型-1"><span class="toc-number">334.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名-1"><span class="toc-number">335.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#备注"><span class="toc-number">336.</span> <span class="toc-text">备注</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高级运算符"><span class="toc-number">337.</span> <span class="toc-text">高级运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位运算符"><span class="toc-number">338.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-NOT-运算符"><span class="toc-number">339.</span> <span class="toc-text">位 NOT 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-AND-运算符"><span class="toc-number">340.</span> <span class="toc-text">位 AND 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-OR-运算符"><span class="toc-number">341.</span> <span class="toc-text">位 OR 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-XOR-运算符"><span class="toc-number">342.</span> <span class="toc-text">位 XOR 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#左右移位运算符"><span class="toc-number">343.</span> <span class="toc-text">左右移位运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无符号整数移动"><span class="toc-number">344.</span> <span class="toc-text">无符号整数移动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#有符号整数移动"><span class="toc-number">345.</span> <span class="toc-text">有符号整数移动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#溢出运算符"><span class="toc-number">346.</span> <span class="toc-text">溢出运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值溢出"><span class="toc-number">347.</span> <span class="toc-text">值溢出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优先级和关联性"><span class="toc-number">348.</span> <span class="toc-text">优先级和关联性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符方法-1"><span class="toc-number">349.</span> <span class="toc-text">运算符方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀运算符"><span class="toc-number">350.</span> <span class="toc-text">前缀和后缀运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符-1"><span class="toc-number">351.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#等式运算符"><span class="toc-number">352.</span> <span class="toc-text">等式运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义运算符"><span class="toc-number">353.</span> <span class="toc-text">自定义运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义中缀运算符的优先级"><span class="toc-number">354.</span> <span class="toc-text">自定义中缀运算符的优先级</span></a></li></ol>
		
		</div>
		
		<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><code>Swift</code> 是为 <code>iOS</code>，<code>macOS</code>，<code>watchOS</code>，和 <code>tvOS</code> 应用开发的一门新的开发语言，尽管如此，<code>Swift</code>很多部分都跟你以往从事<code>C</code>和<code>Objective-C</code>开发经验很相似。</p>
<p>基于<code>C</code> 和 <code>Objective-C</code> 的数据类型，<code>Swift</code> 提供了自己的版本，包括 <code>Int</code>， <code>Double</code>， <code>Float</code>，<code>Bool</code> 和 <code>String</code>。它同时也提供了三种集合类型，<code>Array</code>，<code>Set</code> 和 <code>Dictionary</code>。</p>
<p>跟C类似，<code>Swift</code> 通过变量名来存取值。<code>Swift</code> 还大量使用常量，这里的常量比C的常量更加强大。常量使用贯穿<code>Swift</code>，用来让代码更加安全和容易推断，特别是在你不想变量值发生改变的时候。</p>
<p>除了基本类型，<code>Swift</code> 还引进了<code>Objective-C</code>中没有的高级类型，比如元组。元组让你可以创建和传递多值。你可以在一个函数里返回元组来作为一个单独的混合值。</p>
<p><code>Swift</code> 还引进了可选类型，用来处理缺值的情况。可选的意思是‘这里有一个值，它等于x’ 或者‘这里没有任何值’。用可选值跟<code>Objective-C</code>里使用<code>nil</code>指针有点像，不过可选类型可以服务任何类型，不仅仅是类类型。可选类型不仅仅安全而且更容易表达意思，它是<code>Swift</code>最重要特性里的核心特性。</p>
<p><code>Swift</code>是一门类型安全的语言，这也就意味着这门语言可以让你更清晰的知道代码使用的值类型。如果你的代码需要一个<code>String</code>，类型安全会保护你不至于传递一个<code>Int</code>类型。同样，类型安全也会保护你，让你不会把非可选类型传递给需要可选类型的代码块。类型安全让你在开发阶段尽快发现问题，修复错误。</p>
<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>常量和变量是一个有特定类型的值，带有一个名字。常量值一旦确定就不能改变，变量在可用随时改变其值。</p>
<p>定义常量和变量<br>常量和变量必须要在使用前定义，常量使用let关键字，变量使用<code>var</code>关键字。下面是一个例子来展示如何使用常量和变量，这个例子是跟踪用户尝试的登录次数。</p>
<pre><code>let maximumNumberOfLoginAttempts = 10 
var currentLoginAttempt = 0</code></pre>
这段代码可以这样解读：
定义个常量<code>maximumNumberOfLoginAttempts</code>，给它一个值10.然后定义一个变量<code>currentLoginAttempt</code>，给它一个值0.
在这个例子里，最大登录次数定义为一个常量，因为最大登录数不会改变。当前登录数定义为变量，因为这个值随着用户的登录尝试会逐渐增长。
你也可以定义多个常量或变量在一行，用逗号分开即可：
<pre><code>var x = 0.0, y = 0.0, z = 0.0</code></pre>

<p>类型注释<br>当定义常量或者变量的时候，你可以提供一个类型注释，这样可以更清楚的知道存储类型是什么。在变量名或者常量名后面加一个冒号，然后一个空格，然后是要使用的类型。</p>
<p>这个例子为变量<code>welcomeMessage</code>提供一个类型解释，来说明这个变量可以存储<code>String</code>值：</p>
<pre><code>var welcomeMessage: String</code></pre>
这段代码可以理解为：
定义个变量叫<code>welcomeMessage</code>，它的类型是<code>String</code>。
<code>welcomeMessage</code>变量现在可以存储任何的字符串：
<pre><code>welcomeMessage = "Hello"</code></pre>
你可以在一行定义多个相关的相同类型的变量，用逗号分开，然后再最后加上类型注释：
<pre><code>var red, green, blue: Double</code></pre>

<p>常量和变量命名<br>常量和变量命名可以包含几乎任何的字符，包括<code>Unicode</code>字符：</p>
<pre><code>let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"</code></pre>
常量和变量命名不能包含空格字符，数学符号，箭头，私有（无效）的<code>Unicode</code>字符码，或者-等。也不能以数字开始，虽然数字可以出现在名字里的任何地方。

一旦你给常量或者变量确定了类型，你就不能用同样的名字来重定义它们，或者改变他们存储的值类型。你也不能把常量改为变量，或者把变量变成常量。

你可以把常量的值改变成同样类型的其他的值。这个例子里，变量<code>friendlyWelcome</code>的值从"Hello!" 变成 "Bonjour!":
<pre><code>var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome is now "Bonjour!"</code></pre>
与变量不同，常量值一旦确定就不能再改变。如果尝试改变编译器会报错：
<pre><code>let languageName = "Swift"
languageName = "Swift++"
// 这是一个编译期错误: languageName 不能修改。
</code></pre>
打印常量和变量
你可以使用<code>print(_:separator:terminator:)</code>函数打印常量或者变量的当前值：
<pre><code>print(friendlyWelcome)
// 打印 "Bonjour!"</code></pre>
<code>print(_:separator:terminator:)</code>是一个全局函数，可以打印一个或者多个值。在XCode里，例如，<code>print(_:separator:terminator:)</code>打印结果会出现在控制台里。<code>separator</code> 和 <code>terminator</code> 参数都有默认值, 所以你可以忽略他们。 默认的, 这个函数打印完会加上换行符。 如果不想打印后换行, 传入一个空字符串作为终止—例如, <code>print(someValue, terminator: "")</code>

<code>Swift</code> 使用 <code>字符串插入</code> 在长字符串里插入常量或者变量名, 同时会提示 <code>Swift</code> 去用当前的常量值活变量值来替换它。 用括号包含名字，然后在前面加上反斜杠:

<pre><code>print("The current value of friendlyWelcome is \(friendlyWelcome)")
// 打印 "The current value of friendlyWelcome is Bonjour!"</code></pre>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在代码中，把注释加到不执行的文本，作为一个备注或者提醒。代码编译的时候，注释会被编译器忽略。<br><code>Swift</code>注释和<code>C</code>语言注释很像，不再赘述。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>跟其他语言不同，<code>Swift</code>不要求在每条语句后写分号（；），不过，在一行写很多语句的时候，还是需要带上分号的：</p>
<pre><code>let cat = "🐱"; print(cat)
// 打印 "🐱"
</code></pre>

<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><p><code>Integers</code> 意思是整个数字没有小数，比如 42 和 -23，整数要么是 <code>signed</code>（负数，0，正数） 要么是 <code>unsigned</code>（正数或者0）</p>
<p><code>Swift</code>提供8，16，32 和 64位的有符号和无符号的整数。这些整数类型和C语言很像，8位的无符号的整数是<code>UInt8</code>，32位的有符号正数是<code>Int32</code>.</p>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><p>你可以用<code>min</code> 和<code>max</code>属性来获取每个整数类型的最小值和最大值：</p>
<pre><code>let minValue = UInt8.min  // minValue 等于 0, 类型是 UInt8
let maxValue = UInt8.max  // maxValue 等于 255, 类型是 UInt8</code></pre>

<h1 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h1><p>大多数情况下，你不需要指定整数的位数。<code>Swift</code>提供了额外的整数类型<code>Int</code>，这个和当前平台的本地字数一样：<br>32位机器，<code>Int</code>等于<code>Int32</code><br>64位机器，<code>Int</code>等于<code>Int64</code><br>除非你要用规定大小的整数，否则，一般只要用<code>Int</code>就可以了。</p>
<h1 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h1><p><code>Swift</code>也提供了无符号的整形，<code>UInt</code>，这个和当前平台的本地字数也是一样的：<br>32位机器，<code>UInt</code>等于<code>UInt32</code><br>64位机器，<code>UInt</code>等于<code>UInt64</code></p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数是带有小数部分的数字，比如 <code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>.<br>浮点数类型比整数类型表达更多的值域，比存在Int中的值更大或者更小。<code>Swift</code>提供了两个有符号的浮点数类型：<br><code>Double</code>表示64位的浮点数。<br><code>Float</code>表示32位的浮点数。</p>
<h1 id="类型安全与推断"><a href="#类型安全与推断" class="headerlink" title="类型安全与推断"></a>类型安全与推断</h1><p><code>Swift</code>是类型安全的语音。类型安全的语言鼓励你清楚知道自己代码使用的值的类型。如果你的代码需要<code>String</code>类型，那么你就不要传递<code>Int</code>给它。</p>
<p>因为<code>Swift</code>是类型安全的，在编译代码的时候类型检查会执行来标记不匹配的类型错误。这让你可以尽可能早的发现代码中的错误。</p>
<p>类型检查帮你避免使用不同类型的时候犯错，然而，这并不意味你必须给所有的常量和变量指定类型。你不需要指定类型，<code>Swift</code>使用类型推断来推断合适的类型。类型推断使得编译器可以在编译代码的时候自动推断表达式的类型，只是通过简单的检查你提供的值。</p>
<p>因为有类型推断，<code>Swift</code> 对类型声明要求的比其他语言要少的多。常量和变量依然要显示输入，但是大部分指定类型的工作都已经帮你做了。</p>
<p>类型推断在给常量或者变量赋初值的时候尤为有用。这个发生在你声明常量或者变量，并给他们指定（字面量）的时候。所谓的字面量就是指直接出现在你的源码中的值，比如下面例子里的 <code>42</code> 和 <code>3.14159</code></p>
<p>例如，如果你给一个新常量指定一个字面量是<code>42</code>， <code>Swift</code>就会推断你想要这个常量的类型是<code>Int</code>， 因为你给他初始化一个数字：</p>
<pre><code>let meaningOfLife = 42
// meaningOfLife 推断为 Int 类型</code></pre>
同样，你也不需要给浮点数指定类型，<code>Swift</code>会推断说你想要一个<code>Double</code>：
<pre><code>let pi = 3.14159
// pi 推断为 Double 类型</code></pre>
<code>Swift</code>在推断浮点数的时候总是选择<code>Double</code>而不是<code>Float</code>
如果你合并整数和浮点数在一个表达式中，<code>Double</code>类型将会被推断出来：
<pre><code>let anotherPi = 3 + 0.14159
// anotherPi 推断为 Double 类型</code></pre>

<h1 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h1><p>整数字面量这可以写：<br>十进制数字，没有前缀<br>二进制数字，用0b做前缀<br>八进制数字，用0o做前缀<br>十六进制数字，用0x做前缀<br>下面所有整数字面量值都是17：</p>
<pre><code>let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation</code></pre>

<p>浮点数字面量可以是十进制或者十六进制。在十进制点的两边都必须有数字。十进制浮点数也有个可选的<code>指数</code>，用大小写<code>e</code>标明；十六进制浮点数也有<code>指数</code>，用大小写的<code>p</code>标明。</p>
<p>用 <code>exp</code> 指数表示十进制数, 基础数字乘以 <code>10exp</code>:<br>1.25e2 意思是 1.25 x 102, 或者是 125.0.<br>1.25e-2 意思是 1.25 x 10-2, 或者是 0.0125.<br>用 <code>exp</code> 指数表示十六进制数, 基础数字乘以 <code>2exp</code>:</p>
<p><code>0xFp2</code> 意思是 <code>15 x 22</code>, 或者是 <code>60.0</code>.<br><code>0xFp-2</code> 意思是 <code>15 x 2-2</code>, 或者是 <code>3.75</code>.<br>下面所有这些浮点数字面量十进制数都是 <code>12.1875</code>:</p>
<pre><code>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0</code></pre>

<h1 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h1><p>在你的代码中使用<code>Int</code>做为一般用途的整形常量和变量，尽快知道他们是非负数的。日常开发使用默认整形类型意味着整形变量和常量立即可以使用，而且它们匹配整形字面量的推断类型。</p>
<p>特别指定的工作才会使用其他的整形类型，因为指定大小的整形类型需要额外的开销。日常开发中，使用指定大小的类型帮助捕获特定值的溢出，同时记录被使用的数据。</p>
<h1 id="整形转换"><a href="#整形转换" class="headerlink" title="整形转换"></a>整形转换</h1><p>不同数值类型，存储在常量或变量中的数值范围是不同的。一个<code>Int8</code>常量或者变量可以存储 <code>-128</code> 到 <code>127</code>， <code>UInt8</code>常量或者变量能存储 <code>0</code> 到 <code>255</code> 之间的数值。如果数值不适合指定大小的整形类型，编译后会报错。</p>
<pre><code>let cannotBeNegative: UInt8 = -1
// UInt8 cannot store negative numbers, and so this will report an error
let tooBig: Int8 = Int8.max + 1
// Int8 无法存储超过它能存储的最大值,
// 因此会报错</code></pre>


<p>为了转换一个特定数值类型，先用一个存在的值初始化一个新的想要类型的新数值。下面的例子，常量<code>twoThousand</code>的类型是<code>UInt16</code>， 而常量<code>one</code>的类型是<code>UInt8</code>.他们不能直接相加，因为类型不同。取而代之的是，这个例子调用<code>UInt16（one）</code>来创建一个新的<code>UInt16</code>，并用<code>one</code>初始化它，并在原来的位置使用这个值：</p>
<pre><code>let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)</code></pre>

<p>因为加好两边的值类型都是<code>UInt16</code>，所以加法是进行的。输出常量推断是<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>
<p><code>SomeType(ofInitialValue)</code> 默认调用<code>Swift</code>类型的初始化函数，然后传递一个初始值。这个语句之前，<code>UInt16</code>有一个构造器接受一个<code>UInt8</code>的值，所以这个构造器就用存在的<code>UInt8 </code>创建了一个新的<code>UInt16</code>.这里你不能随便传入类型-必须传入<code>UInt16</code>构造器接受的值。</p>
<h1 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h1><p>整数和浮点数之间的转换必须是显示的：</p>
<pre><code>let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi 等于 3.14159, 推断为 Double 类型</code></pre>

<p>这里，常量<code>three</code>用来创建新的<code>Double</code>数值，现在加号两边的类型是一样的，所以可以相加。如果没有这里的转换，加法是不允许的。</p>
<p>浮点数转整数也必须是显示进行的。一个整形可以用<code>Double</code> 或者 <code>Float</code>的值来初始化：</p>
<pre><code>let integerPi = Int(pi)
// integerPi equals 3, and is inferred to be of type Int</code></pre>

<p>用这种方式初始化一个新的整形数值，浮点数会被截断。意思就是 <code>4.75</code> 会变成 <code>4</code>， <code>-3.9</code>会变成<code>-3</code>.</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p><code>type aliases</code> 为已知类型定一个别名。定义类型别名使用<code>typealias</code>关键字。</p>
<p>类型别名在你想通过名字调用一个已知类型的时候很有用，这种名字在上下文中更合适，比如使用指定大小的外部数据时：</p>
<pre><code>typealias AudioSample = UInt16</code></pre>
定义好类型别名后，你可以在任何使用原名的地方使用它：
<pre><code>var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound 现在是 0</code></pre>

<p>这里，<code>AudioSample</code>就是<code>UInt16</code>的别名。因为是别名，调用<code>AudioSample.min</code>实际上就是调用<code>UInt16.min</code>，这给<code>maxAmplitudeFound</code>变量提供一个初始值<code>0</code>.</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p><code>Swift</code>有个一基础布尔类型， 叫做 <code>Bool</code>。布尔值用作逻辑调用，因为它只能是<code>true</code>或者<code>false</code>。<code>Swift</code>提供了两个布尔常量值，<code>true</code>和<code>false</code></p>
<pre><code>let orangesAreOrange = true
let turnipsAreDelicious = false</code></pre>

<p><code>orangesAreOrange</code> 和 <code>turnipsAreDelicious</code> 的类型被推断是<code>Bool</code>。同上面的<code>Int</code> 和 <code>Double</code> 一样，你不需要声明常量或者变量为<code>Bool</code></p>
<p>布尔值在if 语句这种条件语句中尤其有用：</p>
<pre><code>if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// 打印 "Eww, turnips are horrible."</code></pre>

<p><code>Swift</code> 类型安全防止非布尔值被替换成布尔值。下面的例子报一个编译错误：</p>
<pre><code>let i = 1
if i {
    // this example will not compile, and will report an error
}</code></pre>

<p>替代的例子如下：</p>
<pre><code>let i = 1
if i == 1 {
    // this example will compile successfully
}</code></pre>

<p><code>i==1</code>比较的结果是<code>Bool</code>类型，所以第二个例子通过了类型检查。</p>
<p>和其他类型安全例子一样，这个方法避免了突发的错误，确保特别代码块推断总是清晰的。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p><code>Tuples</code> 包含多值到一个单独的组合值。元组里的值可以是任何类型，彼此之间可以是不同类型。</p>
<p>在这个例子中，<code>(404, “Not Found”)</code>是一个元组，代表Http的错误码。一个Http错误码是访问网页时网页服务器返回的特殊数值。如果你请求的网页不存在，就会返回<code>404 Not Found</code>的错误码。</p>
<pre><code>let http404Error = (404, "Not Found")
// http404Error 是 (Int, String)类型, 等于 (404, "Not Found")</code></pre>

<p><code>(404, “Not Found”)</code> 元组包含了一个<code>Int</code> 和一个<code>String</code>，一个数字和一个人工可读的描述。它可以描述成一个类型为<code>（Int, String）</code>的元组。</p>
<p>你可以用任何变化的类型创建元组，你可以按照需要要创建不同的元组。</p>
<p>你可以分解元组到分离的常量或者变量，通常你会访问它们：</p>
<pre><code>let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// 打印 "The status code is 404"
print("The status message is \(statusMessage)")
// 打印 "The status message is Not Found"</code></pre>

<p>如果你只需要元组中的某些值，当你分解元组的时候可以用下划线替换忽略的部分：</p>
<pre><code>let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// 打印 "The status code is 404"</code></pre>

<p>或者，通过下标访问元组中单独的元素值：</p>
<pre><code>print("The status code is \(http404Error.0)")
// 打印 "The status code is 404"
print("The status message is \(http404Error.1)")
// 打印 "The status message is Not Found"</code></pre>

<p>你可以在元组定义时，给单独的原色命名：</p>
<pre><code>let http200Status = (statusCode: 200, description: "OK")</code></pre>

<p>如果你在元组中命名了元素，那么，你可以在访问元素值的时候通过名字访问它们的值：</p>
<pre><code>print("The status code is \(http200Status.statusCode)")
// 打印 "The status code is 200"
print("The status message is \(http200Status.description)")
// 打印 "The status message is OK"</code></pre>

<h1 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h1><p>当一个值可能缺失的时候使用可选类型。一个可选值包含两种可能：或者有一个值，你可以通过拆包访问这个值，或者根本没有值。</p>
<p>这里有一个例子，说明可选类型如何在值缺失的时候使用。<code>Swift</code> 的<code>Int</code> 类型有一个构造器，可以把<code>String</code> 转换为<code>Int</code> 值。不过，不是每一个字符串都可以转换的。<code>“123”</code>可以转换为<code>123</code>，但是<code>“helloworld”</code>就不可以。</p>
<p>下面的例子使用构造器去转换<code>String</code>：</p>
<pre><code>let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推断为 "Int?" 类型, 或者说 "可选的 Int"</code></pre>

<p>因为构造器有可能失败，所以它返回一个可选的 <code>Int</code>，而不是<code>Int</code>。一个可选<code>Int</code>写作<code>Int？</code>，不是<code>Int</code>。问号表示包含的值是可选的，意思就是它可能包含某个<code>Int</code>值，也可能不包含任何值。</p>
<h1 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h1><p>通过赋值<code>nil</code>来把可选值设置成无值状态：</p>
<pre><code>var serverResponseCode: Int? = 404
// serverResponseCode 包含一个实际的整数值 404
serverResponseCode = nil
// serverResponseCode 现在没有值</code></pre>

<p>如果定义一个可选变量，但是没有提供默认值，这个变量会被自动设置为<code>nil</code>：</p>
<pre><code>var surveyAnswer: String?
// surveyAnswer 自动设置为 nil</code></pre>

<h1 id="if语句和强制拆包"><a href="#if语句和强制拆包" class="headerlink" title="if语句和强制拆包"></a>if语句和强制拆包</h1><p>用<code>if</code>语句，通过与<code>nil</code>做比较，你可以知道一个可选项是否包含一个值，用<code>（==）</code>或者<code>（！=）</code>来做比较。如果一个可选项有值，那么它不等于<code>nil</code>：</p>
<pre><code>if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// 打印 "convertedNumber contains some integer value."</code></pre>

<p>一旦你确定可选项包含一个值，你可以通过在可选项的名字后面加（！）来获取它的值。这个感叹号是说：我知道这个可选项一定有值；请使用它！下面是强制拆包获取可选项的值：</p>
<pre><code>if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// 打印 "convertedNumber has an integer value of 123."</code></pre>


<h1 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h1><p>使用可选绑定找出可选项是否包含一个值。如果要这样做，使这个值作为一个临时常量或者变量。可选绑定用<code>if</code>和<code>while</code>语句来判断可选项的值，然后提取这个值到常量或者变量，作为操作的一部分。</p>
<p>用<code>if</code>语句像下面这样写：</p>
<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>

<p>你可以重写<code>possibleNumber</code>实例，通过使用可选绑定而不是强制拆包：</p>
<pre><code> if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" could not be converted to an integer")
}
// 打印 ""123" has an integer value of 123"</code></pre>

<p>代码可以这样读:<br><br>如果<code>Int（possibleNumber）</code>返回的可选<code>Int</code>包含一个值，设置一个新的常量叫<code>actualNumber</code>，它的值就是包含在可选项中的值。</p>
<p>如果转换成功，<code>actualNumber</code> 常量变的可用，执行第一个分支的语句。因为已经初始化了可选项的值，所以不需要用感叹号去拆包。</p>
<p>你可以同时使用常量和变量，如果你想操作if语句第一个分支里的actualNumber，你可能要写 if var actualNumber来替换代码，然后可选项的值会变成变量值而不是常量值。</p>
<p>你可以在单独的<code>if</code>语句包括尽可能多的可选绑定和布尔条件，用逗号分开即可。如果任何可选项的值为<code>nil</code>或者布尔条件等于<code>false</code>，<code>if</code>条件被认为是<code>false</code>。下面的<code>if</code>语句是一样的：</p>
<pre><code>if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// 打印 "4 < 42 < 100"

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// 打印 "4 < 42 < 100"</code></pre>

<h1 id="隐式拆包可选项"><a href="#隐式拆包可选项" class="headerlink" title="隐式拆包可选项"></a>隐式拆包可选项</h1><p>如上所述，可选项表示一个常量或者变量可以没有值。可选项可以用<code>if</code>语句判断是否存在值，如果不存在，可以有条件用可选绑定拆包来访问可选项的值。</p>
<p>有时候，通过程序的结构可以很清楚的知道可选项有值，然后这个值被第一次设置。这种情况，就不需要每次都判断和拆包了，因为可以安全的假设总是有值。</p>
<p>这种可选项定义为隐式拆包可选项。隐式拆包可选项的写法是，在类型后面假设感叹号而不是问号。</p>
<p>当可选项的值在首次定义后就能确定存在的事，隐式拆包可选项很有用。隐式拆包可选项主要用在类的初始化。</p>
<p>隐式拆包可选项在这种场景下，是正常可选项，但是也可以用作一个非可选项，无需每次访问都拆包。下面的例子展示了，可选字符串和隐式拆包可选项字符串作为显示<code>String</code>时访问它们包含的值的不同行为。</p>
<pre><code>let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // 需要一个感叹号

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // 不需要感叹号</code></pre>

<p>你依然可以把隐式拆包可选项当做正常的可选项，来判断它是否包含一个值：</p>
<pre><code>if assumedString != nil {
    print(assumedString)
}
// 打印 "An implicitly unwrapped optional string."</code></pre>

<p>你可以结合可选绑定来使用隐式拆包可选项，然后在一行语句中判断和拆包它的值：</p>
<pre><code>if let definiteString = assumedString {
    print(definiteString)
}
// 打印 "An implicitly unwrapped optional string."</code></pre>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>使用错误处理响应程序执行中错误条件。<br>与可选项做对照，可选项用有无值来表示一个函数的成功失败，错误处理允许你检测迁走的失败原因，同时如果必要的话，会把错误传递到程序的另外一部分。</p>
<p>当函数遇到一个错误情况，它就会<code>throws</code> 一个错误。函数调用者可以捕获这个错并正确响应。</p>
<pre><code>func canThrowAnError() throws {
    // this function may or may not throw an error
}</code></pre>

<p>一个函数表明它可以通过在定义中包含<code>throws</code>关键词来抛出一个错误。当你调用这个可以抛出错误的函数时，你要准备<code>try</code>关键词。</p>
<p><code>Swift</code> 自动把错误往外抛知道它被一个<code>catch</code>语句处理。</p>
<pre><code>do {
    try canThrowAnError()
    // 无错误抛出
} catch {
    // 抛出一个错误
}</code></pre>

<p><code>do</code> 语句创建了一个代码块，它允许错误可以传递给一个或者多个<code>catch</code> 项。</p>
<p>这里有一个列子，展示响应不同错误条件的错误处理方式：</p>
<pre><code>func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}</code></pre>

<p>在这个例子里，如果没有干净的餐具可用或者任何调料确实，<code>makeASandwich</code>将会抛出一个错误。因为<code>makeASandwich</code>可以抛出错误，所以函数调用包含在<code>try</code>表达式。经过<code>do</code>语句包含处理，任何抛出的错误都会传递到<code>catch</code>项。</p>
<p>如果没有错误抛出，<code>eatASandwich</code>函数会被调用。如果一个错误抛出然后匹配<code>SandwichError.outOfCleanDishes</code>这个条件，那么<code>washDishes</code>会被调用。如果一个错误抛出然后匹配<code>SandwichError.missingIngredients</code>条件，那么<code>buyGroceries</code>会被调用</p>
<h1 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h1><p><code>operator</code> 是特殊的符号或者短语，用来检查，改变，或者合并数值。比如，加号<code>（+）</code>用来加两个数值，比如 <code>let = 1 + 2</code>，逻辑与<code>（&amp;&amp;）</code>合并两个布尔值，比如 <code>enteredDoorCode &amp;&amp; passedRetinaScan</code><br><code>Swift</code>支持大部分的<code>C</code>语言操作符，并且提升了消除一般编码错误的能力。赋值运算符<code>（=）</code>不会返回一个值，用来防止错误是使用<code>（==）</code>。算数运算符—<code>（+，-，*，/，%</code>等等）监测和拒绝值溢出，为了避免值溢出造成未知的结果。你可以用<code>Swift</code>的溢出运算符选择值溢出行为。</p>
<p><code>Swift</code>同时提供了两个范围运算符<code>（a..\<b和a...b）< code="">，这在<code>C</code>语言里没有。这些作为表达一个范围值的快捷方式。</b和a...b）<></code></p>
<p>这个章节介绍<code>Swift</code>的普通运算符。<code>Advanced Operators</code> 包含了<code>Swift</code>的高级运算符，描述如何定义你自己的运算符，然后为你自定义的类型实现标准运算符。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>运算符是一元的，二元的，或者三元的：</p>
<ul><br><li>一元运算符操作单一目标（比如<code>-a</code>）。一元前缀操作费直接写在目标前（比如<code>！b</code>），一元后缀操作费则直接出现在目标后（比如<code>c！</code>）。</li><br><li>二元运算符操作两个目标（比如<code>2+3</code>），并且出现在两个目标的中间。</li><br><li>三元运算符操作三个目标，跟<code>C</code>语言一样，<code>Swift</code> 只有一个三元运算符，也就是三元条件运算符<code>（a ？b ：c）</code>。</li><br></ul>

<p>运算符作用的值是操作数。在表达式<code>1 + 2</code>里，<code>+</code>号是二元运算符，两个操作数分别是<code>1</code>和<code>2</code>.</p>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>赋值运算符<code>（a=b）</code>用<code>b</code>的值初始化或者更新<code>a</code>的值。</p>
<pre><code>let b = 10
var a = 5
a = b
// a 等于 10</code></pre>
如果赋值语句的右侧是多值的元组，它的元素可以一次分解为多个常量或者变量：

<pre><code>let (x, y) = (1, 2)
// x 等于 1, y 等于 2</code></pre>
与<code>C</code>语言 和 <code>Objective-C</code>语言不同，<code>Swift</code>赋值运算符自身不返回值。下面的语句是无效的：

<pre><code>if x = y {
    // 无效, 因为 x = y 不返回值。
}</code></pre>

<p>这个特性防止<code>=</code>与<code>==</code>混淆。 让<code>if x = y</code> 无效, <code>Swift</code> 帮你避免这种错误。</p>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p><code>Swift</code> 对所有类型支持四种标准算术运算符:</p>
<ul><br><li>加号 <code>(+) 1 + 2</code>   // 等于 3</li><br><li>减号 <code>(-) 5 - 3 </code>  // 等于 2</li><br><li>乘号 <code>(<em>) 2 </em> 3 </code>  // 等于 6</li><br><li>除号 <code>(/) 10.0 / 2.5</code>  // 等于 4.0</li><br></ul>

<p>与<code>C</code>语言 和 <code>Objective-C</code>语言不同, <code>Swift</code> 算术运算符默认不允许值溢出。 你可以通过<code>Swift</code>溢出运算符来选择值溢出行为(例如 <code>a &amp;+ b</code>)。</p>
<p>加号也支持字符串连接:</p>
<pre><code>"hello, " + "world"  // 等于 "hello, world"</code></pre>

<h1 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h1><p>余数运算符 <code>(a % b)</code> 计算<code>a中b</code>的倍数，并且返回余数。</p>
<p>备注</p>
<p>余数运算符 <code>(%)</code> 在其他语言中作为取模运算符。 不过, 在 <code>Swift</code> 中对负数来说, 严格来讲, 它是余数而不是一个取模运算。</p>
<p>下面演示余数运算符是如何工作的。 计算 <code>9 % 4</code>, 你首先算出9里有多少个4:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png"><br></div>

<p>你可以确定9里有两个4, 余数是 1 (橙色显示)。</p>
<p>在 <code>Swift 里</code>, 这个会写作:</p>
<pre><code>9 % 4    // 等于 1</code></pre>
为了确定 <code>a % b</code> 的结果, <code>%</code> 运算符计算下面的方程式，然后返回余数作为输出:

<code>a = (b x 倍数) + 余数</code>

这里倍数是a里面b的最大倍数。

把 9 和 4 代入方程式值域:

<pre><code>9 = (4 x 2) + 1</code></pre>

<p>计算负值a的余数也是用相同的方法:</p>
<pre><code>-9 % 4   // 等于 -1</code></pre>
把 -9 和 4 代入方程式值域:

<pre><code>-9 = (4 x -2) + -1</code></pre>

<p>活的余数 -1.</p>
<p>负值b被忽略。 意思就是 <code>a % b </code>和<code> a % -b</code> 结果是一样的。</p>
<h1 id="一元减法运算符"><a href="#一元减法运算符" class="headerlink" title="一元减法运算符"></a>一元减法运算符</h1><p>数值符号可以用前缀 <code>-</code> 连接, 也就是大家熟知的一元减法运算符:</p>
<pre><code>
let three = 3
let minusThree = -three       // minusThree equals -3
let plusThree = -minusThree   // plusThree equals 3, or "minus minus three"
</code></pre>

<p>一元减法运算符 <code>(-) </code>直接放在操作数前, 没有空格。</p>
<h1 id="一元加法运算符"><a href="#一元加法运算符" class="headerlink" title="一元加法运算符"></a>一元加法运算符</h1><p>一元加法运算符 <code>(+) </code>返回操作数值, 没有任何改变:</p>
<pre><code>
let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6
</code></pre>

<p>尽管一元加法运算符实际上不做任何事, 你可以用它来提供对称的代码，当在代码中使用正负数的时候。</p>
<h1 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h1><p>和<code> C </code>语言相似, <code>Swift</code> 提供复合赋值运算符来合并赋值 <code>(=)</code> 和其他操作数。 一个例子就是加法赋值运算符 <code>(+=)</code>:</p>
<pre><code>
var a = 1
a += 2
// a 现在等于 3
</code></pre>

<p>表达式 <code>a += 2</code> 是<code> a = a + 2 </code>的快捷方式。 实际上, 加法和赋值合并进一个操作符，同时做了两件事。</p>
<p>备注</p>
<p>复合赋值运算符不返回值。 比如, 你不能这样写 <code>let b = a += 2</code>.</p>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p><code>Swift</code> 支持所有标准<code>C</code>语言比较运算符:</p>
<ul><br><li><code>等于 (a == b)</code></li><br><li><code>不等于(a != b)</code></li><br><li><code>大于 (a &gt; b)</code></li><br><li><code>小于 (a &lt; b)</code></li><br><li><code>大于等于 (a &gt;= b)</code></li><br><li><code>小于等于 (a &lt;= b)</code></li><br></ul>

<p>备注</p>
<p><code>Swift</code> 同时提供两个相等运算符 <code>(=== and !==)</code>, 你可以用来测试两个对象引用是否引用了相同的对象实例。 更多信息参考类和结构体。</p>
<p>每个比较运算符都返回一个布尔值，来表明语句是否是真的:</p>
<ul><br><li><code>1 == 1   // 真，因为1 等于 1</code></li><br><li><code>2 != 1   // 真，因为2 不等于 1</code></li><br><li><code>2 &gt; 1    // 真，因为2 大于 1</code></li><br><li><code>1 &lt; 2    // 真，因为1 小于 2</code></li><br><li><code>1 &gt;= 1   // 真，因为1大于或者等于1</code></li><br><li><code>2 &lt;= 1   // 假，因为2不小于或者等于1</code></li><br></ul><br>比较运算符通常用于条件语句, 例如<code>if</code>语句:<br><pre><code><br>let name = “world”<br>if name == “world” {<br>    print(“hello, world”)<br>} else {<br>    print(“I’m sorry (name), but I don’t recognize you”)<br>}<br>// 打印 “hello, world”, because name is indeed equal to “world”.<br></code></pre><br>更多<code>if</code>语句, 参考控制流章节。<br><br>你可以比较含有相同数量值的元组, 只要元组里的值可以比较。 例如, <code>Int</code> 和 <code>String</code> 可以比较, 意思就是 <code>(Int, String)</code> 可以比较。 相反, <code>Bool</code> 不能比较, 意思就是包含布尔值的元组不能作比较。<br><br>元组是从左到右做比较的, 每次一个值, 直到比较发现两个值不等为止。 这两个被比较的值, 比较的结果决定了整个元组比较的结果。 如果所有元素都相等, 那么元组就是相等的。例如:<br><pre><code><br>(1, “zebra”) &lt; (2, “apple”)   // 真，因为1小于2; “zebra” 和 “apple” 不比较<br>(3, “apple”) &lt; (3, “bird”)    // 真，以为3等于3, “apple” 小于 “bird”<br>(4, “dog”) == (4, “dog”)      // 真，因为4等于4, “dog” 等于 “dog”<br></code></pre><br><br>上面这个例子, 在第一行你可以看见从左到右比较的行为。 因为1小于2, <code>(1, “zebra”)</code> 被认为小于 <code>(2, “apple”)</code>, 不用管元组里的其他值。 不管 “zebra” 是不是小于 “apple”, 因为比较已经取决于元组里的第一个元素了。 不过, 当元组第一个元素相等的时候，比较就像第二行，第三行发生的那样。<br><br># 三元条件运算符<br><br>三元条件运算符是含有三部分的特殊运算符, 样式是 <code>问题 ? 答案1 : 答案2</code>。 这是基于问题是真假对表达式之一的判断。 如果问题是真, 求 <code>answer1</code> 的值并返回; 否则, 求 <code>answer2</code> 的值并返回。<br><br>三元条件运算符是下面代码的简写:<br><pre><code><br>if question {<br>    answer1<br>} else {<br>    answer2<br>}<br></code></pre><br>这里有一个例子, 用例计算列表行高。 如果行有头部，那么行高比内容高度加<code>50</code>，如果没有头部，那么高度加<code>20</code>:<br><pre><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight = contentHeight + (hasHeader ? 50 : 20)<br>// rowHeight 等于 90<br><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight: Int<br>if hasHeader {<br>    rowHeight = contentHeight + 50<br>} else {<br>    rowHeight = contentHeight + 20<br>}<br>// rowHeight 等于 90<br></code></pre><br><br>第一个例子使用三元条件运算符，意味着行高可以在一行代码里正确设置, 这个比第二个例子的代码要简洁。<br><br>三元条件运算符提供一个简写，来决定使用两个表达式中的哪一个。 小心使用三元条件运算符。 过度使用，代码就是很难理解。 尽量避免把三元条件运算符的多个实例合并到一个符合语句。<br><br># Nil-联合运算符<br><br><code>nil-联合运算符 (a ?? b) </code>展开一个可选项 <code>a</code> 如果它包含一个值的话, 或者返回一个默认值<code> b</code> 如果<code> a 是 nil</code>。 表达式 <code>a</code> 总是一个可选类型。 表达式 <code>b</code> 必须匹配存储在<code>a</code>里的值类型。<br><br>nil-联合运算符是下面代码的简写:<br><br>a != nil ? a! : b<br>上面的代码使用三元条件运算符,然后强制展开 <code>(a!)</code> 来获取<code>a</code>中的值，如果这个值不空的话, 否则返回 <code>b</code> 。 nil-联合运算符提供了更优雅简洁的方式来压缩这个条件判断和展开。<br><br>备注<br><br>如果值非空, <code>b</code>的值不会得到。 这就是人们熟知的短路估算。<br><br>下面的例子使用 nil-联合运算符在默认颜色名称和可选用户定义的颜色名称之间做选择:<br><pre><code><br>let defaultColorName = “red”<br>var userDefinedColorName: String?   // 默认是 nil<br><br>var colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName 是 nil, 所以colorNameToUse 设置成默认值 “red”<br></code></pre><br><code>userDefinedColorName</code> 变量定义成可选的 <code>String</code>, 默认值是 <code>nil</code>. 因为 <code>userDefinedColorName</code> 是个可选类型, 你可以使用nil-联合运算符来获取它的值。 上面的例子, 运算符用来决定变量 <code>colorNameToUse</code> 的一个初始值。 因为 <code>userDefinedColorName</code> 是 <code>nil</code>,  <code>userDefinedColorName ?? defaultColorName</code> 表达式返回了<code>defaultColorName</code> 的值, 或者 <code>“red”</code>.<br><br>如果你给 <code>userDefinedColorName</code> 赋了一个非空值，然后执行 nil-联合运算符再次判断, <code>userDefinedColorName</code> 中包含的值就取代了默认值:<br><pre><code><br>userDefinedColorName = “green”<br>colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName is not nil, so colorNameToUse is set to “green”<br></code></pre><br><br># 范围运算符<br><br><code>Swift</code> 有两个范围运算符, 是表达值范围的简写。<br><br># 闭合区间运算符<br><br>闭合区间运算符 <code>(a…b) </code>定义从a到b的范围, 包含<code>a</code>和<code>b</code>的值。 <code>a</code>的值不能比<code>b</code>大。<br><br>闭合区间运算符在范围迭代很有用，特别是你想使用所有的值的时候。例如 <code>for-in</code> 循环:<br><pre><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index * 5)”)<br>}<br>// 1 乘以 5 等于 5<br>// 2 乘以 5 等于 10<br>// 3 乘以 5 等于 15<br>// 4 乘以 5 等于 20<br>// 5 乘以 5 等于 25<br></code></pre><br><br>更多 <code>for-in</code> 循环, 参考控制流。<br><br># 半开区间运算符<br><br>半开区间运算符 <code>(a..\<b) <="" code="">定义了从<code>a</code>到<code>b</code>的范围, 但是不包含<code>b</code>， 之所以成为半开是因为它包含初值, 但是不包含终值。 正如闭合区间运算符, <code>a</code>的值不能大于<code>b</code>。 如果<code>a</code>的值等于<code>b</code>的值, 这个范围就会是空的。<br><br>半开区间在你使用类似数组这种基于零的列表时非常有用, 计算列表长度 (但是不包括) 很有帮助:<br><pre><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>let count = names.count<br>for i in 0..<count 1="" 2="" 3="" 4="" {="" print("person="" \(i="" +="" 1)="" is="" called="" \(names[i])")="" }="" person="" anna="" alex="" brian="" jack="" <="" code=""></count></code></pre><br><br>数组包含4项, 不过 <code>0..\<count< code=""> 只计算到3 (数组最后一项的索引), 因为是半开区间。 更多数组, 参见数组。<br><br># 逻辑运算符<br><br>逻辑运算符改变或者合并布尔值真和假。 <code>Swift</code> 支持三种基于<code>C</code>语言的标准逻辑运算符:<br><ul><br><li>逻辑非 <code>(!a)</code></li><br><li>逻辑与 <code>(a &amp;&amp; b)</code></li><br><li>逻辑或 <code>(a || b)</code></li><br></ul>

<h1 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h1><p>逻辑非运算符 <code>(!a)</code> 反转布尔值，这样真就变成假, 假变成了真。</p>
<p>逻辑非运算符是个前缀运算符, 直接写在操作数前面, 没有任何空格。 可以读作 <code>“not a”</code>, 下面的例子可以看到:</p>
<pre><code>
let allowedEntry = false
if !allowedEntry {
    print("ACCESS DENIED")
}
// 打印 "ACCESS DENIED"
</code></pre>

<p>语句 <code>if !allowedEntry</code> 可以读作 <code>“if not allowed entry.”</code> 后面一行仅执行 <code>“not allowed entry”</code> 是 <code>true</code>; 也就是, <code>if allowedEntry </code>是 <code>false</code>.</p>
<p>在这个例子中, 谨慎定义布尔常量和变量名，可以让代码具有可读性和简洁性, 同时避免双重否定或者混乱的逻辑语句。</p>
<h1 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a>逻辑与运算符</h1><p>逻辑与运算符 <code>(a &amp;&amp; b)</code> 创建逻辑表达式，这个表达式中两个值为真，表达式也要为真。</p>
<p>如果任何一个值为假, 表达式的结果也将是假。 事实上, 如果第一个值为假, 第二个值不会再计算, 因为它不会让所有表达式都等于真。 这就是人们熟知的短路估值。</p>
<p>这个例子有两个布尔值，只有两个值都是真的时候才允许访问:</p>
<pre><code>
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaScan {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// 打印 "ACCESS DENIED"
</code></pre>

<h1 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a>逻辑或运算符</h1><p>逻辑或运算符 <code>(a || b)</code> 是两个竖线组成的中间运算符。 用来创建逻辑表达式，这个表达式中只要有一个值为真，表达式的结果就是真。</p>
<p>跟上面逻辑与类似, 逻辑或使用短路估值去计算表达式。 如果逻辑或的左侧是真, 右侧就不再估值, 因为它不会改变整个表达式的结果。</p>
<p>下面的例子, 第一个布尔值 <code>(hasDoorKey)</code> 是假, 但是第二个布尔值 <code>(knowsOverridePassword) </code>是真。 因为一个值为真, 表达式结果就是真, 所以允许访问:</p>
<pre><code>
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// 打印 "Welcome!"
</code></pre>

<h1 id="合并逻辑运算符"><a href="#合并逻辑运算符" class="headerlink" title="合并逻辑运算符"></a>合并逻辑运算符</h1><p>你可以合并多个逻辑运算符来创建更长的复合表达式:</p>
<pre><code>
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// 打印 "Welcome!"
</code></pre>

<p>这个例子使用了多个 <code>&amp;&amp;</code> 和<code> || </code>运算符来创建一个更长的复合表达式。 不过, <code>&amp;&amp;</code> 和 <code>|| </code>运算符依然只能操作两个值, 所以，这实际上是三个小表达式链接起来的。 </p>
<p>备注</p>
<p><code>Swift</code> 逻辑运算符 <code>&amp;&amp; </code>和<code> || </code>是左联想的, 意思就是多个逻辑运算符的复合表达式，首先计算最左边的子表达式。</p>
<h1 id="显示括号"><a href="#显示括号" class="headerlink" title="显示括号"></a>显示括号</h1><p>虽然不是严格需要，但是包含括号还是有用的, 使得复杂表达式的意图很容易理解。 上述实例, 给第一部分加上括号很有用，会让它的意图很明显:</p>
<pre><code>
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// 打印 "Welcome!"
</code></pre>

<p>括号让第一部分作为独立可能的状态，这样在整个逻辑中就很清晰。 符合表达式的输出不变, 但是整体意图很清晰。 比起简洁，可读性是首选的。使用括号会让你的意图清晰明了。</p>
<h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><p>字符串是字符集合, 比如<code> “hello, world”</code> 或者 <code>“albatross”</code>. <code>Swift</code> 字符串用 <code>String </code>类型表示。 字符串内容有多种访问方法, 包括字符值的集合。</p>
<p><code>Swift</code>的 <code>String</code> 和 <code>Character</code> 类型提供一个快速的, <code>Unicode</code> 方式来作用于你的文本。 字符串创建和操作的语法是轻量和可读的, 字面语法跟C类似。 字符串连接和使用加号运算符一样简单, 字符的可变性由选择常量还是变量来管理, 就像<code>Swift</code>中其他值。 你还可以使用字符串把常量,变量,字面量,和表达式插入更长的字符串, 在一个众所周知的字符串插值。 这让显示自定义字符串变得容易。</p>
<p>尽快语法简单, <code>Swift</code>的 <code>String</code> 类型是个快速, 现代化的字符串实现。 每个字符串有独立编码的 <code>Unicode</code> 字符组成, 提供用多种<code>Unicode</code>形式访问这些字符的支持。</p>
<h1 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h1><p>你可以在代码中为字符串预定义字符值。 字符串字面量是由<code>（””）</code>包围的固定的文字字符序列。</p>
<p>用字符串值作为一个常量或者变量的初始值:</p>
<pre><code>let someString = "Some string literal value"</code></pre>

<p>注意 <code>Swift</code> 推断<code>someString</code> 常量是一个 <code>String</code> 类型, 因为它用字符串值初始化。</p>
<h1 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h1><p>创建空字符串值作为更长字符串的起点, 或者给一个变量赋一个空字符串值, 或者用初始化方法来初始化一个新的字符串实例:</p>
<pre><code>
var emptyString = ""               // 空字面量
var anotherEmptyString = String()  // 构造语法
// 这两个字符串都是空的, 彼此相等
判读一个字符串是否为空,可以使用它的布尔属性 isEmpty:

if emptyString.isEmpty {
    print("Nothing to see here")
}
// 打印 "Nothing to see here"
</code></pre>

<h1 id="字符串易变性"><a href="#字符串易变性" class="headerlink" title="字符串易变性"></a>字符串易变性</h1><p>你来指定一个特定字符串能不能改变（或者突变），这种变化通过把它赋给一个变量实现。 (这种情况它是可以改变的), 或者赋值给一个常量实现 (这种情况它不能被改变):</p>
<pre><code>
var variableString = "Horse"
variableString += " and carriage"
// variableString 等于 "Horse and carriage"

let constantString = "Highlander"
constantString += " and another Highlander"
// 报编译期错误 - 常量不能修改
</code></pre>

<h1 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h1><p><code>Swift</code> 的字符串类型是值类型。 如果你创建了一个新的字符串值, 这个字符串值在传给函数或者方法的时候被复制, 或者当它被赋值给一个常量或者变量的时候。这两种情况, 已存在字符串值的拷贝被创建, 新的拷贝被传递或者赋值, 而不是原来的字符串。 值类型在 <code>结构体和枚举是值类型<code> 中有描述。</code></code></p>
<p>很清楚你拥有精确的字符串值，而不用关心它从哪里来的。你可以确信传给你的字符串不会被改变,除非你自己改变它。</p>
<p>在幕后, <code>Swift</code> 的编译器优化了字符串的使用，这使得实际的拷贝只有真正需要的时候才会占用空间。 这就意味你使用字符串作为值类型总可以获得高性能。</p>
<h1 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h1><p>你可以用<code>for-in</code> 循环语句,通过它的字符属性来迭代访问每一个单独的字符:</p>
<pre><code>
for character in "Dog!🐶".characters {
    print(character)
}
// D
// o
// g
// !
// 🐶
</code></pre>

<p>或者, 你可以创建一个单独的字符常量或者变量，这变量通过提供一个字符类型注释的单字符字符串值。:</p>
<pre><code>
let exclamationMark: Character = "!"
String values can be constructed by passing an array of Character values as an argument to its initializer:

let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]
let catString = String(catCharacters)
print(catString)
// 打印 "Cat!🐱"
</code></pre>

<h1 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h1><p>字符串值可以通过加号连接成新的字符串:</p>
<pre><code>
let string1 = "hello"
let string2 = " there"
var welcome = string1 + string2
// welcome now equals "hello there"
</code></pre>
你也可以通过赋值运算符（+=）把字符串添加到已存在的字符串变量:
<pre><code>
var instruction = "look over"
instruction += string2
// instruction 等于 "look over there"
你可以使用 append() 方法向字符串后面添加一个字符:
let exclamationMark: Character = "!"
welcome.append(exclamationMark)
// welcome 等于 "hello there!"
</code></pre>

<h1 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h1><p><code>String</code> 字符串插入是构建新字符串的一种方法，这种方法通过混合常量,变量,字面量,表达式中的字面量来实现。每个你要插入的值都包括在括弧里,前面是一个反斜杠:</p>
<pre><code>
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// message is "3 times 2.5 is 7.5"
</code></pre>

<p>上面这个例子,  <code>multiplier</code> 的值以 <code>\(multiplier)</code> 的形式插入到一个字符串。 这个占位符会被 <code>multiplier</code> 的实际值取代，当插值被计算创建新字符串的时候。</p>
<p><code>multiplier</code> 的值是字符串后面大表达式的一部分。 这个表达式计算 <code>Double(multiplier) <em> 2.5 </em></code>的值，然后把结果<code> (7.5) </code>插入字符串。 这种情况下, 当它被包括进字符串字面量的时候，表达式就写作 <code>\(Double(multiplier)  2.5)</code> .</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p><code>Unicode </code>是在不同写作体系中用作编码,表达,处理文字的一种国际标准。 让你可以用一种标准形式表示任何语言的任何字符, 在诸如文本文件或者网页等外部资源,去读写这些字符。 <code>Swift</code> 的字符串和字符是完全 <code>Unicode</code> 编译的。</p>
<h1 id="Unicode-标量"><a href="#Unicode-标量" class="headerlink" title="Unicode 标量"></a>Unicode 标量</h1><p>背后, <code>Swift</code> 的本地字符串类型建立于 <code>Unicode</code> 标量值。对应字符或者修饰符来说, 一个 <code>Unicode</code> 标量是唯一的一个21位数字, 例如 <code>U+0061</code> 是 <code>LATIN SMALL LETTER A (“a”)</code>, 或者 <code>U+1F425</code> 是 <code>FRONT-FACING BABY CHICK (“🐥”)</code>.<br>注意并非所有 21-位 <code>Unicode</code> 标量都会被赋值给一些给未来预留的字符标量。 分配给字符的标量通常有一个名字, 比如 <code>LATIN SMALL LETTER A</code> 和 <code>FRONT-FACING BABY CHICK </code>.</p>
<h1 id="字符串字面量里的特殊字符"><a href="#字符串字面量里的特殊字符" class="headerlink" title="字符串字面量里的特殊字符"></a>字符串字面量里的特殊字符</h1><p>字符串字面量可以包括下面的特殊字符:</p>
<p>转义字符 <code>\0</code> (空字符), <code>\</code> (反斜杠), <code>\t</code> (水平制表符), <code>\n</code> (换行), <code>\r</code> (回车), <code>\”</code> (双引号) and <code>\’</code> (单引号)<br>任意一个 <code>Unicode</code> 标量, 写作 <code>\u{n}</code>, n 是 一个 1–8 位十六进制数字，这个数字有个和 有效的<code>Unicode</code> 编码点相等的值。<br>下面四个例子显示了特殊字符的编码。<code>wiseWords</code> 常量包括两个转义的双引号字符。 <code>dollarSign</code>, <code>blackHeart</code>, 和<code>sparklingHeart</code> 常量展示了<code>Unicode</code> 标量的格式:</p>
<pre><code>
let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
// "Imagination is more important than knowledge" - Einstein
let dollarSign = "\u{24}"        // $,  Unicode scalar U+0024
let blackHeart = "\u{2665}"      // ♥,  Unicode scalar U+2665
let sparklingHeart = "\u{1F496}" // 💖, Unicode scalar U+1F496
</code></pre>

<h1 id="扩展字形集"><a href="#扩展字形集" class="headerlink" title="扩展字形集"></a>扩展字形集</h1><p><code>Swift</code>的每个字符类型的实例带包一个单独的扩展字形集。 一个扩展字形集是一个或者多个<code> Unicode </code>标量，这些标量（当合并时）生成一个人可读的字符。</p>
<p>这里有个例子。 字符 <code>é</code> 可以表示成单独的 <code>Unicode</code> 标量 <code>é (LATIN SMALL LETTER E WITH ACUTE</code>, 或者<code> U+00E9</code>). 不过, 相同的字母也可以表示成标量集的一部分，字母 <code>e (LATIN SMALL LETTER E</code>, 或者<code> U+0065</code>), 后面跟着 <code>COMBINING ACUTE ACCENT </code>标量 <code>(U+0301).COMBINING ACUTE ACCENT </code>标量 应用于之前的标量, 在一个<code>Unicode</code>识别 文本渲染系统渲染的时候，把 <code>e</code> 变成 <code>é</code>.</p>
<p>在这两个例子里, 字符 <code>é</code> 表示为一个单独的<code>Swift </code>字符值，这个值表示一个扩展字形集。 第一个例子, 集合包含一个单独的标量; 第二个例子, 是两个标量的集合:</p>
<pre><code>
let eAcute: Character = "\u{E9}"                         // é
let combinedEAcute: Character = "\u{65}\u{301}"          // e followed by ́
// eAcute is é, combinedEAcute is é
</code></pre>
扩展字形集是一种灵活的方式去表示很多复杂脚本字符作为单独字符值。 比如, 来自朝鲜字母的朝鲜语音节可以表示成复合或者分离的序列。 在<code>Swift</code>里,这些表达都是合格的字符值:
<pre><code>
let precomposed: Character = "\u{D55C}"                  // 한
let decomposed: Character = "\u{1112}\u{1161}\u{11AB}"   // ᄒ, ᅡ, ᆫ
// precomposed is 한, decomposed is 한
</code></pre>
扩展字形集使得封闭标志的标量 (比如 <code>COMBINING ENCLOSING CIRCLE</code>, 或者 <code>U+20DD</code>) 可以装入其他 <code>Unicode</code> 标量作为一个单独字符值的一部分:
<pre><code>
let enclosedEAcute: Character = "\u{E9}\u{20DD}"
// enclosedEAcute is é⃝
</code></pre>
<code>Unicode</code> 局部指示器符号标量可以成对组合来生成一个单独的字符值, 比如 <code>REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA)</code> 和 <code>REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8) </code>的组合:
<pre><code>
let regionalIndicatorForUS: Character = "\u{1F1FA}\u{1F1F8}"
// regionalIndicatorForUS is 🇺🇸
</code></pre>

<h1 id="计算字符"><a href="#计算字符" class="headerlink" title="计算字符"></a>计算字符</h1><p>在字符串中获取字符值的数量, 可以使用字符串字符属性中的计数属性:</p>
<pre><code>
let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
print("unusualMenagerie has \(unusualMenagerie.characters.count) characters")
// 打印 "unusualMenagerie has 40 characters"
</code></pre>
注意 <code>Swift</code> 对字符值使用扩展字形集，意味着字符拼接和修改可能不会总是影响字符串的字符数。

例如, 如果你用四个字符的单词咖啡来初始化一个新字符串, 然后添加 <code>COMBINING ACUTE ACCENT (U+0301)</code> 到字符串的尾部, 最后字符的数量还是4, 第四个字符是 <code>é</code>, 而不是 <code>e</code>:
<pre><code>
var word = "cafe"
print("the number of characters in \(word) is \(word.characters.count)")
// 打印 "the number of characters in cafe is 4"

word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301

print("the number of characters in \(word) is \(word.characters.count)")
// 打印 "the number of characters in café is 4"
</code></pre>

<h1 id="访问和修改字符串"><a href="#访问和修改字符串" class="headerlink" title="访问和修改字符串"></a>访问和修改字符串</h1><p>你可以通过方法和属性来访问和修改字符串, 或者用下标语法。</p>
<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><p>每个字符串值都有一个对应的索引类型, <code>String.Index</code>, 代表每个字符在字符串中的位置。</p>
<p>上面提到的,不同字符要求不等数量的内存, 所以为了决定哪个字符在一个特定的位置, 你必须从头到尾枚举每个 <code>Unicode </code>标量。 因为这个原因, <code>Swift </code>字符串不能通过整数值来索引。</p>
<p>使用 <code>startIndex</code> 属性访问字符串的首字符位置。 <code>endIndex</code> 属性是字符串中最后一个字符的位置。 因此, <code>endIndex</code> 属性不是一个字符串下标的有效参数。 如果一个字符串是空的,<code> startIndex </code>和 <code>endIndex</code> 相等。</p>
<p>你可以用 <code>index(before:) </code>和 <code>index(after:) </code>字符串方法访问给定索引前后的索引, 你可以使用 <code>index(_:offsetBy:) </code>方法代替多次调用这些方法。</p>
<p>你可以使用下标语法访问特定索引位置的字符。</p>
<pre><code>
let greeting = "Guten Tag!"
greeting[greeting.startIndex]
// G
greeting[greeting.index(before: greeting.endIndex)]
// !
greeting[greeting.index(after: greeting.startIndex)]
// u
let index = greeting.index(greeting.startIndex, offsetBy: 7)
greeting[index]
// a
</code></pre>

<p>尝试访问越界的索引和字符都会引发运行时的错误。</p>
<pre><code>
greeting[greeting.endIndex] // Error
greeting.index(after: greeting.endIndex) // Error
</code></pre>

<p>用字符属性中的索引属性获取字符串中的所有字符。</p>
<pre><code>
for index in greeting.characters.indices {
    print("\(greeting[index]) ", terminator: "")
}
// 打印 "G u t e n   T a g ! "
</code></pre>

<h1 id="插入和移除"><a href="#插入和移除" class="headerlink" title="插入和移除"></a>插入和移除</h1><p>在特定位置向字符串插入一个字符, 使用<code> insert(_:at:)</code> 方法, 插入其他字符串内容到制定索引使用 <code>insert(contentsOf:at:)</code> 方法。</p>
<pre><code>
var welcome = "hello"
welcome.insert("!", at: welcome.endIndex)
// welcome 等于 "hello!"
welcome.insert(contentsOf:" there".characters, at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 "hello there!"
</code></pre>

<p>从指定索引移除字符, 使用 <code>remove(at:)</code> 方法, 在指定范围移除一个字串, 用 <code>removeSubrange(_:)</code> 方法:</p>
<pre><code>
welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 "hello there"
let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endindex welcome.removesubrange(range)="" welcome="" 现在等于="" "hello"="" <="" code=""></welcome.endindex></code></pre>

<p>备注</p>
<p>你可以使用 <code>insert(<em>:at:), insert(contentsOf:at:), remove(at:), </em></code>和 <code>removeSubrange(:) </code>这些方法,只要符合 <code>RangeReplaceableCollection </code>协议的任何类型。 这包括 <code>String</code>, 还有集合类型 <code>Array</code>, <code>Dictionary</code>, 和 <code>Set</code>.</p>
<h1 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h1><p><code>Swift</code> 提供三种方式来比较文本值: 字符串和字符等式, 前缀等式, 和后缀等式。</p>
<h1 id="字符串和字符等式"><a href="#字符串和字符等式" class="headerlink" title="字符串和字符等式"></a>字符串和字符等式</h1><p>字符串和字符等式用<code>“equal to”</code> 运算符<code> (==) </code>和 <code>“not equal to” </code>运算符<code> (!=) </code>来判断, 在<code>比较运算符</code>中描述:</p>
<pre><code>
let quotation = "We're a lot alike, you and I."
let sameQuotation = "We're a lot alike, you and I."
if quotation == sameQuotation {
    print("These two strings are considered equal")
}
// 打印 "These two strings are considered equal"
</code></pre>

<p>两个字符串的值 (或者两个字符的值) 如果他们的扩展字形集相同,就被认为是相等的。 扩展字形集如果有相同的语义和表现形式，就是相等的, 即使他们背后是由不同 <code>Unicode</code> 标量组成。</p>
<p>比如, <code>LATIN SMALL LETTER E WITH ACUTE (U+00E9) </code>常规等于 <code>LATIN SMALL LETTER E (U+0065) </code>加上 <code>COMBINING ACUTE ACCENT (U+0301)</code>. 两种扩展字形集都是有效的方式来表示字符<code> é</code>, 隐藏它们被认为相等:</p>
<pre><code>
// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"
// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"
if eAcuteQuestion == combinedEAcuteQuestion {
    print("These two strings are considered equal")
}
// 打印 "These two strings are considered equal"
</code></pre>

<p>相反, <code>LATIN CAPITAL LETTER A</code> (<code>U+0041</code>, 或者 <code>“A”</code>), 英语中使用, 不等于俄语中使用的 <code>CYRILLIC CAPITAL LETTER A</code> (<code>U+0410</code>, 或者 <code>“А”</code>)。 这两个字符看上去相似, 但是语义不同:</p>
<pre><code>
let latinCapitalLetterA: Character = "\u{41}"
let cyrillicCapitalLetterA: Character = "\u{0410}"
if latinCapitalLetterA != cyrillicCapitalLetterA {
    print("These two characters are not equivalent.")
}
// 打印 "These two characters are not equivalent."
</code></pre>

<p>备注</p>
<p>字符串和字符比较在<code>Swift</code>中不是地区敏感的。</p>
<h1 id="前缀和后缀等式"><a href="#前缀和后缀等式" class="headerlink" title="前缀和后缀等式"></a>前缀和后缀等式</h1><p>判断字符串是否有一个特定前缀或者后缀, 调用字符串的 <code>hasPrefix(<em>:)</em></code> 和 <code>hasSuffix(:)</code> 方法, 两个方法都一个 <code>String</code> 类型，然后返回一个布尔值。 </p>
<p>下面这个例子有一个字符串数组，用来表示场景的位置,它们来自莎士比亚的罗密欧与朱丽叶的前两个表演:</p>
<pre><code>
let romeoAndJuliet = [
    "Act 1 Scene 1: Verona, A public place",
    "Act 1 Scene 2: Capulet's mansion",
    "Act 1 Scene 3: A room in Capulet's mansion",
    "Act 1 Scene 4: A street outside Capulet's mansion",
    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
    "Act 2 Scene 1: Outside Capulet's mansion",
    "Act 2 Scene 2: Capulet's orchard",
    "Act 2 Scene 3: Outside Friar Lawrence's cell",
    "Act 2 Scene 4: A street in Verona",
    "Act 2 Scene 5: Capulet's mansion",
    "Act 2 Scene 6: Friar Lawrence's cell"
]
</code></pre>

<p>你可以用 <code>hasPrefix(_:) </code>方法用 <code>romeoAndJuliet</code> 数组来技术表演1中的场景数:</p>
<pre><code>
var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix("Act 1 ") {
        act1SceneCount += 1
    }
}
print("There are \(act1SceneCount) scenes in Act 1")
// 打印 "There are 5 scenes in Act 1"
</code></pre>

<p>相似的, 用 <code>hasSuffix(_:)</code> 方法来计算发生在<code> Capulet’s mansion</code> 和 <code>Friar Lawrence’s cell</code> 的场景数:</p>
<pre><code>
var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix("Capulet's mansion") {
        mansionCount += 1
    } else if scene.hasSuffix("Friar Lawrence's cell") {
        cellCount += 1
    }
}
print("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
// 打印 "6 mansion scenes; 2 cell scenes"
</code></pre>

<h1 id="Unicode-字符串表示"><a href="#Unicode-字符串表示" class="headerlink" title="Unicode 字符串表示"></a>Unicode 字符串表示</h1><p>当一个 <code>Unicode</code> 字符串写入文本文件或者别的存储时,字符串里的 <code>Unicode</code> 标量会以一些<code>Unicode </code>定义的编码形式进行编码。 每种字符串编码在人们熟知的代码单元块中。 包括<code> UTF-8 </code>编码 (把字符串编码成一个 8-位的代码单元),<code> UTF-16 </code>编码 (把字符串编码成一个16-位的代码单元), 和 <code>UTF-32 </code>编码 (把字符串编码成 32-位代码单元)</p>
<p><code>Swift</code> 提供了几种不同的方式去访问字符串的<code>Unicode</code> 形式。你可以用<code>for-in</code>语句遍历字符串, 访问作为<code>Unicode </code>扩展字形集的单个字符值。这个过程在<code> 使用字符 </code>中描述。</p>
<p>或者, 或者用以下三种形式来访问字符串的值:</p>
<ul><br><li><code>UTF-8</code> 代码单元集合 (用字符串的utf8属性来访问)</li><br><li><code>UTF-16 </code>代码单元集合 (用字符串的utf16属性来访问)</li><br><li>21-位 <code>Unicode</code> 标量值的集合, 等于字符串的 <code>UTF-32</code> 编码方式 (用字符串的 <code>unicodeScalars</code> 属性访问)</li><br></ul>

<p>下面的例子展示字符串的不同表现形式,字符串由字符 <code>D, o, g, ‼ (DOUBLE EXCLAMATION MARK</code>, 或者 <code>Unicode scalar U+203C)</code>, 和<code> 🐶 </code>字符 (<code>DOG FACE</code>, 或者 <code>Unicode scalar U+1F436</code>)组成:</p>
<p><code>let dogString = “Dog‼🐶”</code></p>
<h1 id="UTF-8-形式"><a href="#UTF-8-形式" class="headerlink" title="UTF-8 形式"></a>UTF-8 形式</h1><p>你可以通过遍历字符串的<code>utf8</code>属性来访问它的<code> UTF-8 </code>表现形式。 这是属性是<code> String.UTF8View</code>, 这是无符号的 8-位 <code>(UInt8)</code>值的集合, 每个字节一个:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png"><br></div>

<pre><code>
for codeUnit in dogString.utf8 {
    print("\(codeUnit) ", terminator: "")
}
print("")
// 68 111 103 226 128 188 240 159 144 182
</code></pre>

<p>上面这个例子, 前三个十进制 <code>codeUnit</code> 值 (68, 111, 103) 代表字符 <code>D</code>,<code> o</code>, 和 <code>g</code>, 它们的<code> UTF-8 </code>形式和它们的<code> ASCII </code>表现形式一样。 接下来三个十进制 <code>codeUnit</code> 值 (226, 128, 188) 是双感叹号的三个字节的 <code>UTF-8</code> 形式。 最后四个 <code>codeUnit</code> 值 (240, 159, 144, 182) 是个四个字节的 <code>UTF-8 </code>形式，代表小狗的脸字符。</p>
<h1 id="UTF-16-形式"><a href="#UTF-16-形式" class="headerlink" title="UTF-16 形式"></a>UTF-16 形式</h1><p>你可以通过遍历字符串的<code>utf16</code>属性来访问它的 <code>UTF-16</code> 形式。 这个属性是 <code>String.UTF16View</code>, 它是无符号16-位 <code>(UInt16)</code>的值的集合, 每个16-位代码单元一个:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png"><br></div>

<pre><code>
for codeUnit in dogString.utf16 {
    print("\(codeUnit) ", terminator: "")
}
print("")
// 打印 "68 111 103 8252 55357 56374 "
</code></pre>

<p>同样, 前三个 <code>codeUnit</code> 值 (68, 111, 103) 代表字符 <code>D</code>, <code>o</code>, 和 <code>g</code>, 它们的 <code>UTF-16</code> 代码单元和它们的 <code>UTF-8</code> 形式一样(因为这些 <code>Unicode</code> 标量表示 <code>ASCII</code> 字符).</p>
<p>第四个 <code>codeUnit</code> 值 (8252) 是十六进制 203C的十进制数值, 用 <code>Unicode</code> 标量 <code>U+203C</code>表示双感叹号字符。 在<code> UTF-16</code> 里表示为一个单独的编码单元。</p>
<p>第五六个 <code>codeUnit</code> 值 (55357 和 56374) 狗脸字符。 这些值是高八位<code> U+D83D </code>(十进制值是 55357) 和一个第八位 <code>U+DC36</code> (十进制值 56374)。</p>
<h1 id="Unicode-标量形式"><a href="#Unicode-标量形式" class="headerlink" title="Unicode 标量形式"></a>Unicode 标量形式</h1><p>你可以通过遍历字符串的 <code>unicodeScalars</code> 属性来访问它的<code>Unicode</code> 标量形式。 这个是属性是 <code>UnicodeScalarView</code>,它是类型<code> UnicodeScalar</code> 值的集合。</p>
<p>每个<code> UnicodeScalar</code> 有一个值属性，它返回这个标量的 21-位值, 用一个 <code>UInt32 </code>值表示:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png"><br></div>

<pre><code>
for scalar in dogString.unicodeScalars {
    print("\(scalar.value) ", terminator: "")
}
print("")
// 打印 "68 111 103 8252 128054 "
</code></pre>

<p>前三个 <code>UnicodeScalar</code> 值 (68, 111, 103) 再次代表 <code>D</code>, <code>o</code>, 和 <code>g</code>.</p>
<p>第四个 <code>codeUnit</code> 值 (8252) 是十六进制 203C 的十进制值, 是双感叹的 <code>Unicod</code>e 标量 <code>U+203C</code> 。</p>
<p>第五个和最后一个 <code>UnicodeScalar</code> 值, 128054, 是十六进制 1F436的十进制值, 是狗脸字符的的<code> Unicode </code>标量<code> U+1F436</code>。</p>
<p>作为查询它们值属性的替代, 每个 <code>UnicodeScalar</code> 值也可以用来构建新的字符串, 例如用做字符串插值:</p>
<pre><code>
for scalar in dogString.unicodeScalars {
    print("\(scalar) ")
}
// D
// o
// g
// ‼
// 🐶
</code></pre>

<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p><code>Swift</code> 提供了三个主要的集合类型, 数组, 集合, 和字典, 用来存储值的集合。 数组是有序的。 集合是唯一值的无序集。 字典是健值匹配的无序集合。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png"><br></div>

<p>数组, 集合, 和字典在<code> Swift </code>里总是清楚的知道存储的值的类型和能够存储的健。 这就意味着你不能往集合里插入错误类型的值。也意味着 你知道可以从集合里或者的值的类型。</p>
<p>备注</p>
<p><code>Swift</code> 的数组, 集合, 和字典类型是用泛型集合实现的。更多泛型和集合, 参见<code>泛型</code>。</p>
<h1 id="集合的不稳定性"><a href="#集合的不稳定性" class="headerlink" title="集合的不稳定性"></a>集合的不稳定性</h1><p>如果你创建了一个数组, 一个集合, 或者一个字典, 然后赋给一个变量。创建的这个集合就是可变的。这就意味着你可以改变这个集合，方式是通过添加, 移除, 或者改变集合里的项。如果把它们赋给一个常量, 这个集合就是不可改变的, 它的大小和内容都不能改变。</p>
<p>备注</p>
<p>如果集合不需要变化，在所有情况下创建不可变的集合是个好的实践。这样做的好处是让你容易理解自己的代码,同时让编译器可以优化你创建的集合。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组有序存储同类型的值。 相同的值可以多次出现在数组的不同位置。</p>
<p>备注</p>
<p><code>Swift</code>的数组类型跟 <code>Foundation</code>的 <code>NSArray</code> 类相桥接。</p>
<h1 id="数组类型缩写语法"><a href="#数组类型缩写语法" class="headerlink" title="数组类型缩写语法"></a>数组类型缩写语法</h1><p>T数组类型的全写法是 <code>Array\<element\></element\></code>, 这里<code>Element</code>是数组运行存储的值类型。 你可以缩写数组类型为<code>[Element]</code>. 尽管这两种形式功能一样, 缩写是优先考虑的而且这个教程后面一直这么写。</p>
<h1 id="创建空数组"><a href="#创建空数组" class="headerlink" title="创建空数组"></a>创建空数组</h1><p>你可以用初始化语法创建一个特定类的空数组:</p>
<pre><code>
var someInts = [Int]()
print("someInts is of type [Int] with \(someInts.count) items.")
// 打印 "someInts is of type [Int] with 0 items."
</code></pre>

<p>注意 <code>someInts</code> 变量的类型经过初始化类型被推断为 <code>[Int]</code></p>
<p>或者, 如果上下文已经提供类型信息, 例如一个函数参数或者一个确定类型的变量或者常量, 你可以用空的字面量来创建空数组, 这个数组通常写作 <code>[] </code>(一个空的中括号对):</p>
<pre><code>
someInts.append(3)
// someInts now contains 1 value of type Int
someInts = []
// someInts is now an empty array, but is still of type [Int]
</code></pre>

<h1 id="用默认值创建数组"><a href="#用默认值创建数组" class="headerlink" title="用默认值创建数组"></a>用默认值创建数组</h1><p><code>Swift</code>的数组类型也提供了一构造器来创建相同默认值固定大小的数组。 给构造器传一个匹配类型的默认值 (调用 <code>repeating)</code>: 然后是在新数组中需要重复的值的个数 (调用 <code>count</code>):</p>
<pre><code>
var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles 是 [Double]类型, 等于 [0.0, 0.0, 0.0]
</code></pre>

<h1 id="通过合并数组创建数组"><a href="#通过合并数组创建数组" class="headerlink" title="通过合并数组创建数组"></a>通过合并数组创建数组</h1><p>你可以通过合并两个已存在的数组来创建新的数组,这两个数组只要类型匹配就可以通过加法运算符<code> (+)</code>来合并。 新数组的类型从合并的数组可以推断出来:</p>
<pre><code>
var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>

<h1 id="用字面量创建数组"><a href="#用字面量创建数组" class="headerlink" title="用字面量创建数组"></a>用字面量创建数组</h1><p>你也可以用字面量来初始化数组, 这是种快速写一个或者多个数组值的方式。 一个数组字面量写作一列值, 用逗号分开, 一对方括号包括起来:</p>
<pre><code>
[value 1, value 2, value 3]
</code></pre>
下面的的例子创建了一个购物列表来存储字符串值:
<pre><code>
var shoppingList: [String] = ["Eggs", "Milk"]
// shoppingList 初始有两项
</code></pre>

<p>购物列表变量定义为 “字符串值的数组”, 写作 <code>[String]</code>. 因为这个数组已经指定一个字符串类型值, 它就值运行存储字符串值。 这里, 购物列表数组用两个字符串值 (<code>“Eggs”</code> 和 <code>“Milk”</code>)来初始化, 写在数字字面量里。</p>
<p>备注</p>
<p>这个数组被声明为一个变量而不是一个常量，是因为在下面的例子将有更多的项目加入这个购物列表。</p>
<p>这种情况, 数组字面量只包含两个字符串值。 这个匹配购物列表变量的声明类型 (只能包括字符串值的数组), 用数组字面量赋值来初始化购物列表是被允许的一种方式。</p>
<p>由于 <code>Swift</code> 的类型推断, 如果你用相同类型的字面量来初始化数组,就不需要写出数组的类型。购物列表的初始化可以简写成以下形式:</p>
<pre><code>
var shoppingList = ["Eggs", "Milk"]
</code></pre>

<p>因为数组里所有的值都是同样的类型, <code>Swift </code>能够推断出 <code>[String] </code>用作购物列表变量是正确的类型。</p>
<h1 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h1><p>你可以通过数组的方法,属性或者下标语法来访问和修改一个数组。</p>
<p>为了确定数组的项数, 使用只读属性<code>count</code>:</p>
<pre><code>
print("The shopping list contains \(shoppingList.count) items.")
// 打印 "The shopping list contains 2 items."
</code></pre>

<p>使用布尔属性 <code>isEmpty</code> 来判断数量属性是否0:</p>
<pre><code>
if shoppingList.isEmpty {
    print("The shopping list is empty.")
} else {
    print("The shopping list is not empty.")
}
// 打印 "The shopping list is not empty."
</code></pre>

<p>通过调用 <code>append(_:)</code> 方法你可以在数组最后添加新项:</p>
<pre><code>
shoppingList.append("Flour")
// shoppingList 现在有3项
</code></pre>

<p>或者, 使用赋值运算 <code>(+=) </code>添加一个或多个符合的项:</p>
<pre><code>
shoppingList += ["Baking Powder"]
// shoppingList 现在有4项
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList 现在有7项
</code></pre>

<p>用下标语法从数组中获取一个值, 在数组后的方括号里传入你想得到值的索引:<br></p></count<></code><br>var firstItem = shoppingList[0]<br>// firstItem is equal to “Eggs”<br></b)></code><br>备注<p></p>
<p>数组第一项的索引是0,不是1。 <code>Swift</code> 数组总是基于0开始索引。</p>
<p>你可以使用下标语法去改变给定索引下的值:</p>
<pre><code>
shoppingList[0] = "Six eggs"
// 第一项现在是 "Six eggs" 而不是 "Eggs"
</code></pre>

<p>你还可以通过下标语法一次改变一个范围的值, 尽管取代值跟被取代的长度不同。 下面的例子用 <code>“Bananas”</code> 和 <code>“Apples”</code> 取代了 <code>“Chocolate Spread”</code>, <code>“Cheese”</code>, 和 <code>“Butter”</code>:</p>
<pre><code>
shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList 现在包含 6项
</code></pre>
备注

你不能用下标语法添加新的项到数组最后。
在特定位置插入新项, 调用数组插入方法 <code>insert(_:at:)</code>:

<pre><code>
shoppingList.insert("Maple Syrup", at: 0)
// shoppingList now contains 7 items
// "Maple Syrup" is now the first item in the list
</code></pre>

<p>调用 <code>insert(_:at:)</code> 方法在购物列表头插入一个新的项 <code>“Maple Syrup”</code>, 用索引0标明。</p>
<p>类似的, 移除一项使用 <code>remove(at:)</code> 方法。 这个方法移除指定索引的项然后返回这个移除项 (尽管你可能无视这个返回值):</p>
<pre><code>
let mapleSyrup = shoppingList.remove(at: 0)
// 位于索引0的项被移除
// 购物列表现在包含6项, 没有 Maple Syrup
// mapleSyrup 常量现在等于被移除的 "Maple Syrup" 字符串
</code></pre>

<p>备注</p>
<p>如果越界访问数组的值, 你会触发运行时错误。你可以用它跟数组个数属性对比来判断索引的有效性。除了个数为0的情况 (意味着数组是空的), 最大索引值通常是数组个数 - 1, 因为数组是从0开始计数的。</p>
<p>一个数据项被移除数组空隙就会闭合,所以索引 0 的值再次等于<code> “Six eggs”</code>:</p>
<pre><code>
firstItem = shoppingList[0]
// firstItem 现在等于 "Six eggs"
</code></pre>

<p>如果你想移除最后一项, 使用 <code>removeLast() </code>方法而不是 <code>remove(at:) </code>方法,这样就避免需要查询数组的个数属性。和 <code>remove(at:)</code> 方法一样, <code>removeLast()</code> 返回移除的项:</p>
<pre><code>
let apples = shoppingList.removeLast()
// 最后一项被移除
// 购物列表现在包含5项, 没有苹果
// apples 常量现在等于被移除的 "Apples" 字符串
</code></pre>

<h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><p>你可以用<code>for-in</code>循环来遍历数组中的所有值集:</p>
<pre><code>
for item in shoppingList {
    print(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
</code></pre>

<p>如果需要数据项的值和整数索引, 使用 <code>enumerated()</code> 方法来遍历数组。对于数组中的每一项, <code>enumerated() </code>方法返回一个包含索引和值的元组。 整数以0开始每项递增; 如果你遍历整个数组, 这些整数匹配数据项的索引。你可以分解元组到临时的常量或者变量,来作为迭代的部分:</p>
<pre><code>
for (index, value) in shoppingList.enumerated() {
    print("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
</code></pre>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合无序存储同样类型的不同值。 如果排序不重要可以选择使用集合代替数组, 或者你需要确保每项只出现一次。</p>
<p>备注</p>
<p><code>Swift</code> 的 <code>Set</code> 类型跟 <code>Foundation</code> 的 <code>NSSet</code> 类桥接。</p>
<h1 id="集合类型的哈希值"><a href="#集合类型的哈希值" class="headerlink" title="集合类型的哈希值"></a>集合类型的哈希值</h1><p>集合里一个类型为了存储就必须可哈希—就是说, 这个类型必须提供一个方式去计算自己的哈希值。 一个哈希值是一个整型值, 这对于相等的对象都是一样的, 如果 <code>if a == b</code>, 那么 <code>a.hashValue == b.hashValue</code>.</p>
<p>所有<code> Swift</code> 的基本类型默认都是可哈希的 (比如 <code>String</code>, <code>Int</code>, <code>Double</code>, 和 <code>Bool</code>), 可以被用作集合值类型或者字典建类型。 枚举分支值没有相应的值默认也是可哈希的。</p>
<p>备注</p>
<p>你可以使用自定义类型作为集合值类型或者字典健类型,通过让它们遵守<code>Swift</code> 标准库中的 <code>Hashable</code> 协议。 符合协议的类型必须提供一个可获取的整形属性 <code>hashValue</code>. 在相同程序中的不同执行,或者在不同程序中, 类型的哈希属性返回的值不要求相同。</p>
<p>因为 <code>Hashable</code> 协议符合 <code>Equatable</code>, 符合类型必须提等号运算符<code> (==)</code>的实现。 <code>Equatable</code> 协议要求任何符合<code>==</code>实现的都是一个相等关系。 就是说, <code>== </code> 的实现必须满足下面的条件, 对于 <code>a</code>,<code> b</code>, 和 <code>c</code> 所有值:</p>
<ul><br><li><code>a == a</code> (自反性)</li><br><li><code>a == b</code> 表示 b <code>== a</code> (对称性)</li><br><li><code>a == b &amp;&amp; b == c</code> 表示 <code>a == c</code> (传递性)</li><br></ul>

<h1 id="集合类型语法"><a href="#集合类型语法" class="headerlink" title="集合类型语法"></a>集合类型语法</h1><p>集合类型写作 <code>Set<element></element></code>, 这里 <code>Element</code> 是集合允许存储的类型。 跟数组不同, 集合没有等价的缩写形式。</p>
<h1 id="创建和初始化空集合"><a href="#创建和初始化空集合" class="headerlink" title="创建和初始化空集合"></a>创建和初始化空集合</h1><p>你可以通过使用构造器语法创建特定类型的空集合:</p>
<pre><code>
var letters = Set<character>()
print("letters is of type Set<character> with \(letters.count) items.")
// 打印 "letters is of type Set<character> with 0 items."
</character></character></character></code></pre>
备注

<code>letters</code> 变量的类型推断为 <code>Set<character></character></code>, 通过构造器的类型。

或者, 如果上下文已经提供了类型信息, 比如一个函数参数或者一个已经指定类型的变量和常量, 你可以用一个空的数组字面量来创建一个空集合:
<pre><code>
letters.insert("a")
// letters 现在包含了一个字符类型的值
letters = []
// letters 现在是一个空集合, 但是依然是 Set<character> 类型
</character></code></pre>

<h1 id="用数组字面量创建集合"><a href="#用数组字面量创建集合" class="headerlink" title="用数组字面量创建集合"></a>用数组字面量创建集合</h1><p>你可以用数组字面量初始化一个集合, 这是一个速写方式来给一个集合赋值。</p>
<p>下面的例子创建一个存储字符串值的集合 <code>favoriteGenres</code>:</p>
<pre><code>
var favoriteGenres: Set<string> = ["Rock", "Classical", "Hip hop"]
// favoriteGenres 有了三个初始值
</string></code></pre>

<p><code>favoriteGenres</code> 变量声明成 “字符串值的集合”, 写作 <code>Set<string></string></code>. 因为这个集合指定了一个字符串的值类型, 它只允许存储字符串值, <code>favoriteGenres</code> 集合用三个字符串 (<code>“Rock”</code>, <code>“Classical”</code>, 和 <code>“Hip hop”</code>)来初始化, 写在一个数组字面量里。</p>
<p>备注</p>
<p><code>favoriteGenres</code> 集合声明成一个变量而不是一个常量, 这是因为添加和移除的项在下面的示例里。</p>
<p>集合通过数组字面量不能推断出类型, 所以类型必须显示声明。 不过, 由于Swift的类型推断, 如果数组字面量包含的值类型相同,你就不需要写集合的类型。<code>favoriteGenres</code> 初始化可以简写如下:</p>
<pre><code>
var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
</code></pre>

<p>因为数组字面量里的值都是同样类型, <code>Swift</code> 可以推断 <code>Set<string></string></code> 用作<code>favoriteGenres</code> 变量是正确的类型。</p>
<h1 id="访问和修改集合"><a href="#访问和修改集合" class="headerlink" title="访问和修改集合"></a>访问和修改集合</h1><p>你可以通过集合的方法和属性来访问和修改它。</p>
<p>为了得到集合的项数, 使用只读的 <code>count</code> 属性:</p>
<pre><code>
print("I have \(favoriteGenres.count) favorite music genres.")
// 打印 "I have 3 favorite music genres."
</code></pre>

<p>使用布尔属性 <code>isEmpty</code> 快速判断 <code>count</code> 属性是否等于 0:</p>
<pre><code>
if favoriteGenres.isEmpty {
    print("As far as music goes, I'm not picky.")
} else {
    print("I have particular music preferences.")
}
// 打印 "I have particular music preferences."
</code></pre>

<p>调用集合的 <code>insert(_:)</code> 方法插入一个新项:</p>
<pre><code>
favoriteGenres.insert("Jazz")
// favoriteGenres 现在包含 4 项
</code></pre>

<p>你可以用集合的 <code>remove(_:)</code> 方法从集合里移除项, 如果它是集合一员的话, 然后返回被移除的项, 如果集合不包含这项就返回<code>nil</code>。 或者, 移除所有项可以用 <code>removeAll()</code> 方法。</p>
<pre><code>
if let removedGenre = favoriteGenres.remove("Rock") {
    print("\(removedGenre)? I'm over it.")
} else {
    print("I never much cared for that.")
}
// 打印 "Rock? I'm over it."
</code></pre>

<p>检查集合是否包含特定项, 用 contains(_:) 方法。</p>
<pre><code>
if favoriteGenres.contains("Funk") {
    print("I get up on the good foot.")
} else {
    print("It's too funky in here.")
}
// 打印 "It's too funky in here."
</code></pre>

<h1 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h1><p>你可以用<code>for-in</code>循环遍历集合的值。</p>
<pre><code>
for genre in favoriteGenres {
    print("\(genre)")
}
// Jazz
// Hip hop
// Classical
</code></pre>

<p><code>Swift</code> 的集合类型是无序的。以特定顺序去遍历集合的值, 使用 <code>sorted()</code> 方法, 这个方法返回一个值数组,按照小于运算符排序。</p>
<pre><code>
for genre in favoriteGenres.sorted() {
    print("\(genre)")
}
// Classical
// Hip hop
// Jazz
</code></pre>

<h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><p>你可以有效进行基础的集合操作, 比如合并两个集合, 判断两个集合是否有共同值, 或者判读两个集合是否包含所有几个或者没有任何相同值。</p>
<h1 id="基本集合操作"><a href="#基本集合操作" class="headerlink" title="基本集合操作"></a>基本集合操作</h1><p>下面的图描述了两个集合<code>a</code> 和 <code>b</code>, 共享区域表示集合操作结果。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png"><br></div><br><ul><br><li>用 <code>intersection(<em>:) </em></code>方法创建交集。</li><br><li>用 <code>symmetricDifference(:)</code> 方法创建交集之外的集合。</li><br><li>用 <code>union(<em>:) </em></code>方法创建并集。</li><br><li>用 <code>subtracting(:) </code>方法创建去掉指定集合的集合。</li><br></ul><br><br><pre><code><br>let oddDigits: Set = [1, 3, 5, 7, 9]<br>let evenDigits: Set = [0, 2, 4, 6, 8]<br>let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]<br>oddDigits.union(evenDigits).sorted()<br>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>oddDigits.intersection(evenDigits).sorted()<br>// []<br>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()<br>// [1, 9]<br>oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()<br>// [1, 2, 9]<br></code></pre><br><br># 集合和等式<br><br>下面的图描述了三个集合 <code>a</code>, <code>b</code> 和 <code>c</code>, 重叠区域表示集合共享的元素。 集合<code>a</code>是集合<code>b</code>的超集, 因为<code>a</code>包含<code>b</code>的所有元素。 相反, 集合<code>b</code>是集合<code>a</code>的子集, 因为<code>b</code>中的元素都包含在集合<code>a</code>中。 集合<code>b</code>与集合<code>c</code>不相交, 因为它们没有共同的元素。<br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png"><br></div>

<ul><br><li>用相等运算符 <code>(==) </code>判断两个集合是否所有值都相同。</li><br><li>用 <code>isSubset(of:) </code>方法判断一个集合是否是另外一个集合的字集。</li><br><li>用 <code>isSuperset(of:) </code>方法判断一个集合是否是另外一个集合的超集。</li><br><li>用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code> 方法判断一个集合是否是一个子集或者超集, 但是不等于一个指定的集合。</li><br><li>用 <code>isDisjoint(with:)</code> 方法判断是否两个集合不相交。</li><br></ul>

<pre><code>
let houseAnimals: Set = ["🐶", "🐱"]
let farmAnimals: Set = ["🐮", "🐔", "🐑", "🐶", "🐱"]
let cityAnimals: Set = ["🐦", "🐭"]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典无序存储匹配的同类型的健值。每个值对应一个唯一的健, 它作为值在字典里的标识符。 跟数组项不同, 字典里的项是无序的。如果基于标识符查找值你可以用字典, 很像真实世界字典的用法。</p>
<h1 id="字典类型速记语法"><a href="#字典类型速记语法" class="headerlink" title="字典类型速记语法"></a>字典类型速记语法</h1><p><code>Swift</code> 字典类型完整写法是 <code>Dictionary<key, value=""></key,></code>, <code>Key</code> 是可以用作字典值的值类型, <code>Value</code> 是字典为健存储的值类型。</p>
<p>备注</p>
<p>字典 <code>Key</code> 类型一定要符合 <code>Hashable</code> 协议, 跟集合值类型一样。</p>
<p>你也可以字典类型的简写形式 <code>[Key: Value]</code>. 尽管两个形式功能一样, 简写形式优先使用并贯穿整个教程。</p>
<h1 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h1><p>跟数组一样, 你可用用初始化语法创建一个特定类型的字典:</p>
<pre><code>
var namesOfIntegers = [Int: String]()
// namesOfIntegers is an empty [Int: String] dictionary
</code></pre>

<p>这个例子定义了一个空字典,类型是<code> [Int: String]</code>,用来存储人类可读的整数名字。健是整形, 值是字符串类型。</p>
<p>如果上下文已经提供了类型信息, 你可以用一个空的字典字面量来创建一个空字典, 写作<code> [:] </code>(一对中括号中间一个冒号):</p>
<pre><code>
namesOfIntegers[16] = "sixteen"
// namesOfIntegers 现在包含 1 key-value pair
namesOfIntegers = [:]
// namesOfIntegers 再次成为空,类型是[Int: String]
</code></pre>

<h1 id="用字面量创建字典"><a href="#用字面量创建字典" class="headerlink" title="用字面量创建字典"></a>用字面量创建字典</h1><p>你还可以用字面量来初始化一个字典, 跟早前数组字面量语法相似。字典字面量是定义一个或者多个键值对集合的速写方法。</p>
<p>键值对是健和值的组合。 在一个字典字面量里, 健和值在键值对里用冒号分开。 键值对写作一个列表, 用逗号分开, 包含在一对中括号里:</p>
<pre><code>
[key 1: value 1, key 2: value 2, key 3: value 3]
</code></pre>

<p>下面的例子创建一个字典来存储国际机场名字。在这个字典里, 健是三个字母的国际航空公司编码, 值是机场名:</p>
<pre><code>
var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
</code></pre>

<p><code>airports</code> 字典类型是 <code>[String: String]</code>, 意思是 “一个字典健值都是字符串类型”.</p>
<p>备注</p>
<p><code>airports </code>字典声明成一个变量而非常量, 因为下面的例子需要添加更多机场进去。</p>
<p><code>airports</code> 用两个键值对字面量初始化。第一个键值对有一个健 <code>“YYZ”</code> 和一个值 <code>“Toronto Pearson”</code>. 第二个键值对有一个健 <code>“DUB”</code> 和一个值<code>“Dublin”</code>.</p>
<p>字面量包含两个 <code>String: String</code> 对。 简直类型匹配机场类型的变量声明 (一个字典只有字符串健和字符串值), 所以字面量赋值是允许的,可以用来初始化机场字典。</p>
<p>跟数组一样, 如果你用相同类型的键值字典初始化，你就不需要写出字典的声明类型。初始化方法可以简写如下:</p>
<pre><code>
var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
</code></pre>

<p>因为字面量的所有健类型都是一样的, 同样所有的值也是, <code>Swift</code> 可以推断出来 <code>[String: String]</code> 是正确的类型声明。</p>
<h1 id="访问和修改字典"><a href="#访问和修改字典" class="headerlink" title="访问和修改字典"></a>访问和修改字典</h1><p>你可以通过字典的方法和属性来访问和修改它, 或者使用下标语法。</p>
<p>跟数组一样, 使用<code>count</code> 属性获取字典的项数:</p>
<pre><code>
print("The airports dictionary contains \(airports.count) items.")
// 打印 "The airports dictionary contains 2 items."
</code></pre>
用 isEmpty 属性判断count 属性是否等于 0:
<pre><code>
if airports.isEmpty {
    print("The airports dictionary is empty.")
} else {
    print("The airports dictionary is not empty.")
}
// 打印 "The airports dictionary is not empty."
</code></pre>

<p>你可以用下标语法往字典添加新项。 使用对应的类型的键作为下标索引, 并赋一个对应的新值:</p>
<pre><code>
airports["LHR"] = "London"
// airports 现在包含 3 项
</code></pre>
你可以用下标语法改变指定键对应的值:
<pre><code>
airports["LHR"] = "London Heathrow"
// "LHR" 的值已经变成"London Heathrow"
</code></pre>

<p>作为下标的替代方案, 用字典的 <code>updateValue(<em>:forKey:)</em></code> 方法设置或者更新指定键的值。 跟上面下标实例一样,  <code>updateValue(:forKey:)</code> 方法在键不存在时设置值, 如果键存在则进行更新。和下标不像的是, <code>updateValue(_:forKey:)</code> 方法在执行更新后返回老的值。 这个可以让你知道更新是否生效。</p>
<p><code>updateValue(_:forKey:)</code> 方法返回可选类型的值。对个存储字符串值的字典来说, 比如, 这个方法返回 <code>String?</code>, 或者 <code>“可选的 String”</code>. 可选值包括未更新前存在的键对应的老值, 如果值不存在则包括<code>nil</code>:</p>
<pre><code>
if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") {
    print("The old value for DUB was \(oldValue).")
}
// 打印 "The old value for DUB was Dublin."
</code></pre>

<p>你可以用下标语法获取特定键对应的值。因为有可能去请求不存在值的键, 字典的下标就会返回一个可选值。 如果字典包含请求键对应的值, 下标就返回一个可选值，这个值包含这个键对应的存在的值。否则返回 <code>nil</code>:</p>
<pre><code>
if let airportName = airports["DUB"] {
    print("The name of the airport is \(airportName).")
} else {
    print("That airport is not in the airports dictionary.")
}
// 打印 "The name of the airport is Dublin Airport."
</code></pre>

<p>你可以通过把键对应的值赋空的方式,用下标语法从字典移除一个键值对:</p>
<pre><code>
airports["APL"] = "Apple International"
// "Apple International" is not the real airport for APL, so delete it
airports["APL"] = nil
// APL 现在已经从字典移除
</code></pre>

<p>或者, 用 <code>removeValue(forKey:)</code> 这个方法来移除。 这个方法移除的键值对如果存在返回被移除的值,否则返回<code>nil</code>:</p>
<pre><code>
if let removedValue = airports.removeValue(forKey: "DUB") {
    print("The removed airport's name is \(removedValue).")
} else {
    print("The airports dictionary does not contain a value for DUB.")
}
// 打印 "The removed airport's name is Dublin Airport."
</code></pre>

<h1 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h1><p>你用<code>for-in</code> 循环来遍历字典。 字典中的每一项都以 <code>(key, value) </code>元组形式返回, 你可以分解元组到临时的变量或者常量:</p>
<pre><code>
for (airportCode, airportName) in airports {
    print("\(airportCode): \(airportName)")
}
// YYZ: Toronto Pearson
// LHR: London Heathrow
</code></pre>

<p>你可以通过访问字典的键值属性来获取键值的集合:</p>
<pre><code>
for airportCode in airports.keys {
    print("Airport code: \(airportCode)")
}
// Airport code: YYZ
// Airport code: LHR
for airportName in airports.values {
    print("Airport name: \(airportName)")
}
// Airport name: Toronto Pearson
// Airport name: London Heathrow
</code></pre>

<p>如果你想使用字典的键值的数组实例, 用键值来初始化一个新的数组:</p>
<pre><code>
let airportCodes = [String](airports.keys)
// airportCodes is ["YYZ", "LHR"]

let airportNames = [String](airports.values)
// airportNames 是 ["Toronto Pearson", "London Heathrow"]
</code></pre>

<p><code>Swift</code>的字典类型无序的。 为了用特定顺序去遍历字典的键值, 用这个 <code>sorted()</code> 方法。</p>
<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><p><code>Swift</code> 提供了一系列控制流语句。 包括 <code>while</code> 循环来执行多次任务; <code>if</code>, <code>guard</code>, <code>switch</code> 语句来在不同条件执行不同代码; 还有 <code>break</code> 和 <code>continue</code> 来转移控制流。</p>
<p><code>Swift</code> 同时提供了 <code>for-in</code> 循环使得遍历数组, 字典, 范围, 字符串, 和其他序列变得容易。</p>
<p><code>Swift</code>的 <code>switch</code> 语句比多数类<code>C</code>语言相同语句更加高效有力。 因为<code>Swift</code> 的 <code>switch</code> 语句的分支不会落到下一分支, 这就避免了<code>C</code>常见的错误。 分支可以匹配不同的模式, 包括区间匹配, 元组, 转换成指定类型。 <code>switch</code> 分支匹配的值可以绑定到临时的变量或者常量。每个分支可以用<code>where</code> 族来表达符合匹配条件。</p>
<h1 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h1><p>你使用 <code>for-in</code> 循环来遍历序列, 比如数值范围, 数组中的项, 字符串中的字符。</p>
<p>下面的例子是五倍乘法表的前几个条目:</p>
<pre><code>
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
</code></pre>

<p>遍历的序列是1 到 5的数值范围, 包括1和5,使用闭合区间运算符 <code>(…)</code>提到过。索引值设置给 <code>range (1)</code>的第一个数, 然后循环体中的语句就会执行。 这种情况, 循环体只有一个语句, 打印当前索引值5的倍数。 这个语句执行后, 索引值更新为包含在 <code>range (2)</code> 中的第二个值, <code>print(_:separator:terminator:) </code>函数再次调用。 这个过程直到区间结束。</p>
<p>上面的例子, 索引值是常量而且自动设置。 像这样, 索引在使用前不必声明。 在循环声明中隐式声明, 不需要<code>let</code>关键字。</p>
<p>如果你不需要序列中的所有值, 可以在变量名位置处使用下划线来忽略这个值。</p>
<pre><code>
let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
print("\(base) to the power of \(power) is \(answer)")
// 打印 "3 to the power of 10 is 59049"
</code></pre>

<p>上面的例子计算一个数的幂(这个例子里, 3 的10次幂)。 它乘以一个初始值 1 (就是 3 的0次幂), 十次, 使用一个闭合区间,1开始10结束。下划线用在这里,使得单个值被忽略同时不会在遍历过程中访问当前值。</p>
<p>使用 <code>for-in</code> 循环来遍历数组的项。</p>
<pre><code>
let names = ["Anna", "Alex", "Brian", "Jack"]
for name in names {
    print("Hello, \(name)!")
}
// Hello, Anna!
// Hello, Alex!
// Hello, Brian!
// Hello, Jack!
</code></pre>

<p>你还可以遍历一个字典来遍历它的键值对。 字典遍历时每次返回一个 <code>(key, value)</code> 元组, 你可以在<code>for-in</code>循环中显示分解元组的值给常量赋值。这里, 字典的键分解给<code>animalName</code> 常量, 字典的值分配给了 <code>legCount</code> 常量。</p>
<pre><code>
let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
for (animalName, legCount) in numberOfLegs {
    print("\(animalName)s have \(legCount) legs")
}
// ants have 6 legs
// spiders have 8 legs
// cats have 4 legs
</code></pre>

<p>字典项遍历的顺序不需要和插入顺序一致。 字典内容是无序的, 遍历时不能保证获取的顺序。</p>
<h1 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h1><p><code>while</code> 循环执行一组语句,直到条件失败。 首次遍历前,遍历次数不知道的时候使用这种方式是最好的。<code>Swift</code> 提供两种 <code>while </code>循环:</p>
<ul><br><li><code>while</code> 每次循环前评估条件。</li><br><li><code>repeat-while</code> 每次循环后评估条件。</li><br></ul>

<h1 id="While"><a href="#While" class="headerlink" title="While"></a>While</h1><p><code>while</code> 循环从评估条件开始。 如果条件是真的, 一组语句会重复执行直到条件变成假的。</p>
<p>这是while 循环的基本形式:</p>
<pre><code>
while condition {
    statements
}
</code></pre>

<p>这个例子是个蛇与梯子的游戏:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png"><br></div>

<p>游戏规则如下:</p>
<ul><br><li>棋盘有25个方格, 目标是占据或者超过25。</li><br><li>每次, 摇一个6边的骰子然后移动对应数目方格, 沿着上图的点箭头的水平路径移动。</li><br><li>如果位于梯子底部, 往梯子上方移动。</li><br><li>如果位于蛇头, 往蛇下方移动。</li><br><li>游戏棋盘用整形值数组表示。大小基于 finalSquare 常量, 用来初始化数组并且判断取胜的条件。 棋盘用26个0值初始化, 而不是25 (每个索引从0到25)。</li><br></ul>

<pre><code>
let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
</code></pre>

<p>一些方格会为蛇和梯子设置更多的指定值。梯子方格是正数,蛇方格是负数。</p>
<pre><code>
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
</code></pre>

<p>方格 3 包含了梯子的底部,可以爬到方格11。 为了表示这个, <code>board[03]</code> 等于 +08, 这等于整数值8 (3和11的差值) 加号 <code>(+i) </code>和减号 <code>(-i)</code>相等, 数值低于10的用0填充,这样所以棋盘都被定义了。 </p>
<p>玩家开始方格是 <code>“方格0”</code>, 靠着棋盘的左下角。 第一次摇骰子总是让玩家进入棋盘。</p>
<pre><code>
var square = 0
var diceRoll = 0
while square < finalSquare {
    // roll the dice
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    // move by the rolled amount
    square += diceRoll
    if square < board.count {
        // if we're still on the board, move up or down for a snake or a ladder
        square += board[square]
    }
}
print("Game over!")
</code></pre>

<p>上面的例子用了一个很简单方法去摇骰子。 不用随机数, 用一初始值为0的 <code>diceRoll</code>。 每次循环, <code>diceRoll </code>加一然后判断它是否过大。 当返回值等于7, 骰子值过大然后重置为1。<code>diceRoll</code> 值总是 1, 2, 3, 4, 5, 6, 1, 2 然后不停循环。</p>
<p>摇完筛子, 往前移动 <code>diceRoll</code> 方格。 如果移动超过25, 游戏结束。考虑边界安全，在操作方格的时候。</p>
<p>备注</p>
<p>没有这个判断, <code>board[square] </code>可能会越界访问棋盘数组的值, 这会触发一个错误。 如果方格等于 26, 代码会判断board[26] 的值, 这会超过数组的大小。</p>
<p>当前<code>while</code> 循环执行然后结束, 然后循环的条件会被判断是否再次执行。如果玩家已经移动或者超过25, 循环的条件变成假然后游戏就结束。</p>
<p><code>while</code> 循环适合这个例子, 因为开始循环的时候游戏的长度并不清楚。 相反, 一个特定条件满足后循环被执行了。</p>
<h1 id="Repeat-While"><a href="#Repeat-While" class="headerlink" title="Repeat-While"></a>Repeat-While</h1><p>另外一种<code>while</code>循环的变种, 就是 <code>repeat-while</code> 循环, 先执行一次循环, 然后再考虑循环的条件。 然后继续执行直到条件变成假。</p>
<p>备注</p>
<p><code>Swift</code> 里的 <code>repeat-while</code> 循环类似其他语言里的 <code>do-while</code> 循环。</p>
<p>这里是 <code>repeat-while</code> 循环的基本样式:</p>
<pre><code>
repeat {
    statements
} while condition
</code></pre>

<p>这里还是蛇与梯子的例子, 用 <code>repeat-while </code>循环来写而不是 <code>while </code>循环。 <code>finalSquare</code>, <code>board</code>, <code>square</code>, 和 <code>diceRoll</code>的值初始化方式跟<code>while</code>循环一样。</p>
<pre><code>
let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
</code></pre>

<p>这个游戏版本, 第一步是判断梯子和蛇。 没有梯子带着玩家直接去方格<code>25</code>, 因为不太可能通过爬梯子去赢得游戏。因此, 判断有没有蛇和梯子是很安全的。</p>
<p>游戏开始, 玩家在 <code>“square zero”</code>. <code>board[0] </code>总是等于0没有影响。</p>
<pre><code>
repeat {
    // move up or down for a snake or ladder
    square += board[square]
    // roll the dice
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    // move by the rolled amount
    square += diceRoll
} while square < finalSquare
print("Game over!")
</code></pre>

<p>蛇与梯子判断后, 摇动筛子玩家往前移动 <code>diceRoll</code> 方格。 当前循环执行然后结束。</p>
<p>循环条件 <code>(while square &lt; finalSquare)</code> 和以前一样, 不过这次开始不评估,直到第一次循环结束才评估。<code>repeat-while</code> 循环比<code> while loop</code> 循环更适合这个游戏。上面的 <code>repeat-while</code> 循环, 当条件确认方格还在棋盘上后, <code>square += board[square] </code>总是立即执行。 这就不需要像之前那样判断数组边界。</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>基于特定条件执行不同代码片段经常用到。 在碰到错误时你可能想运行额外的代码片段, 或者在数值变得太高或者太低的时候也是。为了做这件事, 你让部分代码带有条件性。</p>
<p><code>Swift</code> 提供两种方式给你的代码添加条件分支: <code>if</code> 语句和 <code>switch</code> 语句。你用 <code>if</code> 语句评估条件会有一些可能的结果。 <code>switch</code> 语句在比较复杂的多个排列时很有用, 在模式匹配可以帮助选择合适代码分支执行的情况也是。</p>
<h1 id="If"><a href="#If" class="headerlink" title="If"></a>If</h1><p>最简单的形式,<code> if </code>语句有一个单一条件。 条件为真执行一个语句集合。</p>
<pre><code>
var temperatureInFahrenheit = 30
if temperatureInFahrenheit <= 32="" {="" print("it's="" very="" cold.="" consider="" wearing="" a="" scarf.")="" }="" 打印="" "it's="" scarf."="" <="" code=""></=></code></pre>

<p>上面的例子判断文档是否小于等于华氏32度 (冰点)。 如果是, 打印一条信息。 否则, 不打印消息, 代码在大括号后继续执行。</p>
<p><code>if</code> 语句还可以提供一个替代语句集合, 就是<code> else </code>字句, 针对条件是假的情况。 这些语句用<code>else </code>关键字表示。</p>
<pre><code>
temperatureInFahrenheit = 40
if temperatureInFahrenheit <= 32="" {="" print("it's="" very="" cold.="" consider="" wearing="" a="" scarf.")="" }="" else="" not="" that="" wear="" t-shirt.")="" 打印="" "it's="" t-shirt."="" <="" code=""></=></code></pre>

<p>两个分支之一总会执行。 因为温度已经增长到华氏40度, 这不够冷到戴围巾,因此<code>else</code>分支被触发了。</p>
<p>你可以链接多个<code>if</code>语句来考虑额外的语句。</p>
<pre><code>
temperatureInFahrenheit = 90
if temperatureInFahrenheit <= 32="" {="" print("it's="" very="" cold.="" consider="" wearing="" a="" scarf.")="" }="" else="" if="" temperatureinfahrenheit="">= 86 {
    print("It's really warm. Don't forget to wear sunscreen.")
} else {
    print("It's not that cold. Wear a t-shirt.")
}
// 打印 "It's really warm. Don't forget to wear sunscreen."
</=></code></pre>

<p>在这个库, 额外的<code>if</code>语句用来响应特别温暖的温度。 最后的<code>else</code>语句保留, 它响应既不太热也不太冷的情况。</p>
<p>最后的<code>else</code>语句是可选的, 不过, 如果不需要执行可以去掉。</p>
<pre><code>
temperatureInFahrenheit = 72
if temperatureInFahrenheit <= 32="" {="" print("it's="" very="" cold.="" consider="" wearing="" a="" scarf.")="" }="" else="" if="" temperatureinfahrenheit="">= 86 {
    print("It's really warm. Don't forget to wear sunscreen.")
}
</=></code></pre>

<p>因为这个温度既不太冷也不太热,所以不会触发<code>if</code>或者<code>else</code>语句,没有打印信息。</p>
<h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><p><code>switch</code> 语句设想一个值,然后跟一些可能的匹配模式比较。然后执行合适的代码, 基于第一次匹配成功。<code>switch </code>语句提供了if语句的替代方法来响应多种潜在状态的情况。</p>
<p>最简单的形式, 一个 <code>switch</code> 语句用一个值跟一个或者多个同类型的值相比较。</p>
<pre><code>
switch some value to consider {
case value 1:
    respond to value 1
case value 2,
     value 3:
    respond to value 2 or 3
default:
    otherwise, do something else
}
</code></pre>

<p>每个 <code>switch</code> 语句由多个分支组成, 每个分支以<code>case</code> 关键字开始。 除了跟指定值比较外, <code>Swift</code> 为分支提供了指定更复杂匹配模式的方法。这些选项本章后面会描述。</p>
<p>跟<code>if</code>语句体很像, 每个分支是代码执行的单独分支。<code> switch </code>语句决定是否选择这个分支。这个过程叫分发。</p>
<p>每个<code>switch</code> 语句务必是详尽的。 就是说, 每个能想到的类型值都要分支匹配。 为每个可能值都提供分支是不合适的。你可以定义一个默认分支覆盖没有显示处理的值。 默认分支使用<code>default</code>关键字指明, 必须总是出现在最后。</p>
<p>这个例子使用一个 switch 语句来出处理一个小写字母someCharacter:</p>
<pre><code>
let someCharacter: Character = "z"
switch someCharacter {
case "a":
    print("The first letter of the alphabet")
case "z":
    print("The last letter of the alphabet")
default:
    print("Some other character")
}
// 打印 "The last letter of the alphabet"
</code></pre>

<p><code>switch</code> 语句第一个分支匹配英文字母表第一个字母 <code>a</code>, 第二个分支匹配最后一个字母 <code>z</code>. 因为 <code>switch</code> 语句对于每个可能的字符都要有分支, 不是每个字母表字符都需要。这个<code>switch</code> 语句使用了一个<code>default 分支</code> 去处理<code>a</code> 和 <code>z</code>之外的其他所有字母。这保证了<code>switch</code>语句的详细性。</p>
<h1 id="非隐式-Fallthrough"><a href="#非隐式-Fallthrough" class="headerlink" title="非隐式 Fallthrough"></a>非隐式 Fallthrough</h1><p>和<code>C</code> 与 <code>Objective-C</code> 的<code>switch</code>语句对比, <code>Swift</code> 中的<code>switch</code>语句不会 <code>fall through 分支</code>底部并且跳到下一个分支。 相反, 在第一次匹配到分支后整个<code>switch</code>语句执行就完成了。不要求显示的<code>break</code>语句。 这使得<code>switch</code>语句更安全,更容易使用,而且避免执行多个分支的错误。</p>
<p>备注</p>
<p>尽管<code>Swift</code> 不要求<code>break</code>, 你仍然可以在<code>Swift</code>中使用。 </p>
<p>分支体必须包含至少一句可执行语句。下面的代码的无效的, 因为第一个分支是空的:</p>
<pre><code>
let anotherCharacter: Character = "a"
switch anotherCharacter {
case "a": // Invalid, the case has an empty body
case "A":
    print("The letter A")
default:
    print("Not the letter A")
}
// 这会报一个编译期错误
</code></pre>

<p>跟<code>C</code>中的<code>switch</code>语句不同, 这个 <code>switch</code> 语句不能同时匹配 <code>“a”</code> 和 <code>“A”</code>. 相反, 它会报一个编译期错误,因为<code>case “a”</code>: 没有任何可以执行的语句。这个方法避免了突然从一个分支跳入另外一个分支, 让代码意图清晰安全。</p>
<p>如果要用一个分支同时匹配<code>“a”</code> 和 <code>“A”</code>, 把这两个值合并到一个分支语句, 用逗号把它们分开。</p>
<pre><code>
let anotherCharacter: Character = "a"
switch anotherCharacter {
case "a", "A":
    print("The letter A")
default:
    print("Not the letter A")
}
// 打印 "The letter A"
</code></pre>

<p>为了可读性, 复合分支也可以写作多行。 </p>
<p>备注</p>
<p>为了显式<code>fall through </code>到某个分支下面, 使用 <code>fallthrough</code> 关键字。</p>
<h1 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h1><p><code>switch 分支</code>里面的值可以包含在区间里判断。 这个例子使用数字区间来提供一个对任何数字大小的自然语言统计。</p>
<pre><code>
let approximateCount = 62
let countedThings = "moons orbiting Saturn"
var naturalCount: String
switch approximateCount {
case 0:
    naturalCount = "no"
case 1..<5: naturalcount="a few" case="" 5..<12:="" 12..<100:="" 100..<1000:="" default:="" }="" print("there="" are="" \(naturalcount)="" \(countedthings).")="" 打印="" "there="" dozens="" of="" moons="" orbiting="" saturn."="" <="" code=""></5:></code></pre>

<p>上面的例子, <code>approximateCount</code> 在<code>switch</code>语句里估算。 每个分支把这个值跟一个数字或者区间进行比较。因为 <code>approximateCount</code> 值落在 12 和 100之间, <code>naturalCount</code> 被赋值为 <code>“dozens of”</code>, 然后代码执行跳出<code>switch</code>语句继续执行。</p>
<h1 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h1><p>你可以在<code>switch</code>语句中使用元组测试多值。元组元素可以跟一个不同值或者值区间进行测试。或者, 使用通配下划线 <code>(_) </code>去匹配可能的值。</p>
<p>下面的例子有一个<code> (x, y) </code>点, 用一个简单的元组类型 <code>(Int, Int)</code> 表示, 并且在下面的图表中标示。</p>
<pre><code>
let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print("(0, 0) is at the origin")
case (_, 0):
    print("(\(somePoint.0), 0) is on the x-axis")
case (0, _):
    print("(0, \(somePoint.1)) is on the y-axis")
case (-2...2, -2...2):
    print("(\(somePoint.0), \(somePoint.1)) is inside the box")
default:
    print("(\(somePoint.0), \(somePoint.1)) is outside of the box")
}
// 打印 "(1, 1) is inside the box"
</code></pre>

<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png"><br></div>

<p><code>switch</code> 语句决定这个点是否位于原点 <code>(0, 0)</code>, 红色的 x-轴, 橙色 y-轴, 在蓝色 <code>4-by-4 </code>方块里原点在中心, 或者在方块之外。</p>
<p>跟 <code>C</code> 不同, <code>Swift</code> 允许多个分支去处理相同的值。 事实上, <code>(0, 0)</code>点可以满足例子的四个分支。不过, 如果多个匹配都可能, 第一个匹配上的总是执行。 <code>(0, 0)</code> 点首先匹配<code>case (0, 0)</code>, 其他所有匹配的分支都会被忽略。</p>
<h1 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h1><p>一个 <code>switch 分支</code> 可以绑定值到临时的常量或者变量, 用在分支体中。这个就是值绑定, 因为值绑定到分支体中的临时常量或者变量上。</p>
<p>下面这个例子有一个<code>(x, y)</code> 点, 是元组类型 <code>(Int, Int)</code>, 在下面的图表中标示:</p>
<pre><code>
let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with a y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
// 打印 "on the x-axis with an x value of 2"
</code></pre>

<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png"><br></div>

<p><code>switch</code> 语句判断这个点是在红色的 x-轴, 橙色的 y-轴, 还是其他什么地方 (不在轴上)。</p>
<p>这三个 <code>switch case</code>声明了占位符常量 <code>x</code> 和 <code>y</code>, 临时存放来自 <code>anotherPoint</code> 的一个或者两个元组值。第一个分支 <code>case (let x, 0)</code>, 匹配任何y值为0 然后把坐标点x的值赋给临时常量 x. 类似的, 第二个分支, <code>case (0, let y)</code>, 匹配任何x值为0,然后把坐标点y值赋给临时常量y.</p>
<p>临时常量声明后, 它们就可以用在分支体中。在这里, 它们用来打印这个点的标示。</p>
<p>这个 <code>switch</code> 语句没有默认的<code>default 分支</code>. 最后一个分支, <code>case let (x, y)</code>, 声明了带有两个占位符常量的元组,它可以匹配任何值。因为 <code>anotherPoint</code> 总是两个值的元组, 这个<code>case</code> 匹配所有可能的剩余值, 所以默认的<code>default case</code> 是不需要的。</p>
<h1 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h1><p>一个 <code>switch 分支</code> 可以用 <code>where</code> 字句来判断额外的条件。</p>
<p>下面的例子在下面的图表中标示一个<code>(x, y) </code>点:</p>
<pre><code>
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
// 打印 "(1, -1) is on the line x == -y"
</code></pre>

<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png"><br></div>

<p><code>switch</code> 语句确定这个点是否在<code>x == y</code>这个绿色对角线上, 或者是<code>x == -y</code>这个紫色对角线上,或者两者都不在。</p>
<p>三个 <code>switch 分支</code> 都声明了占位符常量 x 和 y, 临时接受来自 <code>yetAnotherPoint</code> 两个元组值。这些常量用作<code>where</code>字句的一部分, 去创建一个动态的过滤器。分支匹配坐标点的当前值,如果<code>where</code>字句条件为真的话。</p>
<p>和前面一个例子一样, 最后的分支匹配所有剩余值, 不再需要<code> default 分支</code></p>
<h1 id="复合-Cases"><a href="#复合-Cases" class="headerlink" title="复合 Cases"></a>复合 Cases</h1><p>共享相同代码块的多个<code>switch 分支 </code>分支可以合并, 写在分支后用逗号分开。如果任何模式匹配, 这个分支就被认为匹配。如果列表很长可以写作多行。如下：</p>
<pre><code>
let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    print("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
     "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
    print("\(someCharacter) is a consonant")
default:
    print("\(someCharacter) is not a vowel or a consonant")
}
// 打印 "e is a vowel"
</code></pre>

<p>第一个分支匹配英文中五个小写元音字母。 类似的, 第二个分支匹配所有小写辅音字母。最后, <code>default 分支</code> 匹配其余的字母。</p>
<p>符合分支可以包含值绑定。 符合分支所有形式必须包括相同的值绑定集合, 每个绑定必须获取一个相同类型的值。这个确保, 无论复合分支哪个部分匹配, 分支代码总是访问一个绑定值,而且这个值总有相同类型。</p>
<pre><code>
let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print("On an axis, \(distance) from the origin")
default:
    print("Not on an axis")
}
// 打印 "On an axis, 9 from the origin"
</code></pre>

<p>上面的分支有两种形式: <code>(let distance, 0)</code> 匹配x轴上的点, <code>(0, let distance)</code> 匹配y轴上点。两个形式都绑定了一个距离值,两种形式下距离都是整形,这就意味着分支代码总是可以访问距离的值。</p>
<h1 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h1><p>控制转移语句改变代码执行的顺序, 通过转移控制从一块代码到另外一块代码。<code>Swift</code> 有五个控制转移语句:</p>
<ol><br><li> continue </li><br><li> break </li><br><li> fallthrough </li><br><li> return </li><br><li> throw </li><br></ol>

<h1 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h1><p><code>continue</code> 语句告诉当前循环停止,然后开始下一次循环。它说 “我在当前循环迭代” 没有离开当前的循环。</p>
<p>下面的例子从一个小写字符串移除所有的元音字母和空格,来创建一个谜语:</p>
<pre><code>
let puzzleInput = "great minds think alike"
var puzzleOutput = ""
let charactersToRemove: [Character] = ["a", "e", "i", "o", "u", " "]
for character in puzzleInput.characters {
    if charactersToRemove.contains(character) {
        continue
    } else {
        puzzleOutput.append(character)
    }
}
print(puzzleOutput)
// 打印 "grtmndsthnklk"
</code></pre>

<p>上面的代码遇见元音或者空格就会调用 <code>continue</code> 关键字, 当前迭代立即结束然后进入下一次迭代。</p>
<h1 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h1><p><code>break </code>立即结束整个控制流语句的执行。<code>break</code> 语句可以用在一个 <code>switch </code>语句或者循环语句,如果你想早点结束执行的话。</p>
<h1 id="Break-在循环语句"><a href="#Break-在循环语句" class="headerlink" title="Break 在循环语句"></a>Break 在循环语句</h1><p>用在循环语句时, <code>break</code> 立即结束循环,然后跳出循环所在的大括号。</p>
<h1 id="Break-在Switch-语句"><a href="#Break-在Switch-语句" class="headerlink" title="Break 在Switch 语句"></a>Break 在Switch 语句</h1><p>用在<code>switch</code> 语句时, <code>break</code> 终止 <code>switch</code> 语句的执行,然后跳出<code>switch</code>语句所在的大括号。</p>
<p>这种行为可以在<code>switch</code>语句中用来匹配或者忽略一个或者多个分支。 因为 <code>Swift</code> 的 <code>switch</code> 语句是详尽的而且不允许有空分支, 有时候需要故意匹配和忽略一个分支,为了让你的意图明显。整个分支写一个<code>break</code>就可以忽略。当分支匹配时, 分支里的<code>break</code>语句立即终止<code>switch</code>语句的执行。</p>
<p>下面的例子转换一个字符值,然后判断它在四种语言之一是否表示一个数字, 单个<code>switch </code>分支覆盖了多个值。</p>
<pre><code>
let numberSymbol: Character = "三"  // Chinese symbol for the number 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    print("The integer value of \(numberSymbol) is \(integerValue).")
} else {
    print("An integer value could not be found for \(numberSymbol).")
}
// 打印 "The integer value of 三 is 3."
</code></pre>

<p>上面的例子判断 <code>numberSymbol</code> 是不是拉丁语, 阿拉伯语, 汉语, 或者泰语中的1到4。如果匹配到, <code>switch</code>中的一个分支会赋值给可选类型变量 <code>possibleIntegerValue</code> 一个合适的整数值。</p>
<p>在 <code>switch</code> 语句执行完成之后, 例子中使用可选绑定去判断一个值是否找到。<code>possibleIntegerValue</code> 变量是一个可选类型有一个初始值<code>nil</code>, 如果四个分支之一给<code>possibleIntegerValue </code>设置了一个实际值,这个可选绑定就成功了。</p>
<p>因为不可能列出所有的可能字符, 一个默认的分支用来处理其他没匹配的字符。默认分支不需要做任何事, 所以它只有一个<code>break</code>语句。当默认分支被匹配后, <code>break</code> 语句就结束<code>switch</code>语句的执行, 代码开始从 <code>if let </code>语句处继续执行。</p>
<h1 id="Fallthrough"><a href="#Fallthrough" class="headerlink" title="Fallthrough"></a>Fallthrough</h1><p><code>Swift</code> 的 <code>Switch</code> 语句不会 <code>fall through</code> 到下一个分支。 相反, 只有第一个匹配到的分支语句执行完成,整个<code>switch</code>语句就完成了执行。不同的是, <code>C </code>语言要求每个分支后面都要加上<code>break</code> 语句,防止 <code>fallthrough</code>. 明显<code>Swift</code> 更加简洁和安全。</p>
<p>如果你想要C语言那种效果的 <code>fallthrough</code>, 你可以选择在分支后面加上 <code>fallthrough</code> 关键字。 下面的例子使用<code>fallthrough</code> 创建一个数字的文字描述。</p>
<pre><code>
let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough
default:
    description += " an integer."
}
print(description)
// 打印 "The number 5 is a prime number, and also an integer."
</code></pre>

<p>上例声明了一个字符串变量 <code>description</code> ,然后赋了一个初始值。后面的函数在switch语句中用了这个值 integerToDescribe. 如果 integerToDescribe 的是列表中的一个素数, 函数就把一段文本添加到 description 的后面, 去备注说这个数字是素数。然后用了fallthrough 关键字进入默认的分支. 默认的分支添加一段额外的文本到 description 之后, 然后switch语句就结束了。</p>
<p>除非integerToDescribe 的值在已知素数列表里, 否则第一个分支就不会匹配。 因为没有其他分支, <code>integerToDescribe </code>会被默认的分支匹配。</p>
<p>switch 语句执行完后, 使用 <code>print(_:separator:terminator:)</code> 函数打印description。 这个例子里, 数字5就是一个素数。</p>
<h1 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h1><p>在 Swift 里, 你可以在循环和条件语句种内嵌循环和条件语句,来创建更复杂的控制流结构。不过, 循环和条件语句都可以使用break 语句来提前结束执行。因此, 有时候这很有用,当你决定哪个循环或者条件语句要用break来终止执行。类似的, 如果你有多个嵌套的循环, 它也是有用的,可以明确哪个循环语句继续有效。</p>
<p>为了达到这些目的, 你可以用一个语句标签来标记一个循环或者条件语句。对于条件语句, 你可以使用带着break语句的语句标签来结束标签的语句。对于循环语句, 你可以用带着break或者continue的语句标签来结束或者继续标签语句的执行。</p>
<p>一个标签语句通过放置一个标签来指示,标签放在相同行作为语句的关键字。跟着是一个冒号。 这里有一个while循环语法的例子, 对于所有的循环和switch语句都是相当的规则:</p>
<pre><code>
label name: while condition {
    statements
}
</code></pre>
下面的例子使用带着标签的break和continue语句,这次游戏有了一个额外的规则:

想要赢,你就要登上方格25
如果掷骰子让你超过了方格25, 你必须重掷,直到投出能够登上方格25的数字为止。

游戏的棋盘和原来一样。

<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
</div>

finalSquare, board, square, 和 diceRoll 初始化方式跟以前一样:
<pre><code>
let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
</code></pre>

<p>这个版本的游戏使用了一个 while 循环和一个switch 语句来实现游戏的逻辑。 while 循环有一个语句标签 gameLoop 用来表示它是游戏的主要循环。</p>
<p>while 循环的条件是是 while square != finalSquare, 告诉你必须登上方格25。</p>
<pre><code>
gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // diceRoll will move us to the final square, so the game is over
        break gameLoop
    case let newSquare where newSquare > finalSquare:
        // diceRoll will move us beyond the final square, so roll again
        continue gameLoop
    default:
        // this is a valid move, so find out its effect
        square += diceRoll
        square += board[square]
    }
}
print("Game over!")
</code></pre>

<p>每次循环开始摇色子。 循环使用了一个switch语句来考虑移动的结果和是否允许移动,而不是立即用的玩家的位置:</p>
<p>如果摇色子使得玩家移动到最后的方格,那么游戏就结束了。break gameLoop 语句转移控制到整个循环的外面的第一行代码, 结束游戏。<br>如果摇色子使得玩家超出了最后的方格, 那么移动无效,玩家需要重新摇色子。continue gameLoop 语句结束当前的迭代然后开始下一次迭代。<br>其他所有情况, 摇色子都是有效的移动。 玩家往前移动 diceRoll 方格, 游戏逻辑检查所有的蛇与梯子。 循环结束, 控制返回条件判断,决定是否需要再来一次。<br>备注</p>
<p>如果break 语句不使用 gameLoop 标签, 它只会跳出switch 语句,而不会跳出while 语句。使用 gameLoop 标签清楚知道要终止哪个控制语句。</p>
<p>不是必须用 gameLoop 标签,当调用 continue gameLoop 来跳到下一次循环迭代。游戏里只有一个循环。continue 语句影响哪个循环是很清楚的。不过, 使用 gameLoop 标签也没有坏处。这样做是为了和break 标签使用一致,并且让逻辑更加轻易阅读和理解。</p>
<h1 id="尽早退出"><a href="#尽早退出" class="headerlink" title="尽早退出"></a>尽早退出</h1><p>guard 语句, 很像 if 语句, 根据表达式布尔值执行语句。 使用guard 语句要求条件必须为真。和 if 语句不同, guard 语句总有一个else 字句—如果条件是假 else 会执行。</p>
<pre><code>
func greet(person: [String: String]) {
    guard let name = person["name"] else {
        return
    }

    print("Hello \(name)!")

    guard let location = person["location"] else {
        print("I hope the weather is nice near you.")
        return
    }

    print("I hope the weather is nice in \(location).")
}

greet(person: ["name": "John"])
// 打印 "Hello John!"
// 打印 "I hope the weather is nice near you."
greet(person: ["name": "Jane", "location": "Cupertino"])
// 打印 "Hello Jane!"
// 打印 "I hope the weather is nice in Cupertino."
</code></pre>

<p>如果 guard 语句的条件满足, 代码继续在guard 语句的大括号后执行。所有变量或者常量使用一个可选绑定赋值,它们作为条件的一部分。<br>如果条件没有满足, else 分支会执行。这个分支转移控制跳出guard 语句所在的代码块。可以使用控制转移语句 return, break, continue, 或者 throw, 或者也可以调用不返回的函数或者方法, 比如 <code>fatalError(_:file:line:)</code>.</p>
<p>跟 if 语句做同样的判断比较,使用 guard 语句为了提高代码的可读性。它让你可以写通常不在else 快执行的代码, 同时让你保持代码,来处理违法要求的要求。</p>
<h1 id="判断-API-可用性"><a href="#判断-API-可用性" class="headerlink" title="判断 API 可用性"></a>判断 API 可用性</h1><p>Swift 支持判断 API 的有效性, 这样可以保证你不会在给定设备上使用不可用的API。</p>
<p>编译器使用SDK中的有效性信息来判断你代码中的所有API。 如果你使用不可用的API,Swift 会报一个编译错误。</p>
<p>在if或者guard语句中使用一个可用性条件去执行一块代码, 取决于你用的API是否运行时可用。一旦编译器验证API在代码块可以用,它就会用这些信息。</p>
<pre><code>
if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}
</code></pre>

<p>上面的可用性条件指出, 对于iOS, if 语句只能在 iOS 10 和以后的版本上执行; 对于 macOS, 只能用在 macOS 10.12 和以后的版本。 最后一个参数, *, 是需要的,用来指定其他平台。if 语句执行在你指定的最小部署设备上。</p>
<p>一般形式中, 可用性条件带着一列平台名和版本号。平台名例如 iOS, macOS, watchOS, 和 tvOS—完整列表, 除了指定大版本号比如 iOS 8, 你还可以指定小版本号比如 iOS 8.3 和 macOS 10.10.3.</p>
<pre><code>
if #available(platform name version, ..., *) {
    statements to execute if the APIs are available
} else {
    fallback statements to execute if the APIs are unavailable
}
</code></pre>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数包含执行特定任务的代码块。你给出一个函数名来表明它是做什么的, 需要时使用函数名来调用。</p>
<p>Swift 统一的函数语法是很灵活的, 可以像C语言一样没有参数名,也可以像objective-C一样带有名称和参数标签。参数可以提供默认值给简单的函数调用,同时可以作为输入输出参数传入。一旦函数调用就会修改传入的变量。</p>
<p>Swift 中的函数都有类型, 由参数类型和返回类型组成。你可以像使用其他类型一样使用这个类型, 这个让传递函数作为参数变得容易, 也可以从函数返回函数。 函数可以写在其他函数里, 在一个内嵌函数范围封装哟有用的功能。</p>
<h1 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h1><p>当你定义一个函数时, 你可以定义一个或者多个命名, 函数的类型值作为输入, 也就是参数。你还可以定义一个值类型,函数执行完传回值。也就是返回值。</p>
<p>每个函数都有名字, 用来描述函数执行的任务。 为了使用一个函数, 你通过名字调用函数,传给它输入值 (参数) 匹配函数参数的类型。函数参数按照相同顺序提供。</p>
<p>下面例子里的函数叫 greet(person:), 因为它做的事情—它输入一个人的名字然后返回一个问候。为了完成这个, 你定义一个输入参数—一个字符串类型 person—然后返回一个字符串类型, 它包含了对这个人问候语。</p>
<pre><code>
func greet(person: String) -> String {
    let greeting = "Hello, " + person + "!"
    return greeting
}
</code></pre>

<p>所有信息都在函数里, 前缀是func 关键字。函数的返回类型用返回箭头-&gt; (连字符跟着一个右方向箭头), 箭头后是返回的类型名。</p>
<p>定义描述了函数的功能, 希望接收的参数, 执行完成返回的值。 定义使得函数在代码各处可以清晰明确的调用:</p>
<pre><code>
print(greet(person: "Anna"))
// 打印 "Hello, Anna!"
print(greet(person: "Brian"))
// 打印 "Hello, Brian!"
</code></pre>
在person 标签后出入一个字符串类型,调用 greet(person:) 函数, 比如 greet(person: "Anna"). 因为这个函数返回一个字符串类型, greet(person:) 可以被 print(_:separator:terminator:) 函数调用去打印返回值。

备注

print(_:separator:terminator:) 函数第一个参数没有标签, 其他参数是可选的,因为他们有默认值。这些函数语法的变化在下面函数参数标签、参数名和默认参数值中描述。

greet(person:) 函数体先是定义了一个新的字符串常量 greeting,然后设置一个简单的问候信息。然后 greeting 作为返回值传出。函数结束执行然后返回greeting 的当前值。

你可以输入不同值多次调用 greet(person:) 函数。上面的例子展示了输入"Anna" 和 "Brian" 发生了什么。函数返回了定制的问候语。

为了让函数体变短, 你可以合并信息创建和返回语句到一行代码:
<pre><code>
func greetAgain(person: String) -> String {
    return "Hello again, " + person + "!"
}
print(greetAgain(person: "Anna"))
// 打印 "Hello again, Anna!"
</code></pre>

<h1 id="函数参数和返回值"><a href="#函数参数和返回值" class="headerlink" title="函数参数和返回值"></a>函数参数和返回值</h1><p>Swift 中函数的参数和返回值非常灵活。 你可以定义任何,从带有不具名参数的简单工具函数到具有表达式参数名和不同参数选项的复杂函数。</p>
<h1 id="没有参数的函数"><a href="#没有参数的函数" class="headerlink" title="没有参数的函数"></a>没有参数的函数</h1><p>函数不要求有输入参数。 这里有个没有输入参数的函数, 调用的时候总是返回相同字符串信息:</p>
<pre><code>
func sayHelloWorld() -> String {
    return "hello, world"
}
print(sayHelloWorld())
// 打印 "hello, world"
</code></pre>

<p>函数定义是还是需要再函数名后加括号, 尽管它没有任何参数。函数调用的时候函数名后面还是跟着一堆括号。</p>
<h1 id="多个参数的函数"><a href="#多个参数的函数" class="headerlink" title="多个参数的函数"></a>多个参数的函数</h1><p>函数可以有多个输入参数, 写在函数的括号里, 用逗号分开。</p>
<p>这个函数有两个参数,一个人名和是否他们已经被问候过。然后返回对这个人的问候语:</p>
<pre><code>
func greet(person: String, alreadyGreeted: Bool) -> String {
    if alreadyGreeted {
        return greetAgain(person: person)
    } else {
        return greet(person: person)
    }
}
print(greet(person: "Tim", alreadyGreeted: true))
// 打印 "Hello again, Tim!"
</code></pre>

<p>你调用 greet(person:alreadyGreeted:) 函数,传入两个参数,一个是带有person标签的字符串值,一个是带有alreadyGreeted标签的布尔值。用逗号分开。注意这个函数跟上面的 greet(person:) 函数不同。 尽管两个函数名字一样,  greet(person:alreadyGreeted:) 函数有两个参数而 greet(person:) 函数只有一个参数。</p>
<h1 id="没有返回值的函数"><a href="#没有返回值的函数" class="headerlink" title="没有返回值的函数"></a>没有返回值的函数</h1><p>函数不要求必须有返回值。 这里有个版本的 greet(person:) 函数, 它打印自己的字符串而不是返回字符串:</p>
<pre><code>
func greet(person: String) {
    print("Hello, \(person)!")
}
greet(person: "Dave")
// 打印 "Hello, Dave!"
</code></pre>
因为不需要返回一个值, 所以函数定义没有返回箭头 (->) 或者一个返回值。

备注

严格来说, 这个版本的 greet(person:) 函数依然返回一个值, 尽管返回值没有定义。函数没有返回值是返回了一个特殊的类型 Void. 就是一个简单的空元组, 写作 ().

函数调用的时候返回值被忽略:
<pre><code>
func printAndCount(string: String) -> Int {
    print(string)
    return string.characters.count
}
func printWithoutCounting(string: String) {
    let _ = printAndCount(string: string)
}
printAndCount(string: "hello, world")
// 打印 "hello, world" and returns a value of 12
printWithoutCounting(string: "hello, world")
// 打印 "hello, world" but does not return a value
</code></pre>

<p>第一个函数, printAndCount(string:), 打印一个字符串, 然后返回它的字符数。 第二个函数, printWithoutCounting(string:), 调用第一个函数, 不过忽略了它的返回值。一旦第二个函数被调用, 依然由第一个函数打印信息,但是不用返回值。</p>
<p>备注</p>
<p>返回值可以忽略, 但是如果函数说要返回值就一直要这么做。带有返回值的函数禁止控制流跳出函数底部,如果没有返回一个值的话。如果坚持这么做会导致编译错误。</p>
<h1 id="带有多返回值的函数"><a href="#带有多返回值的函数" class="headerlink" title="带有多返回值的函数"></a>带有多返回值的函数</h1><p>你可以用元组做为函数的返回值,来实现返回多个值。</p>
<p>下面的例子定义了一个函数 minMax(array:), 用来茶盅整形数组里面的最小值和最大值:</p>
<pre><code>
func minMax(array: [Int]) -> (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {="" if="" value="" <="" currentmin="" }="" else=""> currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
</array.count]></code></pre>

<p>minMax(array:) 函数返回包含两个整数值的元组。这些值用最小和最大标签表明,这个可以在查询函数返回值的时候通过名字访问它们。</p>
<p>minMax(array:) 函数体开始时设置两个变量currentMin 和 currentMax值为数组第一项的值。然后函数开始遍历剩下的值,然后重复和 currentMin 和 currentMax 值进行大小比较。 最后, 最大值和最小值作为一个元组返回。</p>
<p>因为元组的成员值作为函数返回值被命名, 所以可以点语法来访问最大值和最小值:</p>
<pre><code>
let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print("min is \(bounds.min) and max is \(bounds.max)")
// 打印 "min is -6 and max is 109"
</code></pre>

<p>注意函数返回元组时,元组的成员不需要命名, 因为它们的名字作为函数返回类型已经被指定了。</p>
<h1 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h1><p>如果函数返回的元组类型有可能不存在值,你可以使用一个可选元组返回类型来反应整个元组可能为nil。一个可选元组返回类型括号后面跟着一个问号, 比如 (Int, Int)? 或者 (String, Int, Bool)?.</p>
<p>备注</p>
<p>可选元组类型比如s (Int, Int)? 不同于元组中包含可选类型比如 (Int?, Int?). 有一个可选元组类型, 整个元组都是可选的, 不单单是元组里的值。</p>
<p>minMax(array:) 函数返回的元组包含两个整数值。 然而, 函数不会对传入的数组做任何安全检查。 如果数组包含空数组, minMax(array:) 函数, 上面定义的, 尝试访问 array[0] 会触发运行时错误。</p>
<p>为了处理这种情况, minMax(array:) 函数返回值写成可选元组返回类型,如果数组为空则返回nil:</p>
<pre><code>
func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {="" if="" value="" <="" currentmin="" }="" else=""> currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
</array.count]></code></pre>

<p>你可以用一个可选绑定来判断, 这个版本的 minMax(array:) 函数是返回一个实际元组值还是nil:</p>
<pre><code>
if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print("min is \(bounds.min) and max is \(bounds.max)")
}
// 打印 "min is -6 and max is 109"
</code></pre>

<h1 id="函数参数标签和参数名"><a href="#函数参数标签和参数名" class="headerlink" title="函数参数标签和参数名"></a>函数参数标签和参数名</h1><p>每个函数参数既有参数标签也有参数名。参数标签在调用函数时使用; 函数中的每个参数调用时使用它们的标签。 参数名用于函数的实现。 默认情况, 参数使用参数名作为标签。</p>
<pre><code>
func someFunction(firstParameterName: Int, secondParameterName: Int) {
    // In the function body, firstParameterName and secondParameterName
    // refer to the argument values for the first and second parameters.
}

someFunction(firstParameterName: 1, secondParameterName: 2)
</code></pre>

<p>所有参数名必须唯一。 尽管多个参数可能有相同的标签, 唯一的参数标签会让你的代码更有可读性。</p>
<h1 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h1><p>参数标签写在参数名之前, 用空格分开:</p>
<pre><code>
func someFunction(argumentLabel parameterName: Int) {
    // In the function body, parameterName refers to the argument value
    // for that parameter.
}
</code></pre>

<p>这里有一个 greet(person:) 函数的变种,接受一个人名和家乡然后返回一个问候:</p>
<pre><code>
func greet(person: String, from hometown: String) -> String {
    return "Hello \(person)!  Glad you could visit from \(hometown)."
}
print(greet(person: "Bill", from: "Cupertino"))
// 打印 "Hello Bill!  Glad you could visit from Cupertino."
</code></pre>

<p>参数标签的使用允许函数用表达方式调用, 像句子一样。</p>
<h1 id="省略参数标签"><a href="#省略参数标签" class="headerlink" title="省略参数标签"></a>省略参数标签</h1><p>如果你不想要参数标签, 写一个下划线代替显式的参数标签。</p>
<pre><code>
func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    // In the function body, firstParameterName and secondParameterName
    // refer to the argument values for the first and second parameters.
}
someFunction(1, secondParameterName: 2)
</code></pre>

<p>如果一个参数有参数标签, 那么调用函数的时候参数必须带上标签。</p>
<h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h1><p>你可以给函数参数赋一个默认值,写在类型的后面。如果定义了默认值, 调用函数时你就可以忽略这个参数。</p>
<pre><code>
func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    // If you omit the second argument when calling this function, then
    // the value of parameterWithDefault is 12 inside the function body.
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12
</code></pre>

<p>没有默认值的参数放在函数参数列表前, 带有默认值的放在后面。没有默认值的参数通常更重要—首先写它们更容易知道相同的函数被调用, 不用管默认参数是否被忽略。</p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>可变参数接受零个或者多个指定类型的值。你用可变参数指定函数调用时可以传入不同个数的输入值。可变参数写法是在参数类型名后写三个点。</p>
<p>传入可变参数的值在函数体中作为对应类型的数组是可用的。 例如, 带有数字名的可变参数和 Double… 在函数中作为常量数组 [Double]是可用的。</p>
<p>下面的例子计算任意长度的数字的平均数:</p>
<pre><code>
func arithmeticMean(_ numbers: Double...) -> Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers
</code></pre>

<p>备注</p>
<p>一个函数最多有一个可变参数。</p>
<h1 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h1><p>函数参数默认是常量。 尝试改变会导致编译期错误。这就意味着你不能错误的改变参数值。如果你想函数改变参数值, 想要这些改变持续到函数调用结束, 你可以定义输入输出参数来代替。</p>
<p>通过把 in-out 关键字写在参数类型前面来写一个输入输出参数。 输入输出参数有一个传入函数的值, 会被函数修改, 然后传出函数取代原有的值。 详情请参照 In-Out Parameters.</p>
<p>你可以只传入一个变量作为输入输出参数。 你不能传入一个常量或者字面值作为参数, 因为常量和字面量不能改变。当你使用它作为输入输出参数时,你可以直接在变量名前加上 (&amp;), 来表示它可以被函数改变。</p>
<p>备注</p>
<p>输入输出参数不能有默认值, 可变参数不能标记为输入输出的。</p>
<p>这里有一个函数 swapTwoInts(<em>:</em>:), 有两个输入输出整形参数 a 和 b:</p>
<pre><code>
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>swapTwoInts(<em>:</em>:) 函数简单的交换a和b的值,这个函数通过把a的值存储到一个临时的常量temporaryA 来实现交换, 把b的值赋给a, 然后把 temporaryA 的值赋给b.</p>
<p>你可以调用 swapTwoInts(<em>:</em>:) 函数交换两个整形变量的值。 注意 someInt 和 anotherInt 在传给函数的时候前面都加上了 &amp;:</p>
<pre><code>
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 打印 "someInt is now 107, and anotherInt is now 3"
</code></pre>

<p>上面例子展示 someInt 和 anotherInt 的原始值被 swapTwoInts(<em>:</em>:) 函数改变, 尽管它们定义在函数之外。</p>
<p>备注</p>
<p>输入输出参数与函数返回值不一样。swapTwoInts 没有定义一个返回值或者返回一个值。但是它依然改变了 someInt 和 anotherInt 的值。 输入输出参数是函数影响外部的一种备选方式。</p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>每个函数都有一个指定的函数类型, 由参数类型和返回值类型组成。</p>
<p>例如:</p>
<pre><code>
func addTwoInts(_ a: Int, _ b: Int) -> Int {
    return a + b
}
func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {
    return a * b
}
</code></pre>
这个例子定义了两个简单的数学函数 addTwoInts 和 multiplyTwoInts. 两个函数都接受两个整形值, 然后返回一个整形值, 执行合适的数学运算会得出这个结果。

两个函数的类型都是(Int, Int) -> Int. 可以解读为:

“一个函数类型有两个参数, 两个都是整数类型t, 然后返回一个整形值”

这里有另外一个例子, 一个没有参数和返回值的函数:
<pre><code>
func printHelloWorld() {
    print("hello, world")
}
</code></pre>

<p>这个函数类型是 () -&gt; Void, 或者 “一个函数没有参数,返回 Void.”</p>
<h1 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h1><p>使用函数类型跟Swift中其他类型很像。例如, 你可以定义一个函数的常量或者变量,然后把一个函数赋值给这个变量:</p>
<pre><code>
var mathFunction: (Int, Int) -> Int = addTwoInts
</code></pre>

<p>这段代码可以解读为:</p>
<p>“定义一个变量 mathFunction, 带有两个整形值的函数类型, 然后返回一个整形值。’ 调用函数 addTwoInts 给这个变量设置值。”</p>
<p>addTwoInts(<em>:</em>:) 函数和 mathFunction 变量一样有相同的类型, 所有赋值是允许的。</p>
<p>你现在可以使用 mathFunction 名字调用赋值函数:</p>
<pre><code>
print("Result: \(mathFunction(2, 3))")
// 打印 "Result: 5"
</code></pre>

<p>有相同匹配类型的不同函数也可以赋值给相同的变量, 和非函数类型一样:</p>
<pre><code>
mathFunction = multiplyTwoInts
print("Result: \(mathFunction(2, 3))")
// 打印 "Result: 6"
</code></pre>

<p>其他任何类型, 当你把函数赋值给一个常量或者变量时,你可以留给 Swift 去推断函数类型:</p>
<pre><code>
let anotherMathFunction = addTwoInts
// anotherMathFunction is inferred to be of type (Int, Int) -> Int
</code></pre>

<h1 id="函数类型作为参数类型"><a href="#函数类型作为参数类型" class="headerlink" title="函数类型作为参数类型"></a>函数类型作为参数类型</h1><p>你可以使用一个函数类型比如 (Int, Int) -&gt; Int 作为另外一个函数的参数。当函数调用的时候,你可以把函数实现的一部分留给调用者。</p>
<p>这里有个一个例子打印上面数学函数的结果:</p>
<pre><code>
func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \(mathFunction(a, b))")
}
printMathResult(addTwoInts, 3, 5)
// 打印 "Result: 8"
</code></pre>

<p>这个例子定义了一个函数 printMathResult(<em>:</em>:_:), 有三个参数。第一个参数是 mathFunction, 类型 (Int, Int) -&gt; Int. 你可以传递任何这种类型的函数作为第一个参数。 第二个和第三个参数是 a 和 b, 都是整型, 用来作为数学函数的输入值。</p>
<p>当 printMathResult(<em>:</em>:<em>:) 调用时, 传入 addTwoInts(</em>:_:) 函数, 和整数 3 和 5. 调用提供的函数, 然后打印结果 8.</p>
<p>printMathResult(<em>:</em>:<em>:) 任务就是打印特定类型数学函数的结果。它不关心函数的实际实现—它只关心函数类型是否正确。 这使得 printMathResult(</em>:<em>:</em>:) 以一种类型安全的方式放手一些功能给函数的调用者。</p>
<h1 id="函数类型和返回值"><a href="#函数类型和返回值" class="headerlink" title="函数类型和返回值"></a>函数类型和返回值</h1><p>你可以用一个函数类型作为另外一个函数的返回类型。把一个完整的函数类型写在返回箭头后面就可以了。</p>
<p>下一个例子定义了两个简单的函数 stepForward(<em>:) 和 stepBackward(</em>:). stepForward(<em>:) 函数返回一个比输入值大一的值, stepBackward(</em>:) 函数返回一个比输入值小一的值。两个函数都有一个类型 (Int) -&gt; Int:</p>
<pre><code>
func stepForward(_ input: Int) -> Int {
    return input + 1
}
func stepBackward(_ input: Int) -> Int {
    return input - 1
}
</code></pre>

<p>这里有一个函数 chooseStepFunction(backward:), 返回类型是 (Int) -&gt; Int. chooseStepFunction(backward:) 函数基于一个布尔参数backward 来返回 stepForward(<em>:) 函数或 stepBackward(</em>:) 函数:</p>
<pre><code>
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return backward ? stepBackward : stepForward
}
</code></pre>

<p>现在你可以使用 chooseStepFunction(backward:) 去获取一个函数, 然后往前走或者往后走:</p>
<pre><code>
var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero 调用 stepBackward() 函数
</code></pre>

<p>前面的例子决定是否需要一个负数或者正数步去移动currentValue ,让它逐渐趋近于0. currentValue 有个初始值3, 意味着 currentValue &gt; 0 返回真, chooseStepFunction(backward:) 会返回 stepBackward(_:) 函数。 引用的返回函数存储在一个常量 moveNearerToZero.</p>
<p>moveNearerToZero 指向恰当的函数, 它可以用来计步到0:</p>
<pre><code>
print("Counting to zero:")
// Counting to zero:
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// 3...
// 2...
// 1...
// zero!
</code></pre>

<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>到目前为止,你在本章看见的函数都是全局的示例, 它们定义在全局范围。你也可以在其他函数体内定义函数,这就是嵌套函数。</p>
<p>嵌套函数默认对外界隐藏, 但是对于它们的封闭函数依然可以使用。封闭函数可以返回一个嵌套函数, 并允许它给外部使用。</p>
<p>你可以重写上面的 chooseStepFunction(backward:) 例子来使用和返回嵌套函数:</p>
<pre><code>
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the nested stepForward() function
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// -4...
// -3...
// -2...
// -1...
// zero!
</code></pre>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是自包含的功能块,可以传递和用在代码中。Swift 中的闭包和C 和 Objective-C 中的相似。</p>
<p>闭包可以捕获和存储上下文定义的任何常量和变量的引用。这就是关闭了常量和变量。Swift 替你处理闭包的所有内存管理。</p>
<p>备注</p>
<p>如果不熟悉闭包的概念不用担心。 下面会详细描述。</p>
<p>全局和嵌套函数实际上是一种特殊的闭包。闭包通常是下面三种形式之一:</p>
<p>全局函数是闭包,没有名字也不捕获任何值。<br>嵌套函数是闭包,有一个名字也可以从封闭函数中捕获值。<br>闭包表达式是匿名闭包,使用轻量级语法书写,可以捕获上下文的值。<br>Swift 的闭包表达式有一个清楚清晰的风格, 鼓励简洁,整齐的语法优化。这些优化包括:</p>
<p>从上下文推断参数和返回值的类型<br>从单个表达式闭包隐式返回<br>简约参数名<br>尾部闭包语法</p>
<h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><p>嵌套函数, 是一个方便的命名方法,也是在较大函数中定义自包含代码块的方式。不过, 有时候写一个更短的版本很有用, 它很像函数但是没有完整的声明和名字。函数作为参数的时候这个尤其有用。</p>
<p>闭包表达式是内联闭包的一种简写。 闭包表达式提供一些语法优化,以更短的样式书写闭包,但不失清晰和目的性。下面的闭包实例通过精炼一个排序函数来展示这些优化, 每个表达式功能一样,只是更简洁。</p>
<h1 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h1><p>Swift 标准库提供了一个方法 sorted(by:), 对已知类型数组值进行排序, 基于你提供的排序闭包输出。一旦排序完成, sorted(by:) 方法就会返回一个跟旧数组相同类型相同大小的新数组, 数组元素按照正确的顺序。原来的数组并没有被排序方法改变。</p>
<p>下面的闭包表达式使用 sorted(by:) 方法按照字母表倒序排列一个字符串数组。这是要排序的原来的数组:</p>
<pre><code>
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>
sorted(by:) 方法接受带有两个相同类型参数的闭包,作为数组的内容。然后返回一个布尔值,来说明排序后第一个值是出现在第二个值的前面还是后面。

这个例子是排序一个字符串值的数组, 所以排序闭包需要是一个函数类型 (String, String) -> Bool.

提供排序闭包的一个方式是写一个正确类型的函数, 然后把它作为参数传给 sorted(by:) 方法:
<pre><code>
func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}

var reversedNames = names.sorted(by: backward)
// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>

<p>如果第一个字符串 (s1) 大于第二个字符串 (s2), backward(<em>:</em>:) 函数返回真, 表明在排序后数组中 s1 应该出现在 s2 前面。 对于字符串中字符, “大于” 意思是 “字母表中出现较晚”。 也就说字母 “B” 大于字母 “A”, 字符串”Tom” 大于字符串 “Tim”. 这是提供了一个字母表的倒序, “Barry” 排在 “Alex”前面, 等等。</p>
<p>不过, 这种写法很冗长,它本质上是个单一表达式函数 (a &gt; b). 这个例子里, 写成内联排序闭包更可取, 使用闭包表达式语法。</p>
<h1 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h1><p>闭包表达式一般是下面这种形式:</p>
<pre><code>
{ (parameters) -> return type in
    statements
}
</code></pre>
闭包表达式语法参数可以是输入输出参数, 但是它们不能有默认值。 如果你命名可变参数,那么可变参数也是可以用的。元组也可以用作参数和返回类型。

下面的例子展示了之前 backward(_:_:) 函数的闭包表达式版本:
<pre><code>
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})
</code></pre>

<p>内联闭包的参数和返回类型声明跟backward(<em>:</em>:)函数的声明一样。两种情况下, 它写作 (s1: String, s2: String) -&gt; Bool. 不过, 对于内联闭包表达式, 参数和返回类型都写作花括号里,而不是外部。</p>
<p>闭包体以关键字in 开始。这个关键词的意思是闭包参数和返回类型的定义完成了, 闭包体开始了。</p>
<p>因为闭包体太短, 它甚至可以写成一行:</p>
<pre><code>
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
</code></pre>

<p>这个说明 sorted(by:) 方法调用还是一样的。一对括号包括方法的所有参数。 只不过,现在参数在一个内联闭包里。</p>
<h1 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h1><p>由于排序闭包作为参数传给函数, Swift 可以推断它的参数类型和返回值类型。sorted(by:) 方法被字符串数组调用, 所以它的参数类型是一个函数类型 (String, String) -&gt; Bool. 这就是说 (String, String) 和 Bool 类型无需写出来作为闭包表达式定义的一部分。因为所有的类型都可以推断, 返回箭头 (-&gt;) 和参数名字外的括号都可以被忽略:</p>
<pre><code>
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
</code></pre>

<p>当把闭包传给一个函数或者方法作为内联闭包表达式时,总是可能要推断参数类型和返回类型。结果是, 一旦这个闭包用作函数或者方法参数,你就不需要用完整的形式书写内联闭包。</p>
<p>尽管如此, 如果你想你依然可以显式说明类型, 如果可以避免代码的二义性,这样做是鼓励的。sorted(by:) 方法这种情况, 闭包的目的很清晰,就是排序。读者假设这个闭包可能作用于字符串值是安全的。因为它帮助字符串数组的排序。</p>
<h1 id="从单一表达式闭包隐式返回"><a href="#从单一表达式闭包隐式返回" class="headerlink" title="从单一表达式闭包隐式返回"></a>从单一表达式闭包隐式返回</h1><p>通过忽略声明的返回关键字,单一表达式闭包可以隐式返回它们单一表达式的结果, 就像前一个例子的版本:</p>
<pre><code>
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
</code></pre>

<p>这里, sorted(by:) 函数的方法参数清晰表明闭包要返回一个布尔值。因为闭包体包含了单一表达式(s1 &gt; s2) ,而且返回值是布尔值, 这里没有二义性, 而且返回值可以忽略。</p>
<h1 id="速记参数名"><a href="#速记参数名" class="headerlink" title="速记参数名"></a>速记参数名</h1><p>Swift 自动提供速记参数名给内联闭包, 可以用 $0, $1, $2, 来调用闭包参数值</p>
<p>如果你在闭包表达式使用这些速记参数名, 你可以忽略闭包定义的参数列表和个数,然后速记参数名类型会被期望的函数类型推断出来。 关键字in 也可以被忽略, 因为闭包表达式由它的整个包体组成。</p>
<pre><code>
reversedNames = names.sorted(by: { $0 > $1 } )
</code></pre>

<p>这里, $0 和 $1 调用闭包的第一个和第二个字符串参数。</p>
<h1 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h1><p>这里其实有一个更短的方式去写上面的闭包。 Swift 的字符串类型定义了它特有的大于号的实现, 是带有两个字符串类型参数的方法,然后返回一个布尔类型。这很符合 the sorted(by:) 方法的类型需要。因此, 你可以简单的传入大于号, 然后 Swift 会推断你想要用它的字符串特有的实现:</p>
<pre><code>
reversedNames = names.sorted(by: >)
</code></pre>

<h1 id="尾闭包"><a href="#尾闭包" class="headerlink" title="尾闭包"></a>尾闭包</h1><p>如果你需要传给函数一个闭包表达式作为最后的参数并且闭包表达式很长的话, 用尾闭包代替是很有用的。尾闭包写在函数调用的括号后面, 尽管它依然是函数的一个参数。 当你使用尾闭包语法时, 作为函数调用部分,你不要给闭包写参数标签。</p>
<pre><code>
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}

// 不使用尾闭包调用函数:

someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})

// 使用尾闭包调用函数:

someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}
</code></pre>

<p>字符串排序闭包也可以使用尾闭包:</p>
<pre><code>
reversedNames = names.sorted() { $0 > $1 }
</code></pre>
如果闭包表达式是作为函数或者方法的唯一参数,并且你使用这个表达式作为尾闭包的话, 你调用这个函数的时候可以不用在函数名后写括号:
<pre><code>
reversedNames = names.sorted { $0 > $1 }
</code></pre>
当闭包太长无法写成内联单行的时候, 使用尾闭包是最有用的。有一个例子, Swift 数组类型有个方法 map(_:) ,带有一个闭包表达式作为它的单一参数。数组中的每一项都会调用它一次, 为每项返回一个替代映射值 (可能是其他类型)。映射的性质和返回值的类型由闭包决定。

对每个数组元素应用提供的闭包后, map(_:) 方法返回包含新的映射值的新数组, 和原有数组对应值的顺序一致。

这里展示使用带尾闭包的 map(_:) 方法如何把整型值数组转换为字符串值数组。数组 [16, 58, 510] 用来创建新数组 ["OneSix", "FiveEight", "FiveOneZero"]:
<pre><code>
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
</code></pre>

<p>上面的代码创建了一个字典,在整数字和英文名之间建立迎神。同时定义了一个整数数组, 准备转换为字符串数组。</p>
<p>现在你可以用这个数字数组来创建一个字符串数组, 把闭包表达式作为尾闭包传入数组的 map(_:) 方法即可:</p>
<pre><code>
let strings = numbers.map {
    (number) -> String in
    var number = number
    var output = ""
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0
    return output
}
// strings is inferred to be of type [String]
// its value is ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>

<p>数组每个元素调用一次 map(_:) 方法。 你不需要指定闭包输入参数的类型, number, 因为这个值可以被推断出来。</p>
<p>这个例子里, 变量 number 用闭包的 number 参数值来初始化, 所以这个值可以在闭包中修改。 (函数和闭包的参数总是常量的) 闭包表达式指定了一个字符串返回值类型, 来说明存储在映射输出数组中的类型。</p>
<p>每次调用闭包表达式创建一个字符串 output. 它使用余数运算符结算数字的最后一位 (number % 10), 然后用这个位去字典中查找对应的字符串。这个闭包可以用来创建任何大于0数字的字符串表示。</p>
<p>备注</p>
<p>调用字典下标后面跟着感叹号 (!), 因为字典下标返回一个可选值来表示如果键不存在查找就会失败。上面的例子里, 可以保证每次能找到有效的下标键, 所以感叹号用来强制拆包存在的值。</p>
<p>从字典获取的字符串会加到 output 前, 有效的建立了倒序的数字字符串版本。</p>
<p>然后数字变量除以10, 因为它是一个整数, 因为取整数倍, 所以 16 变成 1, 58 变成 5, 510 变成 51.</p>
<p>这个过程直到nubmer等于0, 这时闭包返回输出字符串, 然后通过 map(_:) 方法添加到数组。</p>
<p>上例尾闭包语法的使用,完整封装了闭包的功能。不要把整个闭包包含在 map(_:) 方法的method 外面括弧里。</p>
<h1 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h1><p>闭包可以在其定义的上下文中捕获常量和变量值。闭包可以在包体内调用和修改这些常量和变量值, 即使定义常量和变量的原来的范围不存在了。</p>
<p>在 Swift 中, 可以捕获值的最简单的闭包形式是一个内嵌函数, 写在另外一个函数体内。 内嵌函数可以捕获它外部函数的任何参数,而且可以捕获定义在外部函数的任何常量和变量。</p>
<p>这里有函数实例 makeIncrementer, 包含了一个内嵌函数 incrementer. 内嵌函数从它的上下文 incrementer() 捕获两个值, runningTotal 和 amount. 捕获这两个值以后, incrementer 被 makeIncrementer 作为闭包返回, 这个闭包每次调用时会把 runningTotal 增加 amount.</p>
<pre><code>
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
</code></pre>

<p>makeIncrementer 的返回类型是 () -&gt; Int. 意思就是返回一个函数, 而不是一个简单值。返回的函数没有参数, 每次调用有一个整型值。</p>
<p>makeIncrementer(forIncrement:) 函数定义了一个整型变量 runningTotal, 用来保存incrementer 返回的增加的总步数。这个变量初始化值是 0.</p>
<p>makeIncrementer(forIncrement:) 有一个整型参数带有forIncrement 标签, 和一个变量名 amount. 这个参数传给指定 runningTotal 应该增加多少步数。makeIncrementer 定义了一个内嵌函数incrementer, 用来执行实际的递增操作。 这个函数简单把 amount 加到 runningTotal 上去然后返回结果。</p>
<p>单独拿出来, 内嵌函数 incrementer() 不太寻常:</p>
<pre><code>
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}
</code></pre>

<p>incrementer() 函数没有任何参数, 然而它从函数体内部调用runningTotal 和 amount。 它从包围它的函数里捕获 runningTotal 和 amount. 引用捕获确保 runningTotal 和 amount 在调用 makeIncrementer 结束后不会消失, 也确保了 runningTotal 在下一次调用 incrementer 函数时依然有效。</p>
<p>备注</p>
<p>作为一个优化, 如果闭包修改一个值, 而且闭包创建后这个值没有改变的话,Swift 可能会不会捕获和保存这个值的副本。</p>
<p>Swift 同时处理了变量释放后的所有的内存管理。</p>
<p>这里有一个 makeIncrementer 活动的例子:</p>
<pre><code>
let incrementByTen = makeIncrementer(forIncrement: 10)</code></pre>
这个例子设置了一个常量 incrementByTen,它调用增量器函数,这个函数每次调用把 runningTotal 变量加10. 多次调用效果如下:
<pre><code>
incrementByTen()
// returns a value of 10
incrementByTen()
// returns a value of 20
incrementByTen()
// returns a value of 30
</code></pre>
如果你再创建一个增量器, 它会有自己新的单独的runningTotal 变量:
<pre><code>
let incrementBySeven = makeIncrementer(forIncrement: 7)
incrementBySeven()
// returns a value of 7
</code></pre>
调用原先的增量器(incrementByTen) 继续增加它的 runningTotal 变量, 不会影响 incrementBySeven 捕获的变量:
<pre><code>
incrementByTen()
// returns a value of 40
</code></pre>

<p>备注</p>
<p>如果你把闭包赋值给一个类实例的属性, 然后闭包会通过引用这个实例或者它的成员来捕获这个实例。你将在闭包和实例之间建立一个强引用循环。 Swift 使用捕获列表来打破这种强引用循环。</p>
<h1 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h1><p>上面的例子, incrementBySeven 和 incrementByTen 都是常量, 但是这些常量引用的闭包依然可以改变它们已经捕获的 runningTotal 变量。 这是因为函数和闭包是引用类型。</p>
<p>每当你赋值函数或者闭包给一个常量或者变量, 实际上你是设置常量或者变量去引用函数或者闭包。上面的例子, incrementByTen 引用的闭包选择是常量, 而不是闭包本身的内容。</p>
<p>这也意味着如果你把一个闭包赋值给两个不同的常量或者变量,它们引用的是相同的闭包:</p>
<pre><code>
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// returns a value of 50
</code></pre>

<h1 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h1><p>闭包被传给函数作为参数的事据说会逃逸, 但是会在函数返回时调用。 一旦你定义带有闭包作为参数的函数, 你可以在参数类型前书写 @escaping 来表示这个闭包允许逃逸。</p>
<p>闭包逃逸的方式之一是,通过存储在定义在函数外部的变量中。作为一个例子, 很多函数用闭包参数作为一个完成处理器来异步工作。 任务开始时函数返回, 但是函数完成之前闭包不会调用—这个闭包需要逃逸, 后面再调用。例如:</p>
<pre><code>
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
</code></pre>

<p>someFunctionWithEscapingClosure(_:) 函数接受一个闭包作为参数,并且把它添加到外部定义的数组。如果你不把这个参数标记为 @escaping, 你会收到一个编译错误。</p>
<p>标记 @escaping 意思是你必须在闭包里显式引用self。例如, 下面的代码, 传给 someFunctionWithEscapingClosure(<em>:) 的闭包是一个逃逸闭包, 意思是需要显式引用self。 相反, 传给 someFunctionWithNonescapingClosure(</em>:) 的闭包是非逃逸的, 意思是可以隐式引用self.</p>
<pre><code>
func someFunctionWithNonescapingClosure(closure: () -> Void) {
    closure()
}

class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}

let instance = SomeClass()
instance.doSomething()
print(instance.x)
// 打印 "200"

completionHandlers.first?()
print(instance.x)
// 打印 "100"
</code></pre>

<h1 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h1><p>自动闭包是自动创建的闭包, 它包含了作为参数传入函数的表达式。它没有任何参数, 并且被调用时, 它会返回表达式的值。 这个语法便利让你可以忽略函数参数的花括号,只要写一个正常的表达式替代显式的闭包。</p>
<p>调用带有自动闭包的函数很常见, 但是实现那种函数却不常见。例如, assert(condition:message:file:line:) 函数为它的 condition 和 message 参数带了一个自动闭包; 它的condition 参数只在调试模式执行, message 参数则在 condition 是假的时候执行。</p>
<p>自动闭包让你延迟执行, 直到你调用闭包内部代码才会运行。延迟作用对于边界影响和昂贵计算代码很有用, 因为它可以让控制代码什么时候执行。 下面的代码展示闭包的延迟执行。</p>
<pre><code>
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)
// 打印 "5"

let customerProvider = { customersInLine.remove(at: 0) }
print(customersInLine.count)
// 打印 "5"

print("Now serving \(customerProvider())!")
// 打印 "Now serving Chris!"
print(customersInLine.count)
// 打印 "4"
</code></pre>

<p>尽管 customersInLine 数组第一个元素被闭包内的代码给移除了, 但是直到这个闭包实际被调用,数组的元素才会被移除。如果闭包永不调用, 闭包内的表达式永远不会执行, 也就是说数组元素永不会被移除。注意 customerProvider 类型不是 String 而是 () -&gt; String—不带参数的函数只是返回一个字符串。</p>
<p>当你把闭包传给函数时,你会得到相同的延迟执行效果。</p>
<pre><code>
// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: { customersInLine.remove(at: 0) } )
// 打印 "Now serving Alex!"
</code></pre>

<p>serve(customer:) 函数有一个显式闭包用户返回一个用户名。 下面版本的 serve(customer:) 做了相同的操作,不过, 不是接受一个显式闭包, 而是在参数类型前用了 @autoclosure 属性。 现在你可以调用这个函数,好像他是带有一个String 参数而不是一个闭包。这个参数会自动转换为闭包,因为 customerProvider 参数类型已经标记为 @autoclosure .</p>
<pre><code>
// customersInLine is ["Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customersInLine.remove(at: 0))
// 打印 "Now serving Ewa!"
</code></pre>

<p>备注</p>
<p>过度使用自动闭包会让你的代码很难理解。 上下文和函数名字应该让人知道执行推迟了。</p>
<p>如果你想让自动闭包可以逃逸, 同时使用 @autoclosure 和 @escaping 属性。 </p>
<pre><code>
// customersInLine is ["Barry", "Daniella"]
var customerProviders: [() -> String] = []
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
    customerProviders.append(customerProvider)
}
collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")
// 打印 "Collected 2 closures."
for customerProvider in customerProviders {
    print("Now serving \(customerProvider())!")
}
// 打印 "Now serving Barry!"
// 打印 "Now serving Daniella!"
</code></pre>

<p>上面的代码, 不是调用作为 customerProvider 参数的闭包, collectCustomerProviders(_:) 函数添加闭包到 customerProviders 数组。 数组在函数外部声明, 意味着函数返回后数组中的闭包会执行。 结果就是, customerProvider 参数值必须被允许逃离函数范围。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>一个枚举定义一组相关的常见类型的值, 让你在代码中用一个类型安全的方式工作。</p>
<p>如果你熟悉 C, 你就会知道 C 枚举会给相关的名字赋值一组整型值。 Swift 中的 枚举更加灵活, 不需要给每个枚举分支赋值。 如果提供一个值 ( “原始” 值), 这个值可以是字符串,字符,或者任意一个整型或者浮点型的值。</p>
<p>另外, 枚举的不同分支可以指定任何类型对应值。很像其他语言的 unions 或者 variants. 你可以定义一个常见的相关的分支集合来作为枚举的一部分。每部分都有相应的值对应它们。</p>
<p>Swift 的枚举是第一等类型。它们采用传统上只有类才支持的多种特性, 例如计算属性来提供关于枚举当前值的额外信息, 实例方法来提供有关枚举表示值的功能。枚举还可以用初始化来定义初始化值; 可以扩大它们原有实现的功能; 并且可以遵守协议去提供标准功能。</p>
<h1 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h1><p>用enum关键字引入枚举,在大括号中定义整个枚举:</p>
<pre><code>
enum SomeEnumeration {
    // enumeration definition goes here
}</code></pre>
这里有个指南者四个方位的例子:
<pre><code>
enum CompassPoint {
    case north
    case south
    case east
    case west
}</code></pre>

<p>定义在枚举中的值就是枚举分支 (比如 north, south, east, and west) 你可以用关键字来引入新的枚举分支.</p>
<p>备注</p>
<p>不像 C 和 Objective-C, Swift 枚举分支创建时不设一个默认的整数值。上面的 CompassPoint 例子, north, south, east 和 west 不会隐式等于 0, 1, 2 和 3. 相反, 不同的枚举分支在右方都有值t, 有一个显式定义的 CompassPoint 类型。</p>
<p>多个分支可以出现在一行,用逗号分开:</p>
<pre><code>
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}</code></pre>
每个枚举定义定义了一个全新的类型。 像Swift中的其他类型一样,它们的名字 (比如 CompassPoint 和 Planet) 应该以大写字母开始。 用单数名而不是复数名:
<pre><code>
var directionToHead = CompassPoint.west</code></pre>
directionToHead 类型在初始化时推断类型。只要 directionToHead 声明为 CompassPoint, 你可以用一个短的点语法来给它设置一个不同的 CompassPoint 值:
<pre><code>
directionToHead = .east</code></pre>

<p>directionToHead 类型已经知道了, 所以设置值的时候可以丢掉类型了。使用显式类型枚举值时这个会让代码高度可读。</p>
<h1 id="用Switch语句匹配枚举值"><a href="#用Switch语句匹配枚举值" class="headerlink" title="用Switch语句匹配枚举值"></a>用Switch语句匹配枚举值</h1><p>你可以用一个switch语句来匹配单个枚举值:</p>
<pre><code>
directionToHead = .south
switch directionToHead {
case .north:
    print("Lots of planets have a north")
case .south:
    print("Watch out for penguins")
case .east:
    print("Where the sun rises")
case .west:
    print("Where the skies are blue")
}
// 打印 "Watch out for penguins"
</code></pre>

<p>你可以这样解读代码:</p>
<p>“考察 directionToHead 的值。等于 .north, 打印 “Lots of planets have a north”. 等于 .south, 打印 “Watch out for penguins”.”</p>
<p>…等等。</p>
<p>控制流里描述过, switch 语句考察枚举分支时一定要详尽。 如果 .west 分支忽略掉, 代码会编译不过, 因为它没有完整考察 CompassPoint 所有分支。 要求详尽保证枚举分支不会被疏忽掉。</p>
<p>如果提供所有的分支不合适, 你可以提供一个默认分支来覆盖没有显式指明的分支:</p>
<pre><code>
let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print("Mostly harmless")
default:
    print("Not a safe place for humans")
}
// 打印 "Mostly harmless"
</code></pre>

<h1 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h1><p>上部分实例展示枚举分支是一个定义值（类型值）。 你可以把一个常量或者变量设置成 Planet.earth, 然后稍晚再判断这个值。 不过, 有时候存储其他类型的对应值是很有用的。这让你可以随着分支存储其他自定义信息。</p>
<p>你可以定义 Swift 枚举来存储给定类型的对应值, 如果需要每个分支的值类型可以不同。枚举和其他语言的可辨识联合，标签联合或者变体很类似。</p>
<p>例如, 假设库存跟踪系统需要用两种不同类型的条形码来追踪产品。一些产品用UPC格式标记为 1D 条形码, 这些使用数字 0 到 9. 每个条形码有一个“数字系统” 位, 后面是5个 “制造商码” 位然后是5个“产品码”位。 最后是“校验” 位来校验扫码正确性:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png"><br></div>

<p>其他产品用二维码标记, 它使用任意的 ISO 8859-1 字符并且可以编码2953个字符长度:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png"><br></div>

<p>这就方便库存跟踪系统能够用四个整数元组存储 UPC 条形码, 用一个任意长度的字符串存储二维码。</p>
<p>在 Swift 里, 枚举定义两种类型条形码可能如下所示:</p>
<pre><code>
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}</code></pre>

<p>可以这样解读:</p>
<p>“定义一个枚举类型 Barcode, 有一个upd的值对应 (Int, Int, Int, Int)类型, 和一个 qrCode 值对应 String 类型。”</p>
<p>定义没有提供任何实际的 Int 或者 String 值—它仅仅定义了对应值的类型。</p>
<p>新的条形码可以用任何一个类型来创建:</p>
<pre><code>
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
</code></pre>

<p>这个例子创建了一个新的变量 productBarcode 然后用一个元组值(8, 85909, 51226, 3)赋给它一个 Barcode.upc值。</p>
<p>相同的产品可以指定一个不同的二维码类型:</p>
<pre><code>
productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
</code></pre>

<p>这时候, 原先的 Barcode.upc 和它的整数值被新的 Barcode.qrCode 和它的字符串值取代。类型的常量或者变量可以存储 .upc 或者 .qrCode (带着对应的值), 不过在给定时间它们只能存储其中之一。</p>
<p>可以用一个switch语句判断不同的条形码类型。 这次, 无论如何, 对应的值被提取作为switch语句的部分。提取的值作为常量或者变量在switch语句的分支中使用:</p>
<pre><code>
switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
case .qrCode(let productCode):
    print("QR code: \(productCode).")
}
// 打印 "QR code: ABCDEFGHIJKLMNOP."
</code></pre>

<p>如果一个分支的所有对应值都提取成常量或者变量, 或者都提取成变量, 你可以在这个分支 名字前单独放一个let 或者 var, 为简洁性考虑:</p>
<pre><code>
switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")
case let .qrCode(productCode):
    print("QR code: \(productCode).")
}
// 打印 "QR code: ABCDEFGHIJKLMNOP."
</code></pre>

<h1 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h1><p>Associated Values 中的条形码例子展示枚举分支如何声明它们存储的不同类型的对应值。作为关联值的替代方式, 枚举分支 可以填充默认值 (raw values), 它们都是相同的类型。</p>
<p>这里有个例子,在指定的枚举分支旁存储原始 ASCII 值:</p>
<pre><code>
enum ASCIIControlCharacter: Character {
    case tab = "\t"
    case lineFeed = "\n"
    case carriageReturn = "\r"
}
</code></pre>

<p>这里, 枚举 ASCIIControlCharacter 的原始值定义为字符类型, 设成成一些比较常见的 ASCII 控制字符。</p>
<p>原始值可以是字符串, 字符, 或者任意整型或者浮点型数字类型。 每个原始值在枚举声明里必须是唯一的。</p>
<p>备注</p>
<p>原始值作为对应值是不相同的。原始值用来在首次声明枚举时填充值, 就像上面三个 ASCII 码。特定分支的原始值总是相同的。基于枚举分支之一创建一个新的常量或者变量时设置关联值, 每次设置都可以不同。</p>
<h1 id="隐式赋原始值"><a href="#隐式赋原始值" class="headerlink" title="隐式赋原始值"></a>隐式赋原始值</h1><p>使用存储整型或者字符串类型的原始值时, 你不需要显式为每个分支指定一个原始值。如果你不设置, Swift 会为你自动指定值。</p>
<p>例如, 当整型用作原始值时, 每个分支的隐式值比前一个分支多一。如果第一个分支没有设置值, 它的值是0.</p>
<p>下面的枚举是早期 Planet 枚举的细化版本, 带有整数原始值来代表距离每个星球距离太阳的顺序:</p>
<pre><code>
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}</code></pre>
上面的例子, Planet.mercury有个显式的原始值1, Planet.venus 有个显式的值 2, 以此类推。

字符串用作原始值时, 每个分支的隐式值是分支名字的文本字符串。

下面的枚举是早期 CompassPoint 枚举的细化版本, 使用字符串原始值表示每个方向的名字:
<pre><code>
enum CompassPoint: String {
    case north, south, east, west
}</code></pre>
上面的例子, CompassPoint.south 有个隐式的原始值 "south", 以此类推。

使用 rawValue 属性来访问枚举分支的原始值:
<pre><code>
let earthsOrder = Planet.earth.rawValue
// earthsOrder is 3

let sunsetDirection = CompassPoint.west.rawValue
// sunsetDirection is "west"
</code></pre>

<h1 id="用原始值初始化"><a href="#用原始值初始化" class="headerlink" title="用原始值初始化"></a>用原始值初始化</h1><p>如果你用原始值类型定义一个枚举, 枚举自动得到一个初始化方法, 这个初始化方法有一个原始值类型 (参数 rawValue) 并且返回一个枚举分支或者nil. 你可以用这个初始化方法试着创建新的枚举实例。</p>
<p>这个例子用原始值7标识 Uranus :</p>
<pre><code>
let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet 是 Planet?类型并且等于Planet.uranus
</code></pre>

<p>不是所有的整数值都能找到一个对应的星球, 不过。 因为如此, 原始值初始化方法总是返回一个可选的枚举分支. 上面的例子, possiblePlanet 是Planet?类型, 或者 “可选的 Planet.”</p>
<p>备注</p>
<p>原始值初始化方法是灵活的, 因为不是每个原始值都会返回一个枚举分支.</p>
<p>如果尝试查找位置是11的星球, 原始值初始化方法返回的 Planet 值为nil:</p>
<pre><code>
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print("Mostly harmless")
    default:
        print("Not a safe place for humans")
    }
} else {
    print("There isn't a planet at position \(positionToFind)")
}
// 打印 "There isn't a planet at position 11"
</code></pre>

<p>这个例子使用可选绑定访问原始值是11的星球。 语句 if let somePlanet = Planet(rawValue: 11) 创建了一个可选的 Planet, 然后设置 somePlanet 值为这个可选绑定的 Planet. 这种情况, 不可能获取到位置是11的星球, 所有else分支被执行了。</p>
<h1 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h1><p>递归枚举是这样一种枚举,它有另外一个枚举的实例,这个实例作为一个或者多个分支的关联值。通过在枚举分支前书写indirect 来标明枚举是递归的。告诉编译器插入必要的间接层。</p>
<p>例如, 这里有一个枚举存储了简单的算术表达式:</p>
<pre><code>
enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}
</code></pre>

<p>你也可以在枚举开始写 indirect, 来保证所有需要的枚举分支是间接的:</p>
<pre><code>
indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}
</code></pre>

<p>这个枚举可以存储三种算术表达式: 一个简单数字, 两个表达式相加, 两个表达式相乘。 加法和乘法分支对应值也是算术表达式—内嵌表达式。 例如, 表达式 (5 + 4) <em> 2 乘法右边有一个数字,乘法左边有一个表达式。 因为数据是嵌套的, 枚举存储这个数据也需要支持嵌套—意思就是说枚举需要递归。 下面的代码展示为(5 + 4) </em> 2创建了一个递归枚举 ArithmeticExpression :</p>
<pre><code>
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))
</code></pre>

<p>递归函数直接使用具有递归结构的数据。例如, 这里有个函数执行一个算术表达式:</p>
<pre><code>
func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}

print(evaluate(product))
// 打印 "18"
</code></pre>

<p>这个函数通过返回关联值执行一个简单的数字。它执行一个加法和一个乘法,执行左边的表达式和右边的表达式,然后相加或者相乘它们。</p>
<h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><p>类和结构体是通用的,灵活的结构, 成为你程序代码的构建块。通过对常量,变量,函数使用相同的语法,你定义属性和方法来给类和结构体添加功能</p>
<p>跟其他语言不一样, Swift 不要你给类和结构体创建单独的接口和实现文件。在 Swift里, 你在一个单独的文件中定义类和结构体。 这些类和结构的对外接口对于其他代码是自动可用的。</p>
<p>备注</p>
<p>类的实例一般认为是一个对象。 不过, Swift 的类和结构体在功能上比其他语言更加接近, 这种描述的功能即可用在类的实例也可以用在结构体的实例上。因为如此, 更多通用术语实例被使用了。</p>
<h1 id="比较类和结构体"><a href="#比较类和结构体" class="headerlink" title="比较类和结构体"></a>比较类和结构体</h1><p>在Swift里类和结构体有很多相同的地方,它们都可以:</p>
<p>定义属性来存储值<br>定义函数提供功能<br>定义下标,提供下标语法访问值<br>定义初始化方法来设定初始状态<br>扩展默认实现的功能<br>遵守协议提供特定类型的标准功能</p>
<p>类具备结构体没有的额外能力:</p>
<p>继承,让一个类继承另外一个类的特征。<br>类型转换,类型转换让你可以在运行是判断和解释类的实例。<br>析构器可以释放类实例分配的任何资源。<br>引用计数允许对类实例的多次引用。</p>
<p>备注</p>
<p>结构体传值时都是拷贝,它不使用引用计数。</p>
<h1 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h1><p>类和结构体有相同的定义语法。 使用class 关键字引入类,使用struct关键字引入结构体。两者都把全部定义放在一堆大括号内:</p>
<pre><code>
class SomeClass {
// class definition goes here
}
struct SomeStructure {
// structure definition goes here
}</code></pre>
备注

一旦你定义了一个新的类或者结构体, 你就有效定义了一个全新的Swift类型。给一个大写驼峰式命名 (比如 SomeClass 和 SomeStructure here) 来匹配标准 Swift 类型大写。(比如 String, Int, 和 Bool). 相反, 属性和方法总是小写驼峰式命名 (比如 frameRate 和 incrementCount)

这里有一个结构体和一个类定义的例子:
<pre><code>
struct Resolution {
var width = 0
var height = 0
}
class VideoMode {
var resolution = Resolution()
var interlaced = false
var frameRate = 0.0
var name: String?
}</code></pre>

<p>上面的例子定义了一个新的结构体 Resolution, 描述一个基于像素的显示器解决方案。 这个结构体有两个存储属性 width 和 height. 存储属性是常量或者变量,捆绑存储作为类或者结构体的一部分。这两个属性因为初始值为0而被推断为整型。</p>
<p>上面的例子同时定义了一个新类 VideoMode, 来描述一个指定的视频模式用来视频显示。 这个类有四个变量存储属性。 第一个是 resolution, 用一个新的 Resolution 结构体实例来初始化, 推断为 Resolution 属性类型。 其他三个属性, 新的 VideoMode 实例将会用一个设置为false的交错设置来初始化 (意思是 “非交错视频”), 一个回放帧率是 0.0, 一个可选字符串 name. name 属性自动得到默认值nil, 或者 “没有名字值”, 因为它是一个可选类型。</p>
<h1 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h1><p>Resolution 结构体定义和 VideoMode 类定义仅仅描述了一个 Resolution 或者 VideoMode 看起来是什么样子。 他们没有描述一个指定的 resolution 或者video mode. 为了实现这个, 你需要创建结构体或者类的实例。</p>
<p>结构体和类实例的创建语法非常相似:</p>
<pre><code>
let someResolution = Resolution()
let someVideoMode = VideoMode()</code></pre>

<p>结构体和类都使用初始化方法创建实例。 最简单的初始化语法就是使用类或者结构的类型名后面跟着一个空的括号, 比如 Resolution() 和 VideoMode(). 这个创建了类或者结构体的实例,给所有属性设置默认值。</p>
<h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h1><p>你可以用点语法访问实例的属性。 在点语法中, 属性名跟着实例名, 用点分开 (.), 没有任何空格:</p>
<pre><code>
print("The width of someResolution is \(someResolution.width)")
// 打印 "The width of someResolution is 0"
</code></pre>

<p>在这个例子里, someResolution.width 调用 someResolution 的宽度属性, 然后返回它的默认值0.</p>
<p>你可以获取子属性, 比如 width 属性就是 VideoMode 中的resolution 的属性:</p>
<pre><code>
print("The width of someVideoMode is \(someVideoMode.resolution.width)")
// 打印 "The width of someVideoMode is 0"
</code></pre>

<p>你还可以用点语法为变量属性指定新值:</p>
<pre><code>
someVideoMode.resolution.width = 1280
print("The width of someVideoMode is now \(someVideoMode.resolution.width)")
// 打印 "The width of someVideoMode is now 1280"
</code></pre>

<p>备注</p>
<p>跟 Objective-C 不同, Swift 让你可以直接设置结构体属性的子属性。 上面最后一个例子, someVideoMode 属性resolution的子属性width 就是直接设置的, 无需你把整个resolution 属性设置成新值。</p>
<h1 id="结构体类型成员初始化方法"><a href="#结构体类型成员初始化方法" class="headerlink" title="结构体类型成员初始化方法"></a>结构体类型成员初始化方法</h1><p>所有的结构体都有一个自动产生的成员初始化方法, 你可以用来初始化新的结构体实例的成员属性。 新实例属性的初始值可以根据名字传入成员初始化方法:</p>
<pre><code>
let vga = Resolution(width: 640, height: 480)
</code></pre>

<p>跟结构体不同, 类实例不会接受一个默认的成员初始化方法。</p>
<h1 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h1><p>值类型指的是赋给变量或者常量的时候会进行拷贝的类型, 或者在传给函数使用的时候。</p>
<p>通过前面的章节,你实际上已经广泛使用了值类型。 事实上, 所有Swift 的基础类型—整型, 浮点数, 布尔类型, 字符串类型, 数组和字典都是值类型, 背后都是用结构体实现。</p>
<p>Swift 中所有的结构体和枚举都是值类型。意思就是你创建的任何结构体和枚举—任何它们作为属性的值类型—当它们在你的代码中传递时总是拷贝的。</p>
<p>看一下这个例子, 使用了前一个例子中的 Resolution 结构体:</p>
<pre><code>
let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
</code></pre>

<p>这个例子定义了一个常量 hd 然后用初始化方法赋值给它。</p>
<p>然后声明一个变量 cinema 并且把hd 的当前值赋给它。因为 Resolution 是一个结构体, 存在实例的拷贝就创建了。新的拷贝赋值给 cinema. 尽管 hd 和 cinema 现在有了相同的宽和高, 它们背后是完全不同的两个实例。</p>
<p>下一步, cinema 宽度属性修改为2K标准的宽度,用于数字电影项目(2048 像素宽和 1080 像素高):</p>
<pre><code>
cinema.width = 2048
检查cinema的宽度属性,显示它的确被修改为 2048:

print("cinema is now \(cinema.width) pixels wide")
// 打印 "cinema is now 2048 pixels wide"

不过, 原来hd 的宽度属性依然是旧值 1920:

print("hd is still \(hd.width) pixels wide")
// 打印 "hd is still 1920 pixels wide"
</code></pre>

<p>一旦cinema赋值为hd的值, 存储在hd中的值就会拷贝到新的cinema实例。 最后的结果是两个完全独立的实例, 正好都包含相同的数值。 因为它们是单独的实例, 设置cinema 的宽度为 2048 并不影响 hd 的宽度。</p>
<p>相同的行为适用于枚举:</p>
<pre><code>
enum CompassPoint {
case north, south, east, west
}
var currentDirection = CompassPoint.west
let rememberedDirection = currentDirection
currentDirection = .east
if rememberedDirection == .west {
print("The remembered direction is still .west")
}
// 打印 "The remembered direction is still .west"
</code></pre>

<p>当 rememberedDirection 被赋值为 currentDirection的值时, 实际上设置的是一个值的拷贝。 改变 currentDirection 的值之后不会影响原先存储在rememberedDirection 中的值。</p>
<h1 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h1><p>跟值类型不同, 它们赋值给变量或者常量的时候不会发生拷贝, 传递给函数也一样。 相对一个拷贝, 用的是引用已经存在的实例。</p>
<p>这里有一个例子, 使用上面定义的 VideoMode 类:</p>
<pre><code>
let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0
</code></pre>

<p>这个例子声明了一个新的变量 tenEighty 并且把一个新的VideoMode 实例赋值给它。视频模式还是用的19020乘以1080 的HD 的拷贝。它设置成交错的,给了一个名字 “1080i”. 最后, 设置了25 帧每秒的帧速。</p>
<p>下一步, tenEighty 赋值给一个新的常量 alsoTenEighty, 然后改变 alsoTenEighty 帧速:</p>
<pre><code>
let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
</code></pre>

<p>因为类是引用类型, tenEighty 和 alsoTenEighty 实际上引用的是相同的 VideoMode 实例。它们不过是同一个实例的两个不同的名字。</p>
<p>查看tenEighty 的帧速属性, 显示它变成了新的帧速率 30.0:</p>
<pre><code>
print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")
// 打印 "The frameRate property of tenEighty is now 30.0"
</code></pre>

<p>注意 tenEighty 和 alsoTenEighty 声明成常量而不是变量。 不过, 你仍然可以改变 tenEighty.frameRate 和 alsoTenEighty.frameRate, 因为 tenEighty 和 alsoTenEighty 常量的值实际没有改变。 tenEighty 和 alsoTenEighty 它们不保存 VideoMode 实例, 背后它们都是引用一个 VideoMode 实例。 是VideoMode 下面的 frameRate 属性被改变了, 不是引用VideoMode 的常量值被改变。</p>
<h1 id="等号运算符"><a href="#等号运算符" class="headerlink" title="等号运算符"></a>等号运算符</h1><p>因为类是引用类型, 背后可能是多个常量或变量引用同一个类实例。 (结构体和枚举不是这样, 因为它们赋值给常量或者变量,或者传给函数总是拷贝的)</p>
<p>有时候,找出两个常量或者变量是否引用同一个类实例是很有用的。为了实现这个, Swift 提供了两个等号运算符:</p>
<pre><code>
相同 (===)
不相同 (!==)</code></pre>
用这两个运算符去判断两个常量或者变量是否引用同一个实例:
<pre><code>
if tenEighty === alsoTenEighty {
print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
}
// 打印 "tenEighty and alsoTenEighty refer to the same VideoMode instance."
</code></pre>

<p>注意“相同” (用三个等号表示) 跟“等于” (用两个等号表示)还不同:</p>
<p>“相同” 意思是两个类实例常量或者变量引用相同的类实例。<br>“等于” 意思是两个实例值相等, 一些“等于”的相关意思, 由类型设计者定义。<br>当你自定义类和结构体时, 你有责任决定两个实例“等于”在符合条件。实现“等于” and “不等于” 运算符的过程在等于运算符中描述。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>如果你熟悉 C, C++, 或者 Objective-C, 你可能会知道这些语言使用指针来指向内存地址。 Swift 的常量或者变量,引用一个实例很像C语言的指针, 但是不会直接指向内存地址, 并且不需要你书写 (*)来表明你要创建一个引用。 相反, 这些引用和Swift 中的其他任何常量或者变量的定义很像。</p>
<h1 id="在类与结构体中选择"><a href="#在类与结构体中选择" class="headerlink" title="在类与结构体中选择"></a>在类与结构体中选择</h1><p>你可以在你的代码块中同时使用类和结构体来定义自定义数据类型。</p>
<p>不过, 结构体实例总是用值传递, 而类总是使用引用传递。这就意味着它们适用于不同的任务种类。在你需要考虑数据构建和功能时, 觉得是否每一个数据构建应该选用类还是结构体。</p>
<p>一个通用的指导是, 下面一个或者多个条件符合时考虑使用一个结构体:</p>
<p>结构体的主要目的是封装一些相关的简单数据值。<br>传递结构体实例是拷贝而非引用。<br>结构体存储的任意属性也是值类型, 这些属性期望是拷贝而非引用使用。<br>结构体不需要继承其他存在类型的属性或者行为。<br>适合结构体的好例子:</p>
<p>几何形状的大小, 可能要封装一个宽度属性和一个高度属性, 两者都是浮点型。<br>使用一个系列的范围, 可能封装一个起点属性和一个长度属性, 两者都是整型。<br>3D坐标系的点, 可能要封装 x, y 和 z 属性, 每个都是浮点型。<br>其他情况, 定义一个类, 然后创建类的实例用来管理和传递引用。 在实践中, 意思自定义数据构建使用类而不是结构体。</p>
<h1 id="字符串-数组和字典的赋值和拷贝行为"><a href="#字符串-数组和字典的赋值和拷贝行为" class="headerlink" title="字符串,数组和字典的赋值和拷贝行为"></a>字符串,数组和字典的赋值和拷贝行为</h1><p>在 Swift 中, 一些基本的数据类型像String, Array, 和 Dictionary 都是用结构体实现的。 这就意味着例如字符串,数组和字典在赋值给常量或者变量时,也是被拷贝的, 传递给函数或者方法时也一样。</p>
<p>这个行为不同于 Foundation: NSString, NSArray, 和 NSDictionary, 它们是用类实现的。字符串,数组和字典在 Foundation 中赋值时用的引用而非拷贝。</p>
<p>备注</p>
<p>上面描述的拷贝。 在你的代码里这种行为似乎总是发生。 然而, Swift 只有在真正需要这么做的时候才进行实际的拷贝。 Swift管理所有的值拷贝来确保性能最优, 所以你不应避免赋值来抢占这种优化。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性关联特定的类,结构体或者枚举的值。 存储属性作为实例的一部分用来存储常量或者变量的值, 而计算属性用来计算一个值。 计算属性由类,结构体和枚举提供。 存储属性仅由类和结构体提供。</p>
<p>存储和计算属性通常关联特定类型的实例。 不过, 属性也可以管理类型本身。 比如类型属性。</p>
<p>另外, 你可以定义观察者来监视属性值的改变, 自定义响应的行为。 属性观察者可以添加到你定义的存储属性, 也可以是子类集成父类的属性。</p>
<h1 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h1><p>最简单的形式, 一个存储属性是作为特定类和结构体的常量或者变量。 存储属性既可以是变量也可以是常量。</p>
<p>你可以提供一个默认值作为存储属性定义的一部分。你也可以在初始化时改变它的初始值。对于常量存储属性也是如此。</p>
<p>下面的例子定义了一个结构体 FixedLengthRange, 描述了一个整型的范围, 它有一个长度一旦创建就不可修改:</p>
<pre><code>
struct FixedLengthRange {
var firstValue: Int
let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// the range represents integer values 0, 1, and 2
rangeOfThreeItems.firstValue = 6
// the range now represents integer values 6, 7, and 8
</code></pre>

<p>FixedLengthRange 实例有一个变量存储属性 firstValue 和一个常量存储属性 length. 上面这个例子, length 在新实例创建时初始化而后不可修改, 因为它是一个常量属性。</p>
<h1 id="常量结构体的存储属性"><a href="#常量结构体的存储属性" class="headerlink" title="常量结构体的存储属性"></a>常量结构体的存储属性</h1><p>如果你创建一个结构体实例并把它赋值给一个常量, 你就不能修改这个实例的属性, 即使它们定义成变量属性:</p>
<pre><code>
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// this range represents integer values 0, 1, 2, and 3
rangeOfFourItems.firstValue = 6
// 这里会报错, 即使 firstValue 是变量属性
</code></pre>

<p>因为rangeOfFourItems 声明成一个常量, 所以不能修改 firstValue 属性, 即使 firstValue 是一个变量属性。</p>
<p>这个行为是因为结构体是值类型。 一个值类型的实例被标记为常量, 那么它所有的属性也变成了常量。</p>
<p>对于类来说不是这样, 类是引用类型。 如果你把类实例赋值给一个常量, 你依然可以修改类的变量属性。</p>
<h1 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h1><p>延迟存储属性的初始值在首次使用时才会计算。标示延迟存储属性通过在声明前书写 lazy 修饰符实现。</p>
<p>备注</p>
<p>你应该总是把延迟属性声明成变量, 因为它的初始值可能在实例初始化完成后才获取到。Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p>
<p>延迟属性在初始化值需要依赖外部因素时很有用,它们的值直到实例初始化完成后才知道。 当属性初始值需要复杂和大量计算时，延迟属性需要时再执行加载也非常有用。</p>
<p>下面的例子使用一个延迟存储属性来避免一个复合类的不必要的初始化。这个例子定义了两个类 DataImporter 和 DataManager, 两个都没有完整显示:</p>
<pre><code>
class DataImporter {
/*
DataImporter is a class to import data from an external file.
The class is assumed to take a non-trivial amount of time to initialize.
*/
var fileName = "data.txt"
// the DataImporter class would provide data importing functionality here
}

class DataManager {
lazy var importer = DataImporter()
var data = [String]()
// the DataManager class would provide data management functionality here
}

let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// the DataImporter instance for the importer property has not yet been created
</code></pre>

<p>DataManager 类有一个存储属性 data, 用一个新的,空的字符串数组初始化。 尽管它其余的功能没有显示, DataManager 类的目的是管理和提供对字符串数据数组的访问。</p>
<p>类的部分功能是可以从文件导入数据。 这个功能由 DataImporter 类提供, 假设初始化时间微不足道。 这是因为当DataImporter实例被初始化时, DataImporter 实例需要读取文件内容到内存。</p>
<p>DataManager 实例在没有任何文件输入的情况下管理数据也是有可能的, 所以 DataManager 创建时不需要创建一个新的 DataImporter 实例。 相反, 真正需要使用DataImporter的时候再创建更有意义。</p>
<p>因为它标记了lazy 修饰符, DataImporter 实例只会在 importer 属性首次被访问的时候创建, 比如当它的 fileName 属性需要的时候:</p>
<pre><code>
print(manager.importer.fileName)
// the DataImporter instance for the importer property has now been created
// 打印 "data.txt"
</code></pre>

<p>备注</p>
<p>如果lazy 标示的属性被多线程同时访问并且这个属性还未初始化, 不能保证这个属性只会初始化一次。</p>
<h1 id="存储属性和实例变量"><a href="#存储属性和实例变量" class="headerlink" title="存储属性和实例变量"></a>存储属性和实例变量</h1><p>如果你熟悉 Objective-C, 你可能了解它提供了两种方式来存储值和引用。 除了属性, 你可以使用实例变量作为属性的后备来存储值。</p>
<p>Swift 把这些概念结合到单独的属性声明。 一个 Swift 属性没有相应的实例变量, 属性的后备存储不能直接访问。 这个方法避免了在不同上下文访问值的混乱并且把属性的声明简化到单独明确的语句。所有的属性信息—包括它的名字, 类型, 和内存管理特性—作为类型定义的部分定义在单独的位置。</p>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>除了存储属性, 类, 结构体, 和枚举还可以定义计算属性, 计算属性不存储值。相反, 它们提供了一个 getter 和一个可选的 setter 方法来简介获取或者设定其他属性和值。</p>
<pre><code>
struct Point {
var x = 0.0, y = 0.0
}
struct Size {
var width = 0.0, height = 0.0
}
struct Rect {
var origin = Point()
var size = Size()
var center: Point {
get {
let centerX = origin.x + (size.width / 2)
let centerY = origin.y + (size.height / 2)
return Point(x: centerX, y: centerY)
}
set(newCenter) {
origin.x = newCenter.x - (size.width / 2)
origin.y = newCenter.y - (size.height / 2)
}
}
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// 打印 "square.origin is now at (10.0, 10.0)"
</code></pre>

<p>这个例子定义了三个结构体使用几何形状:</p>
<p>Point 封装了一个点的x和y坐标。<br>Size 封装了一个宽度和高度。<br>Rect 用一个原点和大小定义了一个矩形。<br>Rect 结构体也提供了一个计算属性 center. 一个Rect 的当前中心位置总是取决于它的原点和大小。所以你不需要显示存储中心的值。 相反, Rect 为计算center自定义了 getter 和 setter 方法。确保你像使用真正的存储属性一样使用矩形的中心。</p>
<p>前面的例子创建了一个新的 Rect 变量 square. square 原点初始化为 (0, 0), 宽度和高度都是 10. 这个正方形在下面的图表里用蓝色正方形表示。</p>
<p>square 变量的 center 属性通过点语法访问, 这个导致 getter 方法被调用, 来获取当前属性值。 相比返回存在的值, getter 实际上计算并返回一个新的 Point 来表示正方形的中心。从上面可以看到, getter 正确返回了中心点 (5, 5).</p>
<p>center 属性然后被设置成新值 (15, 15), 这会把正方形往右上方移动, 如下图中的橙色正方形。 设置 center 属性会调用 setter 方法, 这个会修改原点属性的x和y值, 然后移动正方形到新的位置。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png"><br></div>

<h1 id="Setter-简化声明"><a href="#Setter-简化声明" class="headerlink" title="Setter 简化声明"></a>Setter 简化声明</h1><p>如果一个计算属性的 setter 没有定义设置用的新值名, 默认的名字 newValue 会被使用。这里有一个Rect 结构体的替代版本, 使用了这种简化符号:</p>
<pre><code>
struct AlternativeRect {
var origin = Point()
var size = Size()
var center: Point {
get {
let centerX = origin.x + (size.width / 2)
let centerY = origin.y + (size.height / 2)
return Point(x: centerX, y: centerY)
}
set {
origin.x = newValue.x - (size.width / 2)
origin.y = newValue.y - (size.height / 2)
}
}
}
</code></pre>

<h1 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h1><p>只有getter 没有 setter 的计算属性就是人们所说的只读计算属性。一个只读计算属性总是返回一个值, 可以通过点语法访问, 但是不可以设置为其他值。</p>
<p>备注</p>
<p>你必须把计算属性包含只读计算属性声明为变量, 因为它们的值是不固定的。let 关键字只有用于常量属性, 表明它们一旦初始化就不能再更改。</p>
<p>去掉 get 关键字和它的括号,你可以简化一个只读计算属性的声明:</p>
<pre><code>
struct Cuboid {
var width = 0.0, height = 0.0, depth = 0.0
var volume: Double {
return width * height * depth
}
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// 打印 "the volume of fourByFiveByTwo is 40.0"
</code></pre>

<p>这个例子定义了一个新的结构体 Cuboid, 表示一个三维长方体, 具有 width, height, 和 depth 属性。 这个结构体同时有一个只读计算属性 volume, 用来计算和返回长方体的体积。 设置体积是没有意义的, 因为特定体积值用哪些长宽高是不清楚的。 尽管如此, 给外部用户提供一个只读计算属性来得到立方体的计算后的体积还是有用的。</p>
<h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><p>属性观察者观察并响应一个属性值的变化。 每次属性值设置都会调用属性观察者, 即使新值和属性当前值一样也会调用。</p>
<p>你可以给任何你定义的存储属性添加观察者, 除了延迟加载的存储属性。 你也可以给一个继承来的属性添加观察者,只需要在子类重写这个属性即可。你不需要给一个非重写的计算属性添加属性观察者, 因为你可以在它们的setter 方法里观察和响应变化。</p>
<p>你可以选择定义这些属性观察者之一或全部:</p>
<p>willSet 在值存储前调用。<br>didSet 在新值存储后立即调用。<br>如果你实现一个 willSet 观察者, 它会以常量参数形式传递新属性的值。 你可以简化参数名作为 willSet 的实现部分。 如果你在实现中不写参数名和括号, 参数名默认是 newValue.</p>
<p>类似的, 如果你实现 didSet 观察者, 它包含旧的属性值作为常量产生传递。 你可以命名这个参数或者使用默认参数名 oldValue. 如果你在它自己的didset 观察者里给这个属性设置值, 你赋给它的新值会替换刚刚设置的值。</p>
<p>备注</p>
<p>父类初始化方法调用后, 父类属性的 willSet 和 didSet 观察者在子类初始化属性的时候调用。 在父类初始化调用之前, 当一个类设置它自己的属性时它们不会再被调用。</p>
<p>这里有一个 willSet 和 didSet 的例子。 下面的例子定义了一个新类 StepCounter, 用来计算一个人走路的总步数。 这个类用在输入数据或者其他记录一个人日常锻炼的计步器。</p>
<pre><code>
class StepCounter {
var totalSteps: Int = 0 {
willSet(newTotalSteps) {
print("About to set totalSteps to \(newTotalSteps)")
}
didSet {
if totalSteps > oldValue  {
print("Added \(totalSteps - oldValue) steps")
}
}
}
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
</code></pre>

<p>StepCounter 类声明了一个整型 totalSteps. 这是一个存储属性,带有 willSet 和 didSet 观察者。</p>
<p>totalSteps 属性设置新值的时候 willSet 和 didSet 观察者会调用。即使这个新值跟当前值一样, 也会调用。</p>
<p>这个例子 willSet 观察值使用一个自定义的参数 newTotalSteps 来更新值。在这个例子里, 它简单打印将要设置的值。</p>
<p>didSet 观察者在 totalSteps 值更新后调用。它比较 totalSteps 的新旧值。如果总步数增加了, 打印增加步数的信息。didSet 观察者没有提供一个自定义参数名, 用的是and the default name of oldValue is used instead.</p>
<p>备注</p>
<p>你如果传递一个带有观察者的属性给函数作为输入输出参数的话, willSet 和 didSet 观察者总会被调用。这是因为输入输出参数的内存赋值模型: 函数结尾这个值总会写回属性。</p>
<h1 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h1><p>上述描述的计算和观察属性的能力也可以用于全局变量和局部变量。全局变量定义在函数,方法,闭包或者类型上下文之外。局部变量则是定义在函数,方法或者闭包上下文内。</p>
<p>前面章节遇到的全局和局部变量都是存储变量。 存储变量很像存储属性, 提供特定类型值的存储并且允许值的设置和获取。</p>
<p>不过, 不过你可以在全局获取局部范围,定义计算变量,为存储变量定义观察者。计算变量计算它们的值, 而非存储它, 它们和计算属性写法一样。</p>
<p>备注</p>
<p>Global 常量和变量总是延迟计算, 跟延迟的存储属性类似方式。但是和延迟存储属性不同的是, 全局常量和变量不需要标记 lazy 修饰符。</p>
<p>局部常量和变量不能是延迟计算的。</p>
<h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><p>Instance 属性属于特定类型的实例。 每次你创建这种类型的实例, 它都有自己一组属性值, 和其他实例区分开来。</p>
<p>你还可以定义类型自己的属性, 而不是这种类型实例的属性。这里只会有这些属性一个拷贝, 不管你创建多少那种类型的实例。这些属性就是类型属性。</p>
<p>定义某种类型实例的通用值时类型属性很有用, 比如常量属性所有实例都可以用 (像C里面的静态常量), 或者变量属性用来存储那种类型的通用值 (想C里面的静态变量).</p>
<p>存储类型属性可以是常量或者变量。计算类型属性总是变量, 和计算实例属性一样。</p>
<p>备注</p>
<p>跟存储实例属性不同, 你必须给存储类型属性一个默认值。这是因为类型本身没有初始化方法, 不能在初始化时给存储类型属性指定一个初始值。</p>
<p>存储类型属性首次访问时是延迟初始化的。它们保证只进行一次初始化, 即使被多线程同时访问, 它们不需要用lazy 修饰符标记。</p>
<h1 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h1><p>在 C 和 Objective-C 中, 你定义静态常量和变量作为全局静态变量。 在 Swift 里, 类型属性写作类型定义的一部分, 在类型外部的大括号里, 并且每种类型属性显式局限于它支持的类型。</p>
<p>用static关键字定义类型属性。 对于类的计算类型属性, 你可以用 class 关键字去允许子类重写父类的实现。下面的例子展示存储和计算类型属性的语法:</p>
<pre><code>
struct SomeStructure {
static var storedTypeProperty = "Some value."
static var computedTypeProperty: Int {
return 1
}
}
enum SomeEnumeration {
static var storedTypeProperty = "Some value."
static var computedTypeProperty: Int {
return 6
}
}
class SomeClass {
static var storedTypeProperty = "Some value."
static var computedTypeProperty: Int {
return 27
}
class var overrideableComputedTypeProperty: Int {
return 107
}
}
</code></pre>

<p>备注</p>
<p>上面的例子是只读类型的计算属性, 不过你要可以定义读写类型的计算属性。</p>
<h1 id="查询和设置类型属性"><a href="#查询和设置类型属性" class="headerlink" title="查询和设置类型属性"></a>查询和设置类型属性</h1><p>类型查询和设置使用点语法, 跟实例属性很像。不过, 类似属性使用类型查询和设置, 不是使用类型的实例。 例如:</p>
<pre><code>
print(SomeStructure.storedTypeProperty)
// 打印 "Some value."
SomeStructure.storedTypeProperty = "Another value."
print(SomeStructure.storedTypeProperty)
// 打印 "Another value."
print(SomeEnumeration.computedTypeProperty)
// 打印 "6"
print(SomeClass.computedTypeProperty)
// 打印 "27"
</code></pre>

<p>下面的例子用了两个存储属性作为结构体的一部分, 对多个音轨模拟了一个音频水平计。每个音轨有一个在0和10之间的整数音频水平。</p>
<p>下面图展示了两个音轨怎样合成一个立体音频水平计。当一个音轨的音频水平是0时, 那个音轨的没有灯会亮。 当这个音频水平是10时, 那个音轨的灯全部点亮。 这个图中, 左边音轨当前水平值是 9, 右边音轨当前水平是 7:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png"><br></div>

<p>上面描述的音轨用 AudioChannel 结构体的实例表示:</p>
<pre><code>
struct AudioChannel {
static let thresholdLevel = 10
static var maxInputLevelForAllChannels = 0
var currentLevel: Int = 0 {
didSet {
if currentLevel > AudioChannel.thresholdLevel {
// cap the new audio level to the threshold level
currentLevel = AudioChannel.thresholdLevel
}
if currentLevel > AudioChannel.maxInputLevelForAllChannels {
// store this as the new overall maximum input level
AudioChannel.maxInputLevelForAllChannels = currentLevel
}
}
}
}
</code></pre>

<p>AudioChannel 结构体定义了两个存储类型属性来支持它的功能。 第一个是 thresholdLevel, 定义了音频水平最大阈值。对于所有AudioChannel 实例这是一个常量值10. 如果音频信号遇到大于10的值, 它封顶就是阈值。</p>
<p>第二个类型属性是一个变量存储属性 maxInputLevelForAllChannels. 这个保持追踪 AudioChannel 实例接收的最大输入值。 它的初始值是 0.</p>
<p>AudioChannel 结构体同时定义了一个存储实例属性currentLevel, 用来表示0到10之间的音轨当前音频水平。</p>
<p>currentLevel 属性有一个didSet 属性观察者来判断 currentLevel 设置时的值。这个观察者执行两个判断:</p>
<p>如果新值大于阈值, currentLevel 封顶值就是阈值。<br>如果新值(还没有封顶) 大于之前 AudioChannel 实例接收的值, 属性观察者把新的 currentLevel 值存储到 maxInputLevelForAllChannels 类型属性中。<br>备注</p>
<p>第一个判断, didSet 观察值把 currentLevel 设置成一个不同值。这个不会导致观察者被再次调用。</p>
<p>你可以用 AudioChannel 结构体创建两个新的音轨 leftChannel 和 rightChannel, 来表示这个音频水平是一个立体声系统:</p>
<pre><code>
var leftChannel = AudioChannel()
var rightChannel = AudioChannel()
If you set the currentLevel of the left channel to 7, you can see that the maxInputLevelForAllChannels type property is updated to equal 7:

leftChannel.currentLevel = 7
print(leftChannel.currentLevel)
// 打印 "7"
print(AudioChannel.maxInputLevelForAllChannels)
// 打印 "7"
If you try to set the currentLevel of the right channel to 11, you can see that the right channel’s currentLevel property is capped to the maximum value of 10, and the maxInputLevelForAllChannels type property is updated to equal 10:

rightChannel.currentLevel = 11
print(rightChannel.currentLevel)
// 打印 "10"
print(AudioChannel.maxInputLevelForAllChannels)
// 打印 "10"
</code></pre>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法是对应特定类型的函数。类,结构体和枚举都可以定义实例方法, 封装了特定的任务和功能用于给定类型的实例。类, 结构体和枚举也可以定义类型方法, 它们对应类型本身。类型方法很像 Objective-C 中的类方法。</p>
<p>结构体与枚举可以定义方法,是Swift 与 C 和 Objective-C之间一个巨大的区别。在Objective-C, 只有类可以定义方法。在 Swift, 你可以选择是否定义一个类,结构体或者枚举, 并且可以灵活定义你创建类型下的方法。</p>
<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p>实例方法属于特定类,结构体或者枚举实例的函数。或者提供方式访问和修改实例的属性,或者提供实例目的相关的功能。实例方法和函数语法一样。</p>
<p>在它所属的类型开闭括号里书写一个实例方法。 一个实例方法可以隐式访问这个类型所有其他的实例方法和属性。一个实例方法只能被它属于的类型调用。 没有实例不能单独调用。</p>
<p>这里有个例子,定义了一个简单的类 Counter , 来计算一个行为的次数:</p>
<pre><code>
class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}
</code></pre>
Counter 类定义了三个实例方法:

increment() 把计数器加1.
increment(by: Int) 把计数器增加指定整数。
reset() 重置计数器为0
Counter 类同时声明了一个变量属性, count, 来跟踪当前计步器的值。

调用实例方法跟属性一样使用点语法:
<pre><code>
let counter = Counter()
// the initial counter value is 0
counter.increment()
// the counter's value is now 1
counter.increment(by: 5)
// the counter's value is now 6
counter.reset()
// the counter's value is now 0
</code></pre>

<p>Function 参数可以用一个名字和一个参数标签。</p>
<h1 id="self-属性"><a href="#self-属性" class="headerlink" title="self 属性"></a>self 属性</h1><p>每个类型的实例都有一个隐式的属性 self, 等于实例自己。 你可以用在实例方法内引用当前实例。</p>
<p>The increment() method in the example above could have been written like this:</p>
<pre><code>
func increment() {
    self.count += 1
}</code></pre>

<p>在实践中, 你不需要经常在代码中写self. 如果不显示书写 self, 一旦你在一个方法里使用了已知的属性或者方法名, Swift 就会假设你引用的是当前实例的属性或者方法。这个假设在Counter三个实例方法中count被证明了。</p>
<p>这个规则的例外情况是, 一个实例方法的参数名和实例的属性名一样。这种情况下, 参数优先, 有必要用更有效的方式调用属性。用self 属性来区分参数名和属性名。</p>
<p>这里, self 避免一个方法参数叫 x 与一个实例属性叫 x 的混乱:</p>
<pre><code>
struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOf(x: Double) -> Bool {
        return self.x > x
    }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOf(x: 1.0) {
    print("This point is to the right of the line where x == 1.0")
}
// 打印 "This point is to the right of the line where x == 1.0"
</code></pre>

<p>不带self 前缀, Swift 会假设两个 x 都是引用方法的参数 x.</p>
<h1 id="在实例方法中修改值类型"><a href="#在实例方法中修改值类型" class="headerlink" title="在实例方法中修改值类型"></a>在实例方法中修改值类型</h1><p>结构体和枚举是值类型。默认情况下, 值类型的属性不能在实例方法内部修改。</p>
<p>不过, 如果你需要再特定方法中修改结构体和枚举的属性, 你可以选择这个方法的变异行为。方法就可以在内部变异它的属性, 方法结束后这个种改变会写回先前的结构体。这个方法也可以给隐式的self属性指定一个完全全新的实例, 方法结束后这个新值会替代原先存在的。</p>
<p>可以在方法的func 关键字前加上 mutating 关键字来实现这个行为:</p>
<pre><code>
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// 打印 "The point is now at (3.0, 4.0)"
</code></pre>

<p>Point 结构体定义了一个变异方法 moveBy(x:y:), 使用一个特定数量移动一个点。不是返回一个新的点, 这个方法实际上修改了这个点。mutating 关键字加在定义是为了保证它可以修改自己的属性。</p>
<p>注意你不能用结构体类型的常量来调用变异方法, 因为它的属性不能改变, 即使它们是变量属性:</p>
<pre><code>
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveBy(x: 2.0, y: 3.0)
// 这会报一个错误
</code></pre>

<h1 id="在变异方法里赋值给self"><a href="#在变异方法里赋值给self" class="headerlink" title="在变异方法里赋值给self"></a>在变异方法里赋值给self</h1><p>变异方法可以把一个全新的实例赋给隐式 self 属性。上面的 Point 例子可以用下面的写法代替:</p>
<pre><code>
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}</code></pre>

<p>这个版本的变异 moveBy(x:y:) 方法创建了一个全新的结构体,它的x和y的值被设置为目标位置。调用这个版本的结果和早前版本是完全一样的。</p>
<p>枚举的变异方法可以把隐式self属性设置为一个不同的分支:</p>
<pre><code>
enum TriStateSwitch {
    case off, low, high
    mutating func next() {
        switch self {
        case .off:
            self = .low
        case .low:
            self = .high
        case .high:
            self = .off
        }
    }
}
var ovenLight = TriStateSwitch.low
ovenLight.next()
// ovenLight is now equal to .high
ovenLight.next()
// ovenLight is now equal to .off
</code></pre>

<p>这个例子定义了三联开关的枚举。 每次调用 next() 方法这个开关就在三种不同的状态下循环。</p>
<h1 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h1><p>实例方法, 如上所述, 是特定类型实例调用的方法。 你也可以定义类型本身调用的方法。这些方法称为类型方法。在方法的func 关键字前加上static 关键来标示类型方法。类可以用class 关键字来允许子类覆盖父类的方法实现。</p>
<p>备注</p>
<p>在 Objective-C 中, 你只能给类定义类型级别的方法。 而在 Swift 里, 你可以给类,结构体和枚举都定义类型级别的方法。每个类型方法仅限于它支持的类型使用。</p>
<p>类型方法使用点语法调用, 和实例方法一样。 不过, 你使用类型调用方法而不是类型的实例。这里有一个类,展示在一个类如何调用类型方法:</p>
<pre><code>
class SomeClass {
    class func someTypeMethod() {
        // type method implementation goes here
    }
}
SomeClass.someTypeMethod()
</code></pre>

<p>在类型方法的函数体中, 隐式self属性调用类型自己而非类型的实例。 这就意味着你可以用self属性来消除类型属性和类型方法参数之间的歧义, 跟处理实例属性和实例方法参数一样。</p>
<p>更一般的是, 用在类型方法内的任何不合适的方法和属性名将会引用其他类型级别的方法和属性。一个类型方法可以用其他方法名调用另外一个类型方法, 不需要再前面加上类型名。相似的, 结构体和枚举的类型方法可以用类型属性名访问类型属性。</p>
<p>下面的例子定义了一个结构体 LevelTracker, 用来跟踪玩家通过游戏不同级别或者阶段的过程。它是一个单人游戏, 但是可以在单机上存储多个玩家的信息。</p>
<p>第一次玩游戏时所有游戏的关都是锁定的 (除了第一关)。 每当玩家完成一关, 这一关在设备上对所有玩家打开。LevelTracker 结构体使用类型属性和方法来跟踪哪些关已经打开了。它同时跟踪单个玩家所在的当前关。</p>
<pre><code>
struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1
    static func unlock(_ level: Int) {
        if level > highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func isUnlocked(_ level: Int) -> Bool {
        return level <= highestunlockedlevel="" }="" @discardableresult="" mutating="" func="" advance(to="" level:="" int)="" -=""> Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
</=></code></pre>

<p>LevelTracker 结构体保持记录任何玩家已经打开的最高关。这个值存储在类型属性 highestUnlockedLevel.</p>
<p>LevelTracker 同时定义了两个类型方法来使用highestUnlockedLevel 属性。第一个类型方法是 unlock(<em>:), 一旦新的关通过了就更新 highestUnlockedLevel 的值。第二个是便利类型方法 isUnlocked(</em>:), 如果特定关已经通过就返回真。 (注意,这两个方法访问 highestUnlockedLevel 类型属性需要写成 LevelTracker.highestUnlockedLevel.)</p>
<p>除了它的类型属性和方法, LevelTracker 还跟踪了个体玩家通过这个游戏的过程。它用一个实例属性 currentLevel 来跟中玩家当前正在玩的关。</p>
<p>为了帮助管理 currentLevel 属性, LevelTracker 定义了一个实例方法 advance(to:). 在更新currentLevel的值之前, 这个方法会判断请求的关是否打开。advance(to:) 方法返回布尔值是否可以设置currentLevel. 因为调用 advance(to:) 方法去忽略这个返回值是不需要一个错误, 这个函数被标记为 @discardableResult 属性。</p>
<p>LevelTracker 结构体和 Player 类一起使用, 下面展示跟踪和更新个体玩家的过程:</p>
<pre><code>
class Player {
    var tracker = LevelTracker()
    let playerName: String
    func complete(level: Int) {
        LevelTracker.unlock(level + 1)
        tracker.advance(to: level + 1)
    }
    init(name: String) {
        playerName = name
    }
}</code></pre>

<p>Player 创建了新的LevelTracker 实例来跟踪玩家的过程。它同时提供了一个方法 complete(level:), 一旦玩家通过一关就会调用。这个方法为所有玩家打开下一关并且更新玩家的过程,把他们带到下一关。(advance(to:) 的布尔返回值被忽略了, 因为通过调用 LevelTracker.unlock(_:) 已经知道这个关被打开了)</p>
<p>你可以为一个新的玩家创建一个Player 类的实例, 并且看看玩家通过第一关会发生什么:</p>
<pre><code>
var player = Player(name: "Argyrios")
player.complete(level: 1)
print("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
// 打印 "highest unlocked level is now 2"
如果你创建第二个玩家, 如果尝试移动他到没有任何玩家打开的关, 那么尝试设置玩家的当前关就会失败:

player = Player(name: "Beto")
if player.tracker.advance(to: 6) {
    print("player is now on level 6")
} else {
    print("level 6 has not yet been unlocked")
}
// 打印 "level 6 has not yet been unlocked"
</code></pre>

<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><p>类,结构体和枚举都快要定义下标, 它是用来访问集合元素的速写方式。你无需单独的设置和获方法,使用下标索引就可以设置和获取元素值。例如, 你访问数组实例的元素用 someArray[index] ,访问字典实例元素用 someDictionary[key].</p>
<p>你可以为单个类型定义多个下标, 选择适当的下标重载使用取决于你传给下标的索引值的类型。一维下标没有限制, 你可以用多个输入参数定义下标来满足自定义类型的需要。</p>
<h1 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h1><p>在一个方括号里写一个或多个值,下标就可以查询一个类型的实例。这个语法跟实例方法和计算属性的语法很像。使用 subscript 关键字定义下标, 同时指定一个或多个输入参数和一个返回值, 跟实例方法一样。和实例方法不同的是, 下标可以读写或者只读。和计算属性方式一样,这个用 setter 和 getter 实现:</p>
<pre><code>
subscript(index: Int) -> Int {
get {
// return an appropriate subscript value here
}
set(newValue) {
// perform a suitable setting action here
}
}
</code></pre>

<p>newValue 类型和返回值类型一样。 和计算属性一样, 你可以不指定setter 的参数名。默认的参数名 newValue 会提供。</p>
<p>和只读计算属性一样, 只读下标可以去掉get 关键字:</p>
<pre><code>
subscript(index: Int) -> Int {
// return an appropriate subscript value here
}</code></pre>
这里有个只读下标实现的例子, 它定义了一个结构体 TimesTable 来表示整数n倍数表:
<pre><code>
struct TimesTable {
let multiplier: Int
subscript(index: Int) -> Int {
return multiplier * index
}
}
let threeTimesTable = TimesTable(multiplier: 3)
print("six times three is \(threeTimesTable[6])")
// 打印 "six times three is 18"
</code></pre>

<p>这个例子里, 一个新的 TimesTable 实例被创建来表示整数的3倍数表。数字3传入结构体的初始化方法来作为乘法的参数。</p>
<p>你可以用下标获取 threeTimesTable 实例, 通过调用 threeTimesTable[6]. 这请求三倍数表中的第六个实体, 返回18, 或者3乘以 6.</p>
<p>备注</p>
<p>n倍数表基于固定的数学规则。把 threeTimesTable[someIndex] 设置为一个新值是不合适的。所以 TimesTable 的下标定义为只读的。</p>
<h1 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h1><p>下标的确切意思取决于它使用的上下文。下标是访问集合元素的速写方式。你可以自由的用最合适的方式为特定的类或者结构体实现下标。</p>
<p>例如, Swift的字典类型实现一个下标去存取存储在字典实例中的值。你可以在下标括号里使用字典的键来设置值, 也可以给下标设置值:</p>
<pre><code>
var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</code></pre>

<p>上面的例子定义了一个变量 numberOfLegs , 然后用一个包含三个键值对的字典字面量来初始化它。numberOfLegs 字典类型被推断为 [String: Int]. 字典创建后, 这个例子使用下标赋值,向字典添加一个键值对 “bird” 和 2 .</p>
<p>备注</p>
<p>Swift 的字典类型实现的键值下标接受和返回一个可选类型。 对于上面的 numberOfLegs 字典, 键值下标接受和返回一个 Int? 类型值, 或者 “可选 int”. 字典类型使用了一个可选的下标类型来模拟这个事实,不是每一个键都有对应的值, 同时提供了一个方法去删除值,只需要给这个键赋一个nil即可。</p>
<h1 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h1><p>下面可以接受任意数量的输入参数, 并且这些输入参数可以是任意类型。 下标也可以返回任意类型。 下标可以使用可变参数, 但是它们不能使用输入输出参数也不能给参数提供默认值。</p>
<p>一个类或者结构体可以提供需要的多个下标实现, 使用的下标基于值类型或者包含在下标括号里的值来推断。这个多个下标的定义就是人们常说的重载。</p>
<p>虽然下标接受一个参数很常见, 但是如果它符合你的类型,你还是可以定义个带多个参数的下标。下面的例子定义了一个结构体 Matrix, 用来表示一个二维的浮点值矩阵。Matrix 结构体的下标带有两个参数:</p>
<pre><code>
struct Matrix {
let rows: Int, columns: Int
var grid: [Double]
init(rows: Int, columns: Int) {
self.rows = rows
self.columns = columns
grid = Array(repeating: 0.0, count: rows * columns)
}
func indexIsValid(row: Int, column: Int) -> Bool {
return row >= 0 && row < rows && column >= 0 && column < columns
}
subscript(row: Int, column: Int) -> Double {
get {
assert(indexIsValid(row: row, column: column), "Index out of range")
return grid[(row * columns) + column]
}
set {
assert(indexIsValid(row: row, column: column), "Index out of range")
grid[(row * columns) + column] = newValue
}
}
}</code></pre>

<p>Matrix 提供了一个初始化方法,它有两个参数 rows 和 columns, 然后创建一个足够存储 rows * columns 个浮点值的数组。矩阵的每个位置的值初始化为 0.0. 为了实现这个, 数组的大小, 初始的cell 值是 0.0, 传给数组的初始化方法, 初始化一个正确大小的数组。</p>
<p>传入一个合适的行列值给初始化方法,你可以创建一个 Matrix 的实例:</p>
<pre><code>
var matrix = Matrix(rows: 2, columns: 2)</code></pre>
前面的例子创建两行两列的 Matrix 实例。实例的grid 数组实际上是一个平的矩阵:

<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png">
</div>

通过传入行列值给下标来设置矩阵中的值,用逗号分开:
<pre><code>
matrix[0, 1] = 1.5
matrix[1, 0] = 3.2</code></pre>

<p>这两个语句调用下标的setter 设置矩阵右上方位置的值为1.5 (行是0列是1), 然后设置左下位置的值为3.2(行是1列是0):</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png"><br></div>

<p>矩阵下标的 getter 和 setter 都包含一个断言,用来判断下标的行列值是有效的。 为了协助这些断言, Matrix 含有一个便利方法 indexIsValid(row:column:), 用来判断需要的行列是否在矩阵的边界内:</p>
<pre><code>
func indexIsValidForRow(row: Int, column: Int) -> Bool {
    return row >= 0 && row < rows && column >= 0 && column < columns
}</code></pre>

<p>如果你访问越界的下标,就会触发断言:</p>
<pre><code>
let someValue = matrix[2, 2]
// 触发断言, 因为 [2, 2] 超出了矩阵的边界
</code></pre>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>一个类可以从另外一个类继承方法,属性和其他特征。当一个类继承另外一个类时, 继承类叫子类, 被继承的类叫超类。继承是类区别于Swift其他类型的基本行为。</p>
<p>Swift 中的类可以调用和访问超类的方法,属性和下标,并且可以覆盖这些方法,属性和下标来重定义或者修改它们的行为。 Swift 会通过判断覆定义在超类是否有对应定义来确保覆盖的正确。</p>
<p>类可以给继承属性添加属性观察者,在属性值改变时可以接到通知。属性观察者可以添加给任何一个属性, 不管它本来定义成存储还是计算属性。</p>
<h1 id="定义一个基类"><a href="#定义一个基类" class="headerlink" title="定义一个基类"></a>定义一个基类</h1><p>任何不继承其他类的类就叫做基类。</p>
<p>备注</p>
<p>Swift 的类不会继承一个通用基类。如果你定义的类没有超类,它就会自动变成基类。</p>
<p>下面的例子定义了一个基类 Vehicle. 这个基类定义了一个存储属性 currentSpeed, 有个默认值 0.0 (推断是一个浮点类型的属性)。 currentSpeed 属性被只读计算字符串属性 description 用来创建一个汽车的描述。</p>
<p>Vehicle 基类同时定义了一个方法 makeNoise. 这个方法实际上不对基类实例做任何事, 但是后面会被子类定制行为:</p>
<pre><code>
class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return "traveling at \(currentSpeed) miles per hour"
    }
    func makeNoise() {
        // do nothing - an arbitrary vehicle doesn't necessarily make a noise
    }
}
</code></pre>

<p>使用初始化语法创建一个 Vehicle 实例, 写作类型名后面跟着括号:</p>
<pre><code>
let someVehicle = Vehicle()
</code></pre>
已经创建了一个新的 Vehicle 实例, 你可以访问它的 description 属性,来打印汽车当前速度的人类可读的信息:
<pre><code>
print("Vehicle: \(someVehicle.description)")
// Vehicle: traveling at 0.0 miles per hour
</code></pre>

<p>Vehicle 类为任意汽车定义了通用特性, 但是对于自己没有多少用处。为了让它变的更有用, 你需要充完善它来描述更具体的汽车。</p>
<h1 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h1><p>子类化的行为是基于现有类的一个新类。子类从现有类继承特性, 然后你可以完善。你也可以给子类添加新的特性。</p>
<p>为了标明子类有一个超类, 子类名写在超类名之前,用冒号分开:</p>
<pre><code>
class SomeSubclass: SomeSuperclass {
    // subclass definition goes here
}</code></pre>
下面的例子定义了一个子类 Bicycle, 有一个超类 Vehicle:
<pre><code>
class Bicycle: Vehicle {
    var hasBasket = false
}</code></pre>

<p>新的 Bicycle 类自动获得 Vehicle 的所有特性, 比如 currentSpeed 和 description 属性还有它的 makeNoise() 方法。</p>
<p>除了继承的特性, Bicycle 类还定义了一个新的存储属性, hasBasket, 默认值是 false (属性类型推断为布尔型).</p>
<p>默认情况下, 你创建的任何 Bicycle 实例都不会有个篮子。你可以在Bicycle 实例创建后给把它的 hasBasket 属性设置为真:</p>
<pre><code>
let bicycle = Bicycle()
bicycle.hasBasket = true</code></pre>
你可以修改继承来的 currentSpeed 属性, 同时查询实例继承的 description 属性:
<pre><code>
bicycle.currentSpeed = 15.0
print("Bicycle: \(bicycle.description)")
// Bicycle: traveling at 15.0 miles per hour
</code></pre>

<p>子类本身也可以子类化。下面的例子创建了一个双座自行车,作为 Bicycle 的子类:</p>
<pre><code>
class Tandem: Bicycle {
    var currentNumberOfPassengers = 0
}</code></pre>

<p>Tandem 从Bicycle继承了所有的属性和方法, Bicycle 依次继承了Vehicle的所有属性和方法。 Tandem 子类也添加了一个新的存储属性 currentNumberOfPassengers, 默认值是 0.</p>
<p>如果你创建一个 Tandem 实例, 你可以使用它的新的和继承来的任意属性, 也可以查询继承自Vehicle的只读 description 属性:</p>
<pre><code>
let tandem = Tandem()
tandem.hasBasket = true
tandem.currentNumberOfPassengers = 2
tandem.currentSpeed = 22.0
print("Tandem: \(tandem.description)")
// Tandem: traveling at 22.0 miles per hour
</code></pre>

<h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><p>一个子类可以自定义实现另外继承超类的一个实例方法,类型方法,实例属性,类型属性或者下标。</p>
<p>为了重写另外继承的特性, 在需要重写的定义前书写 override 关键字。 做这样的澄清,你想要提供一个重写,却没有提供一个匹配的定义的错误。 意外重写会导致不希望的行为, 重写不带上 override 关键字,代码编译时会报错。</p>
<p>override 关键字提醒 Swift 编译器去检查超类是否有一个匹配的声明。这个判断确保你的重新定义是正确的。</p>
<h1 id="访问超类的方法-属性和下标"><a href="#访问超类的方法-属性和下标" class="headerlink" title="访问超类的方法,属性和下标"></a>访问超类的方法,属性和下标</h1><p>当你为子类提供方法,属性和下标的重写时, 使用超类实现作为子类重写的部分是很有用的。比如, 你可以完善已存在实现的行为, 或者在一个已存在的继承变量存储改变的值。</p>
<p>任何合适的地方, 你都可以用super 前缀访问超类版本的方法,属性或者下标:</p>
<p>重写的方法 someMethod() 可以在实现里通过super.someMethod() 调用超类的 someMethod().<br>重写的属性 someProperty 可以在重写的setter和getter 实现里通过super.someProperty访问超类的 someProperty.<br>重写的下标 someIndex 可以在重写的下标实现里通过super[someIndex] 访问超类的下标 super[someIndex].</p>
<h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><p>你可以重写一个实例或者类型方法,在你的子类中提供一个定制的方法实现。</p>
<p>下面的例子定义了一个 Vehicle 的子类 Train, 它重写了继承自Vehicle 的 makeNoise()方法:</p>
<pre><code>
class Train: Vehicle {
    override func makeNoise() {
        print("Choo Choo")
    }
}</code></pre>
如果你创建了一个新的 Train 实例并且调用它的 makeNoise() 方法, 你可以看到 Train 子类版本的方法被调用了:
<pre><code>
let train = Train()
train.makeNoise()
// 打印 "Choo Choo"
</code></pre>

<h1 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h1><p>你可以重写一个继承实例或者类型属性,来给属性提供自定义的 getter 和 setter, 或者添加属性观察者确保重写属性可以观察潜在的属性值的改变。</p>
<h1 id="重写属性的-Getters-和-Setters"><a href="#重写属性的-Getters-和-Setters" class="headerlink" title="重写属性的 Getters 和 Setters"></a>重写属性的 Getters 和 Setters</h1><p>你可以提供一个自定义的 getter (和setter, 如果合适) 来重写任何继承的属性, 不管继承的属性是存储属性还是计算属性。 子类并不知道继承属性是计算的还是存储的—它只知道继承来的属性有一个名字和类型。 你应该声明重写属性的名字和类型, 来确保编译器判断你重新的属性和超类的属性有一样的名字和类型。</p>
<p>你可以在子类重写的时候提供setter和getter,把继承的只读属性变成读写属性。不过你不能把继承的读写属性变为只读属性。</p>
<p>备注</p>
<p>如果你提供一个setter作为重写的一部分, 你必须也提供一个getter. 如果你不想在getter里改变继承过来的属性的值, 你可以简单通过返回 super.someProperty 获取这个值, someProperty 是你要重写属性的名字。</p>
<p>下面的例子定义了一个新的类 Car, 它是 Vehicle 的子类。 Car 类引入了一个新的存储属性 gear, 默认值是 1. Car 类同时重写从Vehicle 继承来的 description 属性, 提供包含当前档位的自定义描述:</p>
<pre><code>
class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.description + " in gear \(gear)"
    }
}</code></pre>

<p>description 属性重写首先调用 super.description, 它放回 Vehicle 类的description 属性。Car 类的 description 版本在描述后添加了一些额外的文本来提供当前档位的信息。</p>
<p>如果你创建一个新的 Car 实例并且设置它的 gear 和 currentSpeed 属性, 你可以看到它会返回自定义的描述信息:</p>
<pre><code>
let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print("Car: \(car.description)")
// Car: traveling at 25.0 miles per hour in gear 3
</code></pre>

<h1 id="重写属性观察者"><a href="#重写属性观察者" class="headerlink" title="重写属性观察者"></a>重写属性观察者</h1><p>你可以用属性重写给继承来的属性添加观察者。这个确保继承来的属性改变时你会得到通知, 不管属性原先是怎么实现的。</p>
<p>备注</p>
<p>你不能给继承来的常量存储属性或者只读计算属性添加属性观察者。这些属性的值不能设置, 因此不适合在重写时提供 willSet 或者 didSet.</p>
<p>注意你也不能对同一个属性同时提供重写的 setter 和 重写的属性观察者。 如果你想观察属性值的变化, 而且你已经给属性提供了自定义的 setter, 你可以在自定义的setter里观察任何值的变化。</p>
<p>下面的例子定义了一个新的类 AutomaticCar, 它是Car的子类。 AutomaticCar 类表示一辆车是自动挡的。它会基于当前速度自动选择合适的档位:</p>
<pre><code>
class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1
        }
    }
}</code></pre>

<p>只要你设置 AutomaticCar 实例的 currentSpeed 属性, 属性的didSet 观察者会为新速度设置合适的档位。特别的是, 属性观察选择的档位等于新的 currentSpeed 值除以 10, 然后转换为最接近的整数再加1. 35.0 的速度产生的档位是 4:</p>
<pre><code>
let automatic = AutomaticCar()
automatic.currentSpeed = 35.0
print("AutomaticCar: \(automatic.description)")
// AutomaticCar: traveling at 35.0 miles per hour in gear 4
</code></pre>

<h1 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h1><p>你可以通过标记为final来防止方法,属性或者下标被重写。 你可以在方法,属性或者下标的关键字前书写final标识符来实现这个 (比如 final var, final func, final class func, 和 final subscript)。</p>
<p>在子类任何尝试去重写一个 final 方法,属性或者下标都会触发编译器错误。 在扩展中添加到类里的方法,属性或者下标也可以在扩展定义时标记为 final.</p>
<p>你可以在类定义的关键字前标记final来表明整个类都是不能重写的。任何尝试去子类化这个类都会报一个编译器错误。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化是类,结构体或者枚举使用前的准备过程。这个过程包括给每个存储属性设置初始化值并且执行其他实例使用前的设置和初始化工作。</p>
<p>通过定义初始化方法来实现这个过程, 它很像特殊函数用来创建特定类型的实例。跟 Objective-C 初始化方法不同, Swift 初始化方法不会返回值。它们的主要任务是确保一个类型的实例在使用前可以正确的初始化。</p>
<p>类类型的实例还可以实现去初始化方法, 它在类销毁之前执行清理工作。 </p>
<h1 id="为存储属性设置初始值"><a href="#为存储属性设置初始值" class="headerlink" title="为存储属性设置初始值"></a>为存储属性设置初始值</h1><p>类或者结构体实例创建的时候,它们的存储属性必须设置成合适的初始值。存储属性不可以是未设置状态。</p>
<p>你可以在初始化方法内给存储属性设置初始值, 或者指定一个默认属性值作为属性定义的部分。这些操作下面会描述。</p>
<p>备注</p>
<p>当你给存储属性指定默认值, 或者在初始化方法里给它设置初始值, 这个设置是直接的, 没有调用任何属性观察者。</p>
<h1 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h1><p>初始化方法用来创建特定类型的实例。最简单的形式, 一个初始化方法很像一个没有参数的实例方法, 用关键字 init 书写:</p>
<pre><code>
init() {
// perform some initialization here
}</code></pre>
下面的例子定义了一个新的结构体 Fahrenheit,它存储了 Fahrenheit 温度表达式。Fahrenheit 结构体有一个存储属性temperature, 类型是 Double:
<pre><code>
struct Fahrenheit {
var temperature: Double
init() {
temperature = 32.0
}
}
var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// 打印 "The default temperature is 32.0° Fahrenheit"
</code></pre>

<p>这个结构体定义了一个单独的初始化方法 init, 没有带参数, 初始化temperature值为 32.0 (Fahrenheit 温度的冰点)。</p>
<h1 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h1><p>你可以在初始化方法内部设置存储属性的值, 就像上面展示的那样。 另外一种方法是, 可以指定默认属性值作为属性定义的一部分。</p>
<p>备注</p>
<p>如果一个属性总是带有相同的初始值, 提供一个默认值而不是在初始化中设置一个值。结果是一样的, 不过默认值把属性的初始化跟它的定义联系的更紧密。 它更短,更清晰。保证你可以根据默认值推断属性的类型。默认值让你更容易利用默认初始化方法和初始化方法继承, 本章稍后会描述。</p>
<p>你可以用简单的形式写上面的结构体 Fahrenheit ,在属性声明的时候给它提供一个默认值:</p>
<pre><code>
struct Fahrenheit {
var temperature = 32.0
}</code></pre>

<h1 id="自定义初始化"><a href="#自定义初始化" class="headerlink" title="自定义初始化"></a>自定义初始化</h1><p>你可以用输入参数和可选属性类型来自定义初始化过程。或者通过初始化时赋值常量属性, 下面会描述。</p>
<h1 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h1><p>你可以提供初始化参数作为初始化方法定义的部分, 定义类型和值名。初始化参数跟函数和方面参数的语法和能力是一样的。</p>
<p>下面的例子定义了一个结构体 Celsius, 存储摄氏温度的表达。 Celsius 结构体实现了两个自定义的初始化方法init(fromFahrenheit:) 和 init(fromKelvin:), 它们使用不同的温标来初始化结构体的实例:</p>
<pre><code>
struct Celsius {
var temperatureInCelsius: Double
init(fromFahrenheit fahrenheit: Double) {
temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
temperatureInCelsius = kelvin - 273.15
}
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
</code></pre>

<p>第一个初始化方法只有一个参数,这个参数有一个参数标签 fromFahrenheit 和一个参数名 fahrenheit. 第二个初始化方法也只有一个参数,这个参数有一个标签 fromKelvin 和一个参数名 kelvin. 两个初始化方法都是把参数转换为对应的摄氏温度值并把它存在属性 temperatureInCelsius 里。</p>
<h1 id="参数名和参数标签"><a href="#参数名和参数标签" class="headerlink" title="参数名和参数标签"></a>参数名和参数标签</h1><p>跟函数和方法参数一样, 初始化参数可以用参数名和参数标签。</p>
<p>不过, 初始化方法不能像函数和方法那样在括号前有一个标示函数名。因此, 所以初始化方法的参数名和参数类型扮演很重要的角色,用来区分应该调用哪个初始化方法。因为这个, 如果你不能提供参数标签,Swift 会自动提供一个这样的标签。</p>
<p>下面的例子定义了一个结构体 Color, 带有三个常量属性 red, green, 和 blue. 这些属性存储0.0到1.0之间的值来表示 red, green, 和 blue 在颜色中的数量。</p>
<p>Color 为三原色提供了一个初始化方法,带有三个有命名的参数,类型是 Double. Color 同时提供了带有一个white参数的初始化方法, 用来给三原色提供相同的值。</p>
<pre><code>
struct Color {
let red, green, blue: Double
init(red: Double, green: Double, blue: Double) {
self.red   = red
self.green = green
self.blue  = blue
}
init(white: Double) {
red   = white
green = white
blue  = white
}
}</code></pre>
通过给每个初始化参数赋值,两个初始化方法都快要创建新 Color 实例:
<pre><code>
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
</code></pre>

<p>注意,不用参数标签无法调用这些初始化方法。如果已经定义，参数标签必须总是使用。忽略它们会导致编译错误:</p>
<pre><code>
let veryGreen = Color(0.0, 1.0, 0.0)
// 这个会报编译错误 - 需要参数标签
</code></pre>

<h1 id="没有参数标签的初始化参数"><a href="#没有参数标签的初始化参数" class="headerlink" title="没有参数标签的初始化参数"></a>没有参数标签的初始化参数</h1><p>如果你不想使用参数标签, 使用下划线 (_) 替代参数的显式参数标签来重写默认行为。</p>
<p>这里有一个早前Celsius例子的扩充版本, 用了一个额外的初始化方法从浮点值创建新的 Celsius 实例,浮点值已经是摄氏温标:</p>
<pre><code>
struct Celsius {
var temperatureInCelsius: Double
init(fromFahrenheit fahrenheit: Double) {
temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
temperatureInCelsius = kelvin - 273.15
}
init(_ celsius: Double) {
temperatureInCelsius = celsius
}
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0
</code></pre>

<p>初始化方法调用 Celsius(37.0) 目的很清楚,不需要使用参数标签。因此初始化方法写作 init(_ celsius: Double) 很合适, 通过无名浮点值可以调用它。</p>
<h1 id="可选属性类型"><a href="#可选属性类型" class="headerlink" title="可选属性类型"></a>可选属性类型</h1><p>如果你自定义类型有一个存储属性允许无值—可能因为它的值在初始化的时候不能设置, 或者因为它在某个时刻允许无值—定义这个属性为可选类型。可选类型属性自动初始化为nil, 表明这个属性故意在初始化时“没有值”。</p>
<p>下面的例子定义了一个类 SurveyQuestion, 带有一个可选字符串属性 response:</p>
<pre><code>
class SurveyQuestion {
var text: String
var response: String?
init(text: String) {
self.text = text
}
func ask() {
print(text)
}
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// 打印 "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
</code></pre>

<p>调查问题的回复只有问后才会知道, 所有 response 属性声明为 String? 类型, 或者 “可选 String”. 当一个新的 SurveyQuestion 实例初始化的时候, 它自动赋默认值为nil, 意思是“还没有字符串”。 </p>
<h1 id="初始化时访问常量属性"><a href="#初始化时访问常量属性" class="headerlink" title="初始化时访问常量属性"></a>初始化时访问常量属性</h1><p>在初始化时,你可以在任何时候给常量属性赋值, 只要在初始化完成时给它设置一个确定值。一旦一个常量属性指定一个值,后面就不能再修改了。</p>
<p>备注</p>
<p>对于类实例, 被类引入的常量属性在初始化时只能被这个类改变。 它不能被子类修改。</p>
<p>你可以修改上面的e SurveyQuestion 例子, 对问题文本使用常量属性而不是变量属性, 来表明一旦SurveyQuestion 实例创建,问题就不能再被修改。即使text 属性现在是一个常量, 它依然可以在初始化方法里设置:</p>
<pre><code>
class SurveyQuestion {
let text: String
var response: String?
init(text: String) {
self.text = text
}
func ask() {
print(text)
}
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// 打印 "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
</code></pre>

<h1 id="默认初始化方法"><a href="#默认初始化方法" class="headerlink" title="默认初始化方法"></a>默认初始化方法</h1><p>Swift 为任何结构体或者类提供一个默认初始化方法, 这些类和结构体给所有的属性提供了初始值,但是没有提供一个初始化方法。默认初始化方法简单创建一个新的实例,然后把所有属性设置为默认值。</p>
<p>这个例子定义了一个类 ShoppingListItem, 封装了购物列表中一项的名字, 数量和购买状态:</p>
<pre><code>
class ShoppingListItem {
var name: String?
var quantity = 1
var purchased = false
}
var item = ShoppingListItem()
</code></pre>

<p>因为所有的 ShoppingListItem 属性都有默认值, 又因为它是基类没有超类, ShoppingListItem 会自动创建默认的初始化方法, 来创建实例并把所有属性设置成默认值。(name 属性是一个可选字符串类型属性, 它会自动设为 nil, 即使这个值没有写在代码里) 这个例子使用默认初始化方法来创建新实例, 初始化语法是 ShoppingListItem(), 然后赋值给一个变量 item.</p>
<h1 id="结构体类型成员初始化方法-1"><a href="#结构体类型成员初始化方法-1" class="headerlink" title="结构体类型成员初始化方法"></a>结构体类型成员初始化方法</h1><p>Structure 如果没有定义自己的初始化方法, 它会自动获取到一个成员初始化方法。跟默认初始化方法不同, 即使结构体有未设置默认值的存储属性,它也会接收到一个成员初始化方法。</p>
<p>成员初始化方法是简写方式,用来初始化新结构体实例的成员属性。新实例的初始值可以通过名字传给成员初始化方法。</p>
<p>下面的例子定义了一个结构体 Size, 它有两个属性 width 和 height. 两个属性根据初始值推断为 Double 类型。</p>
<p>Size 结构体自动获取一个成员初始化方法 init(width:height:), 你可以用来初始化一个新的 Size 实例:</p>
<pre><code>
struct Size {
var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>

<h1 id="值类型初始化方法代理"><a href="#值类型初始化方法代理" class="headerlink" title="值类型初始化方法代理"></a>值类型初始化方法代理</h1><p>初始化方法可以调用其他初始化方法来执行实例的部分初始化工作。这个过程, 称为初始化方法代理, 通过多个初始化方法避免重复代码。</p>
<p>初始化方法代理如何工作的规则, 代理被允许是什么形式, 对于值类型和类类型是不同的。值类型不支持继承 (结构体和枚举), 所以它们的初始化函数代理过程相对简单, 因为它们只能代理它们自己提供的其他初始化方法。不过类可以继承其他类。这就意味着类有额外的责任,以确保它们继承来的所有存储属性在初始化时都分配了合适的值。</p>
<p>对于值类型, 在写你自己定义的初始化方法时,你使用 self.init 从相同的值类型调用其他初始化方法。你可以只在一个初始化方法里调用 self.init.</p>
<p>注意,如果你为一个值类型定义一个初始化方法, 你将不再访问那种类型的默认初始化方法 (或者成员初始化方法, 如果它是一个结构体)。这种情况下复合初始化方法提供的额外必要的设置, 这个防止不小心被使用自动初始化方法规避。</p>
<p>备注</p>
<p>如果你想自定义值类型使用默认初始化方法和成员初始化方法来初始化, 同时使用你自定义的初始化方法, 那就在扩展里实现自定义初始化方法而不是作为值类型原先实现的部分。更多信息, 参见扩展。</p>
<p>下面的例子定义了一个Rect 结构体来表示一个几何矩形。这个例子需要两个支持的结构体 Size 和 Point, both of which provide default values of 0.0 for all of their properties:</p>
<pre><code>
struct Size {
var width = 0.0, height = 0.0
}
struct Point {
var x = 0.0, y = 0.0
}
</code></pre>
你可以用下面三种方式初始化 Rect 结构体—默认初始化值为0, 提供一个特定的原点和大小, 或者指定一个特定的中心点和大小。三个初始化选择用三个自定义的初始化方法表示:
<pre><code>
struct Rect {
var origin = Point()
var size = Size()
init() {}
init(origin: Point, size: Size) {
self.origin = origin
self.size = size
}
init(center: Point, size: Size) {
let originX = center.x - (size.width / 2)
let originY = center.y - (size.height / 2)
self.init(origin: Point(x: originX, y: originY), size: size)
}
}</code></pre>
第一个初始化方法, init(), 功能和结构体未定义初始化方法自动分配的默认初始化方法一样。这个初始化方法函数体为空, 有一堆空的大括号表示 {}. 调用这个初始化方法,返回一个 Rect 实例, 它的原点和大小都是默认值, 分别是 Point(x: 0.0, y: 0.0) 和 Size(width: 0.0, height: 0.0):
<pre><code>
let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
</code></pre>
第二个初始化方法, init(origin:size:), 功能和结构体未定义初始化方法自动分配的成员初始化方法一样。这个初始化方法简单指定原点和大小参数值给对应的存储属性:
<pre><code>
let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
</code></pre>
第三个初始化方法, init(center:size:), 稍微有点复杂。开始基于中心点和大小值计算一个合适的原点值。然后调用 (或者代理)  init(origin:size:) 初始化方法, 存储新的原点值和大小到对应的属性:
<pre><code>
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
</code></pre>

<p>init(center:size:) 初始化方法可以给对应的属性指定新的原点值和大小。不过, 对于 init(center:size:) 初始化方法来说采用已存在的构造器更加遍历。</p>
<h1 id="类继承和初始化"><a href="#类继承和初始化" class="headerlink" title="类继承和初始化"></a>类继承和初始化</h1><p>类的所有存储属性—包含来自超类的任何属性—初始化的时候必须分配一个初始值。</p>
<p>Swift 为了类类型定义了两种初始化方法,帮助确保所有的存储属性都有初始值。这就大家熟知的指定初始化方法和便利初始化方法。</p>
<h1 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h1><p>指定初始化方法是类的主要初始化方法。一个指定初始化方法会完全初始化类引入的所有属性,同时会调用合适的超类初始化方法来继续超类链的初始化过程。</p>
<p>Classes 倾向于有很少的指定初始化方法, 对于类来说只有一个很平常。 指定构造器是通过初始化发生地的漏斗点, 通过它初始化继续往超类链上走。</p>
<p>每个类至少应该有一个指定构造器。在某些情况下, 这个需求通过继承超类的一个或者多个指定构造器来实现。</p>
<p>便利构造器是次要的, 对类来说只是支持初始化方法。你可以定义一个便利构造器来调用同类的指定构造器, 这个便利构造器设置指定构造器的参数为默认值。你可以定义一个便利构造器来创建类的实例,用作特定用途或者输入值类型。</p>
<p>如果你的类不需要便利构造器,你就不必要提供它们。什么时候要简化构造形式来节省时间或者让类的初始化意图更清楚,可以创建便利构造器。</p>
<h1 id="指定构造器和便利构造器的语法"><a href="#指定构造器和便利构造器的语法" class="headerlink" title="指定构造器和便利构造器的语法"></a>指定构造器和便利构造器的语法</h1><p>类的指定构造器写法和值类型的简单构造器一样:</p>
<pre><code>
init(parameters) {
statements
}</code></pre>
便利构造器写法一样, 但是init 关键字之前有个 convenience 修饰符, 用空格分开:
<pre><code>
convenience init(parameters) {
statements
}</code></pre>

<h1 id="类的初始化代理"><a href="#类的初始化代理" class="headerlink" title="类的初始化代理"></a>类的初始化代理</h1><p>为了简化指定构造器和便利构造器之间的关系, Swift 使用下面三种规则在构造器之间代理调用:</p>
<p>规则 1<br>一个指定构造器必须调用它的直接超类的指定构造器。</p>
<p>规则 2<br>一个便利构造器必须调用同类的其他构造器。</p>
<p>规则 3<br>一个便利构造器最后必须调用一个指定构造器。</p>
<p>一个简单的方式可以记住这个:</p>
<p>指定构造器必须总是向上代理。<br>便利构造器必须总是横着代理。<br>下图列出了这三个规则:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png"><br></div><br>这里, 超类有一个指定构造器和两个便利构造器。一个便利构造器调用另外一个便利构造器, 它依次调用这个单独的指定构造器。这个满足了上面的规则2和3. 超类本身没有超类, 所以第1条规则不适用。<br><br>图中的子类有两个指定构造柱和一个便利构造器。便利构造器必须调用这两个指定构造器之一, 因为它只能调用同类的另外的构造器。这个满足上面的规则2和3. 两个指定构造器必须调用超类的指定构造器, 这个满足上面的规则1.<br><br>备注<br><br>这个规则不影响你类的使用者如何创建每个类的实例。 上图中的任何构造器都可以用来完全初始化它们所属类的实例。这个规则只是影响你对类构造器的实现。<br><br>下面的图展示了更加复杂的四个类继承关系。 它展示了继承关系中的指定构造器如何扮演类构造器的漏斗点, 简化继承链中的类的相互关系:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png"><br></div>

<h1 id="两阶段初始化"><a href="#两阶段初始化" class="headerlink" title="两阶段初始化"></a>两阶段初始化</h1><p>Swift 中的类初始化是两阶段的过程。在第一阶段, 每个存储属性被指定一个初始值。一旦每个存储属性初始状态确定了, 第二阶段就开始了, 在新实例将要使用之前, 每个类都有机会去定制存储属性。</p>
<p>两阶段初始化过程的使用使得初始化更安全, 在类层次中依然给予完全的灵活性。两阶段初始化防止属性值在初始化前被访问, 同时也防止了属性值被另外的构造器意味的设置成一个不同的值。</p>
<p>备注</p>
<p>Swift 的两阶段初始化过程很像 Objective-C 的初始化。 主要区别是阶段 1, Objective-C 会给每个属性设定零或者空值 (比如 0 或者 nil). Swift 的初始化更加灵活, 可以让你自定义初始值, 可以应对0或者nil不是有效默认值的情况。</p>
<p>Swift 的编译器执行四项安全检查来确保两阶段初始化无错误的完成:</p>
<p>安全检查 1<br>一个指定构造器必须确保, 在向上代理超类构造器之前,所属类的所有属性都被初始化。</p>
<p>就像上面提及的, 对象的内存只考虑完全初始化一次所有的存储属性的初始状态。为了让这条规则满足, 一个指定构造器必须保证在向上传递前自己所有的属性都已经初始化。</p>
<p>安全检查 2<br>在给继承来的属性赋值前,一个指定构造器必须向上委托超类的构造器。如果不这样做, 指定构造器指定的新值会被超类自己的构造器给覆盖了。</p>
<p>安全检查 3<br>在给任意属性赋值前, 一个便利构造器必须委托另外一个构造器。(包括相同类定义的属性)。如果不这样做, 便利构造器指定的新值会被本类的指定构造器覆盖。</p>
<p>安全检查 4<br>一个构造器不能调用任何实例方法, 不能读任何实例属性的值, 或者直到第一阶段初始化完成才可以引用self.</p>
<p>第一阶段初始化结束后类的实例才完全有效。第一阶段类的实例有效后,属性只能被访问, 方法只能被调用。</p>
<p>这里是两阶段初始化的呈现, 基于以上四个安全检查:</p>
<p>阶段 1</p>
<p>一个指定构造器或者便利构造器在类里调用。<br>给类的实例分配内存。内存尚未初始化。<br>类的指定构造器确保所有存储属性都有一个值。这些存储属性的内存开始初始化。<br>指定构造器放手给超类的构造器,对它的存储属性执行同样的操作。<br>沿着继承链继续往上直到尽头。<br>一旦到了继承链的尽头, 继承链最后的类已经确保所有存储属性都有一个值。实例的内存被认为已经全部初始化, 第一阶段完成。.<br>阶段 2</p>
<p>从继承链尽头回来, 链中的每个指定构造器都有选择去继续定制实例。构造器现在可以访问 self 和改变属性, 也可以调用函数。<br>最后, 链中的任何便利构造器都有选择去定制实例并且使用 self.<br>这里展示第一阶段如何为一个假设的子类和超类寻找初始化调用的:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png"><br></div>

<p>在这个例子中, 初始化开始于调用子类的便利构造器。这个便利构造器尚不能修改任何属性。它委托了本类的一个指定构造器。</p>
<p>指定构造器确保所有的子类属性都有一个值, 根据安全检查 1. 然后在它的超类调用一个指定构造器继续沿着链初始化。</p>
<p>超类指定构造器确保超类属性都有一个值。因为没有更深的超类要初始化, 所以也不需要更深的委托。</p>
<p>只要所有超类的属性都有一个初始值, 它的内存就被认为已经完成初始化, 那么阶段1就完成了。</p>
<p>这里是阶段2如何寻找相同的初始化调用:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png"><br></div>

<p>子类的指定构造器现在有机会更进一步去定制实例 (尽管它不必要这么做)。</p>
<p>一旦子类指定构造器完成, 超类的指定构造器可以执行额外的定制(尽管它没有必要这么做)。</p>
<p>最后, 一旦子类的指定构造器完成, 原先调用的便利构造器就可以执行额外的定制。</p>
<h1 id="初始化方法的继承和重写"><a href="#初始化方法的继承和重写" class="headerlink" title="初始化方法的继承和重写"></a>初始化方法的继承和重写</h1><p>不像 Objective-C 中的子类, Swift 子类默认不继承它的超类的初始化方法。 Swift 的方法防止了一种情况,在这种情况下来自一个超类的初始化方法被一个更专业的子类继承,并且用来这个子类的新实例,但是这个实例并未完全或者正确的初始化。</p>
<p>备注</p>
<p>超类的初始化方法在特定情况下被继承, 只有安全而且合适才会这么做。</p>
<p>如果你想让自定义子类展示和超类一样的一个或者多个初始化方法, 你可以在子类内提供这些初始化方法的自定义实现。</p>
<p>当你写一个子类初始化方法,这个方法匹配一个超类的指定构造器, 你可以提供这个指定构造器的重写。因此, 你必须在子类初始化方法定义前写上 override 修饰符。 即使你重写一个自动提供的默认初始化方法,也是这样。</p>
<p>跟一个重写的属性,方法或者下标一样, override 修饰符提醒Swift 去判断超类有这么一个指定构造器可以重写, 并且验证重写初始化方法的参数已经有目的的指定了。</p>
<p>备注</p>
<p>当重写超类指定构造器时你应该总是写上 override 修饰符, 即使子类初始化方法的实现是一个便利构造器。</p>
<p>相反, 如果你写一个子类初始化方法匹配超类的便利构造器, 超类便利构造器不能直接被子类调用。因此, 你的子类不能提供一个超类初始化方法的重写。结果是, 当提供一个超类便利构造器的匹配实现时,你不能写上 override 修饰符。</p>
<p>下面的例子定义了一个基类 Vehicle. 这个基类声明了一个存储属性 numberOfWheels, 带有一个默认值 0. numberOfWheels 被一个计算属性 description用来创建汽车特征的字符串描述:</p>
<pre><code>
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}</code></pre>

<p>Vehicle 类给它唯一的存储属性提供了一个默认值, 本身没有提供任何自定义的初始化方法。结果是, 它会自动收到一个默认的初始化方法。这个默认的初始化方法总是一个指定构造器, 可以用来创建一个 numberOfWheels 为0的Vehicle 实例:</p>
<pre><code>
let vehicle = Vehicle()
print("Vehicle: \(vehicle.description)")
// Vehicle: 0 wheel(s)
</code></pre>
下面的例子定义了一个 Vehicle 的子类 Bicycle:
<pre><code>
class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}</code></pre>

<p>Bicycle 定义了一个自定义指定构造器init(). 这个构造器匹配来着超类的指定构造器, 所以 Bicycle 版本的这个构造器用override 修饰符标记。</p>
<p>init() 初始化方法先调用 super.init(), 这是超类的默认初始化方法。这个确保 numberOfWheels 属性在被子类修改前可以被 Vehicle 初始化。调用 super.init() 后, numberOfWheels 原有值会被新值2替代。</p>
<p>如果你创建一个 Bicycle 实例, 你可以调用它的继承来的计算属性 description 来查看 numberOfWheels 属性是否被更新了:</p>
<pre><code>
let bicycle = Bicycle()
print("Bicycle: \(bicycle.description)")
// Bicycle: 2 wheel(s)
</code></pre>

<p>备注</p>
<p>子类在初始化的时候可以改变继承来的变量属性, 但是无法改变继承来的常量属性。</p>
<h1 id="自动初始化方法的继承"><a href="#自动初始化方法的继承" class="headerlink" title="自动初始化方法的继承"></a>自动初始化方法的继承</h1><p>就像上面提到的, 默认情况子类并不继承超类的初始化方法。不过, 不过如果某种条件满足了,超类的初始化方法还是可以被自动继承的。在实践中, 这意味着你通常不需要重写初始化方法, 只要这样做安全,你可以用最小的代价继承超类的初始化方法。</p>
<p>假设你给子类的任何新属性都设定了默认值, 下面的规则适用:</p>
<p>规则 1<br>如果你的子类没有定义任何指定构造器, 它会自动继承超类所有的指定构造器。</p>
<p>规则 2<br>如果你的子类提供了超类所有指定构造器的实现—或者通过像规则1那样的继承, 或者提供自定义实现—然后它会自动继承超类所有的便利构造器。</p>
<p>即使你的子类添加更深的便利构造器,这个规则都适用。</p>
<p>备注</p>
<p>一个子类可以实现一个超类的指定构造器,来作为自己的便利构造器,这个是满足规则2的部分。</p>
<h1 id="指定和便利构造器的初始化"><a href="#指定和便利构造器的初始化" class="headerlink" title="指定和便利构造器的初始化"></a>指定和便利构造器的初始化</h1><p>下面的例子展示了指定构造器,便利构造器和自动构造器继承的活动。这个例子定义了三个类 Food, RecipeIngredient 和 ShoppingListItem 的继承关系, 并且展示了它们如何交互。</p>
<p>这个继承关系中的基类是 Food, 它是封装了一个食品名字的简单类。Food 类引入了一个单独的字符串属性 name 并且提供了两个构造器来创建 Food 实例:</p>
<pre><code>
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
</code></pre>
下图展示了Food 类的构造链:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png">
</div>
类没有默认的成员构造器, 所以 Food 类提供了一个指定构造器,这个构造器有一个参数 name. 这个构造器可以用一个指定名字来创建一个新的 Food 实例:
<pre><code>
let namedMeat = Food(name: "Bacon")
// namedMeat's name is "Bacon"
</code></pre>
init(name: String) 构造器是一个指定构造器, 因为它可以保证一个新的Food 实例的所有存储属性完全初始化。Food 类没有超类, 所以 init(name: String) 不需要调用 super.init() 来完成初始化。

Food 类同时提供了一个便利构造器, init(), 没有任何参数。 通过委托Food 类的init(name: String), init() 为新食物提供了一个默认的占位符名字 [Unnamed]:
<pre><code>
let mysteryMeat = Food()
// mysteryMeat's name is "[Unnamed]"
</code></pre>
继承关系中的第二个类 RecipeIngredient 是Food 类的子类。RecipeIngredient 类模拟了烹调配方的成分。它引入了一个 Int 属性quantity (除了从Food 继承来的name属性) 然后定义了两个构造器用来创建 RecipeIngredient 实例:
<pre><code>
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}</code></pre>
下图展示了 RecipeIngredient 类的构造链:
<div style="text-align:center">
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png">
</div>
RecipeIngredient 类只有一个指定构造器, init(name: String, quantity: Int), 它可以填充一个新 RecipeIngredient 实例的所有属性。构造器首先把传入的数量参数赋值给 quantity 属性, 这个是 RecipeIngredient 唯一的新属性。这个操作之后, 构造器向上委托基类的 init(name: String) 构造器。这个过程符合两阶段初始化的安全检查1.

RecipeIngredient 同时定义了一个便利构造器, init(name: String), 它用名字来创建一个 RecipeIngredient 实例。任何 RecipeIngredient 实例没有显式数量的,这个便利构造器都会假设一个数量值为1. 这个便利构造器方便 RecipeIngredient 实例快速创建, 并且当创建一些单个数量的实例时可以避免代码重复。这个便利构造器简单调用了指定构造器, 传入数量值 1.

init(name: String) 便利构造器跟指定构造器 init(name: String) 接受一样的参数。因为这个便利构造器重写了超类的指定构造器, 它必须标记 override 修饰符。

尽管 RecipeIngredient 提供了 init(name: String) 作为便利构造器, RecipeIngredient 也提供了所有超类的指定构造器的实现。因此, RecipeIngredient 也就自动继承了超类的所有便利构造器。

在这个例子里, RecipeIngredient 的超类是 Food, 它只有一个便利构造器 init(). 这个构造器会被 RecipeIngredient 继承。继承 init() 函数版本和 Food 版本是一样的。除了它是调用e RecipeIngredient 版本的 init(name: String) 而不是 Food 版本之外。

三个构造器都快要用来创建新的 RecipeIngredient 实例:
<pre><code>
let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)</code></pre>
继承关系里的最后一个类ShoppingListItem也是 RecipeIngredient 子类。ShoppingListItem 模拟了一个配方成分。

购物清单中的每一项都以“unpurchased”开始。为了说明这个事实, ShoppingListItem 引入一个布尔属性 purchased, 带有一个默认值 false. ShoppingListItem 同时添加了一个计算属性description, 它提供了ShoppingListItem 实例的文本描述:
<pre><code>
class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}</code></pre>

<p>备注</p>
<p>ShoppingListItem 没有提供构造器来为 purchased 设定初始值, 因为购物清单里的项目一开始都是未购买的。</p>
<p>因为它给所有的属性提供了默认值并且没有提供任何构造函数, ShoppingListItem 自动从超类继承了所有的指定和便利构造器。</p>
<p>下图展示了三个类所有的构造函数:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png"><br></div>

<p>你可以用所有继承来的构造函数创建一个新的 ShoppingListItem 实例:</p>
<pre><code>
var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    print(item.description)
}
// 1 x Orange juice ✔
// 1 x Bacon ✘
// 6 x Eggs ✘
</code></pre>

<p>这里, 用数组字面量创建了一个新的数组 breakfastList, 它包含了3个 ShoppingListItem 实例。 数组类型推断为 [ShoppingListItem]. 这个数组创建后, 数组开始项 ShoppingListItem 名字从”[Unnamed]” 变成 “Orange juice” 并且标记为已购买。打印数组中的每一项来表示它们的默认状态按照预期设置了。</p>
<h1 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h1><p>有时候允许类,结构体或者枚举构造失败是有用的。无效初始化参数值,缺少必需的外部资源,或者其他阻止初始化成功的条件都会引起构造失败。</p>
<p>为了应对这些引起失败的初始化条件, 在类,结构体或者枚举体中定义一个或者多个可失败构造器。写一个可失败构造器的方法是在 init 关键字后面加上问号 (init?).</p>
<p>备注</p>
<p>你不可以用相同的参数类型和名称来同时定义一个可失败或者非失败的构造器。</p>
<p>一个可失败构造器创建一个可选类型值。通过在可失败构造器中返回 nil 来表明某个时刻初始化失败发生。</p>
<p>备注</p>
<p>严格来说, 构造器不会任何值。相反, 它们的角色是确保初始化结束时self被完全而正确的初始化。尽管你写了返回 nil 去触发构造失败, 你不能用 return 关键字来表明构造成功。</p>
<p>下面的例子定义了一个结构体 Animal, 有一个常量字符串属性 species.Animal 同时定义了带有一个参数species 的可失败构造器。 这个构造器判断species 是否为空。如果是空字符串, 构造失败触发。否则, 设置species 的属性值, 然后初始化成功:</p>
<pre><code>
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
</code></pre>
你可以使用可失败构造器尝试去初始化一个新的 Animal 实例,然后判断构造是否成功:
<pre><code>
let someCreature = Animal(species: "Giraffe")
// someCreature is of type Animal?, not Animal

if let giraffe = someCreature {
    print("An animal was initialized with a species of \(giraffe.species)")
}
// 打印 "An animal was initialized with a species of Giraffe"
If you pass an empty string value to the failable initializer’s species parameter, the initializer triggers an initialization failure:

let anonymousCreature = Animal(species: "")
// anonymousCreature is of type Animal?, not Animal

if anonymousCreature == nil {
    print("The anonymous creature could not be initialized")
}
// 打印 "The anonymous creature could not be initialized"
</code></pre>

<p>备注</p>
<p>判断空字符串和判断可选值为nil是不同的。在上面的例子中, 一个空字符串 (“”) 是一个有效,非可选的字符串。不过, 对于动物来说species属性值为空不太合适。 为了模拟这种限制, 如果这个字符串为空,就触发构造失败。</p>
<h1 id="枚举的可失败构造器"><a href="#枚举的可失败构造器" class="headerlink" title="枚举的可失败构造器"></a>枚举的可失败构造器</h1><p>你可以基于一个或多个参数使用构造器去选择一个合适的枚举分支. 如果提供的参数没有匹配合适的分支,构造就会失败。</p>
<p>下面的例子定义了一个枚举 TemperatureUnit, 有三种可能的状态 (kelvin, celsius, 和 fahrenheit). 可失败构造器根据代表温度符号的字符值来寻找一个合适的枚举分支:</p>
<pre><code>
enum TemperatureUnit {
    case kelvin, celsius, fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .kelvin
        case "C":
            self = .celsius
        case "F":
            self = .fahrenheit
        default:
            return nil
        }
    }
}</code></pre>

<p>你使用可失败构造器为三种可能的状态选择一个合适的枚举分支, 如果参数不匹配三种状态之一就会引发构造失败:</p>
<pre><code>
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// 打印 "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</code></pre>

<h1 id="带原始值枚举的可失败构造器"><a href="#带原始值枚举的可失败构造器" class="headerlink" title="带原始值枚举的可失败构造器"></a>带原始值枚举的可失败构造器</h1><p>带有原始值的枚举会自动接收一个可失败构造器, init?(rawValue:), 有一个参数 rawValue, 如果找到就匹配一个枚举分支, 否则触发构造失败。</p>
<p>你用原始值重写上面的 TemperatureUnit 例子,然后使用 init?(rawValue:) 构造器:</p>
<pre><code>
enum TemperatureUnit: Character {
    case kelvin = "K", celsius = "C", fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// 打印 "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</code></pre>

<h1 id="构造可失败的传递"><a href="#构造可失败的传递" class="headerlink" title="构造可失败的传递"></a>构造可失败的传递</h1><p>在相同类,结构体或者枚举中可失败构造器可以委托调用另外的可失败构造器。相似的, 子类可失败构造器可以向上调用超类的可失败构造器。</p>
<p>另外一种情况, 如果你委托其他构造器导致构造失败, 那么整个构造过程就会立即失败, 后面的构造代码不会再执行。</p>
<p>备注</p>
<p>一个可失败构造器要可以委托调用一个非失败构造器。如果你需要给一个存在的初始化过程添加一个潜在的失败状态,可以用这个方法。</p>
<p>下面的例子定义了一个 Product 的子类 CartItem. CartItem 模拟了在线购物车的一项。CartItem 引入了一个存储常量属性 quantity 并且保证这个属性的值至少为 1:</p>
<pre><code>
class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}

class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity < 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
</code></pre>

<p>CartItem 可失败构造器首先判断 quantity 是否小于1. 如果 quantity 无效, 整个初始化过程立即失败并且后面的初始化代码不会执行。 同样的, Product 的可失败构造器判断 name 的值, 如果name是空字符串这个构造过程也会立即失败。</p>
<p>如果使用非空name和quantity大于等于1的值构造一个 CartItem 实例, 初始化就成功了:</p>
<pre><code>
if let twoSocks = CartItem(name: "sock", quantity: 2) {
    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}
// 打印 "Item: sock, quantity: 2"
</code></pre>
如果你用quantity 等于0来创建一个 CartItem 实例, CartItem 构造器会引起初始化失败:
<pre><code>
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    print("Unable to initialize zero shirts")
}
// 打印 "Unable to initialize zero shirts"
</code></pre>
相似的, 如果你使用空名字去创建一个 CartItem 实例, 超类 Product 构造器会导致初始化失败:
<pre><code>
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    print("Unable to initialize one unnamed product")
}
// 打印 "Unable to initialize one unnamed product"
</code></pre>

<h1 id="重写可失败构造器"><a href="#重写可失败构造器" class="headerlink" title="重写可失败构造器"></a>重写可失败构造器</h1><p>你可以在子类重写超类的可失败构造器, 就像其他构造器一样。 或者, 你可以用子类的非失败构造器重写一个超类的构造器。 这使得你可以定义个子类,它的初始化不会失败。即使超类的构造允许失败。</p>
<p>注意,如果你用子类非失败构造器重写了超类的可失败构造器, 唯一向上调用超类构造器的方式是强制拆包超类可失败构造器的结果。</p>
<p>备注</p>
<p>你可以用一个非失败构造器重写一个可失败构造器,除此之外别无他法。</p>
<p>下面的例子定义了一个类 Document. 这个类模拟了一个文档,这个文档可以用一个非空字符串名字或者nil来初始化, 但是不能用一个空字符串:</p>
<pre><code>
class Document {
    var name: String?
    // this initializer creates a document with a nil name value
    init() {}
    // this initializer creates a document with a nonempty name value
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
</code></pre>
下面的例子定义了 Document 的一个子类 AutomaticallyNamedDocument. AutomaticallyNamedDocument 子类重写了两个 Document 类引入的指定构造器。这些重写保证了一个 AutomaticallyNamedDocument 有一个初始值 "[Untitled]" :
<pre><code>
class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Untitled]"
        } else {
            self.name = name
        }
    }
}
</code></pre>

<p>AutomaticallyNamedDocument 用非失败init(name:)构造器重写了超类的可失败构造器init?(name:). 因为 AutomaticallyNamedDocument 处理空字符串的情况和超类不同, 它的构造器不需要失败, 所以它提供了一个非失败的构造器版本。</p>
<p>你可以在构造器里使用强制拆包,来调用超类的可失败构造器。 例如, UntitledDocument 子类总是命名为 “[Untitled]”, 并且在它的初始化过程中,它会使用超类的可失败构造器init(name:)</p>
<pre><code>
class UntitledDocument: Document {
    override init() {
        super.init(name: "[Untitled]")!
    }
}</code></pre>

<p>在这种情况下, 如果超类的 init(name:) 构造器用空名字字符串调用, 强制拆包操作会引发一个运行时错误。不过, 它是用常量字符串调用的, 你可以看到这个构造器不会失败, 所以这种情况不会发生运行时错误。</p>
<h1 id="init-可失败构造器"><a href="#init-可失败构造器" class="headerlink" title="init! 可失败构造器"></a>init! 可失败构造器</h1><p>通过在init关键之后面加上一个问号,你可以定义一个可失败构造器来创建一个对应类型的可选实例。或者, 你可以定义一个可失败构造器,来创建对应类型隐式拆包可选实例。 这个可以通过在init关键之后面加上感叹号而不是问好来实现。</p>
<p>你可以从init? 调用到 init! ,反之亦然, 而且你可以用init!重写 init? with init! ,反之亦然。你还可以从init 调用到 init!, 尽管这样做会触发一个断言,如果 init! 构造器导致构造失败的话。</p>
<h1 id="必需构造器"><a href="#必需构造器" class="headerlink" title="必需构造器"></a>必需构造器</h1><p>在一个类的构造器前写上 required 修饰符来表明这个类的每个子类都要实现这些构造器:</p>
<pre><code>
class SomeClass {
    required init() {
        // initializer implementation goes here
    }
}</code></pre>
你也必需在每一个实现必须构造器的子类构造器前写上 required 修饰符, 来表明在链中构造需求适用更远的子类。当重写一个必须指定构造器时,你不需要写上 override 修饰符:
<pre><code>
class SomeSubclass: SomeClass {
    required init() {
        // subclass implementation of the required initializer goes here
    }
}</code></pre>

<p>备注</p>
<p>如果你可以用一个继承来的构造器满足要求,你就不必要提供一个显式的必须构造器。</p>
<h1 id="用闭包或者函数设定默认属性值"><a href="#用闭包或者函数设定默认属性值" class="headerlink" title="用闭包或者函数设定默认属性值"></a>用闭包或者函数设定默认属性值</h1><p>如果一个存储属性的默认值需要定制或者设置, 你可以使用一个闭包或者一个全局函数。一旦一个属性所属的新的实例被初始化, 闭包或者函数就会调用, 然后返回值被赋值给属性的默认值。</p>
<p>这些闭包或者函数特别创建和属性相同类型的一个临时值, 返回的临时值用来作为这个属性的默认值。</p>
<p>这里有一个框架, 来展示一个闭包如何用来提供默认属性值:</p>
<pre><code>
class SomeClass {
    let someProperty: SomeType = {
        // create a default value for someProperty inside this closure
        // someValue must be of the same type as SomeType
        return someValue
    }()
}
</code></pre>

<p>注意闭包花括号结束后跟着一对空括号。这个会通知 Swift 立即执行这个闭包。如果你忽略这对括号, 你在尝试把闭包本身赋值给这个属性, 而不是闭包的返回值。</p>
<p>备注</p>
<p>如果你用闭包初始化一个属性, 记住,闭包执行时,实例的其他部分还没有进行初始化。这就意味着你不能在闭包里访问其他任何属性, 即使这些属性具有默认值。你也不能使用隐式self 属性, 或是调用任何实例方法。</p>
<p>下面的例子定义了一个结构体 Chessboard, 它为象棋游戏模拟了一个棋盘。象棋是在一个 8 x 8 的去棋盘上玩的, 带着交替的黑白方格。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png"><br></div>

<p>为了表示这个游戏棋盘, Chessboard 结构体有一个属性 boardColors, 它是一个带有64个布尔值的数组。真值代表黑色方块,假值代表白色方块。第一项代表棋盘的左上方块,最后一项代表棋盘的右下方块。</p>
<p>boardColors 数组使用一个闭包初始化,设定它的颜色值:</p>
<pre><code>
struct Chessboard {
    let boardColors: [Bool] = {
        var temporaryBoard = [Bool]()
        var isBlack = false
        for i in 1...8 {
            for j in 1...8 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
    }()
    func squareIsBlackAt(row: Int, column: Int) -> Bool {
        return boardColors[(row * 8) + column]
    }
}
</code></pre>

<p>一旦新的Chessboard 实例创建, 闭包就会执行, boardColors 默认值会计算和返回。上面例子里的闭包在一个临时数组temporaryBoard 为棋盘上每个方块计算和设置了对应的颜色值, 并且等设置完成就作为闭包返回值返回。返回数组值存储在 boardColors 中,并且可以用squareIsBlackAtRow 功能函数进行查询:</p>
<pre><code>
let board = Chessboard()
print(board.squareIsBlackAt(row: 0, column: 1))
// 打印 "true"
print(board.squareIsBlackAt(row: 7, column: 7))
// 打印 "false"
</code></pre>

<h1 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h1><p>在一个类实例销毁前,一个析构器会立即调用。使用deinit 关键字来表示析构器, 跟构造器写法类似。析构器只能用在类类型上。 types.</p>
<h1 id="析构器如何工作"><a href="#析构器如何工作" class="headerlink" title="析构器如何工作"></a>析构器如何工作</h1><p>Swift 在实例不需要时会自动析构它, 去释放资源。Swift 通过自动引用计数来管理实例的内存(ARC). 当实例销毁时你不需要手动执行清理操作。不过, 当你使用自己的资源时, 你可能需要额外执行一些清理。例如, 如果你创建一个类去读写文件, 在类的实例销毁前你可能需要去关闭这个文件。</p>
<p>类最多只能有一个析构器。析构器没有任何参数也没有括号:</p>
<pre><code>
deinit {
    // perform the deinitialization
}</code></pre>

<p>析构器会自动调用, 在实例销毁发生前。禁止自己去调用析构器。子类会继承超类的析构器, 超类析构器在子类析构器实现后调用。 即使子类不提供自己的析构器,超类析构器也会调用。</p>
<p>因为实例直到析构器调用才会销毁, 一个析构器可以访问调用实例的所有属性,同时也可以改变基于这些属性的行为 (例如寻找需要关闭的文件名).</p>
<h1 id="析构器的活动"><a href="#析构器的活动" class="headerlink" title="析构器的活动"></a>析构器的活动</h1><p>这里有一个析构器活动的例子。这个例子定义了两个新类型, Bank 和 Player, Bank 类管理一个虚拟货币, 它的流通货币不会超过 10,000 硬币。游戏里只有能有一个银行, 所以 Bank 用类实现,带有类型属性和方法来存储和管理它的当前状态:</p>
<pre><code>
class Bank {
    static var coinsInBank = 10_000
    static func distribute(coins numberOfCoinsRequested: Int) -> Int {
        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)
        coinsInBank -= numberOfCoinsToVend
        return numberOfCoinsToVend
    }
    static func receive(coins: Int) {
        coinsInBank += coins
    }
}</code></pre>

<p>Bank 用coinsInBank 属性跟中当前硬币的数量。它同时提供了两个方法s—distribute(coins:) 和 receive(coins:)—来管理硬币的发行和回收。</p>
<p>distribute(coins:) 方法判断在发行前银行是否有足够的硬币。如果没有足够的硬币, Bank 返回一个比要求数量少的数量 (如果银行没有硬币了就返回0). 它返回一个整数来表示实际提供的硬币数量。</p>
<p>receive(coins:) 方法简单加上收到的硬币数量。</p>
<p>Player 类描述了游戏中的一个玩家。 每一个玩家在任何时间都有一定数量的硬币在钱包里。这个用玩家的coinsInPurse 来表示:</p>
<pre><code>
class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.distribute(coins: coins)
    }
    func win(coins: Int) {
        coinsInPurse += Bank.distribute(coins: coins)
    }
    deinit {
        Bank.receive(coins: coinsInPurse)
    }
}</code></pre>

<p>在初始化过程中,每个玩家都会用一定数量的硬币来初始化, 尽管玩家可能在银行硬币不足的时候获取较少的数量。</p>
<p>Player 类定义了一个方法 win(coins:), 它从银行获取一定数量的硬币然后把它们加入玩家的钱包。Player 类同时实现了一个去构造器, 它在 Player 实例销毁前调用。在这里, 这个构造器简单把玩家的硬币返还给银行:</p>
<pre><code>
var playerOne: Player? = Player(coins: 100)
print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
// 打印 "A new player has joined the game with 100 coins"
print("There are now \(Bank.coinsInBank) coins left in the bank")
// 打印 "There are now 9900 coins left in the bank"
</code></pre>

<p>一个新的 Player 实例被创建, 如果有硬币就请求100个硬币。这个Player 实例存在一个可选的 Player 变量 playerOne 中。可选变量用在这里, 因为玩家可能在任何时间离开游戏。可选项让你跟踪玩家当前是否还在游戏中。</p>
<p>因为 playerOne 是一个可选项, 当它的 coinsInPurse 属性被访问来打印硬币数量时, 需要使用感叹号。一旦它的 winCoins(_:) 方法被调用:</p>
<pre><code>
playerOne!.win(coins: 2_000)
print("PlayerOne won 2000 coins & now has \(playerOne!.coinsInPurse) coins")
// 打印 "PlayerOne won 2000 coins & now has 2100 coins"
print("The bank now only has \(Bank.coinsInBank) coins left")
// 打印 "The bank now only has 7900 coins left"
</code></pre>

<p>在这里, 玩家已经赢得了 2,000 个硬币。玩家的钱包现在有 2,100 个硬币, 银行还有 7,900 个硬币。</p>
<pre><code>
playerOne = nil
print("PlayerOne has left the game")
// 打印 "PlayerOne has left the game"
print("The bank now has \(Bank.coinsInBank) coins")
// 打印 "The bank now has 10000 coins"
</code></pre>

<p>玩家现在离开游戏。设置可选playerOne变量为nil 说明了这点。意思是 “没有Player 实例。” 此时, playerOne 变量引用的Player 实例被销毁。没有其他属性或者变量再引用 Player 实例, 所以它被销毁来释放内存。在这个发生之前, 它的析构器自动调用, 然后它的硬币全部归还给银行。</p>
<h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><p>Swift 使用自动引用计数来跟踪和管理你的应用的存储使用。在大多数情况里, 这就意味着内存管理 “仅仅工作” 在 Swift, 你自己不需要管理内存。类的实例不再需要的时候,ARC 会自动释放实例使用的内存。</p>
<p>不过, 在一些少见的情况下,为了替你管理内存,ARC 需要更多关于你代码关系的信息。这个章节描述这些场景并且向你展示你怎么使用 ARC 来管理应用的内存。</p>
<p>备注</p>
<p>引用计数只适用于类的实例。结构体和枚举是值类型, 而非引用类型, 不能用引用存储和传递。</p>
<h1 id="ARC-如何工作"><a href="#ARC-如何工作" class="headerlink" title="ARC 如何工作"></a>ARC 如何工作</h1><p>每次你创建一个新的类实例, ARC 就会分配一块内存来存储实例的信息。这个内存掌握了实例类型的信息, 还有对应实例的存储属性的值。</p>
<p>另外, 当一个实例不再需要的时候, ARC 会释放实例使用的内存,让内存另有他用。这个确保类的实例不需要的时候,不会继续占用内存空间。</p>
<p>不过, 如果 ARC 将要销毁在使用的实例, 它将不能访问实例的属性, 或者是实例的方法。 事实上, 如果你访问这个实例, 你的应用可能会崩溃。</p>
<p>为了确保实例在使用时不会消失, ARC 跟踪有多少属性, 常量和变量正在引用类的每个实例。只要有一个对实例的引用,ARC 都不会销毁这个实例。</p>
<p>为了实现这种可能, 一旦你把类赋给一个属性, 常量或者变量, 这些属性,常量或者变量就会强引用这个实例。 这个引用之所以叫强引用,是因为它牢牢掌握了这个实例。只要强引用还在,就不会允许它被销毁。</p>
<h1 id="ARC-的活动"><a href="#ARC-的活动" class="headerlink" title="ARC 的活动"></a>ARC 的活动</h1><p>下面有个自动引用计数的例子,来展示它如何工作。这个例子以一个简单的类 Person 开始, 它定义了一个存储常量属性 name:</p>
<pre><code>
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}</code></pre>

<p>Person 类有一个构造器,用来设置实例的 name 属性,并且打印一条信息来表明构造在进行。Person 类同时也有一个析构器,在类的实例被销毁时打印一条信息。</p>
<p>下面代码定义了三个 Person? 类型的变量, 在后续代码中,它们用来设置多个对新Person 实例的引用。因为这些变量是可选类型(Person?, 不是 Person), 它们会自动初始化为nil, 并且当前不会引用一个Person 实例。</p>
<pre><code>
var reference1: Person?
var reference2: Person?
var reference3: Person?
</code></pre>

<p>你现在可以创建一个新的 Person 实例,并且把它赋值给三个变量的其中一个:</p>
<pre><code>
reference1 = Person(name: "John Appleseed")
// 打印 "John Appleseed is being initialized"
</code></pre>
注意这条信息 "John Appleseed is being initialized" 在调用Person 来的构造器时打印。这个确认了初始化已经发生。

因为新的 Person 实例已经指定给 reference1 变量, 现在从reference1 到新的Person 实例有了一个强引用。因为有了至少一个强引用, ARC 确保 Person 保持在内存里不被销毁。

如果你把相同的 Person 实例赋值给另外两个变量, 指向这个实例的两个强引用就建立了:
<pre><code>
reference2 = reference1
reference3 = reference1
</code></pre>

<p>现在有三个强引用指向这个单独的 Person 实例。</p>
<p>通过给其中两个变量赋值为nil,你可以打破这些强引用, 还剩一个强引用, 但是Person 实例不会被销毁:</p>
<pre><code>
reference1 = nil
reference2 = nil
</code></pre>

<p>ARC 直到最后一个强引用被打破才会销毁 Person 实例, 在这个时刻很清楚你无法再继续使用这个 Person 实例:</p>
<pre><code>
reference3 = nil
// 打印 "John Appleseed is being deinitialized"
</code></pre>

<h1 id="类实例的强引用循环"><a href="#类实例的强引用循环" class="headerlink" title="类实例的强引用循环"></a>类实例的强引用循环</h1><p>上面的例子中, ARC 可以跟踪你创建的实例的引用数量,并且在实例不需要的时候销毁它。</p>
<p>不过, 有可能写下这种代码,在代码里一个类实例不知道什么时候强引用数量为0. 如果两个类实例互相强引用就会出现这个问题, 这样每个实例都保有其他活动的实例。这就是众所周知的强引用循环。</p>
<p>使用weak 或者 unowned 来代替强引用, 这样你可以解决强引用循环的问题。不过, 在你学习如何解决强引用问题前, 有必要先学习循环引用是怎么产生的。</p>
<p>下面的例子展示强引用循环是如何偶发的。这个例子定义了两个类 Person 和 Apartment, 它模拟了一组公寓和居民:</p>
<pre><code>
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</code></pre>

<p>每个 Person 实例有一个字符串类型的name属性和一个可选的 apartment 属性,后者初始化为nil. apartment 属性是可选的, 因为一个人有可能没有公寓。</p>
<p>相似的, 每个 Apartment 实例有一个字符串类型的 unit属性和一个可选的 tenant 属性,后者初始化为nil nil. tenant 属性是可选的,因为一个公寓有可能没有租客。</p>
<p>两个类都定义了析构器, 它们打印类实例被销毁的事实。这个可以帮你查看两个类的实例是否按照预期销毁了。</p>
<p>下面的代码片段定义了两个可选类型的变量 john 和 unit4A, 他们将会被设置为特定的 Apartment 和 Person 实例。这两个变量初始值都是 nil, 因为它们是可选的:</p>
<pre><code>
var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
</code></pre>

<p>这里展示创建和赋值这两个实例后,强引用的样子。john 变量现在强引用这个新的 Person 实例, unit4A 变量现在强引用这个新的 Apartment 实例:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png"><br></div>

<p>现在可以联系两个实例到一起,现在人有了公寓,公寓也有了一个租客。注意这里使用了感叹号来拆包和访问 john 和 unit4A 可选变量, 所以这些实例的属性可以被设置:</p>
<pre><code>
john!.apartment = unit4A
unit4A!.tenant = john
</code></pre>

<p>下面是连接两个实例之后的强引用的样子:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png"><br></div>

<p>不幸运的是, 联系这两个实例,导致在它们之间建立了强引用循环。Person 实例现在有了一个强引用到 Apartment 实例, 然后 Apartment 实例有一个强引用到 Person 实例。因此, 当你打破 john 和 unit4A 变量拥有的强引用, 引用计数也不会降为0, 实例也不会被ARC销毁:</p>
<pre><code>
john = nil
unit4A = nil
</code></pre>

<p>注意当你设置两个变量为nil时,两个析构器都不会调用。强引用循环阻止了 Person 和 Apartment 实例的销毁。导致你的应用内存泄露。</p>
<p>这里展示设置john 和 unit4A 变量为 nil后强引用的样子:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png"><br></div>

<p>Person 实例和 Apartment 实例之间的强引用依然没有打破。</p>
<h1 id="解决实例间的强引用循环"><a href="#解决实例间的强引用循环" class="headerlink" title="解决实例间的强引用循环"></a>解决实例间的强引用循环</h1><p>针对类类型的属性, Swift 提供了两个方法来解决强引用循环问题: weak 引用 和 unowned 引用。</p>
<p>Weak 和 unowned references 可以使一个实例在引用循环中去调用另外一个实例,而不会强引用它。然后实例之间可以互相引用而不会出现强引用循环。</p>
<p>其他实例有更短的生命期的时候使用一个弱引用—就是说, 当其他实例首先被销毁的时候。 上面的 Apartment 例子, 在公寓的生命周期内, 在某个时刻没有租客是正常的。所以在这个情况下,使用弱引用来打破强引用是合适的方式。相反, 如果其他实例有着相同或者更长的生命周期,就使用无主引用。</p>
<h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p>弱引用不会强持有它引用的实例, 并且不会阻止ARC处理引用的实例。这个行为防止出现强引用循环。你可以在属性或者变量声明前加上weak关键字来声明一个弱引用。</p>
<p>因为弱引用不会强持有它引用的实例, 在弱引用仍然引用实例的时候,有可能这个实例将要被销毁了。因此, 在引用实例销毁时, ARC 自动把弱引用设置为nil. 并且, 由于弱引用要在运行时允许它们的值修改为nil, 它们总是声明成可选类型变量, 而不是常量。</p>
<p>你可以判断在弱引用中一个值的存在与否, 就像其他可选值一样, 实例不存后,你不会得到一个无效的实例引用。</p>
<p>备注</p>
<p>ARC 设置一个弱引用为nil时, 属性观察者不会调用。</p>
<p>下面的例子和上面 Person 和 Apartment 例子是一样的, 只有一个重要的不同。这一次, Apartment 类型的 tenant 属性声明为弱引用:</p>
<pre><code>
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</code></pre>

<p>两个变量的强引用它们之间的联系创建如前 (john 和 unit4A):</p>
<pre><code>
var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")

john!.apartment = unit4A
unit4A!.tenant = john
</code></pre>

<p>这里展示联系两个实例后,引用的样子:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png"><br></div>

<p>Person 实例依然强引用 Apartment 实例, 不过 Apartment 实例现在是弱引用 Person 实例了。这就意味着, 当你设置john为nil来打破这个强引用的时候, 就不会再有对 Person 实例的强引用:</p>
<pre><code>
john = nil
// 打印 "John Appleseed is being deinitialized"
</code></pre>

<p>因为没有更多对Person实例的强引用, 它被销毁而且tenant 属性被设置为 nil:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png"><br></div>

<p>现在只剩下unit4A 变量对 Apartment 实例的强引用。如果你打破这个强引用, 就不会再有对Apartment实例的强引用:</p>
<pre><code>
unit4A = nil
// 打印 "Apartment 4A is being deinitialized"
</code></pre>

<p>因为没有更多对 Apartment 实例的强引用, 它也被销毁了:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png"><br></div>

<p>备注</p>
<p>在使用垃圾回收的系统里, 弱指针有时用来实现一个简单的缓存机制,因为没有强引用的对象只有在内存紧张的时候才会触发垃圾回收。不过, 使用 ARC, 只要值的强引用被移除了,它们就会被销毁, 为了这个目的使用弱引用是不合适的。</p>
<h1 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h1><p>很像弱引用, 无主引用不会强持有它引用的实例。跟弱引用不同的是, 当其他实例有相同或者更久的生命周期时才使用无主引用。通过在属性或者变量声明的前面加上unowned 关键字来声明无主引用。</p>
<p>一个无主引用总希望有值。结果是, ARC 永远不会把无主引用的值设为nil, 这意味着无主引用使用非可选类型来定义。</p>
<p>重要</p>
<p>使用无主引用前提是,只在你能确保引用的实例不会被销毁情况下使用。</p>
<p>如果你在实例销毁后尝试调用无主引用的值,你会得到一个运行时错误。</p>
<p>下面的例子定义了两个类, Customer 和 CreditCard, 它模拟了一个银行用户和用户的信用卡。这两个类都存储了对方的实例作为属性。这种关系有产生强引用循环的可能。</p>
<p>Customer 和 CreditCard 之间的关系与上面的Apartment 和 Person之间的关系略有不同。在这个数据模型里, 一个用户可能有或者没有一张信用卡, 但是一张信用卡总有对应的用户。一个 CreditCard 实例永远不会比它调用的用户活的更久。为了表示这个, Customer 类有一个可选的 card 属性, CreditCard 类有一个无主的 (非可选) customer 属性。</p>
<p>此外, 一个新的 CreditCard 实例创建时, 需要传递一个number 值和一个 customer 实例给自定义的 CreditCard 构造器。这个确保了一个 CreditCard 实例总会有一个对应的用户。</p>
<p>因为一张信用卡总会有一个用户, 你定义customer 属性为一个无主引用, 可以避免强引用循环:</p>
<pre><code>
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print("\(name) is being deinitialized") }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print("Card #\(number) is being deinitialized") }
}
</code></pre>

<p>备注</p>
<p>CreditCard 的number属性定义成 UInt64 类型而不是 Int, 是为了保证 number 属性的容量做够大可以在32位和64位系统上存储一个16位的信用卡号。</p>
<p>下面的代码片段定义了一个可选的 Customer 变量 john, 用来存储指向特定用户的引用。这个变量初始值是 nil, 因为它是可选的:</p>
<pre><code>
var john: Customer?
</code></pre>

<p>现在你创建了一个 Customer 实例, 然后用它初始化和分配一个新的CreditCard 实例作为用户的card 属性:</p>
<pre><code>
john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>

<p>这里是引用的样子, 现在你把两个实例联系起来了:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png"><br></div>

<p>Customer 实例现在强引用 CreditCard 实例, CreditCard 实例则是无主引用 Customer 实例。</p>
<p>由于无主的 customer 引用, 当你打破john 变量持有的强引用, 就不会有其他对 Customer 的强用了:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png"><br></div>

<p>因为没有其他对 Customer 实例的强引用, 它会被销毁，然后, 对CreditCard 实例的强引用也没有了, 所以它也被销毁了:</p>
<pre><code>
john = nil
// 打印 "John Appleseed is being deinitialized"
// 打印 "Card #1234567890123456 is being deinitialized"
</code></pre>

<p>最后的代码片段展示了Customer 实例和 CreditCard 实例析构器都打印出析构的信息。</p>
<p>备注</p>
<p>上面的例子展示了如何使用安全的无主引用。 Swift 同时提供了不安全的无主引用, 使用场景是你需要去禁用运行时安全检查—例如, 性能原因。使用所有的不安全操作, 你都有责任检查代码的安全问题。</p>
<p>通过写上unowned(unsafe)来表明这是一个不安全的无主引用。如果在实例销毁后尝试访问一个不安全的无主引用, 你的程序会访问实例原来存在的内存位置, 这是不安全的操作。</p>
<h1 id="无主引用和隐式拆包可选属性"><a href="#无主引用和隐式拆包可选属性" class="headerlink" title="无主引用和隐式拆包可选属性"></a>无主引用和隐式拆包可选属性</h1><p>上面弱引用和无主引用的例子,覆盖了更多常见情况的两种,在这种场景下需要打破一个强引用循环。</p>
<p>Person 和 Apartment 例子展示了一个情况, 有两个属性都可以设置为nil, 有导致一个强引用循环的可能。这种情况最好使用弱引用来解决。</p>
<p>Customer 和 CreditCard 例子展示了一个情况,有一个属性允许设置为nil,而另外一个属性不能设置成nil,也有产生强引用循环的可能。这个情况最好用无主引用来解决。</p>
<p>不过, 存在第三种情况, 这种情况下两个属性都应该有值, 一旦初始化完成两个属性都不能为nil. 在这个情况下, 把一个类的无主属性和其他类的隐式拆包可选属性合并是很有用的。</p>
<p>一旦初始化完成,这个可以保证两个属性都可以直接访问 (没有可选拆包), 同时避免了一个引用循环。这部分内容介绍如何建立这种关系。</p>
<p>下面的例子定义了两个类, Country 和 City, 它们互相存储对方类的实例作为属性。在这个数据模型中, 每个国家必须有一个首都,每个城市必须属于一个国家。为了表示这个, Country 有一个 capitalCity 属性, City 有一个 country 属性:</p>
<pre><code>
class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>

<p>为了建立这两个类的关联, City 构造器接收一个Country 实例, 然后把这个实例存储到它的 country 属性。</p>
<p>City 的构造器在 Country 构造器中调用。不过, Country 构造器直到一个新的Country 实例完成构造后才可以传给 City 构造器。</p>
<p>为了应对这个需求, 你把Country 的capitalCity 属性声明成一个隐式拆包可选属性, 通过在类型后加上感叹号来表明 (City!). 这就意味着 capitalCity 属性默认值为 nil, 不需要拆包就可以访问它的值。</p>
<p>因为 capitalCity 默认值是 nil, 一个新的 Country 实例在name属性在构造器被设置后会被完全初始化。这就意味着 Country 构造器开始引用和传递隐式的 self 属性,当name属性设置的时候。当Country 构造器开始设置它的capitalCity 属性时,Country 构造器可以把self作为参数传给 City 构造器。</p>
<p>所有这一切意味着,你可以在一条语句里创建 Country 和 City 实例, 而不会产生强引用循环, capitalCity 属性可以直接访问, 不需要使用感叹号去拆包它的可选值:</p>
<pre><code>
var country = Country(name: "Canada", capitalName: "Ottawa")
print("\(country.name)'s capital city is called \(country.capitalCity.name)")
// 打印 "Canada's capital city is called Ottawa"
</code></pre>

<p>上面例子里, 隐式拆包可选意味着,所有两阶段类构造需求都满足了。一旦初始化完成, capitalCity 属性可以像非可选值一样使用和访问, 同时避免了一个强引用循环。</p>
<h1 id="闭包强引用循环"><a href="#闭包强引用循环" class="headerlink" title="闭包强引用循环"></a>闭包强引用循环</h1><p>你可以看到上面展示的,实例互相引用产生的强引用循环。你也看到如何使用弱引用和无主引用来打破这种循环。</p>
<p>如果你把一个闭包赋值给类属性,也可能产生一个强引用循环, 包体捕获了这个实例。因为包体访问了实例属性, 比如 self.someProperty, 或者因为闭包调用了实例方法, 例如 self.someMethod(). 在这两种情况下, 这些访问会导致闭包捕获self, 这就产生了一个强引用循环。</p>
<p>这个强引用循环是因为闭包产生,像类一样是引用类型。当你把闭包赋值给属性时, 你就赋值了一个引用给这个闭包。本质上, 它的问题和上面是一样的—两个强引用互相保持。不过, 相比两个类实例, 这次是一个类实例和一个闭包互相保有。</p>
<p>Swift 提供一个优雅的方案来解决这个问题, 就是大家熟知的捕获列表。不过, 在你知道怎么用捕获列表来打破一个强引用循环前,有必要知道它是怎么产生的。</p>
<p>下面的例子展示使用闭包调用self时, 是如何产生强引用循环的。这个例子定义了一个类 HTMLElement, 它提供了一个简单的模拟HTML文档里的单个元素:</p>
<pre><code>
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -> String = {
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name)>"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
</\(self.name)></code></pre>

<p>HTMLElement 类定义了一个name属性, 用来表示元素名, 比如头部元素 “h1” , 段落原色”p”, 或者换行符”br”。HTMLElement 同时定义了一个可选text属性, 可以设置成字符串来表示渲染的文本。</p>
<p>除了这两个简单的属性, HTMLElement 类定义了一个lazy属性asHTML. 这个属性引用了一个闭包来把name和text合并成一个HTML片段。asHTML 属性类型是 () -&gt; String, 或者 “没有参数的函数,返回一个字符串”。</p>
<p>默认情况, asHTML 属性被指定了一个闭包,这个闭包返回字符串来表示一个 HTML 标签。如果文本存在,这个标签就包含可选文本值,否则不包含文本内容。对于一个段落元素, 闭包会返回 “</p><p>some text</p>“ 或者 “<p>“, 取决于text 属性是否等于 “some text” 或者 nil.</p>
<p>asHTML 属性命名和使用稍微有点像实例方法。不过, 因为 asHTML 是一个闭包而不是实例方法, 你可以用自定义闭包来替换它的默认值, 如果你想为一个特殊HTML元素改变HTML渲染的话。</p>
<p>例如, asHTML 属性可以设置成一个闭包, 如果text属性为nil就默认设置成一些文本, 以防返回一个空的HTML标签:</p>
<pre><code>
let heading = HTMLElement(name: "h1")
let defaultText = "some default text"
heading.asHTML = {
    return "<\(heading.name)>\(heading.text ?? defaultText)</\(heading.name)>"
}
print(heading.asHTML())
// 打印 "<h1>some default text</h1>"
</code></pre>

<p>备注</p>
<p>asHTML 属性声明成lazy属性, 因为它只有在元素需要作为字符串值进行渲染的时候才需要。asHTML 是一个lazy属性意味着你可以在默认闭包里调用self, 因为初始化完成同时self存在后,lazy属性才能访问。</p>
<p>HTMLElement 类只提供了一个构造器,它有一个name参数和一个text参数。这个类同时定义了一个析构器, 它打印一条信息来表示HTMLElement 实例被销毁了。</p>
<p>这里是如何使用 HTMLElement 类来创建和打印一个新的实例:</p>
<pre><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// 打印 "<p>hello, world</p>"
</code></pre>

<p>注意</p>
<p>paragraph 变量定义成一个可选的 HTMLElement 类型, 所以它可以设置成nil。下面展示一个强引用循环的存在。</p>
<p>不幸的是, HTMLElement 类, 在 HTMLElement 实例和用作asHTML 值的闭包之间产生了一个强引用循环。看起来是这个样子:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png"><br></div>

<p>实例的asHTML 属性强引用它的闭包。然而, 因为这个闭包在它的包体里调用了self(self.name 和 self.text), 闭包捕获了self, 这以为着它又强引用回HTMLElement 实例。两者之间就产生了一个强引用循环。</p>
<p>备注</p>
<p>尽管这个闭包多次调用self, 它只会捕获一个对 HTMLElement 实例的强引用。</p>
<p>如果你把paragraph 变量设置成nil来打破这个强引用, HTMLElement 实例和它的闭包都不会销毁, 就是因为这个强引用循环:</p>
<pre><code>
paragraph = nil
</code></pre>

<p>注意 HTMLElement 析构器的信息没有打印, 这就说明 HTMLElement 实例没有销毁。</p>
<h1 id="解决闭包强引用循环"><a href="#解决闭包强引用循环" class="headerlink" title="解决闭包强引用循环"></a>解决闭包强引用循环</h1><p>通过在闭包里定义一个捕获列表,你可以解决闭包和类实例之间的强引用循环的问题。捕获列表定义了在包体里捕获一个或者多个引用类型时的使用规则。就像两个类实例间的强引用, 你声明每个捕获的引用为弱引用或者无主引用而不是强引用。弱引用和无主引用的选择取决于你代码不同部分的联系。</p>
<p>备注</p>
<p>当你在闭包中调用self 的成员时, Swift 要求你写成 self.someProperty 或者 self.someMethod() (而不是只有someProperty 或者 someMethod())。这个帮你记住, 闭包偶尔会捕获self.</p>
<h1 id="定义捕获列表"><a href="#定义捕获列表" class="headerlink" title="定义捕获列表"></a>定义捕获列表</h1><p>捕获列表中的每一项都是一对 weak 或者 unowned 关键字,带有对一个类实例或者变量的引用或者使用一些值初始化的变量。这些写在一堆方括号内,用逗号分开。</p>
<p>把捕获列表放在闭包参数列表前,如果它们提供则返回类型:</p>
<pre><code>
lazy var someClosure: (Int, String) -> String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
    // closure body goes here
}
</code></pre>

<p>如果一个闭包没有指定参数列表或者返回类型, 就把捕获列表放在闭包最开始,后面跟着in关键字:</p>
<pre><code>
lazy var someClosure: () -> String = {
    [unowned self, weak delegate = self.delegate!] in
    // closure body goes here
}
</code></pre>

<h1 id="弱引用和无主引用"><a href="#弱引用和无主引用" class="headerlink" title="弱引用和无主引用"></a>弱引用和无主引用</h1><p>当闭包和它捕获的实例将要互相引用, 并且会同时销毁时,定义成捕获无主引用。</p>
<p>相反, 当捕获的实例在某个时间会变成nil时,定义成捕获弱引用。弱引用总是一个可选类型, 当引用的实例销毁后自动变成nil. 这个确保你可以在包体内判断它们是否存在。</p>
<p>备注</p>
<p>如果捕获的引用永不会变成nil, 它应该总是捕获为一个无主引用, 而不是一个弱引用。</p>
<p>无主引用比较适合解决上面 HTMLElement 例子里的强引用循环的问题。这里是如何写 HTMLElement 类来避免这种循环:</p>
<pre><code>
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -> String = {
        [unowned self] in
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name)>"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
</\(self.name)></code></pre>

<p>这个版本的实现和前面版本的实现是一样的, 除了asHTML闭包里的捕获列表。在这种情况下, 捕获列表是 [unowned self], 意思是 “捕获self作为无主引用而不是强引用”。</p>
<p>你可以跟以前一样创建和打印一个 HTMLElement 实例:</p>
<pre><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// 打印 "<p>hello, world</p>"
</code></pre>

<p>这里是使用捕获列表后引用的样子:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png"><br></div>

<p>这次, 闭包捕获的self是一个无主引用, 不会强引用 HTMLElement 实例。如果你把 paragraph 变量的引用设置为nil,  HTMLElement 实例就会被销毁, 可以看到析构器打印的信息在下面:</p>
<pre><code>
paragraph = nil
// 打印 "p is being deinitialized"
</code></pre>

<p>更多捕获列表信息, 参见捕获列表。</p>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><p>可选链是一个过程,用来查询和调用属性, 方法和下标用一个可选项。如果可选项包含一个值, 属性, 方法或者下标调用成功; 如果可选项为nil, 属性, 方法或者下标调用返回nil. 多次调用可以写在一起, 如果任何链中任何联系为nil,整个链就会失败。</p>
<p>备注</p>
<p>Swift 中的可选链和Objective-C中的消息传递nil很像, 但是它对任何类型都一样, 可以判断失败或者成功。</p>
<h1 id="作为强制拆包替代方案的可选链"><a href="#作为强制拆包替代方案的可选链" class="headerlink" title="作为强制拆包替代方案的可选链"></a>作为强制拆包替代方案的可选链</h1><p>在可选值后面加上问号就可以指定可选链, 如果可选值不为nil,你可以调用一个属性,函数或者下标。这个跟在可选值后放置感叹号来强制拆包很相似。区别是,当可选项为nil时,可选链接就会失败。如果可选项为nil,强制拆包会触发运行时错误。</p>
<p>为了反映可选链接可以被nil值调用的事实, 一个可选链接调用的结果总是一个可选值, 即使你查询的属性,方法或者下标返回一个非可选的值。你使用返回值来判断可选链接调用是否成功, 或者判断是否因为有nil存在导致了失败。</p>
<p>特别指出, 可选连接调用的结果和预期返回值的类型是一样的, 但是包在一个可选项中。如果通过可选链接访问, 正常要返回Int的属性会返回Int?</p>
<p>下面的代码片段展示了可选链接和强制拆包的区别, 确保你可以用来判断成功与否。</p>
<p>首先, 定义两个类Person 和 Residence:</p>
<pre><code>
class Person {
    var residence: Residence?
}

class Residence {
    var numberOfRooms = 1
}
</code></pre>

<p>Residence 实例只有一个整型属性 numberOfRooms, 默认值是 1. Person 实例有一个可选Residence?类型属性 residence.</p>
<p>如果你创建一个新的 Person 实例, 它的residence 属性默认初始化为nil,因为它是可选的。下面的代码里, john 有一个值为nil的属性residence:</p>
<pre><code>
let john = Person()
</code></pre>

<p>如果你想访问person属性 residence的属性 numberOfRooms, 可以在residence 后面放置一个感叹号来强制拆包它的值, 由于还没有值可以拆包,所以你会触发一个运行时错误:</p>
<pre><code>
let roomCount = john.residence!.numberOfRooms
// 触发运行时错误
</code></pre>

<p>当john.residence有一个非nil值时,上面的代码会成功,然后会把合适的房间数量设置给 roomCount. 不过, 当residence 为nil时,这个代码总会触发运行时错误。</p>
<p>可选链接提供了一个替代方式来访问 numberOfRooms 的值。通过在感叹号的位置使用问号来使用可选链接:</p>
<pre><code>
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 "Unable to retrieve the number of rooms."
</code></pre>

<p>这会告诉 Swift 去链接可选的residence 属性,如果它存在就返回 numberOfRooms 的值。</p>
<p>由于尝试访问 numberOfRooms 有可能失败, 可选链接尝试放回一个 Int? 类型值, 或者“可选整型”。当 residence 为nil, 这个可选整型将会是nil, 这样就不能访问 numberOfRooms. 可选整型通过可选绑定来访问,然后去拆包这个整数同时把非空值赋值给roomCount 变量。</p>
<p>注意,尽管numberOfRooms 是一个非空的整型,这个也是真的。通过可选链接查询的事实意味着调用numberOfRooms 总是返回 Int? 而不是 Int.</p>
<p>你可以把一个 Residence 实例赋值给john.residence, 这样它就不会是一个空值了:</p>
<pre><code>
john.residence = Residence()
</code></pre>

<p>john.residence 现在有了一个实际的 Residence 实例, 而不是nil. 如果你用之前一样的可选链接访问 numberOfRooms, 它将放回 Int? , 包含一个默认值为1的 numberOfRooms:</p>
<pre><code>
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 "John's residence has 1 room(s)."
</code></pre>

<h1 id="为可选链接定义模型类"><a href="#为可选链接定义模型类" class="headerlink" title="为可选链接定义模型类"></a>为可选链接定义模型类</h1><p>你可以用可选链接调用多个层次的属性,方法或者下标。这使得你可以在复合相关类型内,向下获取子属性。然后判断是否可以在这些子属性上访问属性,方法或者下标。</p>
<p>下面的代码片段定义了四个模型类,用于下面的例子。包括多层次可选链接的例子。这些类在 the Person 和 Residence 模型上展开, 加入了两个类 Room 和 Address, 带有对应的属性,方法和下标。</p>
<p>Person 类定义和以前一样:</p>
<pre><code>
class Person {
    var residence: Residence?
}
</code></pre>
Residence 类比以前复杂。这次, Residence 类定义了一个变量属性rooms, 用一个空数组[Room]初始化:
<pre><code>
class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("The number of rooms is \(numberOfRooms)")
    }
    var address: Address?
}
</code></pre>

<p>因为这个版本的 Residence 存储了一组 Room 实例, 它的numberOfRooms 属性实现成一个计算属性, 而不是一个存储属性。numberOfRooms 属性简单返回了rooms 数组的个数。</p>
<p>作为访问romms 数组的简写, 这个版本的 Residence 提供了一个读写下标,来访问rooms数组指定索引下的房间。</p>
<p>这个版本的 Residence 同时提供了一个方法printNumberOfRooms, 它只是简单打印住宅中的房间数。</p>
<p>最后, Residence 定义了一个可选属性 address, 类型是 Address?. Address 类下面定义。</p>
<p>用于rooms数组的Room类是带有一个属性name的简单类, 还有一个构造器,用来设置这个房间的名字:</p>
<pre><code>
class Room {
    let name: String
    init(name: String) { self.name = name }
}
</code></pre>

<p>模型里最后一个类是 Address. 这个类有三个类型为String?的可选属性。前面两个属性, buildingName 和 buildingNumber, 是两种方案来识别某个建筑的地址部分。第三个属性 street, 用来命名地址里的街道:</p>
<pre><code>
class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if buildingNumber != nil && street != nil {
            return "\(buildingNumber) \(street)"
        } else if buildingName != nil {
            return buildingName
        } else {
            return nil
        }
    }
}
</code></pre>

<p>Address 类同时提供了一个方法 buildingIdentifier(), 它有一个String?类型的返回值。这个方法判断地址的属性,如果有值就返回 buildingName, 如果buildingNumber 和 street 都有值,就返回两者的连接, 否则返回nil.</p>
<h1 id="通过可选链接访问属性"><a href="#通过可选链接访问属性" class="headerlink" title="通过可选链接访问属性"></a>通过可选链接访问属性</h1><p>可选链接中描述它可以作为强制拆包的替代方案, 你可以在一个可选值上使用可选链接来访问一个属性, 然后判断属性访问是否成功。</p>
<p>使用上面定义的类创建一个新的 Person 实例, 然后像以前一样访问它的属性numberOfRooms:</p>
<pre><code>
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 "Unable to retrieve the number of rooms."
</code></pre>
因为 john.residence 为nil, 可选链接像以前一样会调用失败。

你也可以通过可选链接给属性设置一个值:
<pre><code>
let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress
</code></pre>

<p>在这个例子里, 尝试设置john.residence的属性 address 将会失败, 因为 john.residence 现在是nil.</p>
<p>赋值是可选链接的一部分, 意味者=运算符的右侧代码不会执行。在上一个例子, 容易看到 someAddress 不会执行, 因为访问一个常量不会有任何边界影响。下面的代码做了同样的赋值, 不过它使用一个函数去创建地址。在返回值前函数会打印 “Function was called”, 这个会让你看到=运算符右侧代码是否执行了。</p>
<pre><code>
func createAddress() -> Address {
    print("Function was called.")

    let someAddress = Address()
    someAddress.buildingNumber = "29"
    someAddress.street = "Acacia Road"

    return someAddress
}
john.residence?.address = createAddress()
</code></pre>

<p>你可以看到createAddress() 函数不会执行, 因为什么也没有打印。</p>
<h1 id="通过可选链接调用方法"><a href="#通过可选链接调用方法" class="headerlink" title="通过可选链接调用方法"></a>通过可选链接调用方法</h1><p>你可以在一个可选值上通过可选链接调用一个方法, 然后判断调用是否成功。即使这个方法没有定义返回值,你也可以这么做。</p>
<p>Residence 类的 printNumberOfRooms() 方法打印numberOfRooms的当前值。这里是方法的样子:</p>
<pre><code>
func printNumberOfRooms() {
    print("The number of rooms is \(numberOfRooms)")
}
</code></pre>

<p>这个方法没有指定返回值。不过, 没有返回值的方法和函数有一个隐式的返回值Void. 这就说它们返回了(), 或者说一个空元组。</p>
<p>如果你使用可选链接,在一个可选值上调用这个方法。这个方法的返回类型会是 Void?, 而不是Void, 因为通过可选链接调用总是返回一个可选值。这让你可以使用if语句来判断能否调用printNumberOfRooms() 方法, 尽管这个方法本身没有定义返回值。把printNumberOfRooms 返回值和 nil 比较来查看方法调用是否成功:</p>
<pre><code>
if john.residence?.printNumberOfRooms() != nil {
    print("It was possible to print the number of rooms.")
} else {
    print("It was not possible to print the number of rooms.")
}
// 打印 "It was not possible to print the number of rooms."
</code></pre>

<p>如果你尝试通过可选链接设置属性也是一样。上面的例子尝试为 john.residence 设置地址值, 尽管residence 属性是nil. 通过可选链接设置属性值都会返回一个Void?, 让你可以跟nil比较,来判断设置属性是否成功:</p>
<pre><code>
if (john.residence?.address = someAddress) != nil {
    print("It was possible to set the address.")
} else {
    print("It was not possible to set the address.")
}
// 打印 "It was not possible to set the address."
</code></pre>

<h1 id="通过可选链接访问下标"><a href="#通过可选链接访问下标" class="headerlink" title="通过可选链接访问下标"></a>通过可选链接访问下标</h1><p>你可以在可选值上使用可选链接来获取或者设置一个下标值, 然后判断下标调用是否成功。</p>
<p>备注</p>
<p>当你通过可选链接访问可选值的下标时, 你要把问号放置在下标括号的前面而不是后面。这个问号总是直接跟在可选表达式的后面。</p>
<p>下面的例子尝试获取john.residence的房子数组中第一个房子的名字,使用的是定义在Residence类里的下标。因为 john.residence 现在是 nil, 下标调用会失败:</p>
<pre><code>
if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// 打印 "Unable to retrieve the first room name."
</code></pre>

<p>下标调用中的可选链接问号直接放在john.residence后面, 在下标括号前面, 因为 john.residence 是可选值。</p>
<p>相似的, 你可以使用可选链接,通过下标来设置新值:</p>
<pre><code>
john.residence?[0] = Room(name: "Bathroom")
</code></pre>
这个下标设置的尝试也会失败, 因为residence 当前值为nil.

如果你创建一个实际的 Residence 实例并把它赋值给 john.residence, 同时带有一个或者多个 Room 实例存于rooms 数组, 你可以通过可选链接,使用 Residence 下标访问rooms数组中的实际项:
<pre><code>
let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Living Room"))
johnsHouse.rooms.append(Room(name: "Kitchen"))
john.residence = johnsHouse

if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// 打印 "The first room name is Living Room."
</code></pre>

<h1 id="访问可选类型下标"><a href="#访问可选类型下标" class="headerlink" title="访问可选类型下标"></a>访问可选类型下标</h1><p>如果一个下标返回一个可选类型值—比如Swift 字典类型的key下标—在下标方括号后面加上问号来链接它的可选返回值:</p>
<pre><code>
var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0] += 1
testScores["Brian"]?[0] = 72
// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]
</code></pre>

<p>上面的例子定义了一个字典 testScores, 它包含了两个键值对,把一个字符串键映射到一个整数数组。这个例子用可选链接把Dave数组的第一项设置成 91; 把Bev数组的第一项值增加1; 并且尝试为键为Brian的数组设置第一项的值。前两个调用成功, 因为testScores 字典包含 “Dave” 和 “Bev”. 第三个调用会失败, 因为 testScores 字典并不包含 “Brian” 键。</p>
<h1 id="多层链接"><a href="#多层链接" class="headerlink" title="多层链接"></a>多层链接</h1><p>你可以使用多层链接来访问模型的属性,方法和下标。不过, 多层链接不会给返回值添加更多可选性。</p>
<p>换句话说:</p>
<p>如果你获取的类型不是可选的, 由于可选链接,它会变成可选类型。<br>如果你获取的类型已经是可选的了, 它不会因为可选链接而变的更可选。<br>因此:</p>
<p>如果你通过可选链接去获取一个Int值, 会返回一个Int?, 不管使用了多少层的链接。<br>类似的, 如果你使用可选链接去获取一个 Int?值, 会返回一个Int?, 不管使用了多少层的连接。<br>下面的例子尝试访问john的属性residence 的属性address 的属性street. 这里用了两层可选链接, 来链接 residence 和 address 属性, 它们都是可选类型:</p>
<pre><code>
if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// 打印 "Unable to retrieve the address."
</code></pre>
john.residence 的值现在有一个有效的 Residence 实例。不过, john.residence.address 的值现在是 nil. 所以,  john.residence?.address?.street 调用失败。

注意在上面的例子里, 你尝试获取street属性的值。这个属性的类型是 String?. 因此 john.residence?.address?.street 也是 String? 类型, 尽管使用了两层可选链接。

如果你为john.residence?.address?设置一个实际的地址, 并且为address的属性street设置一个实际值, 你就可以使用多层链接访问street属性的值了:
<pre><code>
let johnsAddress = Address()
johnsAddress.buildingName = "The Larches"
johnsAddress.street = "Laurel Street"
john.residence?.address = johnsAddress

if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// 打印 "John's street name is Laurel Street."
</code></pre>

<p>在这个例子里, 尝试设置john.residence的address属性会成功, 因为john.residence现在包含了一个有效的 Residence 实例。</p>
<h1 id="使用可选返回值链接方法"><a href="#使用可选返回值链接方法" class="headerlink" title="使用可选返回值链接方法"></a>使用可选返回值链接方法</h1><p>前面的例子展示如何通过可选链接获取一个可选类型的属性值。你也可以使用可选链接,调用返回值是可选类型的方法, 如果需要可以链接方法的返回值。</p>
<p>下面的例子使用可选链接调用 Address 类的 buildingIdentifier() 方法。这个方法返回值类型是 String?. 就像上面描述的, 可选链接最后的返回类型也是 String?:</p>
<pre><code>
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print("John's building identifier is \(buildingIdentifier).")
}
// 打印 "John's building identifier is The Larches."
</code></pre>

<p>如果你想执行更深的操作链接方法的返回值, 就在方法括号的后面放上可选链接的问号:</p>
<pre><code>
if let beginsWithThe =
    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
    if beginsWithThe {
        print("John's building identifier begins with \"The\".")
    } else {
        print("John's building identifier does not begin with \"The\".")
    }
}
// 打印 "John's building identifier begins with "The"."
</code></pre>

<p>备注</p>
<p>在上面的例子里, 你在括号后面放上了可选链接问号, 因为你链接的可选值是 buildingIdentifier() 方法的返回值, 并不是buildingIdentifier() 方法本身。</p>
<h1 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h1><p>错误处理是在你的程序中响应错误条件并恢复的过程。Swift 为在运行时抛出,捕获,传递和恢复错误提供了一级支持。</p>
<p>有些操作不能保证总能顺利执行或者产生有用的输出。可选用来代表缺值, 但是当一个操作失败了, 知道失败怎么产生的通常很有用, 所以你的代码可以相应作出响应。</p>
<p>例如, 考虑从磁盘读取和处理数据的任务。这个任务有很多方式失败, 包括指定位置文件不存在, 文件没有读的权限, 或者文件不能以兼容的格式进行编码。这些不同场景的区分允许程序去解决一些错误,和用户沟通它不能解决的任何错误。</p>
<h1 id="表示和抛出错误"><a href="#表示和抛出错误" class="headerlink" title="表示和抛出错误"></a>表示和抛出错误</h1><p>在 Swift里, 错误用符合错误协议的类型值表示。这个空协议表明一个类型可以用来错误处理。</p>
<p>Swift 枚举类型特别适合用来模拟一组相关的错误条件, 带有对应的值来传达错误的额外信息。例如, 这里有一组,在一个游戏中操作自动售货机的错误条件:</p>
<pre><code>
enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
</code></pre>

<p>抛出一个错误,让你表明异常发生了,正常执行语句不能继续了。例如, 下面的代码抛出一个错误,表明自动售货机需要五个以上的硬币:</p>
<pre><code>
throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre>

<h1 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h1><p>当一个错误抛出来后, 一些包围的代码要负责处理这个错误—比如, 通过修正这个问题, 尝试替代方法或者通知用户执行失败。</p>
<p>Swift 里有四种方法来处理错误。你可以把错误从函数传递到调用函数的代码里;使用一个 do-catch 语句来处理错误,;把错误当做一个可选值来处理;或者断言这个错误不会发生。</p>
<p>当一个函数抛出一个错误时, 它改变了你的程序流, 所以快速判断抛出错误代码的位置很重要。为了在你的代码里判断这些位置,在调用会抛出错误的函数,方法或者构造器的代码前写上try 关键字—或者它的变体 try? 或者 try!. </p>
<p>备注</p>
<p>Swift 的错误处理像其他语言的异常处理, 也是使用try, catch 和throw 关键字。给很多语言不同的是—包括 Objective-C— Swift 的错误处理不涉及解除调用堆栈, 这个过程花费太多的计算。像这样, 抛出异常语句的性能可以媲美这些返回语句。</p>
<h1 id="用抛出函数传递错误"><a href="#用抛出函数传递错误" class="headerlink" title="用抛出函数传递错误"></a>用抛出函数传递错误</h1><p>为了表示一个函数,方法或者构造器可以抛出错误, 在函数定义里,把throws 关键字写在函数括号的后面。用throws 标记的函数就是一个抛出函数。如果函数指定了一个返回值, 把 throws 关键字写在返回箭头之前 (-&gt;).</p>
<pre><code>
func canThrowErrors() throws -> String

func cannotThrowErrors() -> String
</code></pre>

<p>一个抛出函数把错误传递到它被调用的地方。</p>
<p>备注</p>
<p>只有抛出函数可以传递错误。非抛出函数内部的错误只能在函数内部处理。</p>
<p>在下面的代码里, VendingMachine 类有一个方法 vend(itemNamed:),如果请求项目不合理,它会抛出一个对应的VendingMachineError, 超出存货, 或者有一笔消费超过了当前的存量:</p>
<pre><code>
struct Item {
    var price: Int
    var count: Int
}
class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Pretzels": Item(price: 7, count: 11)
    ]
    var coinsDeposited = 0
    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.invalidSelection
        }
        guard item.count > 0 else {
            throw VendingMachineError.outOfStock
        }
        guard item.price <= coinsdeposited="" else="" {="" throw="" vendingmachineerror.insufficientfunds(coinsneeded:="" item.price="" -="" coinsdeposited)="" }="" var="" newitem="item" newitem.count="" inventory[name]="newItem" print("dispensing="" \(name)")="" <="" code=""></=></code></pre>

<p>vend(itemNamed:) 方法使用 guard 语句,如果任何购买小吃的要求不能满足,就尽早退出和抛出错误。因为一个throw 语句会立即转移程序控制, 只有所有的要求都满足才会出售货品。</p>
<p>因为 vend(itemNamed:) 方法会传递所有抛出的错误, 任何调用这个方法的代码要么处理这个错误—用 do-catch 语句, try?, 或者 try!—要么继续传递这些错误。例如, 这个例子里的buyFavoriteSnack(person:vendingMachine:) 方法也是一个抛出函数, vend(itemNamed:) 方法抛出的错误会传递到 buyFavoriteSnack(person:vendingMachine:) 函数被调用的地方。</p>
<pre><code>
let favoriteSnacks = [
    "Alice": "Chips",
    "Bob": "Licorice",
    "Eve": "Pretzels",
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre>

<p>在这个例子里,buyFavoriteSnack(person: vendingMachine:) 函数查询给定客户最喜欢的小吃,然后调用vend(itemNamed:)方法来购买。由于 vend(itemNamed:) 方法可以抛出错误, 所以在它前面加上try关键字来调用。</p>
<p>抛出构造器和抛出函数一样可以传递错误。例如, 下面PurchasedSnack 结构体的构造器调用了一个抛出函数作为构造过程的一部分, 通过传递错误给调用者,它处理任何它遇见的错误。</p>
<pre><code>
struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
</code></pre>

<h1 id="使用-Do-Catch-处理错误"><a href="#使用-Do-Catch-处理错误" class="headerlink" title="使用 Do-Catch 处理错误"></a>使用 Do-Catch 处理错误</h1><p>你可以用一个 do-catch 语句来处理错误。如果一个错误被do字句的代码抛出来, 它匹配 catch 字句来决定哪一个来处理这个错误。</p>
<p>这里是 do-catch 语句的一般样式:</p>
<pre><code>
do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</code></pre>

<p>在catch后面写上模式来表明这个字句可以处理什么错误。如果一个 catch 字句没有一个模式, 字句就会匹配所有的错误并且把错误绑定到一个本地的常量 error. 更多模式匹配,参见模式。</p>
<p>catch 字句并不需要处理所有do字句抛出来的错误。如果没有 catch 字句处理这个错误, 这个错误就会传递到周围代码。不过, 这个错误必须被周围代码处理—或者被一个封闭的 do-catch 字句或者在一个抛出函数内部处理。例如, 下面的代码处理了VendingMachineError 列举的所有三种情况, 但是所有其他的错我必须被周围代码处理:</p>
<pre><code>
var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.invalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
    print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
}
// 打印 "Insufficient funds. Please insert an additional 2 coins."
</code></pre>

<p>在上面的例子里, buyFavoriteSnack(person:vendingMachine:) 在一个try表达式里调用, 因为它可以抛出一个错误。如果一个错误抛出了, 语句执行立即转到 catch 字句, 它觉得是否允许传递继续。如果没有错误抛出来, do 语句剩下的语句会继续执行。</p>
<h1 id="转换错误成可选值"><a href="#转换错误成可选值" class="headerlink" title="转换错误成可选值"></a>转换错误成可选值</h1><p>通过转换错误成一个可选值,你可以使用 try? 来处理错误。当执行try?表达式时,如果一个错误抛出来了,表达式的值就会变成nil. 例如, 下面的例子里x和y有着相同的值和行为:</p>
<pre><code>
func someThrowingFunction() throws -> Int {
    // ...
}

let x = try? someThrowingFunction()

let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>

<p>如果 someThrowingFunction() 抛出一个错误, x和y的值就是nil. 否则, x和y值就是函数的返回值。注意,无论函数返回什么类型,x和y都是可选的。这里函数返回的是一个整数, 所以x和y是可选的整数。</p>
<p>当你想处理所有相同方式的错误时,使用 try? 让你可以写出更加精确的错误处理代码。例如, 下面的代码使用了一些简单的方法来获取数据, 如果所有的方法都失败了则返回nil.</p>
<pre><code>
func fetchData() -> Data? {
    if let data = try? fetchDataFromDisk() { return data }
    if let data = try? fetchDataFromServer() { return data }
    return nil
}
</code></pre>

<h1 id="禁用错误传递"><a href="#禁用错误传递" class="headerlink" title="禁用错误传递"></a>禁用错误传递</h1><p>有时,你不希望一个抛出函数或者方法在运行时抛出一个错误。这种情况下, 可以在表达式前面写上 try!来禁用错误传递并且把调用包裹在运行的断言中,这错误就不会抛出。如果一个错误时间上出现了, 你会得到一个运行时错误。</p>
<p>例如, 下面的代码使用了 loadImage(atPath:) 函数, 它从一个给定的路径导入图片资源,如果图片不能导入则抛出一个错误。在这种情况下, 因为图片是靠程序输送, 运行时不会有错误抛出, 所以它适合禁用错误传递。</p>
<pre><code>
let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
</code></pre>

<h1 id="指定清理行为"><a href="#指定清理行为" class="headerlink" title="指定清理行为"></a>指定清理行为</h1><p>在代码执行离开当前代码块之前,你可以用一个defer语句来执行一组语句。这个语句让你可以做一些必须的清理工作,这个工作执行时无视怎样离开当前代码块—不管它是因为错误发生还是因为return或者break语句。例如, 你可以使用一个defer语句,来确保文件描述符被关闭,手动分配的内存被释放。</p>
<p>一个defer语句一直到当前代码块退出才会执行。这个语句由defer关键字和执行语句组成。推迟语句不会包含任何把控制转移的语句。 比如 break 或者 return 语句, 也不会抛出错误。推迟行为以它们被指定的相反顺序执行—也就说, defer语句第一行代码会在第二行代码后执行,以此类推。</p>
<pre><code>
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
    }
}
</code></pre>

<p>上面的例子使用了一个 defer 语句来确保 open(<em>:) 函数会调用 close(</em>:).</p>
<p>备注</p>
<p>即使没有涉及错误处理代码,你也可以使用一个defer语句。</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型转换是是判断实例类型的一种方法, 或者在它的继承层次里,把来自某些地方的实例作为不同的超类或者子类。</p>
<p>Swift中的类型转换使用is和as操作符。这两个操作符提供了简单有效的方式来判断一个值的类型或者把一个值转换成不同的类型。</p>
<p>你可以通过类型转换来判断一个类型是否遵守某个协议, hecking for Protocol Conformance 有描述。</p>
<h1 id="为类型转换定义类层次"><a href="#为类型转换定义类层次" class="headerlink" title="为类型转换定义类层次"></a>为类型转换定义类层次</h1><p>你可以在类和子类层次使用类型转换,来判断特定类实例的类型,同时可以在相同的层次里把实例转换成另外一个类类型。下面三个代码片段定义了一类层次,还有一个包含这些类实例的数组, 在类型转换的例子中使用。</p>
<p>第一个代码片段定义了了一个新的基类 MediaItem. 这个类为任何出现在数字媒体库中的项目提供基本的功能。特别的是, 它声明了一个字符串类型的 name属性, 还有个一个 init 构造器。 (它假定所有媒体项,包括电影和歌曲,都有名字)</p>
<pre><code>
class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
</code></pre>

<p>下面的代码片段定义了两个 MediaItem的子类。第一个子类, Movie, 封装了一部电影的额外信息。它添加了一个 director 属性和一个对应的构造器。第二个子类, Song, 添加了一个add属性和一个构造器:</p>
<pre><code>
class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
</code></pre>

<p>最后的代码片段创建了一个常量数组 library, 它包括了两个 Movie 实例和三个 Song 实例。library 数组的类型通过用字面量内容初始化可以推断出来。 Swift 类型检查者可以推断出 Movie 和 Song 有一个共同的基类 MediaItem, 所以它推断library 数组是 [MediaItem] 类型:</p>
<pre><code>
let library = [
    Movie(name: "Casablanca", director: "Michael Curtiz"),
    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
    Movie(name: "Citizen Kane", director: "Orson Welles"),
    Song(name: "The One And Only", artist: "Chesney Hawkes"),
    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// the type of "library" is inferred to be [MediaItem]
</code></pre>

<p>实际上存储在 library 数组里的依然是 Movie 和 Song 实例。不过, 如果遍历这个数组的内容, 你获得的类型是 MediaItem, 而不是 Movie 或者 Song. 为了使用它们本来的类型, 你需要检测它们的类型, 或者向下转换它们的类型。0</p>
<h1 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h1><p>使用类型判断操作符 (is) 来判断一个实例是否是每个子类类型。如果实例是那个子类类型,类型判断操作符就返回真,否则就返回假。</p>
<p>下面的例子定义了两个变量, movieCount 和 songCount, 用来计算存储在library数组中的 Movie 和 Song 实例的数量:</p>
<pre><code>
var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        movieCount += 1
    } else if item is Song {
        songCount += 1
    }
}

print("Media library contains \(movieCount) movies and \(songCount) songs")
// 打印 "Media library contains 2 movies and 3 songs"
</code></pre>

<p>上面的例子遍历library数组所有的项。每次传递, for-in 循环把item常量设置成数组里的下一个 MediaItem.</p>
<p>如果当前MediaItem 是一个Movie 实例, 就返回真。否则就返回假。类似的, MediaItem是 Song 就判断它是不是一个 Song 实例。for-in 循环结束后, movieCount 和 songCount 包含了对应实例的数量。</p>
<h1 id="向下转换"><a href="#向下转换" class="headerlink" title="向下转换"></a>向下转换</h1><p>实际上,特定类类型的常量或者变量调用是子类的实例。你可以使用类型转换操作符(as? 或者 as!)向下转换成子类类型。</p>
<p>由于向下转换会失败, 所以类型转换操作符有两种形式。条件形式, as?, 返回你想转换类型的可选值。强制形式, as!, 尝试向下转换并强制拆包结果。</p>
<p>当你不能确定向下转换能否成功时,使用条件形式的类型转换操作符 (as?). 这个操作符总是返回一个可选值, 如果向下转换不可能就会返回nil. 这个确保你可以判断转换的成功。</p>
<p>当你确定向下转换可以成功时,使用强制形式的类型转换操作符 (as!). 如果你转换到一个错误的类类型,这个形式的操作符会引发一个运行时的错误。</p>
<p>下面的例子遍历了library数组里的的每一个 MediaItem , 然后为每一项打印一条对应的描述信息。为了实现这个, 它需要每一项作为真实的 Movie 或者 Song来访问, 不仅仅是作为 MediaItem. 为了能可以访问 director 或者 artist 属性,然后用在描述里,这样做是必须的。</p>
<p>在这个例子里, 数组里的每一项有可能是 Movie, 或者 Song. 你不会提前知道每一项实际使用哪个类, 所以这里很适合使用条件形式的操作符 (as?) 来在循环中判断向下转换成功与否:</p>
<pre><code>
for item in library {
    if let movie = item as? Movie {
        print("Movie: \(movie.name), dir. \(movie.director)")
    } else if let song = item as? Song {
        print("Song: \(song.name), by \(song.artist)")
    }
}

// Movie: Casablanca, dir. Michael Curtiz
// Song: Blue Suede Shoes, by Elvis Presley
// Movie: Citizen Kane, dir. Orson Welles
// Song: The One And Only, by Chesney Hawkes
// Song: Never Gonna Give You Up, by Rick Astley
</code></pre>

<p>这个例子开始先尝试将当前项向下转换到类型 Movie. 因为当前项是 MediaItem 实例, 它有可能是一个 Movie; 它也有可能是一个 Song, 或者仅仅是一个基本的 MediaItem. 因为不确定性, as? 形式的类型转换符会返回一个可选值,在尝试向下转换成一个子类型时。item as? Movie 返回结果是 Movie? 类型, 或者 “可选的 Movie”.</p>
<p>如果对数组中的Song实例向下转换到 Movie 就会失败。为了处理这个情况, 例子里使用可选绑定来判断可选的l Movie 是否包含了一个值 (就是说, 判断向下转换是否成功) 可选绑定写作 “if let movie = item as? Movie”, 它可以这样读:</p>
<p>“尝试作为一个Movie来访问。 如果成功了, 把可选返回值设置给一个临时常量 movie.”</p>
<p>如果向下转换成功了, movie的属性用来为Movie实例打印一条描述信息, 包括导演名。相似的原则用于判断 Song 实例, 在找到Song实例的时候就打印对应的描述信息(包括艺术家名字)。</p>
<p>备注</p>
<p>转换不会修改实例的值。潜在的实例依然相同; 它会简单处理和访问作为转换的类型。</p>
<h1 id="Any-和-AnyObject的类型转换"><a href="#Any-和-AnyObject的类型转换" class="headerlink" title="Any 和 AnyObject的类型转换"></a>Any 和 AnyObject的类型转换</h1><p>Swift 提供两个特别类型来使用未指定的类型:<br>Any 可以表示任意类型的实例, 包括函数类型。<br>AnyObject可以表示任意类类型的实例。<br>当你需要它们提供的行为和能力的时候, 可以使用Any 和 AnyObject. 更好的建议是,在你的代码中指定你希望的类型。<br>这里有一个例子使用Any来处理不同类型的混合, 包括函数类型和非类的类型。这个例子创建了一个数组 things, 它可以存储Any类型的值:</p>
<pre><code>
var things = [Any]()
things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
things.append({ (name: String) -> String in "Hello, \(name)" })
</code></pre>

<p>things 数组包含了两个整型值, 两个浮点值, 一个字符串值, 一个元组类型 (Double, Double), 电影 “Ghostbusters”, 和一组表达式,这个表达式有一个字符串参数和一个字符串返回值。</p>
<p>为了找出一个常量或者变量的特定类型, Any 和 AnyObject 类型, 你可以在一个switch语句分支里使用is或者as. 下面的例子遍历了things数组里的每一项,然后使用一个switch语句来查询它们的类型。一些分支绑定了指定类型常量的匹配值来确保它的值被打印出来:</p>
<pre><code>
for thing in things {
    switch thing {
    case 0 as Int:
        print("zero as an Int")
    case 0 as Double:
        print("zero as a Double")
    case let someInt as Int:
        print("an integer value of \(someInt)")
    case let someDouble as Double where someDouble > 0:
        print("a positive double value of \(someDouble)")
    case is Double:
        print("some other double value that I don't want to print")
    case let someString as String:
        print("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        print("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        print("a movie called \(movie.name), dir. \(movie.director)")
    case let stringConverter as (String) -> String:
        print(stringConverter("Michael"))
    default:
        print("something else")
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called Ghostbusters, dir. Ivan Reitman
// Hello, Michael
</code></pre>

<p>NOTE</p>
<p>Any 类型表示任意类型值, 包括可选类型。如果某个地方需要一个Any类型值,你而你使用了可选值, Swift 会给你一个警告。如果你真的需要使用一个可选值作为 Any 值, 你可以使用 as 操作符显式把可选项转换为 Any, 就像下面展示的这样。</p>
<pre><code>
let optionalNumber: Int? = 3
things.append(optionalNumber)        // Warning
things.append(optionalNumber as Any) // No warning
</code></pre>

<h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><p>枚举通常用来支持一个特定类或者结构体的功能。类似的, 有时候在一个复杂类型的内部定义工具类或者结构体来使用是很方便的。为了完成这个, Swift 确保你可以定义嵌套类型, 即在支持类型定义中内嵌支持的枚举,类和结构体。</p>
<p>为了在其他类型中内嵌一个类型, 在它支持类型的外部大括号内写定义。类型可以按照需要内嵌多层。</p>
<h1 id="内嵌类型的行为"><a href="#内嵌类型的行为" class="headerlink" title="内嵌类型的行为"></a>内嵌类型的行为</h1><p>下面的例子定义了一个结构体 BlackjackCard, 它模拟了在Blackjack 游戏中玩牌。BlackJack 结构体包含了两个内嵌的枚举类型 Suit 和 Rank.</p>
<p>在 Blackjack里, Ace 牌面值或者是一或者是十一。这个特性用一个结构体 Values来表示, 它嵌套在 Rank 枚举里:</p>
<pre><code>
struct BlackjackCard {

    // nested Suit enumeration
    enum Suit: Character {
        case spades = "♠", hearts = "♡", diamonds = "♢", clubs = "♣"
    }

    // nested Rank enumeration
    enum Rank: Int {
        case two = 2, three, four, five, six, seven, eight, nine, ten
        case jack, queen, king, ace
        struct Values {
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
            case .ace:
                return Values(first: 1, second: 11)
            case .jack, .queen, .king:
                return Values(first: 10, second: nil)
            default:
                return Values(first: self.rawValue, second: nil)
            }
        }
    }

    // BlackjackCard properties and methods
    let rank: Rank, suit: Suit
    var description: String {
        var output = "suit is \(suit.rawValue),"
        output += " value is \(rank.values.first)"
        if let second = rank.values.second {
            output += " or \(second)"
        }
        return output
    }
}
</code></pre>

<p>Suit 枚举描述了玩牌的四种花色, 带有原始字符值来表示它们的符号。</p>
<p>Rank 枚举描述了13种玩牌排名, 带有一个原始整型值来表示它们的牌面值 (这个原始整型值没有用于Jack, Queen, King, 和 Ace)</p>
<p>正如上面提到的,Rank 枚举定义了更深的嵌套结构体 Values. 这个结构体封装了大多数牌都有一个值的事实, 不过 Ace 牌有两个值。 Values 结构体定义了两个属性来表示这个:</p>
<p>第一个, 类型是 Int<br>第二个, 类型是 Int?, 或者“可选 Int”<br>Rank 同时定义了一个计算属性values, 它会返回 Values 结构体的实例。这个计算属性考察牌的排名并且基于排名用对应的值来初始化新的 Values 实例。它为jack, queen, king, 和 ace使用特别的值。对于数子牌, 它使用原始整型值。</p>
<p>BlackjackCard 结构体自己有两个属性—rank 和 suit. 它也定义了一个计算属性description, 它使用rank 和 suit中的值建立牌名字和数值的描述。description 属性使用可选绑定来判断是否有第二个值需要展示, 如果是, 把第二个值插入描述信息。</p>
<p>由于 BlackjackCard 是一个没有自定义构造器的结构体, 它有一个隐式的成员构造器。你可以用这个构造器来构造一个新的常量theAceOfSpades:</p>
<pre><code>
let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)
print("theAceOfSpades: \(theAceOfSpades.description)")
// 打印 "theAceOfSpades: suit is ♠, value is 1 or 11"
</code></pre>

<p>尽管 Rank 和 Suit 嵌套在 BlackjackCard里面, 它们的类型可以通过上下文推断出来, 所以这个实例的初始化可以根据分支名调用枚举分支 (.ace 和 .spades) . 上面的例子里, description 属性正确报出黑桃 Ace 牌面值是1或者11.</p>
<h1 id="调用嵌套类型"><a href="#调用嵌套类型" class="headerlink" title="调用嵌套类型"></a>调用嵌套类型</h1><p>在定义上下文之外调用嵌套类型, 要在它的名字前加上它内嵌的类型名:</p>
<pre><code>
let heartsSymbol = BlackjackCard.Suit.hearts.rawValue
// heartsSymbol is "♡"
</code></pre>

<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展可以给存在的类,结构体,枚举或者协议类型添加新功能。包括给你无法访问的源代码扩展类型的能力 (也就是逆向建模)。 扩展类似于Objective-C 的分类。 (跟 Objective-C 分类的是, Swift 扩展没有名字)</p>
<h1 id="Swift-扩展可以"><a href="#Swift-扩展可以" class="headerlink" title="Swift 扩展可以:"></a>Swift 扩展可以:</h1><p>添加计算实例属性和计算类型属性<br>定义实例方法和类型方法<br>提供新的构造器<br>定义下标<br>定义和使用新的嵌套类型<br>让已存在的类型符合一个协议<br>在 Swift里, 你甚至可以扩展一个协议来提供需要的实现或者或者添加额外的功能符合使用的类型。</p>
<p>备注</p>
<p>扩展可以给一个类型添加新功能, 但是它们不能覆盖已经存在的功能。</p>
<h1 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h1><p>使用 extension 关键字来声明扩展:</p>
<pre><code>
extension SomeType {
    // new functionality to add to SomeType goes here
}
</code></pre>
扩展可以让已存在的类型符合一个或者多个协议。 在这种情况下, 协议名跟类和结构体的名字写法一样:
<pre><code>
extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}
</code></pre>

<p>备注</p>
<p>如果定义一个扩展来给已存在的类型添加新功能, 这个新功能给所有这种类型的实例使用, 即使它们在扩展定义前已经创建。</p>
<h1 id="计算属性-1"><a href="#计算属性-1" class="headerlink" title="计算属性"></a>计算属性</h1><p>扩展可以给已存在类型添加计算实例属性和计算类型属性。下面的例子给Swift的内建浮点类型添加了五个计算实例属性, 提供了基本支持来使用距离单位:</p>
<pre><code>
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// 打印 "One inch is 0.0254 meters"
let threeFeet = 3.ft
print("Three feet is \(threeFeet) meters")
// 打印 "Three feet is 0.914399970739201 meters"
</code></pre>

<p>这些计算属性表示,一个浮点值应该被当做一个特定的长度单位。尽管它们实现成计算属性, 这些属性的名字可以用点语法添加到浮点值的后面, 使用这些字面量来执行距离的转换。</p>
<p>在这个例子里, 浮点值 1.0 被认为表示1米。就是为什么m计算属性返回self—1.m 表达式被认为是计算1.0的浮点值。</p>
<p>其他单位转换使用米测量。一千米相当于 1,000 米, 所以km计算属性把数值乘以1_000.00 来转换成用米表示的数。相似的, 一米有3.28084 尺, 所以 ft 计算属性用潜在的浮点数值除以3.28084, 把尺转换为米。</p>
<p>这些属性是只读的计算属性, 所以它们表示的时候没有带上 get 关键字, 为了简洁性。它们的返回值是浮点型, 可以用在接受浮点数的数学运算中。</p>
<pre><code>
let aMarathon = 42.km + 195.m
print("A marathon is \(aMarathon) meters long")
// 打印 "A marathon is 42195.0 meters long"
</code></pre>

<p>备注</p>
<p>扩展可以添加新的计算属性, 但是它们不能添加存储属性, 也不能给已存在的属性添加观察者。</p>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>扩展可以给已存在类型添加新的构造器。这让你可以扩展其他类型来接受你自定的类型作为构造器的参数, 或者提供额外的构造选项,这些不会包含在类型的原始实现代码中。</p>
<p>扩展可以给一个类添加新的便利构造器, 但是不能添加新的指定构造器或者析构器。指定构造器和析构器必须在原始类实现中提供。</p>
<p>备注</p>
<p>如果使用扩展为值类型添加一个构造器, 为所有的存储属性提供默认值,同时不会定义任何自定义的构造器。你可以在你的扩展构造器里调用默认的构造器和成员构造器。</p>
<p>下面的例子定义了一个 Rect 结构体来表示一个算术矩形。这个例子同时定义了两个辅助的结构体Size 和 Point, 两个结构体都给所有的属性提供默认值 0.0:</p>
<pre><code>
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>由于 Rect 结构体给所有的属性提供了默认值, 它会有一个默认的构造器和一个成员构造器。 这些构造器可以用来创建新的 Rect 实例:</p>
<pre><code>
let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
                          size: Size(width: 5.0, height: 5.0))
                          </code></pre>
你可以扩展Rect结构体,提供一个额外的构造器,带有一个指定的中心点和大小:
<pre><code>
extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
 </code></pre>

<p>新的构造器一开始先基于提供的中心点和大小,计算出一个对应的原点。然后调用结构体的成员构造器 init(origin:size:), 它在对应的属性中存储最新的原点和大小值:</p>
<pre><code>
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
</code></pre>

<p>备注</p>
<p>如果你用扩展来提供新的构造器, 你有责任确保初始化完成时,所有实例都被完全的构造了。</p>
<h1 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h1><p>扩展可以给已存在的类型添加实例方法和类型方法。下面的例子给Int类型添加了一个新的实例方法repetitions:</p>
<pre><code>
extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {="" task()="" }="" <="" code=""></self></code></pre>

<p>repetitions(task:) 方法只有一个参数 () -&gt; Void, 它表明一个没有参数和返回值的函数。</p>
<p>扩展定义之后, 你可以在任何整数上调用 repetitions(task:) 方法来执行多次同样的任务:</p>
<pre><code>
3.repetitions {
    print("Hello!")
}
// Hello!
// Hello!
// Hello!
</code></pre>

<h1 id="改变实例方法"><a href="#改变实例方法" class="headerlink" title="改变实例方法"></a>改变实例方法</h1><p>用扩展添加的实例方法也可以改变实例本身。结构体和枚举方法,能改变自身或者属性的必须标记为 mutating, 就像来自原始实现的 mutating 方法一样。</p>
<p>下面的例子给Swift的整型添加了一个新的 mutating 方法, 它用来计算原始值的平方:</p>
<pre><code>
extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt is now 9
</code></pre>

<h1 id="下标-1"><a href="#下标-1" class="headerlink" title="下标"></a>下标</h1><p>扩展可以给已存在的类型添加下标。下面的例子给Swift 内建整型添加了个整型下标。下标 [n] 返回从右边算第n个十进制数字:</p>
<p>123456789[0] returns 9<br>123456789[1] returns 8<br>…and so on:</p>
<pre><code>
extension Int {
    subscript(digitIndex: Int) -> Int {
        var decimalBase = 1
        for _ in 0..<digitindex 2="" 5="" 7="" 9="" 10="" {="" decimalbase="" *="10" }="" return="" (self="" decimalbase)="" %="" 746381295[0]="" returns="" 746381295[1]="" 746381295[2]="" 746381295[8]="" <="" code=""></digitindex></code></pre>
如果整数没有足够的位数满足请求索引, 下标实现会返回 0, 好像这个数字左边填充了0:
<pre><code>
746381295[9]
// returns 0, as if you had requested:
0746381295[9]
</code></pre>
# 嵌套类型

扩展可以给已存在的类,结构体和枚举添加新的嵌套类型:
<pre><code>
extension Int {
    enum Kind {
        case negative, zero, positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}
</code></pre>

<p>这个例子向Int类型添加了一个新的嵌套枚举。这个枚举 Kind, 表示一个整数表示的数字种类。特别的是, 它表示这个数组是否是正数,0,或者负数。</p>
<p>这个例子同时也添加了一个新的计算属性 kind, 它会根据整数返回对应的 Kind 枚举分支。</p>
<p>这个嵌套的枚举可以用在任意整数值:</p>
<pre><code>
func printIntegerKinds(_ numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .negative:
            print("- ", terminator: "")
        case .zero:
            print("0 ", terminator: "")
        case .positive:
            print("+ ", terminator: "")
        }
    }
    print("")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// 打印 "+ + - 0 - 0 + "
</code></pre>

<p>这个函数 printIntegerKinds(_:), 输入一个整数数组然后遍历这些值。对于数组中的每一个整数来说, 函数会检查它的kind计算属性, 然后打印对应的描述信息。</p>
<p>备注</p>
<p>number.kind 已经知道是 Int.Kind 类型。因为这个原因, 所有 Int.Kind 分支值在switch语句中都是简写, 比如 .negative rather 而不是 Int.Kind.negative.</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.</p>
<p>In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</p>
<h1 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h1><p>定义协议的方式跟类,结构体和枚举很相似:</p>
<pre><code>
protocol SomeProtocol {
    // protocol definition goes here
}
</code></pre>
自定义类型规定,遵守某个协议,要把协议名写在类型名的后面,用冒号分开。多个协议可以用逗号隔开:
<pre><code>
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
</code></pre>
如果一个类有超类, 把超类名写在所有协议的前面, 后面跟着逗号:
<pre><code>
class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
</code></pre>

<h1 id="属性需求"><a href="#属性需求" class="headerlink" title="属性需求"></a>属性需求</h1><p>一个协议可以要求符合类型去提供一个带有名字和类型的实例属性或者类型属性。协议不能指定属性是否应该是一个存储属性还是一个计算属性—它只能指定需要的属性的名字和类型。协议也指定了是否每一个属性必须是 gettable 或者同时是 gettable 和 settable.</p>
<p>如果一个协议要求属性是 gettable 和 settable, 这个属性要求对于一个常量存储属性或者一个只读计算属性是没有办法完成的。如果协议只要求属性是 gettable, 这个要求可以被任意类型的属性满足, 如果这个对你自己的代码有用的话,对于settable的属性也是有效的。</p>
<p>属性需求总是声明为变量属性, 前面是var关键字。Gettable 和 settable 属性,在它们的类型声明后面写上 { get set } 来标明。gettable 属性只需写上 { get }.</p>
<pre><code>
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>
当你定义类型属性需求时,总是要在它们前面加上static 关键字。尽管类型属性需求前缀可以是static或者class,这个规则在用类实现的时候同样适用:
<pre><code>
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>
这里有一个例子,协议只有一个实例属性需求:
<pre><code>
protocol FullyNamed {
    var fullName: String { get }
}
</code></pre>
FullyNamed 协议要求符合类型提供一个完全限定的名字。协议不能指定其他关于符合类型本身的东西—它只能指定类型必须提供一个全名。协议规定任何 FullyNamed 类型必须有一个 gettable 实例属性 fullName, 它是一个字符串类型。

这里有一个结构体的例子,它采用并符合了 FullyNamed 协议:
<pre><code>
struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
</code></pre>
这个例子定义了一个结构体 Person, 它表示一个指定名字的人。它规定,采用 FullyNamed 协议作为实现的第一行的部分。

Person 每个实例都只有一个存储属性 fullName, 它们是字符串类型。这个匹配了 FullyNamed 协议的唯一需求, 说明 Person 正确遵守了这个协议。 (如果协议要求没有实现,Swift 会报编译期错误)

这里有个更复杂的类, 它也是采用并遵守了 FullyNamed 协议:
<pre><code>
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
</code></pre>

<p>这个类把fullName 属性实现为一个只读计算属性。 每个Starship 类实例存储一个强制名和一个可选的前缀。如果前缀存在,fullName 属性就使用它。放在 name 前,为 starship 创建一个完整的名字。</p>
<h1 id="方法需求"><a href="#方法需求" class="headerlink" title="方法需求"></a>方法需求</h1><p>协议可以要求符合类型实现特定的实例方法和类型方法。这些方法写在协议定义里面,跟普通实例方法和类型方法写法一致。但是没有花括号或者方法体。允许有可变参数, 遵守普通方法的规则限制。不过,协议定义中的方法参数不能指定默认值。</p>
<p>像类型属性需求一样, 定义在协议里的类型方法需要在前面加上static关键字:</p>
<pre><code>
protocol SomeProtocol {
    static func someTypeMethod()
}
</code></pre>
下面的例子,定义了一个协议,里面有一个实例方法:
<pre><code>
protocol RandomNumberGenerator {
    func random() -> Double
}
</code></pre>

<p>这个协议, RandomNumberGenerator, 要求任何符合类型必须有一个实例方法 random, 这个方法调用后会返回一个浮点值。 尽管它不是协议指定的部分, 它假设这个值会从0.0 到 1.0 (但是不包括)</p>
<p>RandomNumberGenerator 协议不会假设每个随机数怎么产生—它简单要求生成器提供一个标准方法来产生新的随机数。</p>
<p>这里实现了一个类,它采用并遵守了 RandomNumberGenerator 协议。这个类实现了一个伪随机数算法,线性同余生成器:</p>
<pre><code>
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// 打印 "Here's a random number: 0.37464991998171"
print("And another one: \(generator.random())")
// 打印 "And another one: 0.729023776863283"
</code></pre>

<h1 id="变异方法需求"><a href="#变异方法需求" class="headerlink" title="变异方法需求"></a>变异方法需求</h1><p>对于方法来说,有时候需要改变或者编译它所属的实例。对于值类型的实例方法 (结构体和枚举),可以在func关键字前加上 mutating 关键字来表明,允许这个方法改变它所属的实例和这个实例的所有属性。</p>
<p>如果你定义了一个协议实例方法,想要改变采用这个协议的任意类型的实例, 在协议定义里,在方法前标记上 mutating 关键字。 这让结构体和枚举可以采用这个协议并且满足方法需求。</p>
<p>备注</p>
<p>如果你把协议实例方法需求标记为 mutating, 那么在为类实现该方法的时候,就不需要写上 mutating 关键字。mutating 关键字只是用在结构体和枚举上。</p>
<p>下面的例子定义了一个协议 Togglable, 它只定义了一个实例方法需求 toggle. 就像它名字提示的, toggle() 方法会触发或者改变符合类型的状态。通常是修改类型的某个属性。</p>
<p>toggle() 方法用 mutating 关键字标记,作为Togglable 协议定义的一部分。表示被调用时,希望改变符合类型实例的状态:</p>
<pre><code>
protocol Togglable {
    mutating func toggle()
}
</code></pre>

<p>如果你为一个结构体或者枚举实现这个协议, 通过实现标记为mutating 的toggle()方法,这个结构体或者枚举就可以符合这个协议了。</p>
<p>下面的例子定义了一个枚举 OnOffSwitch. 这个枚举开关有两个状态, 用枚举分支 on 和 off表示。枚举开关实现标记为 mutating, 为了匹配 Togglable 协议的需求:</p>
<pre><code>
enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch is now equal to .on
</code></pre>

<h1 id="构造器需求"><a href="#构造器需求" class="headerlink" title="构造器需求"></a>构造器需求</h1><p>协议可以要求符合类型实现指定的构造器。协议定义中的构造器和普通构造器的写法是一样的, 但是没有花括号和构造体:</p>
<pre><code>
protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h1 id="类实现协议构造器需求"><a href="#类实现协议构造器需求" class="headerlink" title="类实现协议构造器需求"></a>类实现协议构造器需求</h1><p>你可以在符合协议的类中,把协议构造器实现成指定构造器或者便利构造器。在这两种情况下, 你必须用required 修饰符来标记构造器的实现:</p>
<pre><code>
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
</code></pre>

<p>使用required 修饰符确保你在所有符合协议的子类上,提供一个显式或者继承的构造器需求实现, 它们也遵守这个协议。</p>
<p>备注</p>
<p>如果符合协议的类标记了final修饰符,你就不需要用required标记协议构造器的实现,因为final 类不能子类化。</p>
<p>如果一个子类重写了超类的指定构造器, 然也实现了协议的构造器需求, 这个构造器就要同时标记required 和 override的修饰符:</p>
<pre><code>
protocol SomeProtocol {
    init()
}

class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}

class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
</code></pre>

<h1 id="可失败构造器需求"><a href="#可失败构造器需求" class="headerlink" title="可失败构造器需求"></a>可失败构造器需求</h1><p>协议可以为符合类型定义失败构造器。</p>
<p>符合类型的失败或者非失败构造器可以满足协议的失败构造器需求。而一个非失败构造器需求,只能用一个非失败构造器或者一个隐式拆包失败构造器才能满足。</p>
<h1 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h1><p>协议本身不实现任何功能。 尽管如此, 你创建的协议在代码中依然是完全成熟的类型。</p>
<p>因为协议是一个类型, 只要其他类型允许,你可以在很多地方使用它。包括:</p>
<p>在函数,方法或者构造器中作为参数类型或者返回类型<br>作为一个常量,变量或者属性类型<br>作为数组,字典或者其他容器中项目的类型<br>备注</p>
<p>因为协议是类型, 它们的名字开始是一个大写字母 (例如 FullyNamed 和 RandomNumberGenerator) ,和Swift 中其他类型名字很匹配 (例如 Int, String, 和 Double).</p>
<p>这里有一个协议作为类型使用的例子:</p>
<pre><code>
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>这个例子定义了一个新类 Dice, 它在棋盘游戏里代表一个n面的骰子。 Dice 实例有一个整数属性 sides, 它表示骰子有多少面,然后还有一个属性 generator, 它用来产生一个随机数作为骰子的值。</p>
<p>generator 属性是 RandomNumberGenerator 类型。因此, 你可以用任何采用RandomNumberGenerator协议的类型来设置它。 你赋值给这个属性的实例无需其他, 主要这个实例采用RandomNumberGenerator 协议即可。</p>
<p>Dice 也有一个构造器, 来设置它的初始状态。这个构造器有一个参数 generator, 它也是 RandomNumberGenerator 类型。在初始化新的Dice实例时,你可以传入任何符合类型的值作为这个参数。</p>
<p>Dice 还提供了一个实例方法, roll, 它返回骰子的值。这个方法调用了生成器的 random() 方法来创建一个0.0到1.0的随机数。 然后使用随机数来生成一个正确的值。因为生成器采用了 RandomNumberGenerator, 它会保证有一个random() 方法可以调用。</p>
<p>这里展示Dice类如何产生一个6面的骰子, 它使用一个LinearCongruentialGenerator 实例作为随机数生成器:</p>
<pre><code>
var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
</code></pre>

<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托是一种设计模式, 让类或者结构体可以把自己的一些责任委托给其他类型的实例。这个设计模式通过定义协议来实现,这个协议封装了委托的责任。符合类型确保提供委托的功能。委托可以用来响应特定的行为, 或者无需知道潜在资源类型,即可从资源获取数据。</p>
<p>下面的例子定义了两个协议, 用来使用基于骰子的棋盘游戏:</p>
<pre><code>
protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}
</code></pre>

<p>DiceGame 协议可以被任何包含骰子的游戏采用。DiceGameDelegate 协议可以被任何跟踪DiceGame过程的类型采用。</p>
<p>这里是有一个前面控制流中介绍过的蛇与梯子的游戏。这个版本使用一个 Dice 实例来摇骰子; 采用了 DiceGame 协议; 然后通知DiceGameDelegate 游戏的进程:</p>
<pre><code>
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
</code></pre>

<p>这个版本的游戏包装成一个类 SnakesAndLadders, 它采用了 DiceGame 协议。它提供了一个 gettable dice 属性和一个 play() 方法来遵守这个协议。(dice 属性声明为常量,因为它在初始化后就不需要变化, 协议只要求它是 gettable.)</p>
<p>蛇与梯子游戏的棋盘在构造器 init() 里设置。游戏的所有逻辑都搬到协议的play 方法里, 它使用协议的 required dice 属性来提供骰子值。</p>
<p>注意 delegate 属性定义为可选的 DiceGameDelegate, 因为委托不要求必须玩游戏。因为它是一个可选类型, delegate属性自动初始化为nil. 之后, 这个游戏实例会有一个选项来设置这个属性为一个固定的代理。</p>
<p>DiceGameDelegate 提供了三个方法来跟踪游戏的过程。 这三个方法已经合并进 play()方法中。在新游戏开始时会调用, 新一轮开始, 或者游戏结束。</p>
<p>由于delegate 属性是一个可选的DiceGameDelegate, play()在代理上调用一个方法时, 它会使用可选链接。如果 delegate  属性为nil, 这些调用会失败而不会发生错误。如果 delegate 属性非nil, 代理方法会被调用, 然后传入SnakesAndLadders 实例作为一个参数。</p>
<p>下面例子展示了一个类 DiceGameTracker, 它采用了 DiceGameDelegate 协议:</p>
<pre><code>
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}
</code></pre>

<p>DiceGameTracker 实现了所有 DiceGameDelegate 协议要求的方法。它用三个方法来跟踪游戏玩了几轮。它在游戏开始时重置 numberOfTurns 属性的值为0, 在每次游戏开始的时候加1, 然后在游戏结束后打印出游戏的总轮数。</p>
<p>gameDidStart(<em>:) 函数使用了game 参数来打印一些游戏介绍的信息。game 参数类型是 DiceGame, 而不是 SnakesAndLadders,  gameDidStart(</em>:) 可以访问和使用, 作为DiceGame 协议部分被实现的方法和属性。不过, 这个方法仍然可以使用类型转换来查询潜在实例的类型。在这个例子里, 它会判断有些是否是一个SnakesAndLadders 实例, 然后打印一条对应的信息。</p>
<p>gameDidStart(<em>:) 方法也会访问game参数的 dice属性。因为已经知道 game 遵守了DiceGame 协议, 它可以保证有一个 dice 属性, 所以 gameDidStart(</em>:) 方法也可以访问和打印dice 的 sides 属性, 而不用管正在玩什么类型的游戏。</p>
<p>这里是 DiceGameTracker 的行为:</p>
<pre><code>
let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
</code></pre>

<h1 id="给扩展添加协议"><a href="#给扩展添加协议" class="headerlink" title="给扩展添加协议"></a>给扩展添加协议</h1><p>你可以扩展一个已存在的类型来采用和遵守一个新的协议, 即使你无法访问已存在类型的源代码。扩展可以给已存在的类型添加新属性,方法和下标, 因此可以添加协议要求的任何需求。</p>
<p>备注</p>
<p>当在扩展里给一个实例类型添加协议时, 这个实例就会自动采用和遵守这个协议。</p>
<p>例如, 这个协议 TextRepresentable, 任何可以表示为文本的类型都可以实现。这可能是自我的描述或者当前状态的文本版本:</p>
<pre><code>
protocol TextRepresentable {
    var textualDescription: String { get }
}
</code></pre>
早前的 Dice 类可以扩展成采用和遵守 TextRepresentable 协议:
<pre><code>
extension Dice: TextRepresentable {
    var textualDescription: String {
        return "A \(sides)-sided dice"
    }
}
</code></pre>

<p>扩展采用新协议的方式跟原来Dice提供的实现一样。协议名写在类型名后,用冒号隔开, 协议需求的所有实现都写在扩展的花括号中。</p>
<p>所以 Dice 实例都可以认为是 TextRepresentable:</p>
<pre><code>
let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
print(d12.textualDescription)
// 打印 "A 12-sided dice"
</code></pre>
类似的, SnakesAndLadders 也可以扩展成采用和遵守TextRepresentable协议:
<pre><code>
extension SnakesAndLadders: TextRepresentable {
    var textualDescription: String {
        return "A game of Snakes and Ladders with \(finalSquare) squares"
    }
}
print(game.textualDescription)
// 打印 "A game of Snakes and Ladders with 25 squares"
</code></pre>

<h1 id="用扩展声明协议"><a href="#用扩展声明协议" class="headerlink" title="用扩展声明协议"></a>用扩展声明协议</h1><p>如果一个类型符合了协议的所有需求, 但是尚未声明它采用这个协议, 你可以用一个空的扩展,让它采用这个协议:</p>
<pre><code>
struct Hamster {
    var name: String
    var textualDescription: String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}
</code></pre>

<p>现在需要TextRepresentable 类型的地方都可以使用 Hamster 实例:</p>
<pre><code>
let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
print(somethingTextRepresentable.textualDescription)
// 打印 "A hamster named Simon"
</code></pre>

<p>备注</p>
<p>仅仅满足协议的需求,类型还不会自动采用这个协议。必须显式声明它们采用了这个协议。</p>
<h1 id="协议类型集合"><a href="#协议类型集合" class="headerlink" title="协议类型集合"></a>协议类型集合</h1><p>一个协议可以用作一个类型,存储在诸如数组或者字典的集合中。下面的例子创建了一组 TextRepresentable:</p>
<pre><code>
let things: [TextRepresentable] = [game, d12, simonTheHamster]
</code></pre>
现在可以遍历数组中的所有项目, 然后打印每一项的文字描述:
<pre><code>
for thing in things {
    print(thing.textualDescription)
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</code></pre>

<p>注意 thing 常量的类型是 TextRepresentable. 不是 Dice, 或者 DiceGame, 或者 Hamster类型, 尽管背后是这些类型。 由于它是 TextRepresentable 类型, 它又一个 textualDescription 属性, 通过循环每次访问thing.textualDescription 是安全的。</p>
<h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><p>一个协议可以继承一个或多个其他协议,在继承的需求顶层还可以添加更多的需求。协议继承的语法和类继承的语法很相似, 但是可以选择列出多个继承协议, 然后用逗号分开:</p>
<pre><code>
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // protocol definition goes here
}
</code></pre>

<p>这里有一个协议的例子,它继承了上面的 TextRepresentable 协议:</p>
<pre><code>
protocol PrettyTextRepresentable: TextRepresentable {
    var prettyTextualDescription: String { get }
}
</code></pre>

<p>这个例子定义了一个新协议, PrettyTextRepresentable, 它继承自 TextRepresentable. 任何采用 PrettyTextRepresentable 协议的都必须满足TextRepresentable 强制要求的所有需求, 然后加上PrettyTextRepresentable 强制要求的额外需求。在这个例子里, PrettyTextRepresentable 只添加了一个需求, 提供了一个 gettable 属性 prettyTextualDescription 来返回一个字符串。</p>
<p>SnakesAndLadders 类可以扩展成采用和遵守 PrettyTextRepresentable 协议:</p>
<pre><code>
extension SnakesAndLadders: PrettyTextRepresentable {
    var prettyTextualDescription: String {
        var output = textualDescription + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder > 0:
                output += "▲ "
            case let snake where snake < 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
</code></pre>

<p>这个扩展表明它采用了 PrettyTextRepresentable 协议,然后为SnakesAndLadders类型提供了prettyTextualDescription属性的实现。任何是 PrettyTextRepresentable 类型的也是 TextRepresentable 类型, 因此 prettyTextualDescription 实现的开始就是访问TextRepresentable的属性 textualDescription,用它作为输出字符串的开始部分。它往后面添加一个冒号和一个换行符, 然后使用它作为文本的开始。然后它遍历棋盘方格数组的项目, 然后把代表每个方格的几何形状添加到最后:</p>
<p>如果方格的值大于0, 它是梯子的底, 用 ▲表示。<br>如果方格的值小于0, 它是蛇的头, 用 ▼表示。<br>否则, 方格的值等于 0, 这是一个空方格, 用 ○ 表示。<br>现在 prettyTextualDescription 属性可以用来为SnakesAndLadders实例打印一条文本描述:</p>
<pre><code>
print(game.prettyTextualDescription)
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</code></pre>

<h1 id="只用于类的协议"><a href="#只用于类的协议" class="headerlink" title="只用于类的协议"></a>只用于类的协议</h1><p>通过添加一个class关键字到一个协议继承列表,你可以限制协议只被类采用 (不是结构体也不是枚举)。class关键字应该总是出现在协议继承列表的第一个, 在任何继承协议之前:</p>
<pre><code>
protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // class-only protocol definition goes here
}
</code></pre>

<p>上面的例子里, SomeClassOnlyProtocol 只能被类采用。如果让结构体或者枚举来采用这个协议,会报一个编译期错误。</p>
<p>备注</p>
<p>当协议需求定义的行为假设或者要求符合类型拥有引用语义而非值语义的时候，要使用只用于类的协议。</p>
<h1 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h1><p>一次要求一个类型符合多个协议是有用的。使用一个协议组合,你可以把多个协议合并到一个需求。协议组合的样式是 SomeProtocol &amp; AnotherProtocol. 你可以列出尽可能多的协议, 用 (&amp;)分开。</p>
<p>下面的例子把两个协议 Named 和 Aged,合并到一个协议组合需求.作为一个函数参数:</p>
<pre><code>
protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named & Aged) {
    print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(to: birthdayPerson)
// 打印 "Happy birthday, Malcolm, you're 21!"
</code></pre>

<p>这个例子定义了一个协议 Named, 需要一个 gettable 字符串属性 name. 同时它也定义了另外一个协议 Aged,需要一个的 gettable 整型属性 age. 这个两个协议都被一个结构体 Person 采用。</p>
<p>这个例子还定义了一个函数 wishHappyBirthday(to:), celebrator 参数类型是 Named &amp; Aged, 意思是 “任何遵守 Named 和 Aged 协议的类型” 它不关心传入的类型是什么, 只要它遵守这两个协议的要求。</p>
<p>这个例子然后创建了一个新的 Person 实例 birthdayPerson, 然后把这个新实例传入 wishHappyBirthday(to:) 函数。因为 Person 遵守两个协议, 这是一个有效的调用, wishHappyBirthday(to:) 函数可以打印生日祝福。</p>
<p>备注</p>
<p>协议组合没有定义一个新的,永久的协议类型。相反, 它们只是定义了一个本地临时的协议,用来合并组合中所有协议的需求。</p>
<h1 id="判断协议一致性"><a href="#判断协议一致性" class="headerlink" title="判断协议一致性"></a>判断协议一致性</h1><p>你可以使用在类型转换中介绍的 is 和 as 操作符来判断协议的一致性, 并且转换成指定的协议。判断和转换协议跟判断和转换类型的语法完全一致:</p>
<p>如果一个实例符合一个协议, is 操作符返回 true,反之返回 false.<br>向下转换操作符 as? 会返回协议类型的一个可选值, 如果这个实例不符合该协议,这个值是 nil.<br>向下转换操作符 as! 强制转换成这个协议,如果转换失败会触发一个运行时错误。<br>下面的例子定义了一个协议 HasArea, 只有一个gettable 要求的浮点型属性 area:</p>
<pre><code>
protocol HasArea {
    var area: Double { get }
}
</code></pre>
这里有两个类, Circle 和 Country, 它们都符合 HasArea 协议:
<pre><code>
class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
</code></pre>

<p>Circle 类把 area 属性要求实现成了一个计算属性, 它基于一个存储属性 radius. Country 类直接把 area 属性需求实现成了一个存储属性。两个类都准确的符合了 HasArea 协议。</p>
<p>这里有一个类 Animal, 它不符合 HasArea 协议:</p>
<pre><code>
class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
</code></pre>
Circle, Country 和 Animal 类没有共享的基类。不过, 它们都是类, 所以三个类型的实例都快要用来初始化数组,这类数组存储AnyObject类型的值:
<pre><code>
let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
</code></pre>

<p>objects 数组用三个字面量来初始化,包括半径为2的 Circle 实例; 用英国表面积初始化的 Country 实例; 有四条腿的 Animal 实例。</p>
<p>现在可以遍历objects 数组, 可以判断数组里的每一项,看看它们是否符合 HasArea 协议:</p>
<pre><code>
for object in objects {
    if let objectWithArea = object as? HasArea {
        print("Area is \(objectWithArea.area)")
    } else {
        print("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>

<p>只要数组中的对象符合 HasArea 协议, as? 操作符返回的可选值会使用可选绑定拆包到一个常量 objectWithArea.  objectWithArea 常量是 HasArea类型, 所以它的 area 属性可以访问和安全的打印。</p>
<p>注意,潜在的对象没有被转换过程改变。它们依然是一个 Circle, 一个 Country 和一个 Animal. 不过, 在它们被存为 objectWithArea 常量的时候, 它们只是 HasArea 类型, 所有只有它们的 area 属性才能被访问。</p>
<h1 id="可选协议需求"><a href="#可选协议需求" class="headerlink" title="可选协议需求"></a>可选协议需求</h1><p>你可以为协议定义可选需求, 符合协议的类型不用去实现这些需求。协议定义中,通过前置 optional 修饰符来实现这些需求。可选需求是可用的,这样你就可以写代码和 Objective-C 交互。协议和可选需求都要用 @objc 属性来标记。注意, @objc 协议只能被继承自 Objective-C 的类或者 @objc 类采用。不能被结构体和枚举采用。</p>
<p>当你在可选需求中使用方法或者属性时, 它的类型自动成为可选。例如, 方法 (Int) -&gt; String 会变成 ((Int) -&gt; String)?. 整个函数都被可选包括,不仅仅是返回值。</p>
<p>可选协议需求可以用可选链接来调用, 来说明符合协议的类型不实现这些需求的可能性。调用可选方法的时候,通过在方法名后面写上问号来判断它是否实现, 例如  someOptionalMethod?(someArgument). </p>
<p>下面的例子定义了一个整型计数类 Counter, 它用一个外部数据源来提供增长数。这个数据源在 CounterDataSource 协议里定义, 它有两个可选需求:</p>
<pre><code>
@objc protocol CounterDataSource {
    @objc optional func increment(forCount count: Int) -> Int
    @objc optional var fixedIncrement: Int { get }
}
</code></pre>

<p>CounterDataSource 协议定义了一个可选方法需求 increment(forCount:) 和一个可选属性需求 fixedIncrement. 这些需求为外部数据源定义了两个不同方法,来为Counter 实例提供一个合适的增长数。</p>
<p>备注</p>
<p>严格来说, 你可以写一个符合CounterDataSource协议的自定义类,却不用实现它的需求。它们都是可选的。</p>
<p>下面定义的Counter 类, 有一个CounterDataSource?类型的可选的 dataSource 属性:</p>
<pre><code>
class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.increment?(forCount: count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>

<p>Counter 在一个变量属性count中存储当前值。同时定义了一个方法increment, 每次方法调用时,它就会增加count属性的值。</p>
<p>increment() 方法通过数据源的increment(forCount:)方法实现,先尝试去获取一个增长数。increment() 方法使用可选链接尝试调用 increment(forCount:), 然后把当前值传入作为参数。</p>
<p>注意,这里有两层可选链接。首先, dataSource 可能为nil, 所以它后面有个问号,来表明如果dataSource 不是nil,就可以调用 increment(forCount:). 其次, 即使 dataSource 存在, 也不能保证它实现了increment(forCount:), 因为它是一个可选需求。在这里, increment(forCount:) 没有实现的可能性也是用可选链接处理的。只有 increment(forCount:) 方法存在,它才会被调用—就是说, 它不为nil. 这就是为什么 increment(forCount:)名字后也有一个问号的原因。</p>
<p>由于上述两种原因的任意一个,调用 increment(forCount:) 都有可能会失败, 所以调用返回一个可选整型值。尽管 increment(forCount:) 在CounterDataSource 中定义的返回值是非可选的,这个也会发生。尽管有两个可选链接操作, 一个接着一个, 结果依然包在一个可选项中。</p>
<p>调用完 increment(forCount:), 返回的可选整型值会拆包到一个常量 amount, 使用可选绑定的方式。如果可选整型值的确包含一个值—就是说, 如果委托和方法都存在, 方法返回一个值—拆包得到的数量会加到存储属性count 上, 然后增长完成。</p>
<p>如果不能从increment(forCount:)方法获取到值—或者是因为 dataSource 为nil, 或者数据源没有实现 increment(forCount:)—然后 increment() 方法尝试从数据源的 fixedIncrement 属性获取值。fixedIncrement 属性也是一个可选的需求, 所以它的值是一个可选的整型值。尽管 fixedIncrement 定义时是一个非可选的属性。</p>
<p>这里有个 CounterDataSource 协议的简单实现,在这里数据源返回一个常量值3,每当它被查询的时候。它通过实现fixedIncrement 属性需求来实现这点:</p>
<pre><code>
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    print(counter.count)
}
// 3
// 6
// 9
// 12
</code></pre>

<p>上面的代码创建了一个新的 Counter 实例; 然后把数据源设置成新的 ThreeSource 实例; 然后调用 increment() 方法四次。 如预料的一样, 每次increment()调用, count 属性都会增加。</p>
<p>这里有一个更复杂的数据源 TowardsZeroSource, 它让 Counter 实例从当前值向上或者向下往0靠近:</p>
<pre><code>
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -> Int {
        if count == 0 {
            return 0
        } else if count < 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>

<p>TowardsZeroSource 类实现了来自CounterDataSource协议的可选方法 increment(forCount:), 同时使用 count 参数值来判断往哪个方向计数。如果 count 已经为0, 方法返回0,表明无需继续计算。</p>
<p>你可以用一个 TowardsZeroSource 实例配合存在的 Counter 实例来计数从-4 到 0. 一旦计数到了0, 计数停止:</p>
<pre><code>
counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    print(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</code></pre>

<h1 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h1><p>协议可以给符合的类型扩展方法和属性的实现。这让你可以在协议本身定义行为, 而不是在每个类型的个体或者在一个全局函数。</p>
<p>例如, RandomNumberGenerator 协议能够扩展提供一个 randomBool() 方法, 它用必须的 random() 方法结果来返回一个随机的布尔值:</p>
<pre><code>
extension RandomNumberGenerator {
    func randomBool() -> Bool {
        return random() > 0.5
    }
}
</code></pre>

<p>通过在协议上创建一个扩展, 所有符合类型无需额外改变即可自动获取这个方法的实现。</p>
<pre><code>
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// 打印 "Here's a random number: 0.37464991998171"
print("And here's a random Boolean: \(generator.randomBool())")
// 打印 "And here's a random Boolean: true"
</code></pre>

<h1 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h1><p>你可以用协议扩展给协议需求的任何方法和计算属性提供一个默认实现。如果符合类型提供了必须的方法和属性的实现, 这个实现会替换扩展提供的实现。</p>
<p>备注</p>
<p>扩展提供的有默认实现的协议需求和可选协议需求是不同的。尽管符合类型没有必要提供任意一种实现, 带有默认实现的需求可以不用可选链接来调用。</p>
<p>例如, PrettyTextRepresentable 协议, 它继承 TextRepresentable 协议,可以提供prettyTextualDescription 属性的默认实现,然后简单返回访问textualDescription属性的结果:</p>
<pre><code>
extension PrettyTextRepresentable  {
    var prettyTextualDescription: String {
        return textualDescription
    }
}
</code></pre>

<h1 id="给协议扩展添加限制"><a href="#给协议扩展添加限制" class="headerlink" title="给协议扩展添加限制"></a>给协议扩展添加限制</h1><p>当你定义了一个协议扩展, 你可以指定限制,符合类型在扩展的方法和属性可用前,必须满足这些限制。在协议名后面用where子句写上限制。</p>
<p>例如, 你可以给Collection 协议定义一个扩展, 它可以用于任何元素符合 TextRepresentable 协议的集合类型。</p>
<pre><code>
extension Collection where Iterator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}
</code></pre>

<p>通过把集合里的每个元素的文本描述连接在一起, textualDescription 属性返回整个集合的文本描述, 然后用方括号括起来。</p>
<p>考虑前面的结构体 Hamster, 它符合 TextRepresentable 协议, 然后是一个 Hamster 值的数组:</p>
<pre><code>
let murrayTheHamster = Hamster(name: "Murray")
let morganTheHamster = Hamster(name: "Morgan")
let mauriceTheHamster = Hamster(name: "Maurice")
let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]
</code></pre>

<p>因为数组符合 Collection 协议,并且数组的元素符合 TextRepresentable 协议, 所以数组可以用 textualDescription 属性获取它内容的文本表示:</p>
<pre><code>
print(hamsters.textualDescription)
// 打印 "[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]"
</code></pre>

<p>备注</p>
<p>如果一个符合类型满足了多个限制表达式的要求, Swift 会使用对应特定限制的实现。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型代码让你可以写出灵活,可重用的函数和类型,它们可以使用任何类型,受你定义的需求的约束。你可以写出代码,避免重复而且可以用一个清晰抽象的方式来表达它的意图。</p>
<p>泛型是Swift中最有力的特征之一, 而且大部分Swift的标准库是用泛型代码建立的。事实上, 在整个语言教程中，你一直在使用泛型,尽管你没有意识到这点。例如, Swift 的数组和字典类型都是泛型集合。 你可以创建一个整数数组,一个字符串数组,甚至是Swift允许创建的任何类型的数组。相似的, 你可以创建字典来保存任何指定类型的值, 什么类型并没有限制。</p>
<h1 id="泛型解决的问题"><a href="#泛型解决的问题" class="headerlink" title="泛型解决的问题"></a>泛型解决的问题</h1><p>这里有一个标准的非泛型的函数 swapTwoInts(<em>:</em>:), 用来交换两个整数值:</p>
<pre><code>
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>这个函数用了输入输出参数来交换a和b的值。</p>
<p>swapTwoInts(<em>:</em>:) 函数把b的原始值交换到a, a的原始值到b. 你可以调用这个函数来交换两个整型变量中的值:</p>
<pre><code>
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 打印 "someInt is now 107, and anotherInt is now 3"
</code></pre>
swapTwoInts(_:_:) 函数是有用的, 不过只能用于整数。如果你想交换两个字符串, 或者两个浮点数, 你就要写更多的函数, 比如swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 函数:
<pre><code>
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>你可能注意到了,swapTwoInts(<em>:</em>:), swapTwoStrings(<em>:</em>:), 和 swapTwoDoubles(<em>:</em>:) 的函数体是一样的。唯一不同的是它们接受的值的类型 (Int, String, 和 Double).</p>
<p>写一个可以交换任何类型值的函数,可能更有用和灵活。泛型代码让你可以写出这种函数。(这些函数的泛型版本会在下面定义。)</p>
<p>备注</p>
<p>在所有三个函数中, 重要的是a和b的类型要一样。如果a和b的类型不一样, 就不可能交换它们两个的值。 Swift 是一门类型安全的语言, 不允许把一个字符串和浮点数进行交换。如果这样做,会报一个编译期错误。</p>
<h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><p>泛型函数可以使用任何类型。这里有一个上面 swapTwoInts(<em>:</em>:)函数的泛型版本 swapTwoValues(<em>:</em>:):</p>
<pre><code>
func swapTwoValues<t>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</t></code></pre>
swapTwoValues(_:_:) 函数体和 swapTwoInts(_:_:) 函数体是一样的。不过, swapTwoValues(_:_:) 函数第一行跟swapTwoInts(_:_:) 稍微有点不一样。下面是第一行的比较:
<pre><code>
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<t>(_ a: inout T, _ b: inout T)
</t></code></pre>

<p>泛型版本的函数用了一个占位符类型名(这里叫T) ,而不是使用实际的类型名 (比如 Int, String, 或者 Double). 这个占位符类型名不说T是到底是什么, 但是它表明a和b是同样的类型 T, 无论T表示什么。每次swapTwoValues(<em>:</em>:)函数调用的时候,再决定T是什么类型。</p>
<p>其他的不同是泛型函数名后面跟着一个T包括在尖括号中 (<t>). 括号告诉 Swift ,T 在 swapTwoValues(<em>:</em>:) 函数定义中是一个占位符类型名。因为 T 是一个占位符, Swift 不能找到真正的类型 T.</t></p>
<p>现在可以像调用swapTwoInts一样调用 swapTwoValues(<em>:</em>:) 函数, 不过你可以传入两个任何类型的值, 只要两个值的类型是一样的。每次调用 swapTwoValues(<em>:</em>:), T的类型会从传入的值的类型推断出来。</p>
<p>下面两个例子里, T 分别推断为整型和字符串类型:</p>
<pre><code>
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>

<p>备注</p>
<p>上面定义的 swapTwoValues(<em>:</em>:) 函数是受到Swift 标准库函数swap的启发。它可以在你的应用里直接使用。如果你需要 swapTwoValues(<em>:</em>:) 函数的功能, 你可以使用 Swift 已存在的 swap(<em>:</em>:) 函数而不用自己重新实现。</p>
<h1 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h1><p>上面的 swapTwoValues(<em>:</em>:) 例子, 占位符类型 T 是类型参数的例子。类型参数指定和命名一个占位符类型, 直接写在函数名的后面, 在一对尖括号里面 (例如 <t>).</t></p>
<p>只要你指定了一个类型参数, 你就可以用它来定义一个函数的参数类型 (例如 swapTwoValues(<em>:</em>:) 函数里的a和b), 或者作为函数的返回值类型, 或者在函数体中用作一个类型注释。每种情况下, 函数调用时,类型参数会被真实的类型替换。</p>
<p>你可以在尖括号里写上多个类型参数,来提供更多的类型参数。用逗号分开就行。</p>
<h1 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h1><p>在大多数情况下, 类型参数有描述性的名字, 例如 Dictionary<key, value=""> 中的Key 和 Value , Array<element>里的Element, 它会告诉读者类型参数和泛型类型或者所在函数的关系。不过, 当它们之间没有一个有意义的关系时, 通常做法是用单个字母来给它们命名,比如 T, U, 和 V, 比如上面 swapTwoValues(<em>:</em>:) 函数中的T。</element></key,></p>
<p>备注</p>
<p>用驼峰式方法给参数类型命名来表明它们是一个占位符类型,而不是一个值。(例如 T 和 MyTypeParameter).</p>
<h1 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h1><p>除了泛型函数, Swift 也可以定义泛型类型。它们是可以使用任何类型的类,结构体和枚举。跟数组和字典有着相似的方式。</p>
<p>这部分内容展示如何写一个泛型集合 Stack. 栈是有序集合, 跟数组类似, 但是操作更加严格。数组允许任何位置的项的插入和移除。栈只允许在集合尾部添加 (压栈)。类似的, 栈只允许项目从集合尾部移除 (出栈)。</p>
<p>备注</p>
<p>UINavigationController 使用栈来模拟在导航层次中的视图控制器。调用 UINavigationController 的 pushViewController(<em>:animated:) 方法在导航栈上添加一个视图控制器, 调用 popViewControllerAnimated(</em>:) 方法从导航栈上移除一个视图控制器。如果你要一个后进先出的方式来管理集合,栈可以派上用场。</p>
<p>下面的图展示了栈的压栈和出栈的行为:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png"><br></div><br>当前栈上有三个值。第四个值添加到栈顶。现在栈内有四个值, 最近的值在最上面。<br>栈顶的值被移除或者出栈。弹出一个值后, 栈内现在再次是三个值。<br>这里有个非泛型版本的栈, 针对的是整型值的情况:<br><pre><code><br>struct IntStack {<br>    var items = <a href="">Int</a><br>    mutating func push(<em> item: Int) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Int {<br>        return items.removeLast()<br>    }<br>}<br></em></code></pre><br><br>这个结构体使用数组属性items来保存栈内的值。IntStack 提供了两个方法, push 和 pop, 用来压栈和出栈。这两个方法都是 mutating, 因为它们要改变结构体的 items 数组。<br><br>IntStack 类型只能用于整数, 不过。如果能定义一个泛型栈类可能会更有用, 它可以管理任何类型值。<br><br>Here’s a generic version of the same code:<br><pre><code><br>struct Stack<element> {<br>    var items = <a href="">Element</a><br>    mutating func push( item: Element) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Element {<br>        return items.removeLast()<br>    }<br>}<br></element></code></pre><br><br>注意,事实上泛型版本的栈和非泛型的版本很像, 只不过有一个类型参数 Element 取代了实际类型 Int. 这个类型名写在结构体名的后面,放在一对尖括号里面(<element>).<br><br>Element 是一个占位符的名字。这个未来类型可以在结构体定义中作为元素使用。在这种情况下, Element 在三个地方用作占位符:<br><br>创建一个属性items, 它是用Element 类型值来初始化的空数组。<br>指定 push(_:) 方法有一个参数 item, 类型是 Element<br>指定 pop() 方法的返回值,类型是 Element<br>因为它是一个泛型类型, Stack可以用来创建Swift中任何有效的类型的栈, 跟字典和数组的用法类似。<br><br>在方括号里写上栈存储类型来创建一个新的 Stack 实例。例如, 创建一个字符串的栈, 这样写 Stack<string>():<br><pre><code><br>var stackOfStrings = Stack<string>()<br>stackOfStrings.push(“uno”)<br>stackOfStrings.push(“dos”)<br>stackOfStrings.push(“tres”)<br>stackOfStrings.push(“cuatro”)<br>// 这个栈现在有4个字符串<br></string></code></pre><br>下面是压入四个值之后stackOfStrings 变化:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png"><br></div><br>从栈中移除一个值并且返回栈顶的值, “cuatro”:<br><pre><code><br>let fromTheTop = stackOfStrings.pop()<br>// fromTheTop 等于 “cuatro”, 现在栈内有3个字符串<br></code></pre><br>下面的弹出一个值后栈的变化:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png"><br></div>

<h1 id="扩展泛型类型"><a href="#扩展泛型类型" class="headerlink" title="扩展泛型类型"></a>扩展泛型类型</h1><p>当你扩展一个泛型类型, 你不需要在扩展定义中提供一个类型参数列表。相反, 原类型定义的类型参数列表可以在扩展内部使用, 并且,使用原类型类型参数名在原来的定义中调用类型参数。</p>
<p>下面的例子扩展了泛型 Stack 类型,添加了一个只读计算属性 topItem, 它返回栈顶元素,而且不用弹出这个元素:</p>
<pre><code>
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>

<p>topItem 属性返回可选的Element 类型值。如果栈是空的, topItem 返回nil; 如果栈非空, topItem 返回items数组最后一个值。</p>
<p>注意,这个扩展没有定义类型参数列表。相反, Stack 类型已存在的类型参数名, Element, 在扩展内部使用来表示topItem 是一个可选类型。</p>
<p>计算属性topItem 现在可以使用 Stack 实例来访问栈顶的元素,而不用去移除它:</p>
<pre><code>
if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// 打印 "The top item on the stack is tres."
</code></pre>

<h1 id="类型限制"><a href="#类型限制" class="headerlink" title="类型限制"></a>类型限制</h1><p>swapTwoValues(<em>:</em>:) 函数和 Stack 类型可以使用任意类型。不过, 有时候对使用泛型函数和类型的类型使用限制是有用的。 类型限制指定一个类型参数必须继承自一个类,或者符合一个协议或者协议组合。</p>
<p>例如, Swift的字典类型对可以用作键的类型进行了限制, 字典的键类型必须是可哈希的。就是说, 它必须提供一个方法让自己独一无二。 字典需要键可哈希,为了判断特定键是否包含了一个值。如果没有这个要求, 字典就不能判断是否可以对一个键插入或者修改一个值。也不能通过给定的键找到一个值。</p>
<p>字典的键类型,这个需求是类型限制强制的。它规定键类型必须符合 Hashable 协议, 它定义在Swift 标准库中。Swift 的所有基本类型默认都是可哈希的。</p>
<p>创建泛型类型时,你可以定义自己的类型限制。这些限制提供泛型编程大部分能力。诸如哈希特性类型的抽象概念,依据的是它们概念性的特征而不是它们的显式类型。</p>
<h1 id="可续限制语法"><a href="#可续限制语法" class="headerlink" title="可续限制语法"></a>可续限制语法</h1><p>通过在类型参数名后放置一个单独的类或者协议,然后用冒号分开,来写类型限制。泛型函数的类型限制的基本语法显示如下:</p>
<pre><code>
func someFunction<t: someclass,="" u:="" someprotocol="">(someT: T, someU: U) {
    // function body goes here
}
</t:></code></pre>

<p>上面的假想函数有两个参数。第一个类型参数, T, 类型限制是要求T是 SomeClass 的子类。第二个类型参数, U, 类型限制是要求U符合 SomeProtocol 协议。</p>
<h1 id="类型限制的行为"><a href="#类型限制的行为" class="headerlink" title="类型限制的行为"></a>类型限制的行为</h1><p>这里有一个非泛型的函数findIndex(ofString:in:), 它有一个查找的字符串值和待查找的字符串数组。findIndex(ofString:in:) 函数返回一个可选的整数值。它是数组中第一个匹配字符串的索引, 如果找不到就返回nil:</p>
<pre><code>
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>
findIndex(ofString:in:) 函数可以用来在字符串数组查找一个字符串:
<pre><code>
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findIndex(ofString: "llama", in: strings) {
    print("The index of llama is \(foundIndex)")
}
// 打印 "The index of llama is 2"
</code></pre>

<p>这种查找字符串的方式只对字符串有用, 不过。 你可以写一个泛型函数来处理其他类型。</p>
<p>这里有一个你期待的泛型版本的 findIndex(ofString:in:)函数, 叫 findIndex(of:in:). 注意,函数返回值仍然是 Int?, 因为函数返回的是可选的索引值, 不是来自数组的可选值。 不过这个函数不能编译, 原因在这个例子后面再解释:</p>
<pre><code>
func findIndex<t>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</t></code></pre>

<p>上面的函数不能编译。问题在于等号判断, “if value == valueToFind”. 不是所有在Swift中的类型都可以用等号进行比较的。如果你创建自己的类或者结构体来表示一个复杂的数据模型, 这个类或者结构体‘等于’的意思不是Swift能够理解的。因为这个原因, 它不能保证这个代码对各种可能的T类型都有效, 当你尝试编译这个代码的时候,就会报错。</p>
<p>不过,没有任何损失。Swift 标准库定义了一个协议 Equatable, 它要求符合类型实现等于和不等于,来比较这个类型的任意两个值。所有 Swift 的标准类型都自动支持这个协议。</p>
<p>任何可以比较的类型都可以安全的使用 findIndex(of:in:) 函数, 因为它保证支持等于运算符。为了说明这个事实, 在你定义函数时,你可以在类型参数定义的时候写一个Equatable类型限制:</p>
<pre><code>
func findIndex<t: equatable="">(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</t:></code></pre>

<p>findIndex(of:in:) 的参数类型写作 T: Equatable, 意思是 “符合Equatable 协议的任意 T 类型。”</p>
<p>限制 findIndex(of:in:) 函数编译成功了,然后可以使用任意可以比较的类型, 例如 Double 或者 String:</p>
<pre><code>
let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"])
// stringIndex is an optional Int containing a value of 2
</code></pre>

<h1 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h1><p>当定义一个协议的时候, 有时候声明一个或者多个关联类型是很有用的。一个关联类型给一个类型提供一个占位符名。关联类型使用的实际类型只要协议被采用才会指定。关联类型使用associatedtype 关键字来指定。</p>
<h1 id="关联类型的行为"><a href="#关联类型的行为" class="headerlink" title="关联类型的行为"></a>关联类型的行为</h1><p>这里有个Container协议的例子, 它声明了一个关联类型 ItemType:</p>
<pre><code>
protocol Container {
    associatedtype ItemType
    mutating func append(_ item: ItemType)
    var count: Int { get }
    subscript(i: Int) -> ItemType { get }
}
</code></pre>

<p>Container 协议定义了任何容器必须提供的三个必须的能力:</p>
<p>它必须要可以用append(_:)方法给容器添加新项目。<br>它必须可以通过count属性访问容器中项目的数量。<br>它必须可以通过下标运算获取到容器的每一项。<br>这个协议没有指定怎么存储项目或者它允许的类型。这个协议只是指定了任何符合类型要提供的三个功能。一个符合类型可以提供额外的功能, 只要它满足三个必须要求。</p>
<p>任何符合 Container 协议的类型必须能够指定它存储值的类型。特别是, 它必须确保只有正确的类型才可以添加到容器, 它必须清楚下标返回的项目的类型。</p>
<p>为了定义这三个必须要求, Container 协议需要一个方法去调用容器将要装载的元素类型, 不用知道特定容器类型是什么。Container 协议需要指定,传入append(_:) 方法的值必须和容器里的元素类型一样。容器下标返回的值的类型也要和容器里的元素类型一样。</p>
<p>为了实现这点, Container 协议定义了一个关联类型 ItemType, 写作 associatedtype ItemType. 协议没有定义 ItemType是什么—这个留给符合类型来提供。 尽管如此, ItemType 别名提供了一种方式来调用容器里的元素类型, 为了使用 append(_:) 方法和下标定义了一个类型。以确保任何容器期望的行为被执行。</p>
<p>这里是早前非泛型版本的 IntStack 类型, 采用和符合了 Container 协议:</p>
<pre><code>
struct IntStack: Container {
    // original IntStack implementation
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Int {
        return items[i]
    }
}
</code></pre>

<p>IntStack 类型实现了 Container 协议要求的三个功能。</p>
<p>此外, IntStack 指定,为了实现 Container, 关联 ItemType 使用Int类型。typealias ItemType = Int 定义,为Container 协议的实现,把抽象类型转换为实际的Int类型。</p>
<p>由于 Swift 的类型推断, 实际上你不需要声明ItemType 为Int. 因为 IntStack 符合 Container 协议所有的要求, Swift 可以推断使用的关联类型 ItemType, 只要简单查找 append(_:) 方法的参数类型和下标的返回类型。事实上, 如果你删除上面的 typealias ItemType = Int, 一切都正常, 因为它知道什么类型用于 ItemType.</p>
<p>你也可以让你泛型版本的 Stack 类型来符合 Container 协议:</p>
<pre><code>
struct Stack<element>: Container {
    // original Stack<element> implementation
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Element {
        return items[i]
    }
}
</element></element></code></pre>

<p>这一次, 类型参数 Element 用作 append(_:) 方法的参数类型和下标的返回类型。Swift 可以推断 Element 是关联类型, 在特定容器用作ItemType.</p>
<h1 id="扩展存在的类型去指定关联类型"><a href="#扩展存在的类型去指定关联类型" class="headerlink" title="扩展存在的类型去指定关联类型"></a>扩展存在的类型去指定关联类型</h1><p>你可以扩展存在的类型去符合一个协议。这个包含带有关联类型的协议。</p>
<p>Swift 的数组类型已经提供了append(_:)方法, 一个count 属性, 和一个带有索引获取元素的下标。这三个能力满足 Container 协议的要求。这个意味着你可以扩展数组来符合 Container 协议。使用空扩展即可实现这个:</p>
<pre><code>
extension Array: Container {}
</code></pre>

<p>数组存在的 append(_:) 方法和下标让 Swift 可以推断使用ItemType的关联类型, 和上面的泛型 Stack 类型一样。扩展定义后, 你可以把数组当成 Container 使用。</p>
<h1 id="泛型-Where-子句"><a href="#泛型-Where-子句" class="headerlink" title="泛型 Where 子句"></a>泛型 Where 子句</h1><p>类型限制, 让你在使用泛型函数或者类型时,可以在类型参数上定义需求。</p>
<p>给关联类型定义需求也是有用的。可以通过定义一个泛型where子句实现。 一个泛型wheare子句,让你可以要求关联类型必须符合一个协议, 或者特定类型参数和关联类型必须一样。一个泛型where子句以where关键字开始, 后面是关联类型的限制或者是类型和关联类型的相等关系。泛型where子句写在类型或者函数体花括号的前面。</p>
<p>下面的例子定义了一个泛型函数 allItemsMatch, 用来判断两个容器实例是否有相同顺序的相同元素。这个函数返回一个布尔值,如果所有元素都满足条件就返回 true 否则返回 false.</p>
<p>待比较的两个容器不需要是相同类型, 但是它们要有相同类型的元素。通过类型限制的组合跟一个泛型where子句来表示这第一点:</p>
<pre><code>
func allItemsMatch<c1: container,="" c2:="" container="">
    (_ someContainer: C1, _ anotherContainer: C2) -> Bool
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {

        // Check that both containers contain the same number of items.
        if someContainer.count != anotherContainer.count {
            return false
        }

        // Check each pair of items to see if they are equivalent.
        for i in 0..<somecontainer.count {="" if="" somecontainer[i]="" !="anotherContainer[i]" return="" false="" }="" all="" items="" match,="" so="" true.="" true="" <="" code=""></somecontainer.count></c1:></code></pre>

<p>这个函数有两个参数 someContainer 和 anotherContainer. someContainer 参数类型是 C1, anotherContainer 参数类型是 C2.  C1 和 C2 是两个容器类型的类型参数,在函数调用的时候确定实际类型。</p>
<p>函数的两个类型参数要求如下:</p>
<p>C1 必须符合 Container 协议 (写作 C1: Container).<br>C2 也必须符合 Container 协议 (写作 C2: Container).<br>C1 的 ItemType 必须和C2的 ItemType 一样 (写作 C1.ItemType == C2.ItemType).<br>C1的 ItemType 必须符合 Equatable 协议 (写作 C1.ItemType: Equatable).<br>第一第二个要求定义在函数的类型参数列表里, 第三第四的要求定义在函数的泛型where子句中。</p>
<p>这些要求的意思是:</p>
<p>someContainer 是类型为C1的容器。<br>anotherContainer 是类型为C2的容器。<br>someContainer 和 anotherContainer 包含类型相同的元素。<br>someContainer 中的元素可以用不等于判断,看它们是否彼此不同。<br>第三第四个要求合并意思是, anotherContainer中的元素也可以用不等于判断, 因为它和someContainer 有着相同类型的元素。</p>
<p>allItemsMatch(<em>:</em>:) 函数的这些要求使得它可以用来比较两个容器, 即使它们是不同的容器类型。</p>
<p>allItemsMatch(<em>:</em>:) 函数一开始判断两个容器是否含有相同数量的元素。如果它们包含的元素的个数不一样, 它们就无法比较,函数返回false.</p>
<p>这个判断满足后, 函数使用for-in循环和半开区间运算符遍历someContainer中所有的元素。对于每个元素来说, 函数判断someContainer 的元素是否不等于anotherContainer 中对应的元素。如果两个元素不同, 说明两个容器不一样, 函数返回 false.</p>
<p>如果循环结束没有发现不匹配, 说明这两个容器是匹配的, 函数返回true.</p>
<p>Here’s how the allItemsMatch(<em>:</em>:) function looks in action:</p>
<pre><code>
var stackOfStrings = Stack<string>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    print("All items match.")
} else {
    print("Not all items match.")
}
// 打印 "All items match."
</string></code></pre>

<p>上面的例子创建了一个 Stack 实例来保存字符串, 然后把三个字符串压入栈。这个例子同时也创建了一个数组实例,它用和栈内容一样的字面量来初始化。尽管栈和数组是不同的类型, 不过它们都符合 Container 协议, 然后都包含相同类型的值。所以使用这两个容器作为参数,来调用 allItemsMatch(<em>:</em>:) 函数。在上面的例子里, allItemsMatch(<em>:</em>:) 函数正确的显示出两个容器中的所有元素都是匹配的。</p>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>访问控制可以让限制其他资源文件和模块访问你的代码块。这个特性可以确保你隐藏代码实现的细节。然后指定一个首选的接口,通过它可以访问和使用代码。</p>
<p>你可以针对单个类型指定访问级别 (类, 结构体和枚举), 像属于这些类型的属性,方法,构造器和下标一样。协议可以限制到特定的上下文, 全局常量,变量和函数也可以。</p>
<p>除了提供多个级别的访问控制, 通过为特殊场景提供默认访问级别, Swift 减少指定显式访问控制级别的需要。事实上, 如果你写的是单一目的的应用, 你根本不需要指定显式访问控制级别。</p>
<p>备注</p>
<p>你的代码大部分可以使用访问控制 (属性, 类型, 函数等) ,它们被作为 “entities” 在下面部分引用, 为了简洁。</p>
<h1 id="模块和源文件"><a href="#模块和源文件" class="headerlink" title="模块和源文件"></a>模块和源文件</h1><p>Swift 的访问控制模型基于模块和源文件的概念。</p>
<p>一个模块是单独的代码分发单元—作为单独单元构建和传输的框架或者程序, 可以用Swift 的import 关键字被其他模块引入。 </p>
<p>在Swift里,用Xcode 构建的每个目标都被作为单独的模块。 (例如应用的bundle或者框架)。如果你把代码组合成一个标准的独立框架—通过多个应用封装和重用这个代码—当它引入和用于一个应用时, 框架里定义的所有都会是独立模块的一部分。或者当它用在其他框架里的时候。</p>
<p>Swift里的源文件指的是模块中的源代码文件。尽管通常做法是在不同的源文件中定义独立的类型。一个单独的源文件可以定义多个类型,函数等等。</p>
<h1 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h1><p>Swift 为你的代码实体提供了五个不同的访问级别。这些访问级别和实体所在的源文件相关。同时也和源文件所属模块相关。</p>
<p>Open 访问和 public 访问让实体可以在任何定义它们的模块的源文件中使用, 也可以在引入该定义模块是其他模块的源文件中使用。当框架指定了pulic接口时,你就可以使用 open 或者 public 访问。open 和 pulic访问的不同下面会描述。<br>Internal 访问让实体可以在任何定义它们的模块的源文件中使用, 但是不能在该模块之外的源文件里使用。当定义一个应用的内部结构体或者框架的内部结构体时,你可以使用internal 访问。<br>私有文件访问只允许实体在自己定义的源文件中使用。使用私有文件访问隐藏了某个功能的实现细节。<br>私有访问限制实体在封闭声明时使用。当某个功能实现细节用在单独声明时,使用私有访问来隐藏这些细节。<br>Open 是最高级别的访问权限, 私有访问是最低级别的访问权限。</p>
<p>Open 访问只适用于类和类的成员, 它跟public 访问不同之处如下:</p>
<p>带有public访问权限的类, 或者任何更严格的访问级别, 只能在它们定义的模块里子类化。<br>带有public访问权限的类成员, 或者任何更严格的访问级别, 只能在它们定义的模块里,被子类重写。<br>Open 类可以在它们定义的模块中被子类化, 引入该模块的其他任意模块也可以。<br>Open 类可以在它们定义的模块中被子类重写, 引入该模块的其他任意模块也可以。<br>让一个类显式open表明, 你可以考虑到了来自其他模块的代码影响,这个模块使用这个类作为一个子类。你也相应的设计了自己的类的代码。</p>
<h1 id="访问级别的指导原则"><a href="#访问级别的指导原则" class="headerlink" title="访问级别的指导原则"></a>访问级别的指导原则</h1><p>Swift 中的访问级别遵守统一的指导原则: 实体不可以定义成另一种低级别的实体。</p>
<h1 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h1><p>一个 public 变量不能定义成internal, file-private, 或者 private 类型, 因为这个类型不能像pulic变量一样到处使用。<br>一个函数不能有比它的参数类型和返回类型更高的访问级别。因为函数不能用在它的组合类型不适用于周围代码的地方。</p>
<h1 id="默认访问级别"><a href="#默认访问级别" class="headerlink" title="默认访问级别"></a>默认访问级别</h1><p>如果你没有指定显式的访问级别,所有的代码中的实体会有一个默认的内部访问级别。这样做的结果是, 大多数情况下,你都不需要指定一个显式的访问级别。</p>
<h1 id="单目标应用的访问级别"><a href="#单目标应用的访问级别" class="headerlink" title="单目标应用的访问级别"></a>单目标应用的访问级别</h1><p>在你写一个单目标的应用的时候, 你的程序代码通常自包含在应用里,不需要给模块外部使用。默认的内部访问级别已经满足要求。因此, 你无需指定一个自定义的访问级别。不过你可能想把部分代码标记成 file private 或者 private,为了因此内部实现细节。</p>
<h1 id="框架访问级别"><a href="#框架访问级别" class="headerlink" title="框架访问级别"></a>框架访问级别</h1><p>当你开发一个框架的时候, 把对外的接口标记为 open 或者 public,这样它就可以被其他模块看到和访问, 比如引入这个框架的应用。 对外公开的接口是框架的API.</p>
<p>备注</p>
<p>框架的所有内部实现细节依然可以使用默认的内部访问级别, 如果想对框架内部其他代码隐藏实现细节,可以标记为 private 或者 file. 如果你想让它成为框架的API,你就需要把实体标记为 open 或者 public.</p>
<h1 id="单元测试目标的访问级别"><a href="#单元测试目标的访问级别" class="headerlink" title="单元测试目标的访问级别"></a>单元测试目标的访问级别</h1><p>当你用单元测试目标写应用的时候, 你的代码需要对这个模块可用,为了能够测试。默认情况下, 只有标记为 open 或者 public 的实体才可以被其他模块访问。不过, 如果你使用@testable属性为产品模块标记引入声明并且使用可测试编译产品模块,单元测试目标可以访问任意内部实体。</p>
<h1 id="访问控制语法"><a href="#访问控制语法" class="headerlink" title="访问控制语法"></a>访问控制语法</h1><p>通过在实体前放置 open, public, internal, fileprivate, 或者 privateDefine 修饰符来给实体定义访问级别:</p>
<pre><code>
public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}
</code></pre>

<p>除非另有说明, 默认访问级别都是内部的。也就说说 SomeInternalClass 和 someInternalConstant 即使不写访问级别修饰符, 它们依然有内部访问级别:</p>
<pre><code>
class SomeInternalClass {}              // implicitly internal
let someInternalConstant = 0            // implicitly internal
</code></pre>

<h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p>如果你想给一个自定义类型指定显式的访问级别, 在定义类型的时候指定。在访问级别允许的地方,新类型可以随便使用。例如, 如果你定义了一个 file-private 的类, 这个类只能用作属性的类型,函数的参数或者返回类型, 而且只能在类定义的源文件中。</p>
<p>一个类型的访问控制级别同样影响这个类型成员的默认访问级别 (它的属性,方法,构造器和下标)。如果类型的访问级别是 private 或者 file private, 它的成员的默认访问级别也将是 private 或者 file private. 如果类型的访问级别是 internal 或者 public, 它的成员的默认访问级别将会是 internal.</p>
<p>重要</p>
<p>一个 public 类型默认有 internal 成员, 而不是public 成员。如果你要成员也是 public, 你必须显式标记。这个可以保证发布的API是你想要发布的, 避免内部使用的代码作为API发布的错误。</p>
<pre><code>
public class SomePublicClass {                  // explicitly public class
    public var somePublicProperty = 0            // explicitly public class member
    var someInternalProperty = 0                 // implicitly internal class member
    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member
    private func somePrivateMethod() {}          // explicitly private class member
}

class SomeInternalClass {                       // implicitly internal class
    var someInternalProperty = 0                 // implicitly internal class member
    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member
    private func somePrivateMethod() {}          // explicitly private class member
}

fileprivate class SomeFilePrivateClass {        // explicitly file-private class
    func someFilePrivateMethod() {}              // implicitly file-private class member
    private func somePrivateMethod() {}          // explicitly private class member
}

private class SomePrivateClass {                // explicitly private class
    func somePrivateMethod() {}                  // implicitly private class member
}
</code></pre>

<h1 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h1><p>元组类型的访问级别是元组里类型中最严格的那个。例如, 如果你用两个不同的类型组成一个元组, 一个用 internal 访问,另外一个用 private 访问, 那么元组的访问级别会是 private.</p>
<p>备注</p>
<p>元组不像类,结构体和函数那样有独立的定义方式。一个元组类型的访问级别在定义时自动推断,不需要显式指定。</p>
<h1 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h1><p>函数的访问级别要计算参数和返回类型中最严格的。如果函数计算的访问级别不符合上下文的默认情况,你就要在定义函数时显式指定。</p>
<p>下面的例子定义了一个全局函数 someFunction(), 没有提供一个特定的访问级别修饰符。你可能希望函数有默认的 “internal”的访问级别, 但是情况不是这样。事实上, 下面的写法,someFunction() 将不能编译:</p>
<pre><code>
func someFunction() -> (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre>

<p>函数的返回值是由两个自定义类组合成的元组。一个类定义成 “internal”, 另外一个类定义成 “private”. 因为, 元组类型的访问级别是 “private” .</p>
<p>因为这个函数的返回类型是 private, 为了函数声明的有效性,你必须标记整个函数的访问级别是 private modifier:</p>
<pre><code>
private func someFunction() -> (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre>

<p>用public或者internal 修饰符标记 someFunction() 是无效的, 使用默认的internal也没有用, 因为函数的 public 或者 internal 用户可能没有权限访问用在函数返回类型的私有类。</p>
<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>枚举的每个分支都会自动获得和枚举一样的访问级别。你不能给单独的分支指定访问级别</p>
<p>在下面的例子里, CompassPoint 枚举有一个显式的访问级别 “public”. 枚举的分支 north, south, east, 和 west 的访问级别因此也是 “public”:</p>
<pre><code>
public enum CompassPoint {
    case north
    case south
    case east
    case west
}
</code></pre>

<h1 id="原始值和关联类型"><a href="#原始值和关联类型" class="headerlink" title="原始值和关联类型"></a>原始值和关联类型</h1><p>枚举中所有原始值和管理类型用到的类型访问级别至少要和枚举一样高。如果枚举访问级别是internal,原始值的访问级别就不能是private.</p>
<h1 id="嵌套类型-1"><a href="#嵌套类型-1" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><p>在private中定义的嵌套类型访问级别自动为 private. 在 file-private 中定义的嵌套类型访问级别自动为 file private. 在public或者internal中定义的嵌套类型访问级别自动为 internal. 如果想让在public 中定义的嵌套类型成为public, 你必须显式声明。</p>
<h1 id="子类化-1"><a href="#子类化-1" class="headerlink" title="子类化"></a>子类化</h1><p>你可以子类化任何可以在当前上下文中访问中的类。子类的访问级别不能高过超类—例如, 不能给internal超类写一个public的子类。</p>
<p>除此之外, 你可以重写在特定上下文可见的类成员 (方法,属性,构造器和下标)。</p>
<p>重写的类成员比超类更容易访问。在下面的例子里, A 是一个 public 类,有一个 file-private 方法 someMethod(). B 是A的子类, 访问级别是 “internal”. 尽管如此, B 提供了一个重写的 someMethod(),它的访问级别是 “internal”, 比超类版本的方法级别要高:</p>
<pre><code>
public class A {
    fileprivate func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {}
}
</code></pre>
甚至,子类成员可以调用超类成员,即使超类成员的访问级别低于子类成员, 只要访问发生在允许访问的上下文中:
<pre><code>
public class A {
    fileprivate func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
</code></pre>

<p>因为超类 A 和子类 B 在同一个源文件里定义, B 的 someMethod()方法可以有效调用 super.someMethod().</p>
<h1 id="常量-变量-属性和下标"><a href="#常量-变量-属性和下标" class="headerlink" title="常量,变量,属性和下标"></a>常量,变量,属性和下标</h1><p>一个常量,变量,属性或属性不能比它的类型更 public. 用private类型来写一个public属性是无效的。相似的, 一个下标不能比它的索引和返回类型更public.</p>
<p>如果一个常量,变量,属性或者下标使用 private 类型, 这个常量,变量,属性或者下标也必须标记为 private:</p>
<pre><code>
private var privateInstance = SomePrivateClass()
</code></pre>

<h1 id="Getters-和-Setters"><a href="#Getters-和-Setters" class="headerlink" title="Getters 和 Setters"></a>Getters 和 Setters</h1><p>常量,变量,属性和下标的Getters 和 setters 自动和它们所属的常量,变量,属性和下标的访问的级别一样。</p>
<p>你可以给 setter 比对应getter 更低的访问级别, 来限制变量,属性或者下标读写的范围。通过写 fileprivate(set), private(set), 或者 internal(set)来指定访问级别。</p>
<p>备注</p>
<p>这个规则适用于存储属性和计算属性。尽管你没有为一个存储属性写显式的 getter 和 setter, Swift 仍然会合成一个隐式的 getter 和 setter, 用来访问存储属性的备份存储。用 fileprivate(set), private(set), 和 internal(set) 来改变这个合成setter的访问级别, 跟计算属性的显式setter使用的方法完全一样。</p>
<p>下面的例子定义了一个结构体 TrackedString, 用来跟踪一个字符串属性改变的次数:</p>
<pre><code>
struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
}
</code></pre>

<p>TrackedString 结构体定义了一个存储字符串属性 value, 初始值为空。这个结构体同时定义了存储整型属性 numberOfEdits, 它用来跟踪value被改变的次数。通过在value属性上使用didSet属性观察者来实现跟踪。每次value属性设置新值的时候,它就把 numberOfEdits 值加1.</p>
<p>TrackedString 结构体和 value 属性没有显式提供访问级别修饰符, 所以它们默认的访问级别是 internal. 不过, numberOfEdits 属性的访问级别标记为 private(set),表明这个属性的 getter的访问级别仍然是 internal, 但是这个属性只能在结构体实现的代码里使用 setter. 这使得 TrackedString 可以在内部修改 numberOfEdits 属性, 但是也表示这个属性对于外部代码来说是只读的—包括 TrackedString 的扩展。</p>
<p>如果你创建一个 TrackedString 实例然后修改它的字符串 value 值几次, 你会看到 numberOfEdits 属性值随着变化次数一起更新:</p>
<pre><code>
var stringToEdit = TrackedString()
stringToEdit.value = "This string will be tracked."
stringToEdit.value += " This edit will increment numberOfEdits."
stringToEdit.value += " So will this one."
print("The number of edits is \(stringToEdit.numberOfEdits)")
// 打印 "The number of edits is 3"
</code></pre>
尽管你可以在其他源文件查询 numberOfEdits 属性的当前值, 但是你不能进行修改。这个限制保护结构体编辑跟踪功能的实现细节。
如果需要,你可以给getter和setter方法指定显式的访问级别。下面的例子把TrackedString 定义成public.因此结构体的成员默认的访问级别是 internal. 你可以设置 numberOfEdits 属性的 getter 是 public的, 它的属性 setter 是 private的, 通过合并 public 和 private(set) 的访问修饰符:
<pre><code>
public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
    public init() {}
}
</code></pre>

<h1 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h1><p>自定义构造器可以指定一个访问级别,这个级别小于或者等于它构造的类型。唯一的区别是必须的构造器。一个必须构造器访问级别必须跟它所属的类一致。</p>
<p>跟函数和方法参数一样, 构造器的参数类型不能比构造器拥有的访问级别更加私有。</p>
<h1 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h1><p>就像默认构造器中描述的那样, Swift 会自动为所有结构体或者基类提供一个没有参数的默认构造器,这些结构体或者基类给所有属性提供了默认值,但是没有提供任何的构造器。</p>
<p>默认构造器的访问级别和它要构造的类型是一样的, 除非这个类型定义为 public. 对于定义为public的类型来说, 默认构造器访问级别是 internal. 在其他模块使用时,如果你想用无参数的构造器来构造 public 类型, 你必须显式定义一个 public 无参数构造器。</p>
<h1 id="结构体类型的默认成员构造器"><a href="#结构体类型的默认成员构造器" class="headerlink" title="结构体类型的默认成员构造器"></a>结构体类型的默认成员构造器</h1><p>如果结构体的存储属性是private的,结构体的默认成员构造器就是 private的。同样的, 如果结构体任意一个存储属性是file private, 构造器也是 file private. 否则, 构造器的访问级别是 internal.</p>
<p>和上面的默认构造器一样, 在其他模块使用时, 如果你想用一个成员构造器来构造一个 public 类型的话, 你必须提供一个public成员构造器。</p>
<h1 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h1><p>如果你想要给一个协议类型指定一个显式的访问级别, 就在协议定义的时候这么做。这个可以让你创建协议, 这个协议只能在某些允许访问的上下文中采用。</p>
<p>协议定义中每个需求的访问级别和协议的访问级别是一样的。你不能把需求设置成协议不支持的访问级别。这可以保证采用协议的类型可以看见所有的需求。</p>
<p>备注</p>
<p>如果你定义了一个 public 协议, 协议的需求实现时要求一个 public 访问级别。这个行为不同于其他类型, public 类型定义意味着类型成员的访问级别是 internal.</p>
<h1 id="协议继承-1"><a href="#协议继承-1" class="headerlink" title="协议继承"></a>协议继承</h1><p>如果定义了一个新协议,它继承自一个存在的协议, 新协议的访问级别最多和继承协议的级别一样。例如, 已存在的协议访问级别是internal, 你写的新协议却是是 public.</p>
<h1 id="协议一致性"><a href="#协议一致性" class="headerlink" title="协议一致性"></a>协议一致性</h1><p>一个类型可以符合一个访问级别比自己低的协议。例如, 你可以定义一个 public 类型用在其他模块里。如果它符合一个 internal 协议,就只能用在 internal 协议的定义模块内。</p>
<p>一个类型符合某个协议的上下文,访问级别是这个类型和协议中最小的一个。如果一个类型是 public, 但是协议是 internal, 这个类型的一致性协议也是 internal.</p>
<p>一个类型符合一个协议或者扩展符合一个协议,你必须确保类型对协议需求的实现,至少和类型的一致性协议有一样的访问级别。例如, 如果一个public 类型符合一个 internal, 这个类型实现的协议需求必须是 “internal”.</p>
<p>备注</p>
<p>在 Swift 里, 跟在 Objective-C里一样, 协议一致性是全局的—不可能在同样的程序里,类型以两种不同的方式来符合一个协议。</p>
<h1 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h1><p>你可以在任何访问权限的上下文中扩展一个类,结构体或者枚举。扩展中添加的类型成员和被扩展类型中声明的类型成员有着一样的访问级别。如果你扩展一个 public 或者 internal 类型, 你添加的任何类型成员默认访问级别是 internal. 如果你扩展一个 file-private 类型, 你添加的所有类型成员的访问级别都是file private. 如果你扩展一个 private 类型, 你添加的任何类型成员访问级别都是 private.</p>
<p>另外, 你可以用显式访问级别修饰符来标记一个扩展,来为定义在扩展里的所有的成员设置一个新的默认访问属性。单个类型成员的扩展里依然可以重写这些新的默认级别。 </p>
<h1 id="使用扩展添加协议一致性"><a href="#使用扩展添加协议一致性" class="headerlink" title="使用扩展添加协议一致性"></a>使用扩展添加协议一致性</h1><p>如果你用扩展来添加协议一致性,你就不能为扩展提供一个显式的访问级别修饰符。相反, 协议自己的访问级别,通常用来为在扩展中实现的协议需求提供默认访问级别。</p>
<h1 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h1><p>泛型类型和泛型函数的访问级别, 是它们自身的访问级别和它们的类型参数的任何类型限制的访问级别之间最小的那个。 </p>
<h1 id="类型别名-1"><a href="#类型别名-1" class="headerlink" title="类型别名"></a>类型别名</h1><p>你定义的所有类型别名,因为访问控制的目的,会被看做是不同的类型。一个类型别名的访问级别小于或者等于这个类型。例如, 一个private 类型的别名可以是一个 private, file-private, internal, public, 或者 open type的别名, 但是一个 public 类型别名不能是一个 internal, file-private, 或者 private 类型的别名。</p>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>这个规则也适用于用来满足协议一致性的关联类型的类型别名。</p>
<h1 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h1><p>除了基本运算符之外, Swift 提供了一些高级运算符来进行更复杂的值操作。包括位和位移运算符。</p>
<p>跟C的算术运算符不同, Swift 的算术运算符默认不会溢出。溢出会被捕获和报错。 选择溢出行为, 使用 Swift 的溢出算术运算符, 例如溢出加运算符 (&amp;+). 所有溢出算术运算符都是以 (&amp;)开始。</p>
<p>当你定义结构体,类和枚举的时候, 为这些自定义类型实现自己的标准Swift运算符是很有用的。Swift 让提供这些实现变得容易,并且能精确决定每种类型的行为。</p>
<p>你不会被限定在预置运算符上。Swift 给你足够的自由,用自定义的优先级和指定值,来定义你自己的中缀,前缀,后缀和赋值运算符。这些运算符的用法和预置运算符一样, 你甚至可以扩展已存在的类型来支持自定义的运算符。</p>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符可以操作数据结构里的单个数据位。它们通常用于低级别编程, 例如图形编程和设备驱动编写。使用外部资源数据时,位运算符也很有用, 例如编解码数据。</p>
<p>Swift 支持C中所有的位运算符, 描述如下。</p>
<h1 id="位-NOT-运算符"><a href="#位-NOT-运算符" class="headerlink" title="位 NOT 运算符"></a>位 NOT 运算符</h1><p>位 NOT 运算符 (~) 把所有位转换成一个数:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseNOT_2x.png"><br></div>

<p>位 NOT 运算符是一个前缀运算符, 直接出现在操作数的前面, 没有空格:</p>
<pre><code>
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // 等于 11110000
</code></pre>

<p>UInt8 整数有8位,可以存储0到255之间的任何值。这个例子用二进制值00001111来初始化一个 UInt8 整数, 它的前四位全是0,后四位全是1. 它等于十进制的 15.</p>
<p>位 NOT 运算符用来创建一个新常量 invertedBits, 它等于 initialBits, 不过所有位都是反转的。0变成1, 1变成0.  invertedBits 的值是 11110000, 它等于十进制的 240.</p>
<h1 id="位-AND-运算符"><a href="#位-AND-运算符" class="headerlink" title="位 AND 运算符"></a>位 AND 运算符</h1><p>位 AND 运算符 (&amp;) 合并两个数的位。它返回一个新的数组,如果两个输入数的位都是1,这个新数的位才是1:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseAND_2x.png"><br></div>

<p>在上面的例子里, firstSixBits 和 lastSixBits 中间四位都是 1. 位 AND 运算符合并它们变成 00111100, 它等于十进制的 60:</p>
<pre><code>
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits & lastSixBits  // 等于 00111100
</code></pre>

<h1 id="位-OR-运算符"><a href="#位-OR-运算符" class="headerlink" title="位 OR 运算符"></a>位 OR 运算符</h1><p>位 OR 运算符 (|) 比较两个数的位。如果两个数任意一个数位为1,这个运算符返回的数位就是1:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseOR_2x.png"><br></div>

<p>在上面的例子里, someBits 和 moreBits 不同位设置为 1. 位 OR 运算符合并它们变成 11111110, 它等于一个无符号十进制254:</p>
<pre><code>
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // 等于 11111110
</code></pre>

<h1 id="位-XOR-运算符"><a href="#位-XOR-运算符" class="headerlink" title="位 XOR 运算符"></a>位 XOR 运算符</h1><p>位 XOR 运算符, 或者 “异或运算符” (^), 比较两个数的位。如果两个数位不同返回1,如果相同则返回0:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseXOR_2x.png"><br></div>

<pre><code>
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // 等于 00010001
</code></pre>

<h1 id="左右移位运算符"><a href="#左右移位运算符" class="headerlink" title="左右移位运算符"></a>左右移位运算符</h1><p>左移位运算符 (&lt;&lt;) 和右移位运算符 (&gt;&gt;) 往左或者往右移动数位, 规则如下。</p>
<p>左移位和右移位实际上是乘以或者除以2. 左移一个整数1位相当于乘以2, 而右移一个整数1位相当于除以2.</p>
<h1 id="无符号整数移动"><a href="#无符号整数移动" class="headerlink" title="无符号整数移动"></a>无符号整数移动</h1><p>无符号整数位移表现如下:</p>
<p>左移或者右移请求数量的位。<br>超出整数存储范围的移位被舍弃。<br>左移或者右移后,缺失的位用0填充。<br>这个方法叫逻辑移位。</p>
<p>下面这个图展示了 11111111 &lt;&lt; 1 和 11111111 &gt;&gt; 1 的结果。蓝色数字是要移动的, 灰色数字是要舍弃的, 橙色的0是填充的:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png"><br></div>

<p>下面是位移动在Swift 代码里的表现:</p>
<pre><code>
let shiftBits: UInt8 = 4   // 00000100 in binary
shiftBits << 1             // 00001000
shiftBits << 2             // 00010000
shiftBits << 5             // 10000000
shiftBits << 6             // 00000000
shiftBits >> 2             // 00000001
</code></pre>

<p>你可以使用位移动在其他数据类型里进行编解码:</p>
<pre><code>
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16    // redComponent 是 0xCC, 或者 204
let greenComponent = (pink & 0x00FF00) >> 8   // greenComponent 是 0x66, 或者 102
let blueComponent = pink & 0x0000FF           // blueComponent 是 0x99, 或者 153
</code></pre>

<p>这个例子使用了一个 UInt32 类型的常量 pink 来保存粉色的CSS颜色值。CSS 颜色值 #CC6699 十六进制形式写作 0xCC6699. 经过位移 AND (&amp;)和右移运算符（&gt;&gt;）操作, 这个颜色会被分解为 red (CC), green (66), 和 blue (99) .</p>
<p>红色部分通过把数字 0xCC6699 和 0xFF0000进行位AND获取。 0xFF0000 中的0 “掩藏”了 0xCC6699的第二个和第三个字节, 导致 6699 被忽略,只留下 0xCC0000 的结果。</p>
<p>然后把这个数字向右移动16位 (&gt;&gt; 16). 十六进制数字每对字母使用8位, 所以向右移动16位把 0xCC0000 转化为 0x0000CC. 它等于 0xCC, 它的十进制值是 204.</p>
<p>类似的, 绿色部分通过把数字 0xCC6699 和 0x00FF00进行位AND获取, 它的输出值是 0x006600. 然后把输出值向右移动8位 0x66, 它的十进制值是 102.</p>
<p>最后, 蓝色部分通过把数字 0xCC6699 和 0x0000FF进行位AND获取, 它的输出值是 0x000099. 它不需要向右移动, 因为 0x000099 已经等于 0x99, 它的十进制值是 153.</p>
<h1 id="有符号整数移动"><a href="#有符号整数移动" class="headerlink" title="有符号整数移动"></a>有符号整数移动</h1><p>有符号整数的移动比无符号的要复杂, 因为有符号整数是用二进制表示的(为了简单,下面的例子用8位有符号整数展示, 不过这个原则适用于任何大小的有符号整数。)</p>
<p>有符号整数使用第一个数位来表示正负 (标志位)。 0表示正数, 1表示负数。</p>
<p>剩余位用来存储实际的值。正数的存储和无符号整数的方式是一样的, 从0往上数。这里是4在Int8中的数位的形式:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png"><br></div>

<p>标志位是 0 (意思是正数), 7个数值位正好是数字 4, 用二进制符号表示。</p>
<p>负数存储是不同的。它们存储的值是绝对值减去2的n次方。这里n是数值位的数字。一个8位数有7个数值位, 所以2的7次方, 或者 128.</p>
<p>这里是-4在Int8中数位的形式 -4:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png"><br></div>

<p>这次符号位是 1 (意思是负数), 七位数值位值是 124 (128 - 4):</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFourValue_2x.png"><br></div>

<p>负数编码是一个二进制补码表示。这似乎不是负数的常见表示方法, 但是它有几个优点。</p>
<p>首先, 你可以把-4加-1, 可以进行8位的简单二进制加法 (包括标志位), 完成后舍弃不符合8位的:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png"><br></div>

<p>其次, 二进制补码表示让你可以像正数那样移动负数的数位。向左移动后依然会翻倍, 向右移动后会减半。为了实现这个, 当有符号整数向右移动时,使用额外的规则: 当你向右移动有符号整数时, 和无符号整数规则一样, 但是左边空出来的位要用标志位填充, 而不是0.</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png"><br></div>

<p>这个行为保证有符号整数向右移动后,有相同的标志位。 也就是算术移位。</p>
<p>由于正负数存储的特殊方式, 向右移动它们接近于0. 移动过程中保持标志位不变,意味着负数在接近0过程中依然是负数。</p>
<h1 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h1><p>如果你尝试向一个整数常数或者变量插入无法保存的值, 默认情况下, Swift 会报错而不是允许无效值的创建。当你使用过大或者过小值的时候,这个规则可以提供额外的安全性。</p>
<p>例如, Int16 整数范围是 -32768 到 32767. 尝试存储超过这个范围的数字会导致错误:</p>
<pre><code>
var potentialOverflow = Int16.max
// potentialOverflow equals 32767, which is the maximum value an Int16 can hold
potentialOverflow += 1
// 这个会报错
</code></pre>

<p>当值变的过大或者过小的时候,提供错误处理,在给边界值条件编码时,会更加灵活。</p>
<p>不过, 当你特别想要一个溢出条件来截断可用位数的时候, 你可以选择这个行为而不是触发一个错误。Swift 提供了三个算术溢出运算符,来为整数计算选择溢出行为。这些运算符都以(&amp;)开始:</p>
<p>溢出加 (&amp;+)<br>溢出减 (&amp;-)<br>溢出乘 (&amp;*)</p>
<h1 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h1><p>负数和整数都可以溢出。</p>
<p>这里有一个例子,展示当一个无符号整数在正数方向溢出时,会发生什么, 使用的是溢出加运算符 (&amp;+):</p>
<pre><code>
var unsignedOverflow = UInt8.max
// unsignedOverflow 等于 255, 它是UInt8可以保存的最大值
unsignedOverflow = unsignedOverflow &+ 1
// unsignedOverflow 现在等于 0
</code></pre>

<p>变量 unsignedOverflow 使用UInt8 的最大值初始化nt8 (255, 或者 11111111). 然后使用溢出加运算符加1. 这个让它的二进制表示正好超过UInt8可以保存的最大值,这个导致了溢出, 如下表所示。溢出加之后这个值00000000依然在UInt8的界限内。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png"><br></div>

<p>相似的事情会发生在无符号数向负数方向的溢出上。下面是使用了溢出减运算符的例子:</p>
<pre><code>
var unsignedOverflow = UInt8.min
// unsignedOverflow 等于 0, 是UInt8可以保存的最小值
unsignedOverflow = unsignedOverflow &- 1
// unsignedOverflow 现在等于 255
</code></pre>

<p>UInt8可以保存的最小值是0, 或者二进制 00000000. 如果使用溢出减运算符减1, 这个数字会溢出变成 11111111, 或者十进制 255 .</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png"><br></div>

<p>溢出也会发生在有符号整数。有符号整数的加减法以位形式执行, 标志位也参与加减。</p>
<pre><code>
var signedOverflow = Int8.min
// signedOverflow 等于 -128, 是Int8可以保存的最小值
signedOverflow = signedOverflow &- 1
// signedOverflow 现在等于 127
</code></pre>

<p>Int8保存的最小值是 -128, 或者二进制 10000000. 使用溢出减减1,结果是 01111111, 它会切换标志位然后得正数 127, 它是Int8可以保存的最大正数值。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png"><br></div>

<p>对于有符号和无符号整数来说, 向正数方向溢出会回到最小值, 向负数方向溢出会回到最大值。</p>
<h1 id="优先级和关联性"><a href="#优先级和关联性" class="headerlink" title="优先级和关联性"></a>优先级和关联性</h1><p>运算符优先级给一些运算符提供更高的优先级; 这些运算符首先起作用。</p>
<p>运算符关联性确定相同优先级的运算符分组的行为—或者从左边分组, 或者从右边分组。可以这样考虑 “它们关联左边的表达式,” 或者 “它们关联右边的表达式。”</p>
<p>在使用复合表达式计算时,考虑每个运算符的优先级和关联性非常重要。例如, 运算符优先级解释了为什么下面的表达式结果是 17.</p>
<pre><code>
2 + 3 % 4 * 5
// this equals 17
</code></pre>
如果从左到右严格读, 你可能期望表达式按照如下执行:

2 加 3 等于 5
5 除以 4 取余为 1
1 乘以 5 等于 5
不过, 实际结果是 17, 而不是 5. 高优先级的运算符比低优先级运算符先执行。在 Swift 中, 和 C 一样, 取余运算符 (%) 和乘法运算符 (*) 比加法运算符有更高的优先级 (+). 结果就是, 它们都比加法先执行。

不过, 取余和乘法运算符优先级是相同的。为了解决准确的执行顺序, 你也需要考虑它们的关联性。取余和乘法运算符都是关联它们左边的表达式。把它想象为从左边开始,在它们的表达式部分加了一个隐式的括号:
<pre><code>
2 + ((3 % 4) * 5)
(3 % 4) 是 3, 这个等于:

2 + (3 * 5)
(3 * 5) 是 15, 这个等于:

2 + 15
计算结果是 17.
</code></pre>

<p>要查看完整的 Swift 运算符优先级和关联性规则的列表, 参见表达式部分。更多表达式, 参见 Swift 标准库运算符参考。</p>
<p>备注</p>
<p>Swift 的运算符优先级和关联性,比 C 和 Objective-C 中的更加简单和可预测。不过, 这个意味着它们和基于C语言的语言有所不同。在移植代码到 Swift 时,谨慎的确保运算符行为要和你想的一样。</p>
<h1 id="运算符方法-1"><a href="#运算符方法-1" class="headerlink" title="运算符方法"></a>运算符方法</h1><p>类和结构体可以为已存在的运算符提供自己的实现。这就是运算符的重载。 </p>
<p>下面的例子展示如何给一个自定义的结构体,实现一个算术加法运算符(+). 算术加法运算符是一个二目运算符,因为它操作两个目标。因为它在两个目标之间,它又是一个中缀运算符。 </p>
<p>下面的例子为一个二维位置向量(x, y)定义了一个 Vector2D 结构体, 后面是一个运算符方法的定义,这个方法把两个 Vector2D 结构体实例进行相加:</p>
<pre><code>
struct Vector2D {
    var x = 0.0, y = 0.0
}

extension Vector2D {
    static func + (left: Vector2D, right: Vector2D) -> Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y + right.y)
    }
}
</code></pre>

<p>这个运算符方法定义为Vector2D 的类型方法, 方法名符合重载的(+)运算符。因为加法不是向量本来的行为, 所以这个类型方法定义在结构体的扩展中,而不是主结构中。因为算术加法运算符是二目运算符, 这个运算符方法接受两个Vector2D 类型的参数,然后返回Vector2D 类型的值。</p>
<p>在这个实现里, 输入参数名 left 和 right 表示 Vector2D 实例在 + 运算符的左右两侧。这个方法返回了一个新的 Vector2D 实例, 它的 x 和 y 属性是左右实例 x 和 y 之和。</p>
<p>这个类型方法可以在两个 Vector2D 实例中用作中缀运算符:</p>
<pre><code>
let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个 Vector2D 实例,值是 (5.0, 5.0)
</code></pre>

<p>这个例子把向量 (3.0, 1.0) 和 (2.0, 4.0) 相加得到向量 (5.0, 5.0), 如下图所示。</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/vectorAddition_2x.png"><br></div>

<h1 id="前缀和后缀运算符"><a href="#前缀和后缀运算符" class="headerlink" title="前缀和后缀运算符"></a>前缀和后缀运算符</h1><p>上面的例子展示了一个中缀运算符的自定义实现。类和结构体也可以提供标准一元运算符的实现。一元运算符只操作一个目标。如果它在目标前面就是前缀运算符 (例如 -a) ,如果在目标后面就是后缀运算符 (例如 b!).</p>
<p>定义运算符方法的时候,在 func 关键字前写上前后缀修饰符,就可以定义前后缀一元运算符:</p>
<pre><code>
extension Vector2D {
    static prefix func - (vector: Vector2D) -> Vector2D {
        return Vector2D(x: -vector.x, y: -vector.y)
    }
}
</code></pre>

<p>上面的例子给Vector2D 实例实现了一元-运算符。一元-运算符是一个前缀运算符, 所以这个方法使用了前缀修饰符。</p>
<p>对于简单的数值, 一元-运算符把正数变成负数,反之亦然。Vector2D 实例的实现就是对 x 和 y 同时进行操作:</p>
<pre><code>
let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative is a Vector2D instance with values of (-3.0, -4.0)
let alsoPositive = -negative
// alsoPositive is a Vector2D instance with values of (3.0, 4.0)
</code></pre>

<h1 id="复合赋值运算符-1"><a href="#复合赋值运算符-1" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h1><p>复合赋值运算符把=与其他运算合并。例如, 加法赋值运算符合并了加法和赋值到一个单独的操作中。把复合赋值运算符的左边输入参数标记为 inout, 因为这个参数值会在方法内修改。</p>
<p>下面的例子为Vector2D 实例实现了一个加法赋值运算符:</p>
<pre><code>
extension Vector2D {
    static func += (left: inout Vector2D, right: Vector2D) {
        left = left + right
    }
}
</code></pre>

<p>因为加法运算符早已定义, 这里你不需要替换加法部分。替代的是, 加法赋值运算符方法采用了已经存在的加法运算符方法, 然后把左右值相加赋值给左值:</p>
<pre><code>
var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original now has values of (4.0, 6.0)
</code></pre>

<p>备注</p>
<p>不可能重载默认的赋值运算符(=). 只有复合赋值运算符可以重载。相似的, 三元条件运算符 (a ? b : c) 也不能重载。</p>
<h1 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h1><p>自定义的类和结构体没有默认的等式运算符的实现, 也就是(==) 和 (!=). Swift 猜不出来你的自定义类型是否有资格 “等于”, 因为这取决于这些类型在你代码里扮演的角色。</p>
<p>使用等式运算符来判断自定类型的相等, 像其他中缀运算符方法一样提供它的实现即可:</p>
<pre><code>
extension Vector2D {
    static func == (left: Vector2D, right: Vector2D) -> Bool {
        return (left.x == right.x) && (left.y == right.y)
    }
    static func != (left: Vector2D, right: Vector2D) -> Bool {
        return !(left == right)
    }
}
</code></pre>

<p>上面的例子实现了“等于” 运算符 (==)来判断两个Vector2D 实例是否有相同值。在 Vector2D 的上下文中, 认为相等就是 “两个实例的x和y值都一样”, 这个就是运算符实现的逻辑。这个例子同时实现了 “不等于” 运算符 (!=), 它只是简单返回了 “等于”的想法结果。</p>
<p>现在你可以使用这些运算符来判断两个 Vector2D 实例是否相等:</p>
<pre><code>
let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {
    print("These two vectors are equivalent.")
}
// 打印 "These two vectors are equivalent."
</code></pre>

<h1 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h1><p>除了 Swift 提供的标准运算符,你也可以声明和实现自定义的运算符。</p>
<p>使用 operator 关键字, 用 prefix, infix 或者 postfix标记,新的运算符会定义在全局:</p>
<pre><code>
prefix operator +++
</code></pre>
上面的例子定义了一个新的前缀运算符 +++. 这个运算符在Swift中不存在任何意义, 所以在下面使用Vector2D 实例的上下文中,给出了自定义的含义。这个例子的目的是, +++ 是一个新的“前缀双倍” 运算符。它双倍 Vector2D 实例的x和y值, 它使用早前定义的加法赋值运算符,把自己加给自己。为了实现 +++ 运算符, 给Vector2D 添加如下的类型方法 +++:

extension Vector2D {
    static prefix func +++ (vector: inout Vector2D) -> Vector2D {
        vector += vector
        return vector
    }
}

var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled now has values of (2.0, 8.0)
// afterDoubling also has values of (2.0, 8.0)


<h1 id="自定义中缀运算符的优先级"><a href="#自定义中缀运算符的优先级" class="headerlink" title="自定义中缀运算符的优先级"></a>自定义中缀运算符的优先级</h1><p>自定义中缀运算符每个都属于一个优先级集。一个优先级集指定一个运算符相对于其他中缀运算符的优先级, 也就是运算符的关联性。 </p>
<p>没有显式加入优先级集的自定义中缀运算符,会被给予一个默认的优先级集。它的优先级比三目条件运算符要高。</p>
<p>下面的例子定义了一个新的自定义的中缀运算符 +-, 它属于优先级集 AdditionPrecedence:</p>
<pre><code>
infix operator +-: AdditionPrecedence
extension Vector2D {
    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y - right.y)
    }
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)
</code></pre>

<p>这个运算符把两个向量的x值相加, 然后把第二个向量的两个y值相减。因为它实际上是一个 “加法的” 运算符, 它跟其他加法中缀运算符,例如 + 和 - , 有相同的优先级集。</p>
<p>备注</p>
<p>定义一个前缀或者后缀运算符的时候,你不要指定优先级。不过, 如果你在相同的操作数上使用前缀和后缀运算符, 后缀运算符会首先发生作用。</p>
</string></element>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/12/16/TestFlight-iOS-Beta测试/" title="TestFlight:iOS Beta测试">
  <strong>上一篇：</strong><br/>
  <span>
  TestFlight:iOS Beta测试</span>
</a>
</div>


<div class="next">
<a href="/2016/09/21/XCode-8-新特性/"  title="XCode 8 新特性">
 <strong>下一篇：</strong><br/> 
 <span>XCode 8 新特性
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1）" data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">33.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">34.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">35.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">36.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">37.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">38.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">39.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化空字符串"><span class="toc-number">40.</span> <span class="toc-text">初始化空字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串易变性"><span class="toc-number">41.</span> <span class="toc-text">字符串易变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串是值类型"><span class="toc-number">42.</span> <span class="toc-text">字符串是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用字符"><span class="toc-number">43.</span> <span class="toc-text">使用字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">连接字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串插入"><span class="toc-number">45.</span> <span class="toc-text">字符串插入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode"><span class="toc-number">46.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量"><span class="toc-number">47.</span> <span class="toc-text">Unicode 标量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量里的特殊字符"><span class="toc-number">48.</span> <span class="toc-text">字符串字面量里的特殊字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展字形集"><span class="toc-number">49.</span> <span class="toc-text">扩展字形集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算字符"><span class="toc-number">50.</span> <span class="toc-text">计算字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字符串"><span class="toc-number">51.</span> <span class="toc-text">访问和修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串索引"><span class="toc-number">52.</span> <span class="toc-text">字符串索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入和移除"><span class="toc-number">53.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较字符串"><span class="toc-number">54.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符等式"><span class="toc-number">55.</span> <span class="toc-text">字符串和字符等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀等式"><span class="toc-number">56.</span> <span class="toc-text">前缀和后缀等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-字符串表示"><span class="toc-number">57.</span> <span class="toc-text">Unicode 字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-8-形式"><span class="toc-number">58.</span> <span class="toc-text">UTF-8 形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-16-形式"><span class="toc-number">59.</span> <span class="toc-text">UTF-16 形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量形式"><span class="toc-number">60.</span> <span class="toc-text">Unicode 标量形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类型"><span class="toc-number">61.</span> <span class="toc-text">集合类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合的不稳定性"><span class="toc-number">62.</span> <span class="toc-text">集合的不稳定性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组"><span class="toc-number">63.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组类型缩写语法"><span class="toc-number">64.</span> <span class="toc-text">数组类型缩写语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建空数组"><span class="toc-number">65.</span> <span class="toc-text">创建空数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用默认值创建数组"><span class="toc-number">66.</span> <span class="toc-text">用默认值创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过合并数组创建数组"><span class="toc-number">67.</span> <span class="toc-text">通过合并数组创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用字面量创建数组"><span class="toc-number">68.</span> <span class="toc-text">用字面量创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改数组"><span class="toc-number">69.</span> <span class="toc-text">访问和修改数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历数组"><span class="toc-number">70.</span> <span class="toc-text">遍历数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合"><span class="toc-number">71.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类型的哈希值"><span class="toc-number">72.</span> <span class="toc-text">集合类型的哈希值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类型语法"><span class="toc-number">73.</span> <span class="toc-text">集合类型语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建和初始化空集合"><span class="toc-number">74.</span> <span class="toc-text">创建和初始化空集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用数组字面量创建集合"><span class="toc-number">75.</span> <span class="toc-text">用数组字面量创建集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改集合"><span class="toc-number">76.</span> <span class="toc-text">访问和修改集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历集合"><span class="toc-number">77.</span> <span class="toc-text">遍历集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合操作"><span class="toc-number">78.</span> <span class="toc-text">集合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本集合操作"><span class="toc-number">79.</span> <span class="toc-text">基本集合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典"><span class="toc-number">80.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典类型速记语法"><span class="toc-number">81.</span> <span class="toc-text">字典类型速记语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建一个空字典"><span class="toc-number">82.</span> <span class="toc-text">创建一个空字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用字面量创建字典"><span class="toc-number">83.</span> <span class="toc-text">用字面量创建字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字典"><span class="toc-number">84.</span> <span class="toc-text">访问和修改字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历字典"><span class="toc-number">85.</span> <span class="toc-text">遍历字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#控制流"><span class="toc-number">86.</span> <span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#For-In-循环"><span class="toc-number">87.</span> <span class="toc-text">For-In 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#While-循环"><span class="toc-number">88.</span> <span class="toc-text">While 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#While"><span class="toc-number">89.</span> <span class="toc-text">While</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Repeat-While"><span class="toc-number">90.</span> <span class="toc-text">Repeat-While</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#条件语句"><span class="toc-number">91.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#If"><span class="toc-number">92.</span> <span class="toc-text">If</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Switch"><span class="toc-number">93.</span> <span class="toc-text">Switch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非隐式-Fallthrough"><span class="toc-number">94.</span> <span class="toc-text">非隐式 Fallthrough</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区间匹配"><span class="toc-number">95.</span> <span class="toc-text">区间匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组-1"><span class="toc-number">96.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值绑定"><span class="toc-number">97.</span> <span class="toc-text">值绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Where"><span class="toc-number">98.</span> <span class="toc-text">Where</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合-Cases"><span class="toc-number">99.</span> <span class="toc-text">复合 Cases</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#控制转移语句"><span class="toc-number">100.</span> <span class="toc-text">控制转移语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Continue"><span class="toc-number">101.</span> <span class="toc-text">Continue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Break"><span class="toc-number">102.</span> <span class="toc-text">Break</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Break-在循环语句"><span class="toc-number">103.</span> <span class="toc-text">Break 在循环语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Break-在Switch-语句"><span class="toc-number">104.</span> <span class="toc-text">Break 在Switch 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fallthrough"><span class="toc-number">105.</span> <span class="toc-text">Fallthrough</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标签语句"><span class="toc-number">106.</span> <span class="toc-text">标签语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尽早退出"><span class="toc-number">107.</span> <span class="toc-text">尽早退出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断-API-可用性"><span class="toc-number">108.</span> <span class="toc-text">判断 API 可用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">109.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义和调用函数"><span class="toc-number">110.</span> <span class="toc-text">定义和调用函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数和返回值"><span class="toc-number">111.</span> <span class="toc-text">函数参数和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有参数的函数"><span class="toc-number">112.</span> <span class="toc-text">没有参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个参数的函数"><span class="toc-number">113.</span> <span class="toc-text">多个参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有返回值的函数"><span class="toc-number">114.</span> <span class="toc-text">没有返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带有多返回值的函数"><span class="toc-number">115.</span> <span class="toc-text">带有多返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选元组返回类型"><span class="toc-number">116.</span> <span class="toc-text">可选元组返回类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数标签和参数名"><span class="toc-number">117.</span> <span class="toc-text">函数参数标签和参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定参数标签"><span class="toc-number">118.</span> <span class="toc-text">指定参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#省略参数标签"><span class="toc-number">119.</span> <span class="toc-text">省略参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认参数值"><span class="toc-number">120.</span> <span class="toc-text">默认参数值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可变参数"><span class="toc-number">121.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#输入输出参数"><span class="toc-number">122.</span> <span class="toc-text">输入输出参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型"><span class="toc-number">123.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用函数类型"><span class="toc-number">124.</span> <span class="toc-text">使用函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型作为参数类型"><span class="toc-number">125.</span> <span class="toc-text">函数类型作为参数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型和返回值"><span class="toc-number">126.</span> <span class="toc-text">函数类型和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套函数"><span class="toc-number">127.</span> <span class="toc-text">嵌套函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">128.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式"><span class="toc-number">129.</span> <span class="toc-text">闭包表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序函数"><span class="toc-number">130.</span> <span class="toc-text">排序函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式语法"><span class="toc-number">131.</span> <span class="toc-text">闭包表达式语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#根据上下文推断类型"><span class="toc-number">132.</span> <span class="toc-text">根据上下文推断类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从单一表达式闭包隐式返回"><span class="toc-number">133.</span> <span class="toc-text">从单一表达式闭包隐式返回</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#速记参数名"><span class="toc-number">134.</span> <span class="toc-text">速记参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符方法"><span class="toc-number">135.</span> <span class="toc-text">运算符方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾闭包"><span class="toc-number">136.</span> <span class="toc-text">尾闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#捕获值"><span class="toc-number">137.</span> <span class="toc-text">捕获值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包是引用类型"><span class="toc-number">138.</span> <span class="toc-text">闭包是引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逃逸闭包"><span class="toc-number">139.</span> <span class="toc-text">逃逸闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动闭包"><span class="toc-number">140.</span> <span class="toc-text">自动闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">141.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举语法"><span class="toc-number">142.</span> <span class="toc-text">枚举语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用Switch语句匹配枚举值"><span class="toc-number">143.</span> <span class="toc-text">用Switch语句匹配枚举值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联值"><span class="toc-number">144.</span> <span class="toc-text">关联值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原始值"><span class="toc-number">145.</span> <span class="toc-text">原始值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式赋原始值"><span class="toc-number">146.</span> <span class="toc-text">隐式赋原始值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用原始值初始化"><span class="toc-number">147.</span> <span class="toc-text">用原始值初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归枚举"><span class="toc-number">148.</span> <span class="toc-text">递归枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和结构体"><span class="toc-number">149.</span> <span class="toc-text">类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较类和结构体"><span class="toc-number">150.</span> <span class="toc-text">比较类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义语法"><span class="toc-number">151.</span> <span class="toc-text">定义语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和结构体实例"><span class="toc-number">152.</span> <span class="toc-text">类和结构体实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问属性"><span class="toc-number">153.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体类型成员初始化方法"><span class="toc-number">154.</span> <span class="toc-text">结构体类型成员初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体和枚举是值类型"><span class="toc-number">155.</span> <span class="toc-text">结构体和枚举是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类是引用类型"><span class="toc-number">156.</span> <span class="toc-text">类是引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#等号运算符"><span class="toc-number">157.</span> <span class="toc-text">等号运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指针"><span class="toc-number">158.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在类与结构体中选择"><span class="toc-number">159.</span> <span class="toc-text">在类与结构体中选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串-数组和字典的赋值和拷贝行为"><span class="toc-number">160.</span> <span class="toc-text">字符串,数组和字典的赋值和拷贝行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性"><span class="toc-number">161.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存储属性"><span class="toc-number">162.</span> <span class="toc-text">存储属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量结构体的存储属性"><span class="toc-number">163.</span> <span class="toc-text">常量结构体的存储属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#延迟存储属性"><span class="toc-number">164.</span> <span class="toc-text">延迟存储属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存储属性和实例变量"><span class="toc-number">165.</span> <span class="toc-text">存储属性和实例变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算属性"><span class="toc-number">166.</span> <span class="toc-text">计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Setter-简化声明"><span class="toc-number">167.</span> <span class="toc-text">Setter 简化声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#只读计算属性"><span class="toc-number">168.</span> <span class="toc-text">只读计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性观察者"><span class="toc-number">169.</span> <span class="toc-text">属性观察者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局变量和局部变量"><span class="toc-number">170.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型属性"><span class="toc-number">171.</span> <span class="toc-text">类型属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型属性语法"><span class="toc-number">172.</span> <span class="toc-text">类型属性语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查询和设置类型属性"><span class="toc-number">173.</span> <span class="toc-text">查询和设置类型属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法"><span class="toc-number">174.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实例方法"><span class="toc-number">175.</span> <span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#self-属性"><span class="toc-number">176.</span> <span class="toc-text">self 属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在实例方法中修改值类型"><span class="toc-number">177.</span> <span class="toc-text">在实例方法中修改值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在变异方法里赋值给self"><span class="toc-number">178.</span> <span class="toc-text">在变异方法里赋值给self</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型方法"><span class="toc-number">179.</span> <span class="toc-text">类型方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标"><span class="toc-number">180.</span> <span class="toc-text">下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标语法"><span class="toc-number">181.</span> <span class="toc-text">下标语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用下标"><span class="toc-number">182.</span> <span class="toc-text">使用下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标选项"><span class="toc-number">183.</span> <span class="toc-text">下标选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-number">184.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义一个基类"><span class="toc-number">185.</span> <span class="toc-text">定义一个基类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子类化"><span class="toc-number">186.</span> <span class="toc-text">子类化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写"><span class="toc-number">187.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问超类的方法-属性和下标"><span class="toc-number">188.</span> <span class="toc-text">访问超类的方法,属性和下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写方法"><span class="toc-number">189.</span> <span class="toc-text">重写方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写属性"><span class="toc-number">190.</span> <span class="toc-text">重写属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写属性的-Getters-和-Setters"><span class="toc-number">191.</span> <span class="toc-text">重写属性的 Getters 和 Setters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写属性观察者"><span class="toc-number">192.</span> <span class="toc-text">重写属性观察者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#防止重写"><span class="toc-number">193.</span> <span class="toc-text">防止重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化"><span class="toc-number">194.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为存储属性设置初始值"><span class="toc-number">195.</span> <span class="toc-text">为存储属性设置初始值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化方法"><span class="toc-number">196.</span> <span class="toc-text">初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认属性值"><span class="toc-number">197.</span> <span class="toc-text">默认属性值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义初始化"><span class="toc-number">198.</span> <span class="toc-text">自定义初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化参数"><span class="toc-number">199.</span> <span class="toc-text">初始化参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参数名和参数标签"><span class="toc-number">200.</span> <span class="toc-text">参数名和参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有参数标签的初始化参数"><span class="toc-number">201.</span> <span class="toc-text">没有参数标签的初始化参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选属性类型"><span class="toc-number">202.</span> <span class="toc-text">可选属性类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化时访问常量属性"><span class="toc-number">203.</span> <span class="toc-text">初始化时访问常量属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认初始化方法"><span class="toc-number">204.</span> <span class="toc-text">默认初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体类型成员初始化方法-1"><span class="toc-number">205.</span> <span class="toc-text">结构体类型成员初始化方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值类型初始化方法代理"><span class="toc-number">206.</span> <span class="toc-text">值类型初始化方法代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类继承和初始化"><span class="toc-number">207.</span> <span class="toc-text">类继承和初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定构造器和便利构造器"><span class="toc-number">208.</span> <span class="toc-text">指定构造器和便利构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定构造器和便利构造器的语法"><span class="toc-number">209.</span> <span class="toc-text">指定构造器和便利构造器的语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的初始化代理"><span class="toc-number">210.</span> <span class="toc-text">类的初始化代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两阶段初始化"><span class="toc-number">211.</span> <span class="toc-text">两阶段初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化方法的继承和重写"><span class="toc-number">212.</span> <span class="toc-text">初始化方法的继承和重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动初始化方法的继承"><span class="toc-number">213.</span> <span class="toc-text">自动初始化方法的继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定和便利构造器的初始化"><span class="toc-number">214.</span> <span class="toc-text">指定和便利构造器的初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可失败构造器"><span class="toc-number">215.</span> <span class="toc-text">可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举的可失败构造器"><span class="toc-number">216.</span> <span class="toc-text">枚举的可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带原始值枚举的可失败构造器"><span class="toc-number">217.</span> <span class="toc-text">带原始值枚举的可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造可失败的传递"><span class="toc-number">218.</span> <span class="toc-text">构造可失败的传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写可失败构造器"><span class="toc-number">219.</span> <span class="toc-text">重写可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init-可失败构造器"><span class="toc-number">220.</span> <span class="toc-text">init! 可失败构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#必需构造器"><span class="toc-number">221.</span> <span class="toc-text">必需构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用闭包或者函数设定默认属性值"><span class="toc-number">222.</span> <span class="toc-text">用闭包或者函数设定默认属性值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#析构器"><span class="toc-number">223.</span> <span class="toc-text">析构器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#析构器如何工作"><span class="toc-number">224.</span> <span class="toc-text">析构器如何工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#析构器的活动"><span class="toc-number">225.</span> <span class="toc-text">析构器的活动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动引用计数"><span class="toc-number">226.</span> <span class="toc-text">自动引用计数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARC-如何工作"><span class="toc-number">227.</span> <span class="toc-text">ARC 如何工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARC-的活动"><span class="toc-number">228.</span> <span class="toc-text">ARC 的活动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类实例的强引用循环"><span class="toc-number">229.</span> <span class="toc-text">类实例的强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决实例间的强引用循环"><span class="toc-number">230.</span> <span class="toc-text">解决实例间的强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#弱引用"><span class="toc-number">231.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无主引用"><span class="toc-number">232.</span> <span class="toc-text">无主引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无主引用和隐式拆包可选属性"><span class="toc-number">233.</span> <span class="toc-text">无主引用和隐式拆包可选属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包强引用循环"><span class="toc-number">234.</span> <span class="toc-text">闭包强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">235.</span> <span class="toc-text">some default text</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决闭包强引用循环"><span class="toc-number">236.</span> <span class="toc-text">解决闭包强引用循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义捕获列表"><span class="toc-number">237.</span> <span class="toc-text">定义捕获列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#弱引用和无主引用"><span class="toc-number">238.</span> <span class="toc-text">弱引用和无主引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选链"><span class="toc-number">239.</span> <span class="toc-text">可选链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#作为强制拆包替代方案的可选链"><span class="toc-number">240.</span> <span class="toc-text">作为强制拆包替代方案的可选链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为可选链接定义模型类"><span class="toc-number">241.</span> <span class="toc-text">为可选链接定义模型类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过可选链接访问属性"><span class="toc-number">242.</span> <span class="toc-text">通过可选链接访问属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过可选链接调用方法"><span class="toc-number">243.</span> <span class="toc-text">通过可选链接调用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过可选链接访问下标"><span class="toc-number">244.</span> <span class="toc-text">通过可选链接访问下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问可选类型下标"><span class="toc-number">245.</span> <span class="toc-text">访问可选类型下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多层链接"><span class="toc-number">246.</span> <span class="toc-text">多层链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用可选返回值链接方法"><span class="toc-number">247.</span> <span class="toc-text">使用可选返回值链接方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理-1"><span class="toc-number">248.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#表示和抛出错误"><span class="toc-number">249.</span> <span class="toc-text">表示和抛出错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理错误"><span class="toc-number">250.</span> <span class="toc-text">处理错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用抛出函数传递错误"><span class="toc-number">251.</span> <span class="toc-text">用抛出函数传递错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-Do-Catch-处理错误"><span class="toc-number">252.</span> <span class="toc-text">使用 Do-Catch 处理错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#转换错误成可选值"><span class="toc-number">253.</span> <span class="toc-text">转换错误成可选值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#禁用错误传递"><span class="toc-number">254.</span> <span class="toc-text">禁用错误传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定清理行为"><span class="toc-number">255.</span> <span class="toc-text">指定清理行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型转换"><span class="toc-number">256.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为类型转换定义类层次"><span class="toc-number">257.</span> <span class="toc-text">为类型转换定义类层次</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断类型"><span class="toc-number">258.</span> <span class="toc-text">判断类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#向下转换"><span class="toc-number">259.</span> <span class="toc-text">向下转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Any-和-AnyObject的类型转换"><span class="toc-number">260.</span> <span class="toc-text">Any 和 AnyObject的类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套类型"><span class="toc-number">261.</span> <span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内嵌类型的行为"><span class="toc-number">262.</span> <span class="toc-text">内嵌类型的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调用嵌套类型"><span class="toc-number">263.</span> <span class="toc-text">调用嵌套类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展"><span class="toc-number">264.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-扩展可以"><span class="toc-number">265.</span> <span class="toc-text">Swift 扩展可以:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展语法"><span class="toc-number">266.</span> <span class="toc-text">扩展语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算属性-1"><span class="toc-number">267.</span> <span class="toc-text">计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造器"><span class="toc-number">268.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法-1"><span class="toc-number">269.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#改变实例方法"><span class="toc-number">270.</span> <span class="toc-text">改变实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下标-1"><span class="toc-number">271.</span> <span class="toc-text">下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议"><span class="toc-number">272.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议语法"><span class="toc-number">273.</span> <span class="toc-text">协议语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性需求"><span class="toc-number">274.</span> <span class="toc-text">属性需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法需求"><span class="toc-number">275.</span> <span class="toc-text">方法需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变异方法需求"><span class="toc-number">276.</span> <span class="toc-text">变异方法需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造器需求"><span class="toc-number">277.</span> <span class="toc-text">构造器需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类实现协议构造器需求"><span class="toc-number">278.</span> <span class="toc-text">类实现协议构造器需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可失败构造器需求"><span class="toc-number">279.</span> <span class="toc-text">可失败构造器需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议作为类型"><span class="toc-number">280.</span> <span class="toc-text">协议作为类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#委托"><span class="toc-number">281.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#给扩展添加协议"><span class="toc-number">282.</span> <span class="toc-text">给扩展添加协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用扩展声明协议"><span class="toc-number">283.</span> <span class="toc-text">用扩展声明协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议类型集合"><span class="toc-number">284.</span> <span class="toc-text">协议类型集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议继承"><span class="toc-number">285.</span> <span class="toc-text">协议继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#只用于类的协议"><span class="toc-number">286.</span> <span class="toc-text">只用于类的协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议组合"><span class="toc-number">287.</span> <span class="toc-text">协议组合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断协议一致性"><span class="toc-number">288.</span> <span class="toc-text">判断协议一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选协议需求"><span class="toc-number">289.</span> <span class="toc-text">可选协议需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议扩展"><span class="toc-number">290.</span> <span class="toc-text">协议扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#提供默认实现"><span class="toc-number">291.</span> <span class="toc-text">提供默认实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#给协议扩展添加限制"><span class="toc-number">292.</span> <span class="toc-text">给协议扩展添加限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型"><span class="toc-number">293.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型解决的问题"><span class="toc-number">294.</span> <span class="toc-text">泛型解决的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型函数"><span class="toc-number">295.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型参数"><span class="toc-number">296.</span> <span class="toc-text">类型参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命名类型参数"><span class="toc-number">297.</span> <span class="toc-text">命名类型参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型类型"><span class="toc-number">298.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展泛型类型"><span class="toc-number">299.</span> <span class="toc-text">扩展泛型类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型限制"><span class="toc-number">300.</span> <span class="toc-text">类型限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可续限制语法"><span class="toc-number">301.</span> <span class="toc-text">可续限制语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型限制的行为"><span class="toc-number">302.</span> <span class="toc-text">类型限制的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联类型"><span class="toc-number">303.</span> <span class="toc-text">关联类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联类型的行为"><span class="toc-number">304.</span> <span class="toc-text">关联类型的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展存在的类型去指定关联类型"><span class="toc-number">305.</span> <span class="toc-text">扩展存在的类型去指定关联类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型-Where-子句"><span class="toc-number">306.</span> <span class="toc-text">泛型 Where 子句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问控制"><span class="toc-number">307.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模块和源文件"><span class="toc-number">308.</span> <span class="toc-text">模块和源文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问级别"><span class="toc-number">309.</span> <span class="toc-text">访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问级别的指导原则"><span class="toc-number">310.</span> <span class="toc-text">访问级别的指导原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例如"><span class="toc-number">311.</span> <span class="toc-text">例如:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认访问级别"><span class="toc-number">312.</span> <span class="toc-text">默认访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单目标应用的访问级别"><span class="toc-number">313.</span> <span class="toc-text">单目标应用的访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#框架访问级别"><span class="toc-number">314.</span> <span class="toc-text">框架访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单元测试目标的访问级别"><span class="toc-number">315.</span> <span class="toc-text">单元测试目标的访问级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问控制语法"><span class="toc-number">316.</span> <span class="toc-text">访问控制语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义类型"><span class="toc-number">317.</span> <span class="toc-text">自定义类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组类型"><span class="toc-number">318.</span> <span class="toc-text">元组类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型-1"><span class="toc-number">319.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举类型"><span class="toc-number">320.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原始值和关联类型"><span class="toc-number">321.</span> <span class="toc-text">原始值和关联类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套类型-1"><span class="toc-number">322.</span> <span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子类化-1"><span class="toc-number">323.</span> <span class="toc-text">子类化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量-变量-属性和下标"><span class="toc-number">324.</span> <span class="toc-text">常量,变量,属性和下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Getters-和-Setters"><span class="toc-number">325.</span> <span class="toc-text">Getters 和 Setters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造器-1"><span class="toc-number">326.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认构造器"><span class="toc-number">327.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构体类型的默认成员构造器"><span class="toc-number">328.</span> <span class="toc-text">结构体类型的默认成员构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议-1"><span class="toc-number">329.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议继承-1"><span class="toc-number">330.</span> <span class="toc-text">协议继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协议一致性"><span class="toc-number">331.</span> <span class="toc-text">协议一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展-1"><span class="toc-number">332.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用扩展添加协议一致性"><span class="toc-number">333.</span> <span class="toc-text">使用扩展添加协议一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型-1"><span class="toc-number">334.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名-1"><span class="toc-number">335.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#备注"><span class="toc-number">336.</span> <span class="toc-text">备注</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高级运算符"><span class="toc-number">337.</span> <span class="toc-text">高级运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位运算符"><span class="toc-number">338.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-NOT-运算符"><span class="toc-number">339.</span> <span class="toc-text">位 NOT 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-AND-运算符"><span class="toc-number">340.</span> <span class="toc-text">位 AND 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-OR-运算符"><span class="toc-number">341.</span> <span class="toc-text">位 OR 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位-XOR-运算符"><span class="toc-number">342.</span> <span class="toc-text">位 XOR 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#左右移位运算符"><span class="toc-number">343.</span> <span class="toc-text">左右移位运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无符号整数移动"><span class="toc-number">344.</span> <span class="toc-text">无符号整数移动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#有符号整数移动"><span class="toc-number">345.</span> <span class="toc-text">有符号整数移动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#溢出运算符"><span class="toc-number">346.</span> <span class="toc-text">溢出运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#值溢出"><span class="toc-number">347.</span> <span class="toc-text">值溢出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优先级和关联性"><span class="toc-number">348.</span> <span class="toc-text">优先级和关联性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符方法-1"><span class="toc-number">349.</span> <span class="toc-text">运算符方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀运算符"><span class="toc-number">350.</span> <span class="toc-text">前缀和后缀运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符-1"><span class="toc-number">351.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#等式运算符"><span class="toc-number">352.</span> <span class="toc-text">等式运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义运算符"><span class="toc-number">353.</span> <span class="toc-text">自定义运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义中缀运算符的优先级"><span class="toc-number">354.</span> <span class="toc-text">自定义中缀运算符的优先级</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mhealth365.cn/" target="_blank" title="一款温暖的心电监测设备">熙健-掌上心电</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m an iOS engineer <br/>
			Hala Madrid</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2779746325" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="跳跳魔王">跳跳魔王</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ecgbao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
