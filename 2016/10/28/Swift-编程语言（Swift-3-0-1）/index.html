
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="跳跳魔王">
    

    
    <meta name="description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 编程语言（Swift 3.0.1）">
<meta property="og:url" content="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/index.html">
<meta property="og:site_name" content="跳跳魔王的博客">
<meta property="og:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
<meta property="og:updated_time" content="2016-11-07T09:11:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 编程语言（Swift 3.0.1）">
<meta name="twitter:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta name="twitter:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">

    
    <link rel="alternative" href="/atom.xml" title="跳跳魔王的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="跳跳魔王的博客">跳跳魔王的博客</a></h1>
				<h2 class="blog-motto">每天进步一点点</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/28/Swift-编程语言（Swift-3-0-1）/" title="Swift 编程语言（Swift 3.0.1）" itemprop="url">Swift 编程语言（Swift 3.0.1）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="跳跳魔王" target="_blank" itemprop="author">跳跳魔王</a>
		
  <p class="article-time">
    <time datetime="2016-10-28T05:54:48.000Z" itemprop="datePublished"> 发表于 2016-10-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三元条件运算符"><span class="toc-number">33.</span> <span class="toc-text">三元条件运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nil-联合运算符"><span class="toc-number">34.</span> <span class="toc-text">Nil-联合运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#范围运算符"><span class="toc-number">35.</span> <span class="toc-text">范围运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭合区间运算符"><span class="toc-number">36.</span> <span class="toc-text">闭合区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#半开区间运算符"><span class="toc-number">37.</span> <span class="toc-text">半开区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">38.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">39.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">40.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">41.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">42.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">43.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">45.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化空字符串"><span class="toc-number">46.</span> <span class="toc-text">初始化空字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串易变性"><span class="toc-number">47.</span> <span class="toc-text">字符串易变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串是值类型"><span class="toc-number">48.</span> <span class="toc-text">字符串是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用字符"><span class="toc-number">49.</span> <span class="toc-text">使用字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接字符串和字符"><span class="toc-number">50.</span> <span class="toc-text">连接字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串插入"><span class="toc-number">51.</span> <span class="toc-text">字符串插入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode"><span class="toc-number">52.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量"><span class="toc-number">53.</span> <span class="toc-text">Unicode 标量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量里的特殊字符"><span class="toc-number">54.</span> <span class="toc-text">字符串字面量里的特殊字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展字形集"><span class="toc-number">55.</span> <span class="toc-text">扩展字形集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算字符"><span class="toc-number">56.</span> <span class="toc-text">计算字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字符串"><span class="toc-number">57.</span> <span class="toc-text">访问和修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串索引"><span class="toc-number">58.</span> <span class="toc-text">字符串索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入和移除"><span class="toc-number">59.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较字符串"><span class="toc-number">60.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符等式"><span class="toc-number">61.</span> <span class="toc-text">字符串和字符等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀等式"><span class="toc-number">62.</span> <span class="toc-text">前缀和后缀等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-字符串表示"><span class="toc-number">63.</span> <span class="toc-text">Unicode 字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-8-形式"><span class="toc-number">64.</span> <span class="toc-text">UTF-8 形式</span></a></li></ol>
		
		</div>
		
		<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。</p>
<p>基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dictionary。</p>
<p>跟C类似，Swift 通过变量名来存取值。Swift 还大量使用常量，这里的常量比C的常量更加强大。常量使用贯穿Swift，用来让代码更加安全和容易推断，特别是在你不想变量值发生改变的时候。</p>
<p>除了基本类型，Swift 还引进了objective-C中没有的高级类型，比如元组。元组让你可以创建和传递多值。你可以在一个函数里返回元组来作为一个单独的混合值。</p>
<p>Swift 还引进了可选类型，用来处理缺值的情况。可选的意思是‘这里有一个值，它等于x’ 或者‘这里没有任何值’。用可选值跟objective-C里使用nil指针有点像，不过可选类型可以服务任何类型，不仅仅是类类型。可选类型不仅仅安全而且更容易表达意思，它是Swift最重要特性里的核心特性。</p>
<p>Swift是一门类型安全的语言，这也就意味着这门语言可以让你更清晰的知道代码使用的值类型。如果你的代码需要一个String，类型安全会保护你不至于传递一个Int类型。同样，类型安全也会保护你，让你不会把非可选类型传递给需要可选类型的代码块。类型安全让你在开发阶段尽快发现问题，修复错误。</p>
<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>常量和变量是一个有特定类型的值，带有一个名字。常量值一旦确定就不能改变，变量在可用随时改变其值。</p>
<p>定义常量和变量<br>常量和变量必须要在使用前定义，常量使用let关键字，变量使用var关键字。下面是一个例子来展示如何使用常量和变量，这个例子是跟踪用户尝试的登录次数。</p>
<p><code>let maximumNumberOfLoginAttempts = 10<br>var currentLoginAttempt = 0</code><br>这段代码可以这样解读：<br>定义个常量maximumNumberOfLoginAttempts，给它一个值10.然后定义一个变量currentLoginAttempt，给它一个值0.<br>在这个例子里，最大登录次数定义为一个常量，因为最大登录数不会改变。当前登录数定义为变量，因为这个值随着用户的登录尝试会逐渐增长。<br>你也可以定义多个常量或变量在一行，用逗号分开即可：<br><code>var x = 0.0, y = 0.0, z = 0.0</code></p>
<p>类型注释<br>当定义常量或者变量的时候，你可以提供一个类型注释，这样可以更清楚的知道存储类型是什么。在变量名或者常量名后面加一个冒号，然后一个空格，然后是要使用的类型。</p>
<p>这个例子为变量welcomeMessage提供一个类型解释，来说明这个变量可以存储String值：<br><code>var welcomeMessage: String</code><br>这段代码可以理解为：<br>定义个变量叫welcomeMessage，它的类型是String。<br>welcomeMessage变量现在可以存储任何的字符串：<br><code>welcomeMessage = “Hello”</code><br>你可以在一行定义多个相关的相同类型的变量，用逗号分开，然后再最后加上类型注释：<br><code>var red, green, blue: Double</code></p>
<p>常量和变量命名<br>常量和变量命名可以包含几乎任何的字符，包括Unicode字符：<br><code>let π = 3.14159<br>let 你好 = “你好世界”<br>let 🐶🐮 = “dogcow”</code><br>常量和变量命名不能包含空格字符，数学符号，箭头，私有（无效）的Unicode字符码，或者-等。也不能以数字开始，虽然数字可以出现在名字里的任何地方。</p>
<p>一旦你给常量或者变量确定了类型，你就不能用同样的名字来重定义它们，或者改变他们存储的值类型。你也不能把常量改为变量，或者把变量变成常量。</p>
<p>你可以把常量的值改变成同样类型的其他的值。这个例子里，变量friendlyWelcome的值从”Hello!” 变成 “Bonjour!”:<br><code>var friendlyWelcome = “Hello!”<br>friendlyWelcome = “Bonjour!”<br>// friendlyWelcome is now “Bonjour!”</code><br>与变量不同，常量值一旦确定就不能再改变。如果尝试改变编译器会报错：<br><code>let languageName = “Swift”<br>languageName = “Swift++”<br>// This is a compile-time error: languageName cannot be changed.<br></code><br>打印常量和变量<br>你可以使用print(<em>:separator:terminator:)函数打印常量或者变量的当前值：<br><code>print(friendlyWelcome)<br>// Prints “Bonjour!”</code><br>print(</em>:separator:terminator:)是一个全局函数，可以打印一个或者多个值。在XCode里，例如，print(_:separator:terminator:)打印结果会出现在控制台里。separator 和 terminator 参数都有默认值, 所以你可以忽略他们。 默认的, 这个函数打印完会加上换行符。 如果不想打印后换行, 传入一个空字符串作为终止—例如, print(someValue, terminator: “”)</p>
<p>Swift 使用 string interpolation 在长字符串里插入常量或者变量名, 同时会提示 Swift 去用当前的常量值活变量值来替换它。 用括号包含名字，然后在前面加上反斜杠:</p>
<p><code>print(“The current value of friendlyWelcome is (friendlyWelcome)”)<br>// Prints “The current value of friendlyWelcome is Bonjour!”</code></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在代码中，把注释加到不执行的文本，作为一个备注或者提醒。代码编译的时候，注释会被编译器忽略。<br>Swift注释和C语言注释很像，不在赘述。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>跟其他语言不同，Swift不要求在每条语句后写分号（；），不过，在一行写很多语句的时候，还是需要带上分号的：<br><code>let cat = “🐱”; print(cat)<br>// Prints “🐱”<br></code></p>
<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><p>Integers 意思是整个数字没有小数，比如 42 和 -23，整数要么是 signed（负数，0，正数） 要么是 unsigned（正数或者0）</p>
<p>Swift提供8，16，32 和 64位的有符号和无符号的整数。这些整数类型和C语言很像，8位的无符号的整数是UInt8，32位的有符号正数是Int32.</p>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><p>你可以用min 和max属性来获取每个整数类型的最小值和最大值：<br><code>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8<br>let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8</code></p>
<h1 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h1><p>大多数情况下，你不需要指定整数的位数。Swift提供了额外的整数类型Int，这个和当前平台的本地字数一样：<br>32位机器，Int等于Int32<br>64位机器，Int等于Int64<br>除非你要用规定大小的整数，否则，一般只要用Int就可以了。</p>
<h1 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h1><p>Swift也提供了无符号的整形，UInt，这个和当前平台的本地字数也是一样的：<br>32位机器，UInt等于UInt32<br>64位机器，UInt等于UInt64</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>Floating-point 是带有小数部分的数字，比如 3.14159，0.1和-273.15.<br>浮点数类型比整数类型表达更多的值域，比存在Int中的值更大或者更小。Swift提供了两个有符号的浮点数类型：<br>Double 表示64位的浮点数。<br>Float 表示32位的浮点数。</p>
<h1 id="类型安全与推断"><a href="#类型安全与推断" class="headerlink" title="类型安全与推断"></a>类型安全与推断</h1><p>Swift是类型安全的语音。类型安全的语言鼓励你清楚知道自己代码使用的值的类型。如果你的代码需要String类型，那么你就不要传递Int给它。</p>
<p>因为Swift是类型安全的，在编译代码的时候type checks会执行来标记不匹配的类型错误。这让你可以尽可能早的发现代码中的错误。</p>
<p>类型检查帮你避免使用不同类型的时候犯错，然而，这并不意味你必须给所有的常量和变量指定类型。你不需要指定类型，Swift使用type inference来推断合适的类型。类型推断使得编译器可以在编译代码的时候自动推断表达式的类型，只是通过简单的检查你提供的值。</p>
<p>因为有类型推断，Swift 对类型声明要求的比其他语言要少的多。常量和变量依然要显示输入，但是大部分指定类型的工作都已经帮你做了。</p>
<p>类型推断在给常量或者变量赋初值的时候尤为有用。这个发生在你声明常量或者变量，并给他们指定literal value（字面量）的时候。所谓的字面量就是指直接出现在你的源码中的值，比如下面例子里的 42 和 3.14159</p>
<p>例如，如果你给一个新常量指定一个字面量是42， Swift就会推断你想要这个常量的类型是Int， 因为你给他初始化一个数字：<br><code>let meaningOfLife = 42<br>// meaningOfLife is inferred to be of type Int</code><br>同样，你也不需要给浮点数指定类型，Swift会推断说你想要一个Double：<br><code>let pi = 3.14159<br>// pi is inferred to be of type Double</code><br>Swift在推断浮点数的时候总是选择Double而不是Float<br>如果你合并整数和浮点数在一个表达式中，Double类型将会被推断出来：<br><code>let anotherPi = 3 + 0.14159<br>// anotherPi is also inferred to be of type Double</code></p>
<h1 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h1><p>整数字面量这可以写：<br>十进制数字，没有前缀<br>二进制数字，用0b做前缀<br>八进制数字，用0o做前缀<br>十六进制数字，用0x做前缀<br>下面所有整数字面量值都是17：<br><code>let decimalInteger = 17<br>let binaryInteger = 0b10001       // 17 in binary notation<br>let octalInteger = 0o21           // 17 in octal notation<br>let hexadecimalInteger = 0x11     // 17 in hexadecimal notation</code></p>
<p>浮点数字面量可以是十进制或者十六进制。在十进制点的两边都必须有数字。十进制浮点数也有个可选的exponent，用大小写e标明；十六进制浮点数也有exponent，用大小写的p标明。</p>
<p>用 exp 指数表示十进制数, 基础数字乘以 10exp:<br>1.25e2 意思是 1.25 x 102, 或者是 125.0.<br>1.25e-2 意思是 1.25 x 10-2, 或者是 0.0125.<br>用 exp 指数表示十六进制数, 基础数字乘以 2exp:</p>
<p>0xFp2 意思是 15 x 22, 或者是 60.0.<br>0xFp-2 意思是 15 x 2-2, 或者是 3.75.<br>下面所有这些浮点数字面量十进制数都是 12.1875:<br><code>let decimalDouble = 12.1875<br>let exponentDouble = 1.21875e1<br>let hexadecimalDouble = 0xC.3p0</code></p>
<h1 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h1><p>在你的代码中使用Int做为一般用途的整形常量和变量，尽快知道他们是非负数的。日常开发使用默认整形类型意味着整形变量和常量立即可以使用，而且它们匹配整形字面量的推断类型。</p>
<p>特别指定的工作才会使用其他的整形类型，因为指定大小的整形类型需要额外的开销。日常开发中，使用指定大小的类型帮助捕获特定值的溢出，同时记录被使用的数据。</p>
<h1 id="整形转换"><a href="#整形转换" class="headerlink" title="整形转换"></a>整形转换</h1><p>不同数值类型，存储在常量或变量中的数值范围是不同的。一个Int8常量或者变量可以存储 -128 到 127， UInt8 常量或者变量能存储 0 到 255 之间的数值。如果数值不适合指定大小的整形类型，编译后会报错。</p>
<p><code>let cannotBeNegative: UInt8 = -1<br>// UInt8 cannot store negative numbers, and so this will report an error<br>let tooBig: Int8 = Int8.max + 1<br>// Int8 cannot store a number larger than its maximum value,<br>// and so this will also report an error</code></p>
<p>为了转换一个特定数值类型，先用一个存在的值初始化一个新的想要类型的新数值。下面的例子，常量twoThousand的类型是UInt16， 而常量one的类型是UInt8.他们不能直接相加，因为类型不同。取而代之的是，这个例子调用UInt16（one）来创建一个新的Uint16，并用one初始化它，并在原来的位置使用这个值：</p>
<p><code>let twoThousand: UInt16 = 2_000<br>let one: UInt8 = 1<br>let twoThousandAndOne = twoThousand + UInt16(one)</code></p>
<p>因为加好两边的值类型都是UInt16，所以加法是进行的。输出常量推断是UInt16，因为它是两个UInt16值的和。</p>
<p>SomeType(ofInitialValue) 默认调用Swift类型的初始化函数，然后传递一个初始值。这个语句之前，UInt16有一个初始化器接受一个UInt8的值，所以这个初始化器就用存在的UInt8 创建了一个新的UInt16.这里你不能随便传入类型-必须传入UInt16初始化器接受的值。</p>
<h1 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h1><p>整数和浮点数之间的转换必须是显示的：<br><code>let three = 3<br>let pointOneFourOneFiveNine = 0.14159<br>let pi = Double(three) + pointOneFourOneFiveNine<br>// pi equals 3.14159, and is inferred to be of type Double</code></p>
<p>这里，常量three用来创建新的Double数值，现在加号两边的类型是一样的，所以可以相加。如果没有这里的转换，加法是不允许的。</p>
<p>浮点数转整数也必须是显示进行的。一个整形可以用Double 或者 Float的值来初始化：</p>
<p><code>let integerPi = Int(pi)<br>// integerPi equals 3, and is inferred to be of type Int</code><br>用这种方式初始化一个新的整形数值，浮点数会被截断。意思就是 4.75 会变成 4， -3.9会变成-3.</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>type aliases 为已知类型定一个别名。定义类型别名使用typealias关键字。</p>
<p>类型别名在你想通过名字调用一个已知类型的时候很有用，这种名字在上下文中更合适，比如使用指定大小的外部数据时：<br><code>typealias AudioSample = UInt16</code><br>定义好类型别名后，你可以在任何使用原名的地方使用它：<br><code>var maxAmplitudeFound = AudioSample.min<br>// maxAmplitudeFound is now 0</code><br>这里，AudioSample就是UInt16的别名。因为是别名，调用AudioSample.min实际上就是调用UInt16.min，这给maxAmplitudeFound变量提供一个初始值0.</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>Swift有个一基础布尔类型， 叫做 Bool。布尔值用作逻辑调用，因为它只能是true或者false。Swift提供了两个布尔常量值，true和falseL<br><code>let orangesAreOrange = true<br>let turnipsAreDelicious = false</code></p>
<p>orangesAreOrange 和 turnipsAreDelicious 的类型被推断是Bool。同上面的Int 和 Double 一样，你不需要声明常量或者变量为Bool</p>
<p>布尔值在if 语句这种条件语句中尤其有用：<br><code>if turnipsAreDelicious {<br>    print(“Mmm, tasty turnips!”)<br>} else {<br>    print(“Eww, turnips are horrible.”)<br>}<br>// Prints “Eww, turnips are horrible.”</code></p>
<p>Swift 类型安全防止非布尔值被替换成布尔值。下面的例子报一个编译错误：</p>
<p><code>let i = 1<br>if i {<br>    // this example will not compile, and will report an error<br>}</code></p>
<p>替代的例子如下：<br><code>let i = 1<br>if i == 1 {<br>    // this example will compile successfully<br>}</code></p>
<p>i==1比较的结果是Boo类型，所以第二个例子通过了类型检查。</p>
<p>和其他类型安全例子一样，这个方法避免了突发的错误，确保特别代码块推断总是清晰的。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>Tuples 包含多值到一个单独的组合值。元组里的值可以是任何类型，彼此之间可以是不同类型。</p>
<p>在这个例子中，(404, “Not Found”)是一个元组，代表Http的错误码。一个Http错误码是访问网页时网页服务器返回的特殊数值。如果你请求的网页不存在，就会返回404 Not Found的错误码。</p>
<p><code>let http404Error = (404, “Not Found”)<br>// http404Error is of type (Int, String), and equals (404, “Not Found”)</code></p>
<p>(404, “Not Found”) 元组包含了一个Int 和一个String，一个数字和一个人工可读的描述。它可以描述成一个类型为（Int, String）的元组。</p>
<p>你可以用任何变化的类型创建元组，你可以按照需要要创建不同的元组。</p>
<p>你可以分解元组到分离的常量或者变量，通常你会访问它们：</p>
<p><code>let (statusCode, statusMessage) = http404Error<br>print(“The status code is (statusCode)”)<br>// Prints “The status code is 404”<br>print(“The status message is (statusMessage)”)<br>// Prints “The status message is Not Found”</code></p>
<p>如果你只需要元组中的某些值，当你分解元组的时候可以用下划线替换忽略的部分：<br><code>let (justTheStatusCode, _) = http404Error<br>print(“The status code is (justTheStatusCode)”)<br>// Prints “The status code is 404”</code></p>
<p>或者，通过下标访问元组中单独的元素值：</p>
<p><code>print(“The status code is (http404Error.0)”)<br>// Prints “The status code is 404”<br>print(“The status message is (http404Error.1)”)<br>// Prints “The status message is Not Found”</code></p>
<p>你可以在元组定义时，给单独的原色命名：</p>
<p><code>let http200Status = (statusCode: 200, description: “OK”)</code></p>
<p>如果你在元组中命名了元素，那么，你可以在访问元素值的时候通过名字访问它们的值：</p>
<p><code>print(“The status code is (http200Status.statusCode)”)<br>// Prints “The status code is 200”<br>print(“The status message is (http200Status.description)”)<br>// Prints “The status message is OK”</code></p>
<h1 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h1><p>当一个值可能缺失的时候使用optionals。一个可选值包含两种可能：或者有一个值，你可以通过拆包访问这个值，或者根本没有值。</p>
<p>这里有一个例子，说明可选类型如何在值缺失的时候使用。Swift 的Int 类型有一个初始化器，可以把String 转换为Int 值。不过，不是每一个字符串都可以转换的。“123”可以转换为123，但是“helloworld”就不可以。</p>
<p>下面的例子使用初始化器去转换String：<br><code>let possibleNumber = “123”<br>let convertedNumber = Int(possibleNumber)<br>// convertedNumber is inferred to be of type “Int?”, or “optional Int”</code></p>
<p>因为初始化器有可能失败，所以它返回一个optional Int，而不是Int。一个可选Int写作Int？，不是Int。问号表示包含的值是可选的，意思就是它可能包含某个Int值，也可能不包含任何值。</p>
<h1 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h1><p>通过赋值nil来把可选值设置成无值状态：</p>
<p><code>var serverResponseCode: Int? = 404<br>// serverResponseCode contains an actual Int value of 404<br>serverResponseCode = nil<br>// serverResponseCode now contains no value</code></p>
<p>如果如果定义一个可选变量，但是没有提供默认值，这个变量会被自动设置为nil：<br><code>var surveyAnswer: String?<br>// surveyAnswer is automatically set to nil</code></p>
<h1 id="if语句和强制拆包"><a href="#if语句和强制拆包" class="headerlink" title="if语句和强制拆包"></a>if语句和强制拆包</h1><p>用if语句，通过与nil做比较，你可以知道一个可选项是否包含一个值，用（==）或者（！=）来做比较。如果一个可选项有值，那么它不等于ni：<br><code>if convertedNumber != nil {<br>    print(“convertedNumber contains some integer value.”)<br>}<br>// Prints “convertedNumber contains some integer value.”</code></p>
<p>一旦你确定可选项包含一个值，你可以通过在可选项的名字后面加（！）来获取它的值。这个感叹号是说：我知道这个可选项一定有值；请使用它！这就是强制拆包获取可选项的值：<br><code>if convertedNumber != nil {<br>    print(“convertedNumber has an integer value of (convertedNumber!).”)<br>}<br>// Prints “convertedNumber has an integer value of 123.”</code></p>
<h1 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h1><p>使用optional binding找出一个可选项是否包含一个值。如果这样的话，使这个值作为一个临时常量或者变量。可选绑定用if和while语句来判断可选项的值，然后提取这个值到常量或者变量，作为操作的一部分。</p>
<p>用if语句写可选绑定像下面这样：</p>
<p><code> if let constantName = someOptional {<br>    statements<br>}<br></code></p>
<p>你可以重写possibleNumber实例，通过使用可选绑定而不是强制拆包：</p>
<p><code> if let actualNumber = Int(possibleNumber) {<br>    print(“\”(possibleNumber)\” has an integer value of (actualNumber)”)<br>} else {<br>    print(“\”(possibleNumber)\” could not be converted to an integer”)<br>}<br>// Prints “”123” has an integer value of 123”</code></p>
<p>代码可以这样解释;<br>如果Int（possibleNumber）返回的可选Int包含一个值，设置一个新的常量叫actualNumber，它的值就是包含在可选项中的值。</p>
<p>如果转换成功，actualNumber 常量变的可用，执行第一个分支的语句。因为已经初始化了可选项的值，所以不需要用感叹号去拆包。</p>
<p>你可以同时使用常量和变量，如果你想操作if语句第一个分支里的actualNumber，你可能要写 if var actualNumber来替换代码，然后可选项的值会变成变量值而不是常量值。</p>
<p>你可以在单独的if语句包括尽可能多的可选绑定和布尔条件，用逗号分开即可。如果任何可选项的值为nil或者布尔条件等于false，if条件被认为是false。下面的if语句是一样的：</p>
<p><code>if let firstNumber = Int(“4”), let secondNumber = Int(“42”), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>    print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>}<br>// Prints “4 &lt; 42 &lt; 100”</code></p>
<p>if let firstNumber = Int(“4”) {<br>    if let secondNumber = Int(“42”) {<br>        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>            print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>        }<br>    }<br>}<br>// Prints “4 &lt; 42 &lt; 100”</p>
<h1 id="隐式拆包可选项"><a href="#隐式拆包可选项" class="headerlink" title="隐式拆包可选项"></a>隐式拆包可选项</h1><p>如上所述，可选项表示一个常量或者变量可以没有值。可选项可以用if语句判断是否存在值，如果不存在，可以有条件用可选绑定拆包来访问可选项的值。</p>
<p>有时候，通过程序的结构可以很清楚的知道可选项有值，然后这个值被第一次设置。这种情况，就不需要每次都判断和拆包了，因为可以安全的假设总是有值。</p>
<p>这种可选项定义为隐式拆包可选项。隐式拆包可选项的写法是，在类型后面假设感叹号而不是问号。</p>
<p>当可选项的值在首次定义后就能确定存在的事，隐式拆包可选项很有用。隐式拆包可选项主要用在类的初始化。</p>
<p>隐式拆包可选项在这种场景下，是正常可选项，但是也可以用作一个非可选项，无需每次访问都拆包。下面的例子展示了，可选字符串和隐式拆包可选项字符串作为显示String时访问它们包含的值的不同行为。</p>
<p><code>let possibleString: String? = “An optional string.”<br>let forcedString: String = possibleString! // requires an exclamation mark</code></p>
<p>let assumedString: String! = “An implicitly unwrapped optional string.”<br>let implicitString: String = assumedString // no need for an exclamation mark</p>
<p>你依然可以把隐式拆包可选项当做正常的可选项，来判断它是否包含一个值：</p>
<p><code>if assumedString != nil {<br>    print(assumedString)<br>}<br>// Prints “An implicitly unwrapped optional string.”</code></p>
<p>你可以结合可选绑定来使用隐式拆包可选项，然后在一行语句中判断和拆包它的值：</p>
<p><code>if let definiteString = assumedString {<br>    print(definiteString)<br>}<br>// Prints “An implicitly unwrapped optional string.”</code></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>使用error handling 响应程序执行中错误条件。<br>与可选项做对照，可选项用有无值来表示一个函数的成功失败，错误处理允许你检测迁走的失败原因，同时如果必要的话，会把错误传递到程序的另外一部分。</p>
<p>当函数遇到一个错误情况，它就会throws 一个错误。函数调用者可以捕获这个错并正确响应。</p>
<p><code>func canThrowAnError() throws {<br>    // this function may or may not throw an error<br>}</code></p>
<p>一个函数表明它可以通过在定义中包含throws关键词来抛出一个错误。当你调用这个可以抛出错误的函数时，你要准备try关键词。</p>
<p>Swift 自动把错误往外抛知道它被一个catch语句处理。</p>
<p><code>do {<br>    try canThrowAnError()<br>    // no error was thrown<br>} catch {<br>    // an error was thrown<br>}</code></p>
<p>do 语句创建了一个代码块，它允许错误可以传递给一个或者多个catch 项。</p>
<p>这里有一个列子，展示响应不同错误条件的错误处理方式：</p>
<p><code>func makeASandwich() throws {<br>    // …<br>}</code></p>
<p>do {<br>    try makeASandwich()<br>    eatASandwich()<br>} catch SandwichError.outOfCleanDishes {<br>    washDishes()<br>} catch SandwichError.missingIngredients(let ingredients) {<br>    buyGroceries(ingredients)<br>}</p>
<p>在这个例子里，如果没有干净的餐具可用或者任何调料确实，makeASandwich将会抛出一个错误。因为makeASandwich可以抛出错误，所以函数调用包含在try表达式。经过do语句包含处理，任何抛出的错误都会传递到catch项。</p>
<p>如果没有错误抛出，eatASandwich函数会被调用。如果一个错误抛出然后匹配SandwichError.outOfCleanDishes这个条件，那么washDishes会被调用。如果一个错误抛出然后匹配SandwichError.missingIngredients条件，那么buyGroceries会被调用</p>
<h1 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h1><p>operator 是特殊的符号或者短语，用来检查，改变，或者合并数值。比如，加号（+）用来加两个数值，比如 let = 1 + 2，逻辑与（&amp;&amp;）合并两个布尔值，比如 enteredDoorCode &amp;&amp; passedRetinaScan<br>Swift支持大部分的C语言操作符，并且提升了消除一般编码错误的能力。赋值运算符（=）不会返回一个值，用来防止错误是使用（==）。算数运算符—（+，-，*，/，%等等）监测和拒绝值溢出，为了避免值溢出造成未知的结果。你可以用Swift的溢出运算符选择值溢出行为。</p>
<p>Swift同时提供了两个范围运算符（a..&lt;b和a…b），这在C语言里没有。这些作为表达一个范围值的快捷方式。</p>
<p>这个章节介绍Swift的普通运算符。Advanced Operators 包含了Swift的高级运算符，描述如何定义你自己的运算符，然后为你自定义的类型实现标准运算符。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>运算符是一元的，二元的，或者三元的：<br>    一元运算符操作单一目标（比如-a）。一元前缀操作费直接写在目标前（比如！b），一元后缀操作费则直接出现在目标后（比如c！）。<br>    二元运算符操作两个目标（比如2+3），并且出现在两个目标的中间。<br>    三元运算符操作三个目标，跟C语言一样，Swift 只有一个三元运算符，也就是三元条件运算符（a ？b ：c）。<br>运算符作用的值是操作数。在表达式1+2里，+号是二元运算符，两个操作数分别是1和2.</p>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>assignment operator（a=b）用b的值初始化或者更新a的值。<br><code>let b = 10<br>var a = 5<br>a = b<br>// a is now equal to 10</code><br>如果赋值语句的右侧是多值的元组，它的元素可以一次分解为多个常量或者变量：</p>
<p><code>let (x, y) = (1, 2)<br>// x is equal to 1, and y is equal to 2</code><br>与C语言 和 Objective-C语言不同，Swift赋值运算符自身不返回值。下面的语句是无效的：</p>
<p><code>if x = y {<br>    // This is not valid, because x = y does not return a value.<br>}</code><br>这个特性防止=与==混淆。 让if x = y 无效, Swift 帮你避免这种错误。</p>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>Swift 对所有类型支持四种标准算术运算符:</p>
<p>加号 (+)<br>减号 (-)<br>乘号 (<em>)<br>除号 (/)<br>1 + 2       // 等于 3<br>5 - 3       // 等于 2<br>2 </em> 3       // 等于 6<br>10.0 / 2.5  // 等于 4.0<br>与C语言 和 Objective-C语言不同, Swift 算术运算符默认不允许值溢出。 你可以通过Swift溢出运算符来选择值溢出行为(例如 a &amp;+ b)。</p>
<p>加号也支持字符串连接:</p>
<p><code>“hello, “ + “world”  // 等于 “hello, world”</code></p>
<h1 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h1><p>余数运算符 (a % b) 计算a中b的倍数，并且返回余数。</p>
<p>备注</p>
<p>余数运算符 (%) 在其他语言中作为取模运算符。 不过, 在 Swift 中对负数来说, 严格来讲, 它是余数而不是一个取模运算。</p>
<p>下面演示余数运算符是如何工作的。 计算 9 % 4, 你首先算出9里有多少个4:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png"><br></div>

<p>你可以确定9里有两个4, 余数是 1 (橙色显示)。</p>
<p>在 Swift 里, 这个会写作:</p>
<p><code>9 % 4    // 等于 1</code><br>为了确定 a % b 的结果, % 运算符计算下面的方程式，然后返回余数作为输出:</p>
<p>a = (b x 倍数) + 余数</p>
<p>这里倍数是a里面b的最大倍数。</p>
<p>把 9 和 4 代入方程式值域:</p>
<p><code>9 = (4 x 2) + 1</code></p>
<p>计算负值a的余数也是用相同的方法:</p>
<p><code>-9 % 4   // 等于 -1</code><br>把 -9 和 4 代入方程式值域:</p>
<p><code>-9 = (4 x -2) + -1</code></p>
<p>活的余数 -1.</p>
<p>负值b被忽略。 意思就是 a % b 和 a % -b 结果是一样的。</p>
<h1 id="一元减法运算符"><a href="#一元减法运算符" class="headerlink" title="一元减法运算符"></a>一元减法运算符</h1><p>数值符号可以用前缀 - 连接, 也就是大家熟知的一元减法运算符:<br><code><br>let three = 3<br>let minusThree = -three       // minusThree equals -3<br>let plusThree = -minusThree   // plusThree equals 3, or “minus minus three”<br></code><br>一元减法运算符 (-) 直接放在操作数前, 没有空格。</p>
<h1 id="一元加法运算符"><a href="#一元加法运算符" class="headerlink" title="一元加法运算符"></a>一元加法运算符</h1><p>一元加法运算符 (+) 返回操作数值, 没有任何改变:<br><code><br>let minusSix = -6<br>let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6<br></code><br>尽管一元加法运算符实际上不做任何事, 你可以用它来提供对称的代码，当在代码中使用正负数的时候。</p>
<h1 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h1><p>和 C 语言相似, Swift 提供复合赋值运算符来合并赋值 (=) 和其他操作数。 一个例子就是加法赋值运算符 (+=):<br><code><br>var a = 1<br>a += 2<br>// a 现在等于 3<br></code><br>表达式 a += 2 是 a = a + 2 的快捷方式。 实际上, 加法和赋值合并进一个操作符，同时做了两件事。</p>
<p>备注</p>
<p>复合赋值运算符不返回值。 比如, 你不能这样写 let b = a += 2.</p>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>Swift 支持所有标准C语言比较运算符:</p>
<p>等于 (a == b)<br>不等于 (a != b)<br>大于 (a &gt; b)<br>小于 (a &lt; b)<br>大于等于 (a &gt;= b)<br>小于等于 (a &lt;= b)</p>
<p>备注</p>
<p>Swift 同时提供两个相等运算符 (=== and !==), 你可以用来测试两个对象引用是否引用了相同的对象实例。 更多信息参考 Classes and Structures.</p>
<p>每个比较运算符都返回一个布尔值，来表明语句是否是真的:</p>
<p>1 == 1   // 真，因为1 等于 1<br>2 != 1   // 真，因为2 不等于 1<br>2 &gt; 1    // 真，因为2 大于 1<br>1 &lt; 2    // 真，因为1 小于 2<br>1 &gt;= 1   // 真，因为1大于或者等于1<br>2 &lt;= 1   // 假，因为2不小于或者等于1<br>比较运算符通常用于条件语句, 例如if语句:<br><code><br>let name = “world”<br>if name == “world” {<br>    print(“hello, world”)<br>} else {<br>    print(“I’m sorry (name), but I don’t recognize you”)<br>}<br>// Prints “hello, world”, because name is indeed equal to “world”.<br></code><br>更多if语句, 参考 Control Flow.</p>
<p>你可以比较含有相同数量值的元组, 只要元组里的值可以比较。 例如, Int 和 String 可以比较, 意思就是 (Int, String) 可以比较。 相反, Bool 不能比较, 意思就是包含布尔值的元组不能作比较。</p>
<p>元组是从左到右做比较的, 每次一个值, 直到比较发现两个值不等为止。 这两个被比较的值, 比较的结果决定了整个元组比较的结果。 如果所有元素都相等, 那么元组就是相等的。例如:<br><code><br>(1, “zebra”) &lt; (2, “apple”)   // 真，因为1小于2; “zebra” 和 “apple” 不比较<br>(3, “apple”) &lt; (3, “bird”)    // 真，以为3等于3, “apple” 小于 “bird”<br>(4, “dog”) == (4, “dog”)      // 真，因为4等于4, “dog” 等于 “dog”<br></code><br>上面这个例子, 在第一行你可以看见从左到右比较的行为。 因为1小于2, (1, “zebra”) 被认为小于 (2, “apple”), 不用管元组里的其他值。 不管 “zebra” 是不是小于 “apple”, 因为比较已经取决于元组里的第一个元素了。 不过, 当元组第一个元素相等的时候，比较就像第二行，第三行发生的那样。</p>
<h1 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h1><p>三元条件运算符是含有三部分的特殊运算符, 样式是 <code>问题 ? 答案1 : 答案2</code>。 这是基于问题是真假对表达式之一的判断。 如果问题是真, 求 answer1 的值并返回; 否则, 求 answer2 的值并返回。</p>
<p>三元条件运算符是下面代码的简写:<br><code><br>if question {<br>    answer1<br>} else {<br>    answer2<br>}<br></code><br>这里有一个例子, 用例计算列表行高。 如果行有头部，那么行高比内容高度加50，如果没有头部，那么高度加20:<br><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight = contentHeight + (hasHeader ? 50 : 20)<br>// rowHeight is equal to 90<br></code></p>
<p><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight: Int<br>if hasHeader {<br>    rowHeight = contentHeight + 50<br>} else {<br>    rowHeight = contentHeight + 20<br>}<br>// rowHeight is equal to 90<br></code><br>第一个例子使用三元条件运算符，意味着行高可以在一行代码里正确设置, 这个比第二个例子的代码要简洁。</p>
<p>三元条件运算符提供一个简写，来决定使用两个表达式中的哪一个。 小心使用三元条件运算符。 过度使用，代码就是很难理解。 尽量避免把三元条件运算符的多个实例合并到一个符合语句。</p>
<h1 id="Nil-联合运算符"><a href="#Nil-联合运算符" class="headerlink" title="Nil-联合运算符"></a>Nil-联合运算符</h1><p>nil-联合运算符 (a ?? b) 展开一个可选项 a 如果它包含一个值的话, 或者返回一个默认值 b 如果 a 是 nil。 表达式 a 总是一个可选类型。 表达式 b 必须匹配存储在a里的值类型。</p>
<p>nil-联合运算符是下面代码的简写:</p>
<p><code>a != nil ? a! : b</code><br>上面的代码使用三元条件运算符,然后强制展开 (a!) 来获取a中的值，如果这个值不空的话, 否则返回 b 。 nil-联合运算符提供了更优雅简洁的方式来压缩这个条件判断和展开。</p>
<p>备注</p>
<p>如果值非空, b的值不会得到。 这就是人们熟知的短路估算。</p>
<p>下面的例子使用 nil-联合运算符在默认颜色名称和可选用户定义的颜色名称之间做选择:<br><code><br>let defaultColorName = “red”<br>var userDefinedColorName: String?   // 默认是 nil</code></p>
<p>var colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName 是 nil, 所以colorNameToUse 设置成默认值 “red”<br><br>userDefinedColorName 变量定义成可选的 String, 默认值是 nil. 因为 userDefinedColorName 是个可选类型, 你可以使用nil-联合运算符来获取它的值。 上面的例子, 运算符用来决定变量 colorNameToUse 的一个初始值。 因为 userDefinedColorName 是 nil,  userDefinedColorName ?? defaultColorName 表达式返回了defaultColorName 的值, 或者 “red”.</p>
<p>如果你给 userDefinedColorName 赋了一个非空的值，然后执行 nil-联合运算符再次判断, userDefinedColorName 中包含的值 就取代了默认值:<br><code><br>userDefinedColorName = “green”<br>colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName is not nil, so colorNameToUse is set to “green”<br></code></p>
<h1 id="范围运算符"><a href="#范围运算符" class="headerlink" title="范围运算符"></a>范围运算符</h1><p>Swift 有两个范围运算符, 是表达值范围的简写。</p>
<h1 id="闭合区间运算符"><a href="#闭合区间运算符" class="headerlink" title="闭合区间运算符"></a>闭合区间运算符</h1><p>闭合区间运算符 (a…b) 定义从a到b的范围, 包含a和b的值。 a的值不能比b大。</p>
<p>闭合区间运算符在范围迭代很有用，特别是你想使用所有的值的时候。例如 for-in 循环:<br><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index * 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br></code><br>更多 for-in 循环, 参考 Control Flow.</p>
<h1 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h1><p>半开区间运算符 (a..&lt;b) 定义了从a到b的范围, 但是不包含b， 之所以成为半开是因为它包含初值, 但是不包含终值。 正如闭合区间运算符, a的值不能大于b。 如果a的值等于b的值, 这个范围就会是空的。</p>
<p>半开区间在你使用类似数组这种基于零的列表时非常有用, 计算列表长度 (但是不包括) 很有帮助:<br><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>let count = names.count<br>for i in 0..<count 1="" 2="" 3="" 4="" {="" print("person="" \(i="" +="" 1)="" is="" called="" \(names[i])")="" }="" person="" anna="" alex="" brian="" jack="" <="" code=""><br>数组包含4项, 不过 0..&lt;count 只计算到3 (数组最后一项的索引), 因为是半开区间。 更多数组, 参见 Arrays.</count></code></p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>逻辑运算符改变或者合并布尔值真和假。 Swift 支持三种基于C语言的标准逻辑运算符:</p>
<p>逻辑非 (!a)<br>逻辑与 (a &amp;&amp; b)<br>逻辑或 (a || b)</p>
<h1 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h1><p>逻辑非运算符 (!a) 反转布尔值，这样真就变成假, 假变成了真。</p>
<p>逻辑非运算符是个前缀运算符, 直接写在操作数前面, 没有任何空格。 可以读作 “not a”, 下面的例子可以看到:<br><code><br>let allowedEntry = false<br>if !allowedEntry {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “ACCESS DENIED”<br></code><br>语句 if !allowedEntry 可以读作 “if not allowed entry.” 后面一行仅执行 “not allowed entry” 是 true; 也就是, if allowedEntry 是 false.</p>
<p>在这个例子中, 谨慎定义布尔常量和变量名，可以让代码具有可读性和简洁性, 同时避免双重否定或者混乱的逻辑语句。</p>
<h1 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a>逻辑与运算符</h1><p>逻辑与运算符 (a &amp;&amp; b) 创建逻辑表达式，这个表达式中两个值为真，表达式也要为真。</p>
<p>如果任何一个值为假, 表达式的结果也将是假。 事实上, 如果第一个值为假, 第二个值不会再计算, 因为它不会让所有表达式都等于真。 这就是人们熟知的短路估值。</p>
<p>这个例子有两个布尔值，只有两个值都是真的时候才允许访问:<br><code><br>let enteredDoorCode = true<br>let passedRetinaScan = false<br>if enteredDoorCode &amp;&amp; passedRetinaScan {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “ACCESS DENIED”<br></code></p>
<h1 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a>逻辑或运算符</h1><p>逻辑或运算符 (a || b) 是两个竖线组成的中间运算符。 用来创建逻辑表达式，这个表达式中只要有一个值为真，表达式的结果就是真。</p>
<p>跟上面逻辑与类似, 逻辑或使用短路估值去计算表达式。 如果逻辑或的左侧是真, 右侧就不再估值, 因为它不会改变整个表达式的结果。</p>
<p>下面的例子, 第一个布尔值 (hasDoorKey) 是假, 但是第二个布尔值 (knowsOverridePassword) 是真。 因为一个值为真, 表达式结果就是真, 所以允许访问:<br><code><br>let hasDoorKey = false<br>let knowsOverridePassword = true<br>if hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code></p>
<h1 id="合并逻辑运算符"><a href="#合并逻辑运算符" class="headerlink" title="合并逻辑运算符"></a>合并逻辑运算符</h1><p>你可以合并多个逻辑运算符来创建更长的复合表达式:<br><code><br>if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code><br>这个例子使用了多个 &amp;&amp; 和 || 运算符来创建一个更长的复合表达式。 不过, &amp;&amp; 和 || 运算符依然只能操作两个值, 所以，这实际上是三个小表达式链接起来的。 </p>
<p>备注</p>
<p>Swift 逻辑运算符 &amp;&amp; 和 || 是左联想的, 意思就是多个逻辑运算符的复合表达式，首先计算最左边的子表达式。</p>
<h1 id="显示括号"><a href="#显示括号" class="headerlink" title="显示括号"></a>显示括号</h1><p>虽然不是严格需要，但是包含括号还是有用的, 使得复杂表达式的意图很容易理解。 上述实例, 给第一部分加上括号很有用，会让它的意图很明显:<br><code><br>if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code><br>括号让第一部分作为独立可能的状态，这样在整个逻辑中就很清晰。 符合表达式的输出不变, 但是整体意图很清晰。 比起简洁，可读性是首选的。使用括号会让你的意图清晰明了。</p>
<h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><p>字符串是字符集合, 比如 “hello, world” 或者 “albatross”. Swift 字符串用 String 类型表示。 字符串内容有多种访问方法, 包括字符值的集合。</p>
<p>Swift的 String 和 Character 类型提供一个快速的, Unicode 方式来作用于你的文本。 字符串创建和操作的语法是轻量和可读的, 字面语法跟C类似。 字符串连接和使用加号运算符一样简单, 字符的可变性由选择常量还是变量来管理, 就像Swift中其他值。 你还可以使用字符串把常量,变量,字面量,和表达式插入更长的字符串, 在一个众所周知的字符串插值。 这让显示自定义字符串变得容易。</p>
<p>尽快语法简单, Swift的 String 类型是个快速, 现代化的字符串实现。 每个字符串有独立编码的 Unicode 字符组成, 提供用多种Unicode形式访问这些字符的支持。</p>
<h1 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h1><p>你可以在代码中为字符串预定义字符值。 字符串字面量是由（””）包围的固定的文字字符序列。</p>
<p>用字符串值作为一个常量或者变量的初始值:</p>
<p><code>let someString = “Some string literal value”</code><br>注意 Swift 推断someString 常量是一个 String 类型, 因为它用字符串值初始化。</p>
<h1 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h1><p>创建空字符串值作为更长字符串的起点, 或者给一个变量赋一个空字符串值, 或者用初始化方法来初始化一个新的字符串实例:<br><code><br>var emptyString = “”               // empty string literal<br>var anotherEmptyString = String()  // initializer syntax<br>// these two strings are both empty, and are equivalent to each other<br>Find out whether a String value is empty by checking its Boolean isEmpty property:</code></p>
<p>if emptyString.isEmpty {<br>    print(“Nothing to see here”)<br>}<br>// Prints “Nothing to see here”<br></p>
<h1 id="字符串易变性"><a href="#字符串易变性" class="headerlink" title="字符串易变性"></a>字符串易变性</h1><p>你来指定一个特定字符串能不能改变（或者突变），这种变化通过把它赋给一个变量实现。 (这种情况它是可以改变的), 或者赋值给一个常量实现 (这种情况它不能被改变):<br><code><br>var variableString = “Horse”<br>variableString += “ and carriage”<br>// variableString is now “Horse and carriage”</code></p>
<p>let constantString = “Highlander”<br>constantString += “ and another Highlander”<br>// this reports a compile-time error - a constant string cannot be modified<br></p>
<h1 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h1><p>Swift 的字符串类型是值类型。 如果你创建了一个新的字符串值, 这个字符串值在传给函数或者方法的时候被复制, 或者当它被赋值给一个常量或者变量的时候。这两种情况, 已存在字符串值的拷贝被创建, 新的拷贝被传递或者赋值, 而不是原来的字符串。 值类型在 Structures and Enumerations Are Value Types 中有描述。</p>
<p>很清楚你拥有精确的字符串值，而不用关心它从哪里来的。你可以确信传给你的字符串不会被改变,除非你自己改变它。</p>
<p>在幕后, Swift 的编译器优化了字符串的使用，这使得实际的拷贝只有真正需要的时候才会占用空间。 这就意味你使用字符串作为值类型总可以获得高性能。</p>
<h1 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h1><p>你可以用for-in 循环语句,通过它的字符属性来迭代访问每一个单独的字符:<br><code><br>for character in “Dog!🐶”.characters {<br>    print(character)<br>}<br>// D<br>// o<br>// g<br>// !<br>// 🐶<br></code></p>
<p>或者, 你可以创建一个单独的字符常量或者变量，这变量通过提供一个字符类型注释的单字符字符串值。:<br><code><br>let exclamationMark: Character = “!”<br>String values can be constructed by passing an array of Character values as an argument to its initializer:</code></p>
<p>let catCharacters: [Character] = [“C”, “a”, “t”, “!”, “🐱”]<br>let catString = String(catCharacters)<br>print(catString)<br>// Prints “Cat!🐱”<br></p>
<h1 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h1><p>字符串值可以通过加号连接成新的字符串:<br><code><br>let string1 = “hello”<br>let string2 = “ there”<br>var welcome = string1 + string2<br>// welcome now equals “hello there”<br></code><br>你也可以通过赋值运算符（+=）把字符串添加到已存在的字符串变量:<br><code><br>var instruction = “look over”<br>instruction += string2<br>// instruction now equals “look over there”<br>You can append a Character value to a String variable with the String type’s append() method:</code></p>
<p>let exclamationMark: Character = “!”<br>welcome.append(exclamationMark)<br>// welcome now equals “hello there!”<br></p>
<h1 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h1><p>String 字符串插入是构建新字符串的一种方法，这种方法通过混合常量,变量,字面量,表达式中的字面量来实现。每个你要插入的值都包括在括弧里,前面是一个反斜杠:<br><code><br>let multiplier = 3<br>let message = “(multiplier) times 2.5 is (Double(multiplier) * 2.5)”<br>// message is “3 times 2.5 is 7.5”<br></code><br>上面这个例子,  multiplier 的值以 (multiplier) 的形式插入到一个字符串。 这个占位符会被 multiplier 的实际值取代，当插值被计算创建新字符串的时候。</p>
<p>multiplier 的值是字符串后面大表达式的一部分。 这个表达式计算 Double(multiplier) <em> 2.5 的值，然后把结果 (7.5) 插入字符串。 这种情况下, 当它被包括进字符串字面量的时候，表达式就写作 (Double(multiplier) </em> 2.5) .</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode 是在不同写作体系中用作编码,表达,处理文字的一种国际标准。 让你可以用一种标准形式表示任何语言的任何字符, 在诸如文本文件或者网页等外部资源,去读写这些字符。 Swift 的字符串和字符是完全 Unicode 编译的。</p>
<h1 id="Unicode-标量"><a href="#Unicode-标量" class="headerlink" title="Unicode 标量"></a>Unicode 标量</h1><p>背后, Swift 的本地字符串类型建立于 Unicode 标量值。对应字符或者修饰符来说, 一个 Unicode 标量是唯一的一个21位数字, 例如 U+0061 是 LATIN SMALL LETTER A (“a”), 或者 U+1F425 是 FRONT-FACING BABY CHICK (“🐥”).<br>注意并非所有 21-位 Unicode 标量都会被赋值给一些给未来预留的字符标量。 分配给字符的标量通常有一个名字, 比如 LATIN SMALL LETTER A 和 FRONT-FACING BABY CHICK .</p>
<h1 id="字符串字面量里的特殊字符"><a href="#字符串字面量里的特殊字符" class="headerlink" title="字符串字面量里的特殊字符"></a>字符串字面量里的特殊字符</h1><p>字符串字面量可以包括下面的特殊字符:</p>
<p>转义字符 \0 (空字符), \ (反斜杠), \t (水平制表符), \n (换行), \r (回车), \” (双引号) and \’ (单引号)<br>任意一个 Unicode 标量, 写作 \u{n}, n 是 一个 1–8 位十六进制数字，这个数字有个和 有效的Unicode 编码点相等的值。<br>下面四个例子显示了特殊字符的编码。wiseWords 常量包括两个转义的双引号字符。 dollarSign, blackHeart, 和sparklingHeart 常量展示了Unicode 标量的格式:<br><code><br>let wiseWords = “\”Imagination is more important than knowledge\” - Einstein”<br>// “Imagination is more important than knowledge” - Einstein<br>let dollarSign = “\u{24}”        // $,  Unicode scalar U+0024<br>let blackHeart = “\u{2665}”      // ♥,  Unicode scalar U+2665<br>let sparklingHeart = “\u{1F496}” // 💖, Unicode scalar U+1F496<br></code></p>
<h1 id="扩展字形集"><a href="#扩展字形集" class="headerlink" title="扩展字形集"></a>扩展字形集</h1><p>Swift的每个字符类型的实例带包一个单独的扩展字形集。 一个扩展字形集是一个或者多个 Unicode 标量，这些标量（当合并时）生成一个人可读的字符。</p>
<p>这里有个例子。 字符 é 可以表示成单独的 Unicode 标量 é (LATIN SMALL LETTER E WITH ACUTE, 或者 U+00E9). 不过, 相同的字母也可以表示成标量集的一部分，字母 e (LATIN SMALL LETTER E, or U+0065), 后面跟着 COMBINING ACUTE ACCENT 标量 (U+0301).COMBINING ACUTE ACCENT 标量 应用于之前的标量, 在一个Unicode识别 文本渲染系统渲染的时候，把 e 变成 é.</p>
<p>在这两个例子里, 字符 é 表示为一个单独的Swift 字符值，这个值表示一个扩展字形集。 第一个例子, 集合包含一个单独的标量; 第二个例子, 是两个标量的集合:<br><code><br>let eAcute: Character = “\u{E9}”                         // é<br>let combinedEAcute: Character = “\u{65}\u{301}”          // e followed by ́<br>// eAcute is é, combinedEAcute is é<br></code><br>扩展字形集是一种灵活的方式去表示很多复杂脚本字符作为单独字符值。 比如, 来自朝鲜字母的朝鲜语音节可以表示成复合或者分离的序列。 在Swift里,这些表达都是合格的字符值:<br><code><br>let precomposed: Character = “\u{D55C}”                  // 한<br>let decomposed: Character = “\u{1112}\u{1161}\u{11AB}”   // ᄒ, ᅡ, ᆫ<br>// precomposed is 한, decomposed is 한<br></code><br>扩展字形集使得封闭标志的标量 (比如 COMBINING ENCLOSING CIRCLE, 或者 U+20DD) 可以装入其他 Unicode 标量作为一个单独字符值的一部分:<br><code><br>let enclosedEAcute: Character = “\u{E9}\u{20DD}”<br>// enclosedEAcute is é⃝<br></code><br>Unicode 局部指示器符号标量可以成对组合来生成一个单独的字符值, 比如 REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA) 和 REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8) 的组合:<br><code><br>let regionalIndicatorForUS: Character = “\u{1F1FA}\u{1F1F8}”<br>// regionalIndicatorForUS is 🇺🇸<br></code></p>
<h1 id="计算字符"><a href="#计算字符" class="headerlink" title="计算字符"></a>计算字符</h1><p>在字符串中获取字符值的数量, 可以使用字符串字符属性中的计数属性:<br><code><br>let unusualMenagerie = “Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪”<br>print(“unusualMenagerie has (unusualMenagerie.characters.count) characters”)<br>// Prints “unusualMenagerie has 40 characters”<br></code><br>注意 Swift 对字符值使用扩展字形集，意味着字符拼接和修改可能不会总是影响字符串的字符数。</p>
<p>例如, 如果你用四个字符的单词咖啡来初始化一个新字符串, 然后添加 COMBINING ACUTE ACCENT (U+0301) 到字符串的尾部, 最后字符的数量还是4, 第四个字符是 é, 而不是 e:<br><code><br>var word = “cafe”<br>print(“the number of characters in (word) is (word.characters.count)”)<br>// Prints “the number of characters in cafe is 4”</code></p>
<p>word += “\u{301}”    // COMBINING ACUTE ACCENT, U+0301</p>
<p>print(“the number of characters in (word) is (word.characters.count)”)<br>// Prints “the number of characters in café is 4”<br></p>
<h1 id="访问和修改字符串"><a href="#访问和修改字符串" class="headerlink" title="访问和修改字符串"></a>访问和修改字符串</h1><p>你可以通过方法和属性来访问和修改字符串, 或者用下标语法。</p>
<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><p>每个字符串值都有一个对应的索引类型, String.Index, 代表每个字符在字符串中的位置。</p>
<p>上面提到的,不同字符要求不等数量的内存, 所以为了决定哪个字符在一个特定的位置, 你必须从头到尾枚举每个 Unicode 标量。 因为这个原因, Swift 字符串不能通过整数值来索引。</p>
<p>使用 startIndex 属性访问字符串的首字符位置。 endIndex 属性是字符串中最后一个字符的位置。 因此, endIndex 属性不是一个字符串下标的有效参数。 如果一个字符串是空的, startIndex 和 endIndex 相等。</p>
<p>你可以用 index(before:) 和 index(after:) 字符串方法访问给定索引前后的索引, 你可以使用 index(_:offsetBy:) 方法代替多次调用这些方法。</p>
<p>你可以使用下标语法访问特定索引位置的字符。<br><code><br>let greeting = “Guten Tag!”<br>greeting[greeting.startIndex]<br>// G<br>greeting[greeting.index(before: greeting.endIndex)]<br>// !<br>greeting[greeting.index(after: greeting.startIndex)]<br>// u<br>let index = greeting.index(greeting.startIndex, offsetBy: 7)<br>greeting[index]<br>// a<br></code><br>尝试访问越界的索引和字符都会引发运行时的错误。<br><code><br>greeting[greeting.endIndex] // Error<br>greeting.index(after: greeting.endIndex) // Error<br></code><br>用字符属性中的索引属性获取字符串中的所有字符。<br><code><br>for index in greeting.characters.indices {<br>    print(“(greeting[index]) “, terminator: “”)<br>}<br>// Prints “G u t e n   T a g ! “<br></code></p>
<h1 id="插入和移除"><a href="#插入和移除" class="headerlink" title="插入和移除"></a>插入和移除</h1><p>在特定位置向字符串插入一个字符, 使用 insert(_:at:) 方法, 插入其他字符串内容到制定索引使用 insert(contentsOf:at:) 方法。<br><code><br>var welcome = “hello”<br>welcome.insert(“!”, at: welcome.endIndex)<br>// welcome now equals “hello!”</code></p>
<p>welcome.insert(contentsOf:” there”.characters, at: welcome.index(before: welcome.endIndex))<br>// welcome 现在等于 “hello there!”<br><br>从指定索引移除字符, 使用 remove(at:) 方法, 在指定范围移除一个字串, 用 removeSubrange(_:) 方法:<br><code><br>welcome.remove(at: welcome.index(before: welcome.endIndex))<br>// welcome 现在等于 “hello there”</code></p>
<p>let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endindex welcome.removesubrange(range)="" welcome="" 现在等于="" "hello"="" <="" code=""><br>备注</welcome.endindex></p>
<p>你可以使用 insert(<em>:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(</em>:) 这些方法,只要符合 RangeReplaceableCollection 协议的任何类型。 这包括 String, 还有集合类型 Array, Dictionary, 和 Set.</p>
<h1 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h1><p>Swift 提供三种方式来比较文本值: 字符串和字符等式, 前缀等式, 和后缀等式。</p>
<h1 id="字符串和字符等式"><a href="#字符串和字符等式" class="headerlink" title="字符串和字符等式"></a>字符串和字符等式</h1><p>字符串和字符等式用“equal to” 运算符 (==) 和 “not equal to” 运算符 (!=) 来判断, 在 Comparison Operators 中描述:<br><code><br>let quotation = “We’re a lot alike, you and I.”<br>let sameQuotation = “We’re a lot alike, you and I.”<br>if quotation == sameQuotation {<br>    print(“These two strings are considered equal”)<br>}<br>// Prints “These two strings are considered equal”<br></code><br>两个字符串的值 (或者两个字符的值) 如果他们的扩展字形集相同,就被认为是相等的。 扩展字形集如果有相同的语义和表现形式，就是相等的, 即使他们背后是由不同 Unicode 标量组成。</p>
<p>比如, LATIN SMALL LETTER E WITH ACUTE (U+00E9) 常规等于 LATIN SMALL LETTER E (U+0065) 加上 COMBINING ACUTE ACCENT (U+0301). 两种扩展字形集都是有效的方式来表示字符 é, 隐藏它们被认为相等:<br><code><br>// “Voulez-vous un café?” using LATIN SMALL LETTER E WITH ACUTE<br>let eAcuteQuestion = “Voulez-vous un caf\u{E9}?”</code></p>
<p>// “Voulez-vous un café?” using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT<br>let combinedEAcuteQuestion = “Voulez-vous un caf\u{65}\u{301}?”</p>
<p>if eAcuteQuestion == combinedEAcuteQuestion {<br>    print(“These two strings are considered equal”)<br>}<br>// Prints “These two strings are considered equal”<br><br>相反, LATIN CAPITAL LETTER A (U+0041, 或者 “A”), 英语中使用, 不等于俄语中使用的 CYRILLIC CAPITAL LETTER A (U+0410, 或者 “А”)。 这两个字符看上去相似, 但是语义不同:<br><code><br>let latinCapitalLetterA: Character = “\u{41}”</code></p>
<p>let cyrillicCapitalLetterA: Character = “\u{0410}”</p>
<p>if latinCapitalLetterA != cyrillicCapitalLetterA {<br>    print(“These two characters are not equivalent.”)<br>}<br>// Prints “These two characters are not equivalent.”<br><br>备注</p>
<p>字符串和字符比较在Swift中不是地区敏感的。</p>
<h1 id="前缀和后缀等式"><a href="#前缀和后缀等式" class="headerlink" title="前缀和后缀等式"></a>前缀和后缀等式</h1><p>判断字符串是否有一个特定前缀或者后缀, 调用字符串的 hasPrefix(<em>:) and hasSuffix(</em>:) 方法, 两个方法都一个 String 类型，然后返回一个布尔值。 </p>
<p>下面这个例子有一个字符串数组，用来表示场景的位置,它们来自莎士比亚的罗密欧与朱丽叶的前两个表演:<br><code><br>let romeoAndJuliet = [<br>    “Act 1 Scene 1: Verona, A public place”,<br>    “Act 1 Scene 2: Capulet’s mansion”,<br>    “Act 1 Scene 3: A room in Capulet’s mansion”,<br>    “Act 1 Scene 4: A street outside Capulet’s mansion”,<br>    “Act 1 Scene 5: The Great Hall in Capulet’s mansion”,<br>    “Act 2 Scene 1: Outside Capulet’s mansion”,<br>    “Act 2 Scene 2: Capulet’s orchard”,<br>    “Act 2 Scene 3: Outside Friar Lawrence’s cell”,<br>    “Act 2 Scene 4: A street in Verona”,<br>    “Act 2 Scene 5: Capulet’s mansion”,<br>    “Act 2 Scene 6: Friar Lawrence’s cell”<br>]<br></code><br>你可以用 hasPrefix(<em>:) 方法用 romeoAndJuliet 数组来技术表演1中的场景数:<br><code><br>var act1SceneCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasPrefix(“Act 1 “) {<br>        act1SceneCount += 1<br>    }<br>}<br>print(“There are (act1SceneCount) scenes in Act 1”)<br>// Prints “There are 5 scenes in Act 1”<br></code><br>相似的, 用 hasSuffix(</em>:) 方法来计算发生在 Capulet’s mansion 和 Friar Lawrence’s cell 的场景数:<br><code><br>var mansionCount = 0<br>var cellCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasSuffix(“Capulet’s mansion”) {<br>        mansionCount += 1<br>    } else if scene.hasSuffix(“Friar Lawrence’s cell”) {<br>        cellCount += 1<br>    }<br>}<br>print(“(mansionCount) mansion scenes; (cellCount) cell scenes”)<br>// Prints “6 mansion scenes; 2 cell scenes”<br></code></p>
<h1 id="Unicode-字符串表示"><a href="#Unicode-字符串表示" class="headerlink" title="Unicode 字符串表示"></a>Unicode 字符串表示</h1><p>当一个 Unicode 字符串写入文本文件或者别的存储时,字符串里的 Unicode 标量会以一些Unicode 定义的编码形式进行编码。 每种字符串编码在人们熟知的代码单元块中。 包括 UTF-8 编码 (把字符串编码成一个 8-位的代码单元), UTF-16 编码 (把字符串编码成一个16-位的代码单元), 和 UTF-32 编码 (把字符串编码成 32-位代码单元)</p>
<p>Swift 提供了几种不同的方式去访问字符串的Unicode 形式。你可以用for-in语句遍历字符串, 访问作为Unicode 扩展字形集的单个字符值。这个过程在 Working with Characters 描述。</p>
<p>或者, 或者用以下三种形式来访问字符串的值:</p>
<p>UTF-8 代码单元集合 (用字符串的utf8属性来访问)<br>UTF-16 代码单元集合 (用字符串的utf16属性来访问)<br>21-位 Unicode 标量值的集合, 等于字符串的 UTF-32 编码方式 (用字符串的 unicodeScalars 属性访问)<br>下面的例子展示字符串的不同表现形式,字符串由字符 D, o, g, ‼ (DOUBLE EXCLAMATION MARK, 或者 Unicode scalar U+203C), 和 🐶 字符 (DOG FACE, 或者 Unicode scalar U+1F436)组成:</p>
<p>let dogString = “Dog‼🐶”</p>
<h1 id="UTF-8-形式"><a href="#UTF-8-形式" class="headerlink" title="UTF-8 形式"></a>UTF-8 形式</h1><p>你可以通过遍历字符串的utf8属性来访问它的 UTF-8 表现形式。 这是属性是 String.UTF8View, 这是无符号的 8-位 (UInt8)值的集合, 每个字节一个:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png"><br></div><br><code><br>for codeUnit in dogString.utf8 {<br>    print(“(codeUnit) “, terminator: “”)<br>}<br>print(“”)<br>// 68 111 103 226 128 188 240 159 144 182<br></code><br>上面这个例子, 前三个十进制 codeUnit 值 (68, 111, 103) 代表字符 D, o, 和 g, 它们的 UTF-8 形式和它们的 ASCII 表现形式一样。 接下来三个十进制 codeUnit 值 (226, 128, 188) 是双感叹号的三个字节的 UTF-8 形式。 最后四个 codeUnit 值 (240, 159, 144, 182) 是个四个字节的 UTF-8 形式，代表小狗的脸字符。<br><br># UTF-16 形式<br><br>你可以通过遍历字符串的utf16属性来访问它的 UTF-16 形式。 这个属性是 String.UTF16View, 它是无符号16-位 (UInt16)的值的集合, 每个16-位代码单元一个:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png"><br></div><br><code><br>for codeUnit in dogString.utf16 {<br>    print(“(codeUnit) “, terminator: “”)<br>}<br>print(“”)<br>// Prints “68 111 103 8252 55357 56374 “<br></code><br>同样, 前三个 codeUnit 值 (68, 111, 103) 代表字符 D, o, 和 g, 它们的 UTF-16 代码单元和它们的 UTF-8 形式一样(因为这些 Unicode 标量表示 ASCII 字符).<br><br>第四个 codeUnit 值 (8252) 是十六进制 203C的十进制数值, 用 Unicode 标量 U+203C表示双感叹号字符。 在 UTF-16 里表示为一个单独的编码单元。<br><br>第五六个 codeUnit 值 (55357 和 56374) 狗脸字符。 这些值是高八位 U+D83D (十进制值是 55357) 和一个第八位 U+DC36 (十进制值 56374)。<br><br># Unicode 标量形式<br><br>你可以通过遍历字符串的 unicodeScalars 属性来访问它的Unicode 标量形式。 这个是属性是 UnicodeScalarView,它是类型 UnicodeScalar 值的集合。<br><br>每个 UnicodeScalar 有一个值属性，它返回这个标量的 21-位值, 用一个 UInt32 值表示:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png"><br></div><br><code><br>for scalar in dogString.unicodeScalars {<br>    print(“(scalar.value) “, terminator: “”)<br>}<br>print(“”)<br>// Prints “68 111 103 8252 128054 “<br></code><br>前三个 UnicodeScalar 值 (68, 111, 103) 再次代表 D, o, 和 g.<br><br>第四个 codeUnit 值 (8252) 是十六进制 203C 的十进制值, 是双感叹的 Unicode 标量 U+203C 。<br><br>第五个和最后一个 UnicodeScalar 值, 128054, 是十六进制 1F436的十进制值, 是狗脸字符的的 Unicode 标量 U+1F436。<br><br>作为查询它们值属性的替代, 每个 UnicodeScalar 值也可以用来构建新的字符串, 例如用做字符串插值:<br><code><br>for scalar in dogString.unicodeScalars {<br>    print(“(scalar) “)<br>}<br>// D<br>// o<br>// g<br>// ‼<br>// 🐶<br></code><br><br># 集合类型<br>Swift 提供了三个主要的集合类型, 数组, 集合, 和字典, 用来存储值的集合。 数组是有序的。 集合是唯一值的无序集。 字典是健值匹配的无序集合。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png"><br></div><br>数组, 集合, 和字典在 Swift 里总是清楚的知道存储的值的类型和能够存储的健。 这就意味着你不能往集合里插入错误类型的值。也意味着 你知道可以从集合里或者的值的类型。<br><br>备注<br><br>Swift 的数组, 集合, 和字典类型是用泛型集合实现的。更多泛型和集合, 参见 Generics.<br><br># 集合的不稳定性<br><br>如果你创建了一个数组, 一个集合, 或者一个字典, 然后赋给一个变量。创建的这个集合就是可变的。这就意味着你可以改变这个集合，方式是通过添加, 移除, 或者改变集合里的项。如果把它们赋给一个常量, 这个集合就是不可改变的, 它的大小和内容都不能改变。<br><br>备注<br><br>如果集合不需要变化，在所有情况下创建不可变的集合是个好的实践。这样做的好处是让你容易理解自己的代码,同时让编译器可以优化你创建的集合。<br><br># 数组<br><br>数组有序存储同类型的值。 相同的值可以多次出现在数组的不同位置。<br><br>备注<br><br>Swift的数组类型跟 Foundation的 NSArray 类相桥接。<br><br># 数组类型缩写语法<br><br>T数组类型的全写法是 Array<element>, 这里Element是数组运行存储的值类型。 你可以缩写数组类型为[Element]. 尽管这两种形式功能一样, 缩写是优先考虑的而且这个教程后面一直这么写。<br><br># 创建空数组<br><br>你可以用初始化语法创建一个特定类的空数组:<br><code><br>var someInts = <a href="">Int</a><br>print(“someInts is of type [Int] with (someInts.count) items.”)<br>// Prints “someInts is of type [Int] with 0 items.”<br></code><br>注意 someInts 变量的类型经过初始化类型被推断为 [Int]<br><br>或者, 如果上下文已经提供类型信息, 例如一个函数参数或者一个确定类型的变量或者常量, 你可以用空的字面量来创建空数组, 这个数组通常写作 [] (一个空的中括号对):<br><code><br>someInts.append(3)<br>// someInts now contains 1 value of type Int<br>someInts = []<br>// someInts is now an empty array, but is still of type [Int]<br></code><br># 用默认值创建数组<br><br>Swift的数组类型也提供了一初始化器来创建相同默认值固定大小的数组。 给初始化器传一个匹配类型的默认值 (调用 repeating): 然后是在新数组中需要重复的值的个数 (调用 count):<br><code><br>var threeDoubles = Array(repeating: 0.0, count: 3)<br>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]<br></code><br># 通过合并数组创建数组<br><br>你可以通过合并两个已存在的数组来创建新的数组,这两个数组只要类型匹配就可以通过加法运算符 (+)来合并。 新数组的类型从合并的数组可以推断出来:<br><code><br>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)<br>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]<br><br>var sixDoubles = threeDoubles + anotherThreeDoubles<br>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]<br></code><br># 用字面量创建数组<br><br>你也可以用字面量来初始化数组, 这是种快速写一个或者多个数组值的方式。 一个数组字面量写作一列值, 用逗号分开, 一对方括号包括起来:<br><code><br>[value 1, value 2, value 3]<br></code><br>下面的的例子创建了一个购物列表来存储字符串值:<br><code><br>var shoppingList: [String] = [“Eggs”, “Milk”]<br>// shoppingList has been initialized with two initial items<br>/code&gt;<br>购物列表变量定义为 “字符串值的数组”, 写作 [String]. 因为这个数组已经指定一个字符串类型值, 它就值运行存储字符串值。 这里, 购物列表数组用两个字符串值 (“Eggs” 和 “Milk”)来初始化, 写在数字字面量里。<br><br>备注<br><br>这个数组被声明为一个变量而不是一个常量，是因为在下面的例子将有更多的项目加入这个购物列表。<br><br>这种情况, 数组字面量只包含两个字符串值。 这个匹配购物列表变量的声明类型 (只能包括字符串值的数组), 用数组字面量赋值来初始化购物列表是被允许的一种方式。<br><br>由于 Swift 的类型推断, 如果你用相同类型的字面量来初始化数组,就不需要写出数组的类型。购物列表的初始化可以简写成以下形式:<br><code><br>var shoppingList = [“Eggs”, “Milk”]<br></code><br>因为数组里所有的值都是同样的类型, Swift 能够推断出 [String] 用作购物列表变量是正确的类型。<br><br># 访问和修改数组<br><br>你可以通过数组的方法,属性或者下标语法来访问和修改一个数组。<br><br>为了确定数组的项数, 使用只读属性count:<br><code><br>print(“The shopping list contains (shoppingList.count) items.”)<br>// Prints “The shopping list contains 2 items.”<br></code><br>使用布尔属性 isEmpty 来判断数量属性是否0:<br><code><br>if shoppingList.isEmpty {<br>    print(“The shopping list is empty.”)<br>} else {<br>    print(“The shopping list is not empty.”)<br>}<br>// Prints “The shopping list is not empty.”<br></code><br>通过调用 append(<em>:) 方法你可以在数组最后添加新项:<br><code><br>shoppingList.append(“Flour”)<br>// shoppingList now contains 3 items, and someone is making pancakes<br></code><br>或者, 使用赋值运算 (+=) 添加一个或多个符合的项:<br><code><br>shoppingList += [“Baking Powder”]<br>// shoppingList now contains 4 items<br>shoppingList += [“Chocolate Spread”, “Cheese”, “Butter”]<br>// shoppingList 现在包含 7项<br></code><br>用下标语法从数组中获取一个值, 在数组后的方括号里传入你想得到值的索引:<br><code><br>var firstItem = shoppingList[0]<br>// firstItem is equal to “Eggs”<br></code><br>备注<br><br>数组第一项的索引是0,不是1。 Swift 数组总是基于0开始索引。<br><br>你可以使用下标语法去改变给定索引下的值:<br><code><br>shoppingList[0] = “Six eggs”<br>// 第一项现在是 “Six eggs” 而不是 “Eggs”<br></code><br>你还可以通过下标语法一次改变一个范围的值, 尽管取代值跟被取代的长度不同。 下面的例子用 “Bananas” 和 “Apples” 取代了 “Chocolate Spread”, “Cheese”, 和 “Butter”:<br><code><br>shoppingList[4…6] = [“Bananas”, “Apples”]<br>// shoppingList 现在包含 6项<br></code><br>备注<br><br>你不能用下标语法添加新的项到数组最后。<br><br>在特定位置插入新项, 调用数组插入方法 insert(</em>:at:):<br><code><br>shoppingList.insert(“Maple Syrup”, at: 0)<br>// shoppingList now contains 7 items<br>// “Maple Syrup” is now the first item in the list<br></code><br>调用 insert(<em>:at:) 方法在购物列表头插入一个新的项 “Maple Syrup”, 用索引0标明。<br><br>类似的, 移除一项使用 remove(at:) 方法。 这个方法移除指定索引的项然后返回这个移除项 (尽管你可能无视这个返回值):<br><code><br>let mapleSyrup = shoppingList.remove(at: 0)<br>// 位于索引0的项被移除<br>// 购物列表现在包含6项, 没有 Maple Syrup<br>// mapleSyrup 常量现在等于被移除的 “Maple Syrup” 字符串<br></code><br>备注<br><br>如果越界访问数组的值, 你会触发运行时错误。你可以用它跟数组个数属性对比来判断索引的有效性。除了个数为0的情况 (意味着数组是空的), 最大索引值通常是数组个数 - 1, 因为数组是从0开始计数的。<br><br>一个数据项被移除数组空隙就会闭合,所以索引 0 的值再次等于 “Six eggs”:<br><code><br>firstItem = shoppingList[0]<br>// firstItem 现在等于 “Six eggs”<br></code><br>如果你想移除最后一项, 使用 removeLast() 方法而不是 remove(at:) 方法,这样就避免需要查询数组的个数属性。和 remove(at:) 方法一样, removeLast() 返回移除的项:<br><code><br>let apples = shoppingList.removeLast()<br>// 最后一项被移除<br>// 购物列表现在包含5项, 没有苹果<br>// apples 常量现在等于被移除的 “Apples” 字符串<br></code><br># 遍历数组<br><br>你可以用for-in循环来遍历数组中的所有值集:<br><code><br>for item in shoppingList {<br>    print(item)<br>}<br>// Six eggs<br>// Milk<br>// Flour<br>// Baking Powder<br>// Bananas<br></code><br>如果需要数据项的值和整数索引, 使用 enumerated() 方法来遍历数组。对于数组中的每一项, enumerated() 方法返回一个包含索引和值的元组。 整数以0开始每项递增; 如果你遍历整个数组, 这些整数匹配数据项的索引。你可以分解元组到临时的常量或者变量,来作为迭代的部分:<br><code><br>for (index, value) in shoppingList.enumerated() {<br>    print(“Item (index + 1): (value)”)<br>}<br>// Item 1: Six eggs<br>// Item 2: Milk<br>// Item 3: Flour<br>// Item 4: Baking Powder<br>// Item 5: Bananas<br></code><br><br># 集合<br><br>集合无序存储同样类型的不同值。 如果排序不重要可以选择使用集合代替数组, 或者你需要确保每项只出现一次。<br><br>备注<br><br>Swift 的 Set 类型跟 Foundation 的 NSSet 类桥接。<br><br># 集合类型的哈希值<br><br>集合里一个类型为了存储就必须可哈希—就是说, 这个类型必须提供一个方式去计算自己的哈希值。 一个哈希值是一个整型值, 这对于相等的对象都是一样的, 如果 if a == b, 那么 a.hashValue == b.hashValue.<br><br>所有 Swift 的基本类型默认都是可哈希的 (比如 String, Int, Double, 和 Bool), 可以被用作集合值类型或者字典建类型。 枚举case 值没有相应的值默认也是可哈希的。<br><br>备注<br><br>你可以使用自定义类型作为集合值类型或者字典健类型,通过让它们遵守Swift 标准库中的 Hashable 协议。 符合协议的类型必须提供一个可获取的整形属性 hashValue. 在相同程序中的不同执行,或者在不同程序中, 类型的哈希属性返回的值不要求相同。<br><br>因为 Hashable 协议符合 Equatable, 符合类型必须提等号运算符 (==)的实现。 Equatable 协议要求任何符合==实现的都是一个相等关系。 就是说, ==  的实现必须满足下面的条件, 对于 a, b, 和 c 所有值:<br><br>a == a (自反性)<br><br>a == b 表示 b == a (对称性)<br><br>a == b &amp;&amp; b == c 表示 a == c (传递性)<br><br># 集合类型语法<br><br>集合类型写作 Set<element>, 这里 Element 是集合允许存储的类型。 跟数组不同, 集合没有等价的缩写形式。<br><br># 创建和初始化空集合<br><br>你可以通过使用初始化器语法创建特定类型的空集合:<br><code><br>var letters = Set<character>()<br>print(“letters is of type Set<character> with (letters.count) items.”)<br>// 打印 “letters is of type Set<character> with 0 items.”<br></character></character></character></code><br>备注<br><br>letters 变量的类型推断为 Set<character>, 通过初始化器的类型。<br><br>或者, 如果上下文已经提供了类型信息, 比如一个函数参数或者一个已经指定类型的变量和常量, 你可以用一个空的数组字面量来创建一个空集合:<br><code><br>letters.insert(“a”)<br>// letters 现在包含了一个字符类型的值<br>letters = []<br>// letters 现在是一个空集合, 但是依然是 Set<character> 类型<br></character></code><br># 用数组字面量创建集合<br><br>你可以用数组字面量初始化一个集合, 这是一个速写方式来给一个集合赋值。<br><br>下面的例子创建一个存储字符串值的集合 favoriteGenres:<br><code><br>var favoriteGenres: Set<string> = [“Rock”, “Classical”, “Hip hop”]<br>// favoriteGenres 有了三个初始值<br></string></code><br>favoriteGenres 变量声明成 “字符串值的集合”, 写作 Set<string>. 因为这个集合指定了一个字符串的值类型, 它只允许存储字符串值, favoriteGenres 集合用三个字符串 (“Rock”, “Classical”, 和 “Hip hop”)来初始化, 写在一个数组字面量里。<br><br>备注<br><br>favoriteGenres 集合声明成一个变量而不是一个常量, 这是因为添加和移除的项在下面的示例里。<br><br>集合通过数组字面量不能推断出类型, 所以类型必须显示声明。 不过, 由于Swift的类型推断, 如果数组字面量包含的值类型相同,你就不需要写集合的类型。favoriteGenres 初始化可以简写如下:<br><code><br>var favoriteGenres: Set = [“Rock”, “Classical”, “Hip hop”]<br></code><br>因为数组字面量里的值都是同样类型, Swift 可以推断 Set<string> 用作favoriteGenres 变量是正确的类型。<br><br># 访问和修改集合<br><br>你可以通过集合的方法和属性来访问和修改它。<br><br>为了得到集合的项数, 使用只读的 count 属性:<br><code><br>print(“I have (favoriteGenres.count) favorite music genres.”)<br>// 打印 “I have 3 favorite music genres.”<br></code><br>使用布尔属性 isEmpty 快速判断 count 属性是否等于 0:<br><code><br>if favoriteGenres.isEmpty {<br>    print(“As far as music goes, I’m not picky.”)<br>} else {<br>    print(“I have particular music preferences.”)<br>}<br>// 打印 “I have particular music preferences.”<br></code><br>调用集合的 insert(</string></string></character></element></em>:) 方法插入一个新项:<br><code><br>favoriteGenres.insert(“Jazz”)<br>// favoriteGenres 现在包含 4 项<br></code><br>你可以用集合的 remove(<em>:) 方法从集合里移除项, 如果它是集合一员的话, 然后返回被移除的项, 如果集合不包含这项就返回nil。 或者, 移除所有项可以用 removeAll() 方法。<br><code><br>if let removedGenre = favoriteGenres.remove(“Rock”) {<br>    print(“(removedGenre)? I’m over it.”)<br>} else {<br>    print(“I never much cared for that.”)<br>}<br>// 打印 “Rock? I’m over it.”<br></code><br>检查集合是否包含特定项, 用 contains(</em>:) 方法。<br><code><br>if favoriteGenres.contains(“Funk”) {<br>    print(“I get up on the good foot.”)<br>} else {<br>    print(“It’s too funky in here.”)<br>}<br>// 打印 “It’s too funky in here.”<br></code><br># 遍历集合<br><br>你可以用for-in循环遍历集合的值。<br><code><br>for genre in favoriteGenres {<br>    print(“(genre)”)<br>}<br>// Jazz<br>// Hip hop<br>// Classical<br></code><br><br>Swift 的集合类型是无序的。以特定顺序去遍历集合的值, 使用 sorted() 方法, 这个方法返回一个值数组,按照小于运算符排序。<br><code><br>for genre in favoriteGenres.sorted() {<br>    print(“(genre)”)<br>}<br>// Classical<br>// Hip hop<br>// Jazz<br></code><br># 集合操作<br><br>你可以有效进行基础的集合操作, 比如合并两个集合, 判断两个集合是否有共同值, 或者判读两个集合是否包含所有,几个,或者没有任何相同值。<br><br># 基本集合操作<br><br>下面的图描述了两个集合a 和 b, 共享区域表示集合操作结果。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png"><br></div><br>用 intersection(<em>:) 方法创建交集。<br>用 symmetricDifference(</em>:) 方法创建交集之外的集合。<br>用 union(<em>:) 方法创建并集。<br>用 subtracting(</em>:) 方法创建去掉指定集合的集合。<br><code><br>let oddDigits: Set = [1, 3, 5, 7, 9]<br>let evenDigits: Set = [0, 2, 4, 6, 8]<br>let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]<br><br>oddDigits.union(evenDigits).sorted()<br>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>oddDigits.intersection(evenDigits).sorted()<br>// []<br>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()<br>// [1, 9]<br>oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()<br>// [1, 2, 9]<br></code><br># 集合成语和等式<br><br>下面的图描述了三个集合 a, b 和 c, 重叠区域表示集合共享的元素。 集合a是集合b的超集, 因为a包含b的所有元素。 相反, 集合b是集合a的子集, 因为b中的元素都包含在集合a中。 集合b与集合c不相交, 因为它们没有共同的元素。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png"><br></div><br>用相等运算符 (==) 判断两个集合是否所有值都相同。<br>用 isSubset(of:) 方法判断一个集合是否是另外一个集合的字集。<br>用 isSuperset(of:) 方法判断一个集合是否是另外一个集合的超集。<br>用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法判断一个集合是否是一个子集或者超集, 但是不等于一个指定的集合。用 isDisjoint(with:) 方法判断是否两个集合不相交。<br><code><br>let houseAnimals: Set = [“🐶”, “🐱”]<br>let farmAnimals: Set = [“🐮”, “🐔”, “🐑”, “🐶”, “🐱”]<br>let cityAnimals: Set = [“🐦”, “🐭”]<br><br>houseAnimals.isSubset(of: farmAnimals)<br>// true<br>farmAnimals.isSuperset(of: houseAnimals)<br>// true<br>farmAnimals.isDisjoint(with: cityAnimals)<br>// true<br></code><br># 字典<br><br>字典无序存储匹配的同类型的健值。每个值对应一个唯一的健, 它作为值在字典里的标识符。 跟数组项不同, 字典里的项是无序的。如果基于标识符查找值你可以用字典, 很像真实世界字典的用法。<br><br># 字典类型速记语法<br><br>Swift 字典类型完整写法是 Dictionary<key, value="">, Key 是可以用作字典值的值类型, Value 是字典为健存储的值类型。<br><br>备注<br><br>字典 Key 类型一定要符合 Hashable 协议, 跟集合值类型一样。<br><br>你也可以字典类型的简写形式 [Key: Value]. 尽管两个形式功能一样, 简写形式优先使用并贯穿整个教程。<br><br># 创建一个空字典<br><br>跟数组一样, 你可用用初始化语法创建一个特定类型的字典:<br><code><br>var namesOfIntegers = <a href="">Int: String</a><br>// namesOfIntegers is an empty [Int: String] dictionary<br></code><br>这个例子定义了一个空字典,类型是 [Int: String],用来存储人类可读的整数名字。健是整形, 值是字符串类型。<br><br>如果上下文已经提供了类型信息, 你可以用一个空的字典字面量来创建一个空字典, 写作 [:] (一对中括号中间一个冒号):<br><code><br>namesOfIntegers[16] = “sixteen”<br>// namesOfIntegers 现在包含 1 key-value pair<br>namesOfIntegers = [:]<br>// namesOfIntegers 再次成为空,类型是[Int: String]<br></code><br># 用字面量创建字典<br><br>你还可以用字面量来初始化一个字典, 跟早前数组字面量语法相似。字典字面量是定义一个或者多个键值对集合的速写方法。<br><br>键值对是健和值的组合。 在一个字典字面量里, 健和值在键值对里用冒号分开。 键值对写作一个列表, 用逗号分开, 包含在一对中括号里:<br><code><br>[key 1: value 1, key 2: value 2, key 3: value 3]<br></code><br>下面的例子创建一个字典来存储国际机场名字。在这个字典里, 健是三个字母的国际航空公司编码, 值是机场名:<br><code><br>var airports: [String: String] = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br></code><br>airports 字典类型是 [String: String], 意思是 “一个字典健值都是字符串类型”.<br><br>备注<br><br>airports 字典声明成一个变量而非常量, 因为下面的例子需要添加更多机场进去。<br><br>airports 用两个键值对字面量初始化。第一个键值对有一个健 “YYZ” 和一个值 “Toronto Pearson”. 第二个键值对有一个健 “DUB” 和一个值”Dublin”.<br><br>字面量包含两个 String: String 对。 简直类型匹配机场类型的变量声明 (一个字典只有字符串健和字符串值), 所以字面量赋值是允许的,可以用来初始化机场字典。<br><br>跟数组一样, 如果你用相同类型的键值字典初始化，你就不需要写出字典的声明类型。初始化方法可以简写如下:<br><code><br>var airports = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br></code><br>因为字面量的所有健类型都是一样的, 同样所有的值也是, Swift 可以推断出来 [String: String] 是正确的类型声明。<br><br># 访问和修改字典<br><br>你可以通过字典的方法和属性来访问和修改它, 或者使用下标语法。<br><br>跟数组一样, 使用count 属性获取字典的项数:<br><code><br>print(“The airports dictionary contains (airports.count) items.”)<br>// 打印 “The airports dictionary contains 2 items.”<br></code><br>用 isEmpty 属性判断count 属性是否等于 0:<br><code><br>if airports.isEmpty {<br>    print(“The airports dictionary is empty.”)<br>} else {<br>    print(“The airports dictionary is not empty.”)<br>}<br>// 打印 “The airports dictionary is not empty.”<br></code><br>你可以用下标语法往字典添加新项。 使用对应的类型的键作为下标索引, 并赋一个对应的新值:<br><code><br>airports[“LHR”] = “London”<br>// airports 现在包含 3 项<br></code><br>你可以用下标语法改变指定键对应的值:<br><code><br>airports[“LHR”] = “London Heathrow”<br>// “LHR” 的值已经变成”London Heathrow”<br></code><br>作为下标的替代方案, 用字典的 updateValue(<em>:forKey:) 方法设置或者更新指定键的值。 跟上面下标实例一样,  updateValue(</em>:forKey:) 方法在键不存在时设置值, 如果键存在则进行更新。和下标不像的是, updateValue(<em>:forKey:) 方法在执行更新后返回老的值。 这个可以让你知道更新是否生效。<br><br>updateValue(</em>:forKey:) 方法返回可选类型的值。对个存储字符串值的字典来说, 比如, 这个方法返回 String?, 或者 “optional String”. 可选值包括未更新前存在的键对应的老值, 如果值不存在则包括nil:<br><code><br>if let oldValue = airports.updateValue(“Dublin Airport”, forKey: “DUB”) {<br>    print(“The old value for DUB was (oldValue).”)<br>}<br>// 打印 “The old value for DUB was Dublin.”<br></code><br>你可以用下标语法获取特定键对应的值。因为有可能去请求不存在值的键, 字典的下标就会返回一个可选值。 如果字典包含请求键对应的值, 下标就返回一个可选值，这个值包含这个键对应的存在的值。否则返回 nil:<br><code><br>if let airportName = airports[“DUB”] {<br>    print(“The name of the airport is (airportName).”)<br>} else {<br>    print(“That airport is not in the airports dictionary.”)<br>}<br>// 打印 “The name of the airport is Dublin Airport.”<br></code><br>你可以通过把键对应的值赋空的方式,用下标语法从字典移除一个键值对:<br><code><br>airports[“APL”] = “Apple International”<br>// “Apple International” is not the real airport for APL, so delete it<br>airports[“APL”] = nil<br>// APL 现在已经从字典移除<br></code><br>或者, 用 removeValue(forKey:) 这个方法来移除。 这个方法移除的键值对如果存在返回被移除的值,否则返回nil:<br><code><br>if let removedValue = airports.removeValue(forKey: “DUB”) {<br>    print(“The removed airport’s name is (removedValue).”)<br>} else {<br>    print(“The airports dictionary does not contain a value for DUB.”)<br>}<br>// Prints “The removed airport’s name is Dublin Airport.”<br></code><br># 遍历字典<br><br>你用for-in 循环来遍历字典。 字典中的每一项都以 (key, value) 元组形式返回, 你可以分解元组到临时的变量或者常量:<br><code><br>for (airportCode, airportName) in airports {<br>    print(“(airportCode): (airportName)”)<br>}<br>// YYZ: Toronto Pearson<br>// LHR: London Heathrow<br></code><br><br>你可以通过访问字典的键值属性来获取键值的集合:<br><code><br>for airportCode in airports.keys {<br>    print(“Airport code: (airportCode)”)<br>}<br>// Airport code: YYZ<br>// Airport code: LHR<br>for airportName in airports.values {<br>    print(“Airport name: (airportName)”)<br>}<br>// Airport name: Toronto Pearson<br>// Airport name: London Heathrow<br></code><br>如果你想使用字典的键值的数组实例, 用键值来初始化一个新的数组:<br><code><br>let airportCodes = <a href="airports.keys">String</a><br>// airportCodes is [“YYZ”, “LHR”]<br><br>let airportNames = <a href="airports.values">String</a><br>// airportNames 是 [“Toronto Pearson”, “London Heathrow”]<br></code><br>Swift的字典类型无序的。 为了用特定顺序去遍历字典的键值, 用这个 sorted() 方法。<br><br># 控制流<br>Swift 提供了一系列控制流语句。 包括 while 循环来执行多次任务; if, guard, 金额 switch 语句来再不同条件这些不同代码; 还有 break 和 continue 来转移控制流。<br><br>Swift 同时提供了 for-in 循环使得遍历数组, 字典, 范围, 字符串, 和其他序列变得容易。<br><br>Swift的 switch 语句比多数类C语言相同语句更加高效有力。 因为Swift 的 switch 语句的分支不会落到下一分支, 这就避免了C常见的错误。 分支可以匹配不同的模式, 包括区间匹配, 元组, 转换成指定类型。 switch 分支匹配的值可以绑定到临时的变量或者常量。每个分支可以用where 族来表达符合匹配条件。<br><br># For-In 循环<br><br>你使用 for-in 循环来遍历序列, 比如数值范围, 数组中的项, 字符串中的字符。<br><br>下面的例子是五倍乘法表的前几个条目:<br><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index <em> 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br></em></code><br>遍历的序列是1 到 5的数值范围, 包括1和5,使用闭合区间运算符 (…)提到过。索引值设置给 range (1)的第一个数, 然后循环体中的语句就会执行。 这种情况, 循环体只有一个语句, 打印当前索引值5的倍数。 这个语句执行后, 索引值更新为包含在 range (2) 中的第二个值, print(<em>:separator:terminator:) 函数再次调用。 这个过程直到区间结束。<br><br>上面的例子, 索引值是常量而且自动设置。 像这样, 索引在使用前不必声明。 在循环声明中隐式声明, 不需要let关键字。<br><br>如果你不需要序列中的所有值, 可以在变量名位置处使用下划线来忽略这个值。<br><code><br>let base = 3<br>let power = 10<br>var answer = 1<br>for </code></em> in 1…power {<br>    answer = base<br>}<br>print(“(base) to the power of (power) is (answer)”)<br>// 打印 “3 to the power of 10 is 59049”<br></key,></code><br>上面的例子计算一个数的幂(这个例子里, 3 的10次幂)。 它乘以一个初始值 1 (就是 3 的0次幂), 十次, 使用一个闭合区间,1开始10结束。下划线用在这里,使得单个值被忽略同时不会在遍历过程中访问当前值。<br><br>使用 for-in 循环来遍历数组的项。<br><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>for name in names {<br>    print(“Hello, (name)!”)<br>}<br>// Hello, Anna!<br>// Hello, Alex!<br>// Hello, Brian!<br>// Hello, Jack!<br></code><br>你还可以遍历一个字典来遍历它的键值对。 字典遍历时每次返回一个 (key, value) 元组, 你可以在for-in循环中显示分解元组的值给常量赋值。这里, 字典的键分解给animalName 常量, 字典的值分配给了 legCount 常量。<br><code><br>let numberOfLegs = [“spider”: 8, “ant”: 6, “cat”: 4]<br>for (animalName, legCount) in numberOfLegs {<br>    print(“(animalName)s have (legCount) legs”)<br>}<br>// ants have 6 legs<br>// spiders have 8 legs<br>// cats have 4 legs<br></code><br>字典项遍历的顺序不需要和插入顺序一致。 字典内容是无序的, 遍历时不能保证获取的顺序。<br><br># While 循环<br><br>while 循环执行一组语句,直到条件失败。 首次遍历前,遍历次数不知道的时候使用这种方式是最好的。Swift 提供两种 while 循环:<br><br>while 每次循环前评估条件。<br>repeat-while 每次循环后评估条件。<br># While<br><br>while 循环从评估条件开始。 如果条件是真的, 一组语句会重复执行直到条件变成假的。<br><br>这是while 循环的基本形式:<br><code><br>while condition {<br>    statements<br>}<br></code><br>这个例子是个蛇与梯子的游戏:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png"><br></div><br>游戏规则如下:<br><br>棋盘有25个方格, 目标是占据或者超过25。<br>每次, 摇一个6边的骰子然后移动对应数目方格, 沿着上图的点箭头的水平路径移动。<br>如果位于梯子底部, 往梯子上方移动。<br>如果位于蛇头, 往蛇下方移动。<br>游戏棋盘用整形值数组表示。大小基于 finalSquare 常量, 用来初始化数组并且判断取胜的条件。 棋盘用26个0值初始化, 而不是25 (每个索引从0到25)。<br><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br></code><br>一些方格会为蛇和梯子设置更多的指定值。梯子方格是正数,蛇方格是负数。<br><code><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br></code><br>方格 3 包含了梯子的底部,可以爬到方格11。 为了表示这个, board[03] 等于 +08, 这等于整数值8 (3和11的差值) 加号 (+i) 和减号 (-i)相等, 数值低于10的用0填充,这样所以棋盘都被定义了。<br><br>玩家开始方格是 “方格0”, 靠着棋盘的左下角。 第一次摇骰子总是让玩家进入棋盘。<br><code><br>var square = 0<br>var diceRoll = 0<br>while square &lt; finalSquare {<br>    // roll the dice<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // move by the rolled amount<br>    square += diceRoll<br>    if square &lt; board.count {<br>        // if we’re still on the board, move up or down for a snake or a ladder<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br></code><br>上面的例子用了一个很简单方法去摇骰子。 不用随机数, 用一初始值为0的 diceRoll。 每次循环, diceRoll 加一然后判断它是否过大。 当返回值等于7, 骰子值过大然后重置为1。diceRoll 值总是 1, 2, 3, 4, 5, 6, 1, 2 然后不停循环。<br><br>摇完筛子, 往前移动 diceRoll 方格。 如果移动超过25, 游戏结束。考虑边界安全，在操作方格的时候。<br><br>备注<br><br>没有这个判断, board[square] 可能会越界访问棋盘数组的值, 这会触发一个错误。 如果方格等于 26, 代码会判断board[26] 的值, 这会超过数组的大小。<br><br>当前while 循环执行然后结束, 然后循环的条件会被判断是否再次执行。如果玩家已经移动或者超过25, 循环的条件变成假然后游戏就结束。<br><br>while 循环适合这个例子, 因为开始循环的时候游戏的长度并不清楚。 相反, 一个特定条件满足后循环被执行了。<br><br># Repeat-While<br><br>另外一种while循环的变种, 就是 repeat-while 循环, 先执行一次循环, 然后再考虑循环的条件。 然后继续执行直到条件变成假。<br><br>备注<br><br>Swift 里的 repeat-while 循环类似其他语言里的 do-while 循环。<br><br>这里是 repeat-while 循环的基本样式:<br><code><br>repeat {<br>    statements<br>} while condition<br></code><br>这里还是蛇与梯子的例子, 用 repeat-while 循环来写而不是 while 循环。 finalSquare, board, square, 和 diceRoll的值初始化方式跟while循环一样。<br><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br></code><br>这个游戏版本, 第一步是判断梯子和蛇。 没有梯子带着玩家直接去方格25, 因为不太可能通过爬梯子去赢得游戏。因此, 判断有没有蛇和梯子是很安全的。<br><br>游戏开始, 玩家在 “square zero”. board[0] 总是等于0没有影响。<br><code><br>repeat {<br>    // move up or down for a snake or ladder<br>    square += board[square]<br>    // roll the dice<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // move by the rolled amount<br>    square += diceRoll<br>} while square &lt; finalSquare<br>print(“Game over!”)<br></code><br>蛇与梯子判断后, 摇动筛子玩家往前移动 diceRoll 方格。 当前循环执行然后结束。<br><br>循环条件 (while square &lt; finalSquare) 和以前一样, 不过这次开始不评估,直到第一次循环结束才评估。repeat-while 循环比 while loop 循环更适合这个游戏。上面的 repeat-while 循环, 当条件确认方格还在棋盘上后, square += board[square] 总是立即执行。 这就不需要像之前那样判断数组边界。<br><br># 条件语句<br><br>基于特定条件执行不同代码片段经常用到。 在碰到错误时你可能想运行额外的代码片段, 或者在数值变得太高或者太低的时候也是。为了做这件事, 你让部分代码带有条件性。<br><br>Swift 提供两种方式给你的代码添加条件分支: if 语句和 switch 语句。你用 if 语句评估条件会有一些可能的结果。 switch 语句在比较复杂的多个排列时很有用, 在模式匹配可以帮助选择合适代码分支执行的情况也是。<br><br># If<br><br>最简单的形式, if 语句有一个单一条件。 条件为真执行一个语句集合。<br><code><br>var temperatureInFahrenheit = 30<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>}<br>// 打印 “It’s very cold. Consider wearing a scarf.”<br></code><br>上面的例子判断文档是否小于等于华氏32度 (冰点)。 如果是, 打印一条信息。 否则, 不打印消息, 代码在大括号后继续执行。<br><br>if 语句还可以提供一个替代语句集合, 就是 else 字句, 针对条件是假的情况。 这些语句用else 关键字表示。<br><code><br>temperatureInFahrenheit = 40<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 打印 “It’s not that cold. Wear a t-shirt.”<br></code><br>两个分支之一总会执行。 因为温度已经增长到华氏40度, 这不够冷到戴围巾,因此else分支被触发了。<br><br>你可以链接多个if语句来考虑额外的语句。<br><code><br>temperatureInFahrenheit = 90<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 打印 “It’s really warm. Don’t forget to wear sunscreen.”<br></code><br>在这个库, 额外的if语句用来响应特别温暖的温度。 最后的else语句保留, 它响应既不太热也不太冷的情况。<br><br>最后的else语句是可选的, 不过, 如果不需要执行可以去掉。<br><code><br>temperatureInFahrenheit = 72<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>}<br></code><br>因为这个温度既不太冷也不太热,所以不会触发if或者else语句,没有打印信息。<br><br># Switch<br><br>switch 语句设想一个值,然后跟一些可能的匹配模式比较。然后执行合适的代码, 基于第一次匹配成功。switch 语句提供了if语句的替代方法来响应多种潜在状态的情况。<br><br>最简单的形式, 一个 switch 语句用一个值跟一个或者多个同类型的值相比较。<br><code><br>switch some value to consider {<br>case value 1:<br>    respond to value 1<br>case value 2,<br>     value 3:<br>    respond to value 2 or 3<br>default:<br>    otherwise, do something else<br>}<br></code><br>每个 switch 语句由多个case分支组成, 每个分支以case 关键字开始。 除了跟指定值比较外, Swift 为case分支提供了指定更复杂匹配模式的方法。这些选项本章后面会描述。<br><br>Like the body of an if statement, each case is a separate branch of code execution. The switch statement determines which branch should be selected. This procedure is known as switching on the value that is being considered.<br><br>Every switch statement must be exhaustive. That is, every possible value of the type being considered must be matched by one of the switch cases. If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly. This default case is indicated by the default keyword, and must always appear last.<br><br>This example uses a switch statement to consider a single lowercase character called someCharacter:<br><br>let someCharacter: Character = “z”<br>switch someCharacter {<br>case “a”:<br>    print(“The first letter of the alphabet”)<br>case “z”:<br>    print(“The last letter of the alphabet”)<br>default:<br>    print(“Some other character”)<br>}<br>// Prints “The last letter of the alphabet”<br>The switch statement’s first case matches the first letter of the English alphabet, a, and its second case matches the last letter, z. Because the switch must have a case for every possible character, not just every alphabetic character, this switch statement uses a default case to match all characters other than a and z. This provision ensures that the switch statement is exhaustive.<br><br>No Implicit Fallthrough<br><br>In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake.<br><br>NOTE<br><br>Although break is not required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution. For details, see Break in a Switch Statement.<br><br>The body of each case must contain at least one executable statement. It is not valid to write the following code, because the first case is empty:<br><br>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”: // Invalid, the case has an empty body<br>case “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// This will report a compile-time error.<br>Unlike a switch statement in C, this switch statement does not match both “a” and “A”. Rather, it reports a compile-time error that case “a”: does not contain any executable statements. This approach avoids accidental fallthrough from one case to another and makes for safer code that is clearer in its intent.<br><br>To make a switch with a single case that matches both “a” and “A”, combine the two values into a compound case, separating the values with commas.<br><br>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”, “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// Prints “The letter A”<br>For readability, a compound case can also be written over multiple lines. For more information about compound cases, see Compound Cases.<br><br>NOTE<br><br>To explicitly fall through at the end of a particular switch case, use the fallthrough keyword, as described in Fallthrough.<br><br>Interval Matching<br><br>Values in switch cases can be checked for their inclusion in an interval. This example uses number intervals to provide a natural-language count for numbers of any size:<br><br>let approximateCount = 62<br>let countedThings = “moons orbiting Saturn”<br>var naturalCount: String<br>switch approximateCount {<br>case 0:<br>    naturalCount = “no”<br>case 1..<5: 12="" naturalcount="a few" case="" 5..<12:="" 12..<100:="" 100..<1000:="" default:="" }="" print("there="" are="" \(naturalcount)="" \(countedthings).")="" prints="" "there="" dozens="" of="" moons="" orbiting="" saturn."="" in="" the="" above="" example,="" approximatecount="" is="" evaluated="" a="" switch="" statement.="" each="" compares="" that="" value="" to="" number="" or="" interval.="" because="" falls="" between="" and="" 100,="" assigned="" "dozens="" of",="" execution="" transferred="" out="" tuples="" you="" can="" use="" test="" multiple values="" same="" element="" tuple="" be="" tested="" against="" different="" interval="" values.="" alternatively,="" underscore="" character="" (_),="" also="" known="" as="" wildcard="" pattern,="" match="" any="" possible="" value.="" example="" below="" takes="" an="" (x,="" y)="" point,="" expressed="" simple="" type="" (int,="" int),="" categorizes="" it="" on="" graph="" follows="" example.="" let="" somepoint="(1," 1)="" {="" (0,="" 0):="" print("(0,="" 0)="" at="" origin")="" (_,="" print("(\(somepoint.0),="" x-axis")="" _):="" \(somepoint.1))="" y-axis")="" (-2...2,="" -2...2):="" inside="" box")="" outside="" "(1,="" box"="" <div="" style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png"><br><br>The switch statement determines whether the point is at the origin (0, 0), on the red x-axis, on the orange y-axis, inside the blue 4-by-4 box centered on the origin, or outside of the box.<br><br>Unlike C, Swift allows multiple switch cases to consider the same value or values. In fact, the point (0, 0) could match all four of the cases in this example. However, if multiple matches are possible, the first matching case is always used. The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored.<br><br>Value Bindings<br><br>A switch case can bind the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body.<br><br>The example below takes an (x, y) point, expressed as a tuple of type (Int, Int), and categorizes it on the graph that follows:<br><br>let anotherPoint = (2, 0)<br>switch anotherPoint {<br>case (let x, 0):<br>    print(“on the x-axis with an x value of (x)”)<br>case (0, let y):<br>    print(“on the y-axis with a y value of (y)”)<br>case let (x, y):<br>    print(“somewhere else at ((x), (y))”)<br>}<br>// Prints “on the x-axis with an x value of 2”<br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png"><br></div><br>The switch statement determines whether the point is on the red x-axis, on the orange y-axis, or elsewhere (on neither axis).<br><br>The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint. The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x. Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y.<br><br>After the temporary constants are declared, they can be used within the case’s code block. Here, they are used to print the categorization of the point.<br><br>This switch statement does not have a default case. The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value. Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case is not needed to make the switch statement exhaustive.<br><br>Where<br><br>A switch case can use a where clause to check for additional conditions.<br><br>The example below categorizes an (x, y) point on the following graph:<br><br>let yetAnotherPoint = (1, -1)<br>switch yetAnotherPoint {<br>case let (x, y) where x == y:<br>    print(“((x), (y)) is on the line x == y”)<br>case let (x, y) where x == -y:<br>    print(“((x), (y)) is on the line x == -y”)<br>case let (x, y):<br>    print(“((x), (y)) is just some arbitrary point”)<br>}<br>// Prints “(1, -1) is on the line x == -y”<br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png"><br></div><br>The switch statement determines whether the point is on the green diagonal line where x == y, on the purple diagonal line where x == -y, or neither.<br><br>The three switch cases declare placeholder constants x and y, which temporarily take on the two tuple values from yetAnotherPoint. These constants are used as part of a where clause, to create a dynamic filter. The switch case matches the current value of point only if the where clause’s condition evaluates to true for that value.<br><br>As in the previous example, the final case matches all possible remaining values, and so a default case is not needed to make the switch statement exhaustive.<br><br>Compound Cases<br><br>Multiple switch cases that share the same body can be combined by writing several patterns after case, with a comma between each of the patterns. If any of the patterns match, then the case is considered to match. The patterns can be written over multiple lines if the list is long. For example:<br><br>let someCharacter: Character = “e”<br>switch someCharacter {<br>case “a”, “e”, “i”, “o”, “u”:<br>    print(“(someCharacter) is a vowel”)<br>case “b”, “c”, “d”, “f”, “g”, “h”, “j”, “k”, “l”, “m”,<br>     “n”, “p”, “q”, “r”, “s”, “t”, “v”, “w”, “x”, “y”, “z”:<br>    print(“(someCharacter) is a consonant”)<br>default:<br>    print(“(someCharacter) is not a vowel or a consonant”)<br>}<br>// Prints “e is a vowel”<br>The switch statement’s first case matches all five lowercase vowels in the English language. Similarly, its second case matches all lowercase English consonants. Finally, the default case matches any other character.<br><br>Compound cases can also include value bindings. All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case. This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type.<br><br>let stillAnotherPoint = (9, 0)<br>switch stillAnotherPoint {<br>case (let distance, 0), (0, let distance):<br>    print(“On an axis, (distance) from the origin”)<br>default:<br>    print(“Not on an axis”)<br>}<br>// Prints “On an axis, 9 from the origin”<br>The case above has two patterns: (let distance, 0) matches points on the x-axis and (0, let distance) matches points on the y-axis. Both patterns include a binding for distance and distance is an integer in both patterns—which means that the code in the body of the case can always access a value for distance.<br><br>Control Transfer Statements<br><br>Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements:<br><br>continue<br>break<br>fallthrough<br>return<br>throw<br>The continue, break, and fallthrough statements are described below. The return statement is described in Functions, and the throw statement is described in Propagating Errors Using Throwing Functions.<br><br>Continue<br><br>The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.<br><br>The following example removes all vowels and spaces from a lowercase string to create a cryptic puzzle phrase:<br><br>let puzzleInput = “great minds think alike”<br>var puzzleOutput = “”<br>let charactersToRemove: [Character] = [“a”, “e”, “i”, “o”, “u”, “ “]<br>for character in puzzleInput.characters {<br>    if charactersToRemove.contains(character) {<br>        continue<br>    } else {<br>        puzzleOutput.append(character)<br>    }<br>}<br>print(puzzleOutput)<br>// Prints “grtmndsthnklk”<br>The code above calls the continue keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration.<br><br>Break<br><br>The break statement ends execution of an entire control flow statement immediately. The break statement can be used inside a switch statement or loop statement when you want to terminate the execution of the switch or loop statement earlier than would otherwise be the case.<br><br>Break in a Loop Statement<br><br>When used inside a loop statement, break ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (}). No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.<br><br>Break in a Switch Statement<br><br>When used inside a switch statement, break causes the switch statement to end its execution immediately and to transfer control to the code after the switch statement’s closing brace (}).<br><br>This behavior can be used to match and ignore one or more cases in a switch statement. Because Swift’s switch statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit. You do this by writing the break statement as the entire body of the case you want to ignore. When that case is matched by the switch statement, the break statement inside the case ends the switch statement’s execution immediately.<br><br>NOTE<br><br>A switch case that contains only a comment is reported as a compile-time error. Comments are not statements and do not cause a switch case to be ignored. Always use a break statement to ignore a switch case.<br><br>The following example switches on a Character value and determines whether it represents a number symbol in one of four languages. For brevity, multiple values are covered in a single switch case.<br><br>let numberSymbol: Character = “三”  // Chinese symbol for the number 3<br>var possibleIntegerValue: Int?<br>switch numberSymbol {<br>case “1”, “١”, “一”, “๑”:<br>    possibleIntegerValue = 1<br>case “2”, “٢”, “二”, “๒”:<br>    possibleIntegerValue = 2<br>case “3”, “٣”, “三”, “๓”:<br>    possibleIntegerValue = 3<br>case “4”, “٤”, “四”, “๔”:<br>    possibleIntegerValue = 4<br>default:<br>    break<br>}<br>if let integerValue = possibleIntegerValue {<br>    print(“The integer value of (numberSymbol) is (integerValue).”)<br>} else {<br>    print(“An integer value could not be found for (numberSymbol).”)<br>}<br>// Prints “The integer value of 三 is 3.”<br>This example checks numberSymbol to determine whether it is a Latin, Arabic, Chinese, or Thai symbol for the numbers 1 to 4. If a match is found, one of the switch statement’s cases sets an optional Int? variable called possibleIntegerValue to an appropriate integer value.<br><br>After the switch statement completes its execution, the example uses optional binding to determine whether a value was found. The possibleIntegerValue variable has an implicit initial value of nil by virtue of being an optional type, and so the optional binding will succeed only if possibleIntegerValue was set to an actual value by one of the switch statement’s first four cases.<br><br>Because it’s not practical to list every possible Character value in the example above, a default case handles any characters that are not matched. This default case does not need to perform any action, and so it is written with a single break statement as its body. As soon as the default case is matched, the break statement ends the switch statement’s execution, and code execution continues from the if let statement.<br><br>Fallthrough<br><br>Switch statements in Swift don’t fall through the bottom of each case and into the next one. Instead, the entire switch statement completes its execution as soon as the first matching case is completed. By contrast, C requires you to insert an explicit break statement at the end of every switch case to prevent fallthrough. Avoiding default fallthrough means that Swift switch statements are much more concise and predictable than their counterparts in C, and thus they avoid executing multiple switch cases by mistake.<br><br>If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the fallthrough keyword. The example below uses fallthrough to create a textual description of a number.<br><br>let integerToDescribe = 5<br>var description = “The number (integerToDescribe) is”<br>switch integerToDescribe {<br>case 2, 3, 5, 7, 11, 13, 17, 19:<br>    description += “ a prime number, and also”<br>    fallthrough<br>default:<br>    description += “ an integer.”<br>}<br>print(description)<br>// Prints “The number 5 is a prime number, and also an integer.”<br>This example declares a new String variable called description and assigns it an initial value. The function then considers the value of integerToDescribe using a switch statement. If the value of integerToDescribe is one of the prime numbers in the list, the function appends text to the end of description, to note that the number is prime. It then uses the fallthrough keyword to “fall into” the default case as well. The default case adds some extra text to the end of the description, and the switch statement is complete.<br><br>Unless the value of integerToDescribe is in the list of known prime numbers, it is not matched by the first switch case at all. Because there are no other specific cases, integerToDescribe is matched by the default case.<br><br>After the switch statement has finished executing, the number’s description is printed using the print(_:separator:terminator:) function. In this example, the number 5 is correctly identified as a prime number.<br><br>NOTE<br><br>The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.<br><br>Labeled Statements<br><br>In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures. However, loops and conditional statements can both use the break statement to end their execution prematurely. Therefore, it is sometimes useful to be explicit about which loop or conditional statement you want a break statement to terminate. Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the continue statement should affect.<br><br>To achieve these aims, you can mark a loop statement or conditional statement with a statement label. With a conditional statement, you can use a statement label with the break statement to end the execution of the labeled statement. With a loop statement, you can use a statement label with the break or continue statement to end or continue the execution of the labeled statement.<br><br>A labeled statement is indicated by placing a label on the same line as the statement’s introducer keyword, followed by a colon. Here’s an example of this syntax for a while loop, although the principle is the same for all loops and switch statements:<br><br>label name: while condition {<br>    statements<br>}<br>The following example uses the break and continue statements with a labeled while loop for an adapted version of the Snakes and Ladders game that you saw earlier in this chapter. This time around, the game has an extra rule:<br><br>To win, you must land exactly on square 25.<br>If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.<br><br>The game board is the same as before.<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png"><br></div>

<p>The values of finalSquare, board, square, and diceRoll are initialized in the same way as before:</p>
<p>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br>This version of the game uses a while loop and a switch statement to implement the game’s logic. The while loop has a statement label called gameLoop to indicate that it is the main game loop for the Snakes and Ladders game.</p>
<p>The while loop’s condition is while square != finalSquare, to reflect that you must land exactly on square 25.</p>
<p>gameLoop: while square != finalSquare {<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    switch square + diceRoll {<br>    case finalSquare:<br>        // diceRoll will move us to the final square, so the game is over<br>        break gameLoop<br>    case let newSquare where newSquare &gt; finalSquare:<br>        // diceRoll will move us beyond the final square, so roll again<br>        continue gameLoop<br>    default:<br>        // this is a valid move, so find out its effect<br>        square += diceRoll<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br>The dice is rolled at the start of each loop. Rather than moving the player immediately, the loop uses a switch statement to consider the result of the move and to determine whether the move is allowed:</p>
<p>If the dice roll will move the player onto the final square, the game is over. The break gameLoop statement transfers control to the first line of code outside of the while loop, which ends the game.<br>If the dice roll will move the player beyond the final square, the move is invalid and the player needs to roll again. The continue gameLoop statement ends the current while loop iteration and begins the next iteration of the loop.<br>In all other cases, the dice roll is a valid move. The player moves forward by diceRoll squares, and the game logic checks for any snakes and ladders. The loop then ends, and control returns to the while condition to decide whether another turn is required.<br>NOTE</p>
<p>If the break statement above did not use the gameLoop label, it would break out of the switch statement, not the while statement. Using the gameLoop label makes it clear which control statement should be terminated.</p>
<p>It is not strictly necessary to use the gameLoop label when calling continue gameLoop to jump to the next iteration of the loop. There is only one loop in the game, and therefore no ambiguity as to which loop the continue statement will affect. However, there is no harm in using the gameLoop label with the continue statement. Doing so is consistent with the label’s use alongside the break statement and helps make the game’s logic clearer to read and understand.</p>
<p>Early Exit</p>
<p>A guard statement, like an if statement, executes statements depending on the Boolean value of an expression. You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed. Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition is not true.</p>
<p>func greet(person: [String: String]) {<br>    guard let name = person[“name”] else {<br>        return<br>    }</p>
<pre><code>print(&quot;Hello \(name)!&quot;)

guard let location = person[&quot;location&quot;] else {
    print(&quot;I hope the weather is nice near you.&quot;)
    return
}

print(&quot;I hope the weather is nice in \(location).&quot;)
</code></pre><p>}</p>
<p>greet(person: [“name”: “John”])<br>// Prints “Hello John!”<br>// Prints “I hope the weather is nice near you.”<br>greet(person: [“name”: “Jane”, “location”: “Cupertino”])<br>// Prints “Hello Jane!”<br>// Prints “I hope the weather is nice in Cupertino.”<br>If the guard statement’s condition is met, code execution continues after the guard statement’s closing brace. Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the guard statement appears in.</p>
<p>If that condition is not met, the code inside the else branch is executed. That branch must transfer control to exit the code block in which the guard statement appears. It can do this with a control transfer statement such as return, break, continue, or throw, or it can call a function or method that doesn’t return, such as fatalError(_:file:line:).</p>
<p>Using a guard statement for requirements improves the readability of your code, compared to doing the same check with an if statement. It lets you write the code that’s typically executed without wrapping it in an else block, and it lets you keep the code that handles a violated requirement next to the requirement.</p>
<p>Checking API Availability</p>
<p>Swift has built-in support for checking API availability, which ensures that you don’t accidentally use APIs that are unavailable on a given deployment target.</p>
<p>The compiler uses availability information in the SDK to verify that all of the APIs used in your code are available on the deployment target specified by your project. Swift reports an error at compile time if you try to use an API that isn’t available.</p>
<p>You use an availability condition in an if or guard statement to conditionally execute a block of code, depending on whether the APIs you want to use are available at runtime. The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.</p>
<p>if #available(iOS 10, macOS 10.12, <em>) {<br>    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS<br>} else {<br>    // Fall back to earlier iOS and macOS APIs<br>}<br>The availability condition above specifies that on iOS, the body of the if executes only on iOS 10 and later; on macOS, only on macOS 10.12 and later. The last argument, </em>, is required and specifies that on any other platform, the body of the if executes on the minimum deployment target specified by your target.</p>
<p>In its general form, the availability condition takes a list of platform names and versions. You use platform names such as iOS, macOS, watchOS, and tvOS—for the full list, see Declaration Attributes. In addition to specifying major version numbers like iOS 8, you can specify minor versions numbers like iOS 8.3 and macOS 10.10.3.</p>
<p>if #available(platform name version, …, *) {<br>    statements to execute if the APIs are available<br>} else {<br>    fallback statements to execute if the APIs are unavailable<br>}</p>
</5:></element>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/09/21/熙健-掌上心电获千万元A轮融资/"  title="熙健-掌上心电获千万元A轮融资">
 <strong>下一篇：</strong><br/> 
 <span>熙健-掌上心电获千万元A轮融资
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1）" data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三元条件运算符"><span class="toc-number">33.</span> <span class="toc-text">三元条件运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nil-联合运算符"><span class="toc-number">34.</span> <span class="toc-text">Nil-联合运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#范围运算符"><span class="toc-number">35.</span> <span class="toc-text">范围运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭合区间运算符"><span class="toc-number">36.</span> <span class="toc-text">闭合区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#半开区间运算符"><span class="toc-number">37.</span> <span class="toc-text">半开区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">38.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">39.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">40.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">41.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">42.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">43.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">45.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化空字符串"><span class="toc-number">46.</span> <span class="toc-text">初始化空字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串易变性"><span class="toc-number">47.</span> <span class="toc-text">字符串易变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串是值类型"><span class="toc-number">48.</span> <span class="toc-text">字符串是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用字符"><span class="toc-number">49.</span> <span class="toc-text">使用字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接字符串和字符"><span class="toc-number">50.</span> <span class="toc-text">连接字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串插入"><span class="toc-number">51.</span> <span class="toc-text">字符串插入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode"><span class="toc-number">52.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量"><span class="toc-number">53.</span> <span class="toc-text">Unicode 标量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量里的特殊字符"><span class="toc-number">54.</span> <span class="toc-text">字符串字面量里的特殊字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展字形集"><span class="toc-number">55.</span> <span class="toc-text">扩展字形集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算字符"><span class="toc-number">56.</span> <span class="toc-text">计算字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字符串"><span class="toc-number">57.</span> <span class="toc-text">访问和修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串索引"><span class="toc-number">58.</span> <span class="toc-text">字符串索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入和移除"><span class="toc-number">59.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较字符串"><span class="toc-number">60.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符等式"><span class="toc-number">61.</span> <span class="toc-text">字符串和字符等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀等式"><span class="toc-number">62.</span> <span class="toc-text">前缀和后缀等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-字符串表示"><span class="toc-number">63.</span> <span class="toc-text">Unicode 字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-8-形式"><span class="toc-number">64.</span> <span class="toc-text">UTF-8 形式</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mhealth365.cn/" target="_blank" title="一款温暖的心电监测设备">熙健-掌上心电</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m an iOS engineer <br/>
			Hala Madrid</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2779746325" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="跳跳魔王">跳跳魔王</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ecgbao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
