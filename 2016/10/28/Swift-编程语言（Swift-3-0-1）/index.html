
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="跳跳魔王">
    

    
    <meta name="description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 编程语言（Swift 3.0.1）">
<meta property="og:url" content="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/index.html">
<meta property="og:site_name" content="跳跳魔王的博客">
<meta property="og:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png">
<meta property="og:updated_time" content="2016-11-18T05:07:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 编程语言（Swift 3.0.1）">
<meta name="twitter:description" content="基本介绍Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。
基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dict">
<meta name="twitter:image" content="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png">

    
    <link rel="alternative" href="/atom.xml" title="跳跳魔王的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="跳跳魔王的博客">跳跳魔王的博客</a></h1>
				<h2 class="blog-motto">每天进步一点点</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/28/Swift-编程语言（Swift-3-0-1）/" title="Swift 编程语言（Swift 3.0.1）" itemprop="url">Swift 编程语言（Swift 3.0.1）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="跳跳魔王" target="_blank" itemprop="author">跳跳魔王</a>
		
  <p class="article-time">
    <time datetime="2016-10-28T05:54:48.000Z" itemprop="datePublished"> 发表于 2016-10-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三元条件运算符"><span class="toc-number">33.</span> <span class="toc-text">三元条件运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nil-联合运算符"><span class="toc-number">34.</span> <span class="toc-text">Nil-联合运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#范围运算符"><span class="toc-number">35.</span> <span class="toc-text">范围运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭合区间运算符"><span class="toc-number">36.</span> <span class="toc-text">闭合区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#半开区间运算符"><span class="toc-number">37.</span> <span class="toc-text">半开区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">38.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">39.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">40.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">41.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">42.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">43.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">45.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化空字符串"><span class="toc-number">46.</span> <span class="toc-text">初始化空字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串易变性"><span class="toc-number">47.</span> <span class="toc-text">字符串易变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串是值类型"><span class="toc-number">48.</span> <span class="toc-text">字符串是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用字符"><span class="toc-number">49.</span> <span class="toc-text">使用字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接字符串和字符"><span class="toc-number">50.</span> <span class="toc-text">连接字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串插入"><span class="toc-number">51.</span> <span class="toc-text">字符串插入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode"><span class="toc-number">52.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量"><span class="toc-number">53.</span> <span class="toc-text">Unicode 标量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量里的特殊字符"><span class="toc-number">54.</span> <span class="toc-text">字符串字面量里的特殊字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展字形集"><span class="toc-number">55.</span> <span class="toc-text">扩展字形集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算字符"><span class="toc-number">56.</span> <span class="toc-text">计算字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字符串"><span class="toc-number">57.</span> <span class="toc-text">访问和修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串索引"><span class="toc-number">58.</span> <span class="toc-text">字符串索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入和移除"><span class="toc-number">59.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较字符串"><span class="toc-number">60.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符等式"><span class="toc-number">61.</span> <span class="toc-text">字符串和字符等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀等式"><span class="toc-number">62.</span> <span class="toc-text">前缀和后缀等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-字符串表示"><span class="toc-number">63.</span> <span class="toc-text">Unicode 字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-8-形式"><span class="toc-number">64.</span> <span class="toc-text">UTF-8 形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尽早退出"><span class="toc-number">65.</span> <span class="toc-text">尽早退出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断-API-可用性"><span class="toc-number">66.</span> <span class="toc-text">判断 API 可用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">67.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义和调用函数"><span class="toc-number">68.</span> <span class="toc-text">定义和调用函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数和返回值"><span class="toc-number">69.</span> <span class="toc-text">函数参数和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有参数的函数"><span class="toc-number">70.</span> <span class="toc-text">没有参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个参数的函数"><span class="toc-number">71.</span> <span class="toc-text">多个参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有返回值的函数"><span class="toc-number">72.</span> <span class="toc-text">没有返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带有多返回值的函数"><span class="toc-number">73.</span> <span class="toc-text">带有多返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选元组返回类型"><span class="toc-number">74.</span> <span class="toc-text">可选元组返回类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数标签和参数名"><span class="toc-number">75.</span> <span class="toc-text">函数参数标签和参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定参数标签"><span class="toc-number">76.</span> <span class="toc-text">指定参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#省略参数标签"><span class="toc-number">77.</span> <span class="toc-text">省略参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认参数值"><span class="toc-number">78.</span> <span class="toc-text">默认参数值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可变参数"><span class="toc-number">79.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#输入输出参数"><span class="toc-number">80.</span> <span class="toc-text">输入输出参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型"><span class="toc-number">81.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用函数类型"><span class="toc-number">82.</span> <span class="toc-text">使用函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型作为参数类型"><span class="toc-number">83.</span> <span class="toc-text">函数类型作为参数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型和返回值"><span class="toc-number">84.</span> <span class="toc-text">函数类型和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套函数"><span class="toc-number">85.</span> <span class="toc-text">嵌套函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">86.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式"><span class="toc-number">87.</span> <span class="toc-text">闭包表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序函数"><span class="toc-number">88.</span> <span class="toc-text">排序函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式语法"><span class="toc-number">89.</span> <span class="toc-text">闭包表达式语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#根据上下文推断类型"><span class="toc-number">90.</span> <span class="toc-text">根据上下文推断类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从单一表达式闭包隐式返回"><span class="toc-number">91.</span> <span class="toc-text">从单一表达式闭包隐式返回</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#速记参数名"><span class="toc-number">92.</span> <span class="toc-text">速记参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符方法"><span class="toc-number">93.</span> <span class="toc-text">运算符方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾闭包"><span class="toc-number">94.</span> <span class="toc-text">尾闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#捕获值"><span class="toc-number">95.</span> <span class="toc-text">捕获值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包是引用类型"><span class="toc-number">96.</span> <span class="toc-text">闭包是引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逃离闭包"><span class="toc-number">97.</span> <span class="toc-text">逃离闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动闭包"><span class="toc-number">98.</span> <span class="toc-text">自动闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">99.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举语法"><span class="toc-number">100.</span> <span class="toc-text">枚举语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用Switch语句匹配枚举值"><span class="toc-number">101.</span> <span class="toc-text">用Switch语句匹配枚举值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联值"><span class="toc-number">102.</span> <span class="toc-text">关联值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Raw-Values"><span class="toc-number">103.</span> <span class="toc-text">Raw Values</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式赋-Raw-值"><span class="toc-number">104.</span> <span class="toc-text">隐式赋 Raw 值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用-Raw-值初始化"><span class="toc-number">105.</span> <span class="toc-text">用 Raw 值初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归枚举"><span class="toc-number">106.</span> <span class="toc-text">递归枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和结构体"><span class="toc-number">107.</span> <span class="toc-text">类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较类和结构体"><span class="toc-number">108.</span> <span class="toc-text">比较类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义语法"><span class="toc-number">109.</span> <span class="toc-text">定义语法</span></a></li></ol>
		
		</div>
		
		<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>Swift 是为 iOS，macOS，watchOS，和 tvOS 应用开发的一门新的开发语言，尽管如此，Swift很多部分都跟你以往从事C和Objective-C开发经验很相似。</p>
<p>基于C 和 Objective-C 的数据类型，Swift 提供了自己的版本，包括 Int， Double， Float，Bool 和 String。它同时也提供了三种集合类型，Array，Set 和 Dictionary。</p>
<p>跟C类似，Swift 通过变量名来存取值。Swift 还大量使用常量，这里的常量比C的常量更加强大。常量使用贯穿Swift，用来让代码更加安全和容易推断，特别是在你不想变量值发生改变的时候。</p>
<p>除了基本类型，Swift 还引进了objective-C中没有的高级类型，比如元组。元组让你可以创建和传递多值。你可以在一个函数里返回元组来作为一个单独的混合值。</p>
<p>Swift 还引进了可选类型，用来处理缺值的情况。可选的意思是‘这里有一个值，它等于x’ 或者‘这里没有任何值’。用可选值跟objective-C里使用nil指针有点像，不过可选类型可以服务任何类型，不仅仅是类类型。可选类型不仅仅安全而且更容易表达意思，它是Swift最重要特性里的核心特性。</p>
<p>Swift是一门类型安全的语言，这也就意味着这门语言可以让你更清晰的知道代码使用的值类型。如果你的代码需要一个String，类型安全会保护你不至于传递一个Int类型。同样，类型安全也会保护你，让你不会把非可选类型传递给需要可选类型的代码块。类型安全让你在开发阶段尽快发现问题，修复错误。</p>
<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>常量和变量是一个有特定类型的值，带有一个名字。常量值一旦确定就不能改变，变量在可用随时改变其值。</p>
<p>定义常量和变量<br>常量和变量必须要在使用前定义，常量使用let关键字，变量使用var关键字。下面是一个例子来展示如何使用常量和变量，这个例子是跟踪用户尝试的登录次数。</p>
<p><code>let maximumNumberOfLoginAttempts = 10<br>var currentLoginAttempt = 0</code><br>这段代码可以这样解读：<br>定义个常量maximumNumberOfLoginAttempts，给它一个值10.然后定义一个变量currentLoginAttempt，给它一个值0.<br>在这个例子里，最大登录次数定义为一个常量，因为最大登录数不会改变。当前登录数定义为变量，因为这个值随着用户的登录尝试会逐渐增长。<br>你也可以定义多个常量或变量在一行，用逗号分开即可：<br><code>var x = 0.0, y = 0.0, z = 0.0</code></p>
<p>类型注释<br>当定义常量或者变量的时候，你可以提供一个类型注释，这样可以更清楚的知道存储类型是什么。在变量名或者常量名后面加一个冒号，然后一个空格，然后是要使用的类型。</p>
<p>这个例子为变量welcomeMessage提供一个类型解释，来说明这个变量可以存储String值：<br><code>var welcomeMessage: String</code><br>这段代码可以理解为：<br>定义个变量叫welcomeMessage，它的类型是String。<br>welcomeMessage变量现在可以存储任何的字符串：<br><code>welcomeMessage = “Hello”</code><br>你可以在一行定义多个相关的相同类型的变量，用逗号分开，然后再最后加上类型注释：<br><code>var red, green, blue: Double</code></p>
<p>常量和变量命名<br>常量和变量命名可以包含几乎任何的字符，包括Unicode字符：<br><code>let π = 3.14159<br>let 你好 = “你好世界”<br>let 🐶🐮 = “dogcow”</code><br>常量和变量命名不能包含空格字符，数学符号，箭头，私有（无效）的Unicode字符码，或者-等。也不能以数字开始，虽然数字可以出现在名字里的任何地方。</p>
<p>一旦你给常量或者变量确定了类型，你就不能用同样的名字来重定义它们，或者改变他们存储的值类型。你也不能把常量改为变量，或者把变量变成常量。</p>
<p>你可以把常量的值改变成同样类型的其他的值。这个例子里，变量friendlyWelcome的值从”Hello!” 变成 “Bonjour!”:<br><code>var friendlyWelcome = “Hello!”<br>friendlyWelcome = “Bonjour!”<br>// friendlyWelcome is now “Bonjour!”</code><br>与变量不同，常量值一旦确定就不能再改变。如果尝试改变编译器会报错：<br><code>let languageName = “Swift”<br>languageName = “Swift++”<br>// This is a compile-time error: languageName cannot be changed.<br></code><br>打印常量和变量<br>你可以使用print(<em>:separator:terminator:)函数打印常量或者变量的当前值：<br><code>print(friendlyWelcome)<br>// Prints “Bonjour!”</code><br>print(</em>:separator:terminator:)是一个全局函数，可以打印一个或者多个值。在XCode里，例如，print(_:separator:terminator:)打印结果会出现在控制台里。separator 和 terminator 参数都有默认值, 所以你可以忽略他们。 默认的, 这个函数打印完会加上换行符。 如果不想打印后换行, 传入一个空字符串作为终止—例如, print(someValue, terminator: “”)</p>
<p>Swift 使用 string interpolation 在长字符串里插入常量或者变量名, 同时会提示 Swift 去用当前的常量值活变量值来替换它。 用括号包含名字，然后在前面加上反斜杠:</p>
<p><code>print(“The current value of friendlyWelcome is (friendlyWelcome)”)<br>// Prints “The current value of friendlyWelcome is Bonjour!”</code></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在代码中，把注释加到不执行的文本，作为一个备注或者提醒。代码编译的时候，注释会被编译器忽略。<br>Swift注释和C语言注释很像，不在赘述。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>跟其他语言不同，Swift不要求在每条语句后写分号（；），不过，在一行写很多语句的时候，还是需要带上分号的：<br><code>let cat = “🐱”; print(cat)<br>// Prints “🐱”<br></code></p>
<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><p>Integers 意思是整个数字没有小数，比如 42 和 -23，整数要么是 signed（负数，0，正数） 要么是 unsigned（正数或者0）</p>
<p>Swift提供8，16，32 和 64位的有符号和无符号的整数。这些整数类型和C语言很像，8位的无符号的整数是UInt8，32位的有符号正数是Int32.</p>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><p>你可以用min 和max属性来获取每个整数类型的最小值和最大值：<br><code>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8<br>let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8</code></p>
<h1 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h1><p>大多数情况下，你不需要指定整数的位数。Swift提供了额外的整数类型Int，这个和当前平台的本地字数一样：<br>32位机器，Int等于Int32<br>64位机器，Int等于Int64<br>除非你要用规定大小的整数，否则，一般只要用Int就可以了。</p>
<h1 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h1><p>Swift也提供了无符号的整形，UInt，这个和当前平台的本地字数也是一样的：<br>32位机器，UInt等于UInt32<br>64位机器，UInt等于UInt64</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>Floating-point 是带有小数部分的数字，比如 3.14159，0.1和-273.15.<br>浮点数类型比整数类型表达更多的值域，比存在Int中的值更大或者更小。Swift提供了两个有符号的浮点数类型：<br>Double 表示64位的浮点数。<br>Float 表示32位的浮点数。</p>
<h1 id="类型安全与推断"><a href="#类型安全与推断" class="headerlink" title="类型安全与推断"></a>类型安全与推断</h1><p>Swift是类型安全的语音。类型安全的语言鼓励你清楚知道自己代码使用的值的类型。如果你的代码需要String类型，那么你就不要传递Int给它。</p>
<p>因为Swift是类型安全的，在编译代码的时候type checks会执行来标记不匹配的类型错误。这让你可以尽可能早的发现代码中的错误。</p>
<p>类型检查帮你避免使用不同类型的时候犯错，然而，这并不意味你必须给所有的常量和变量指定类型。你不需要指定类型，Swift使用type inference来推断合适的类型。类型推断使得编译器可以在编译代码的时候自动推断表达式的类型，只是通过简单的检查你提供的值。</p>
<p>因为有类型推断，Swift 对类型声明要求的比其他语言要少的多。常量和变量依然要显示输入，但是大部分指定类型的工作都已经帮你做了。</p>
<p>类型推断在给常量或者变量赋初值的时候尤为有用。这个发生在你声明常量或者变量，并给他们指定literal value（字面量）的时候。所谓的字面量就是指直接出现在你的源码中的值，比如下面例子里的 42 和 3.14159</p>
<p>例如，如果你给一个新常量指定一个字面量是42， Swift就会推断你想要这个常量的类型是Int， 因为你给他初始化一个数字：<br><code>let meaningOfLife = 42<br>// meaningOfLife is inferred to be of type Int</code><br>同样，你也不需要给浮点数指定类型，Swift会推断说你想要一个Double：<br><code>let pi = 3.14159<br>// pi is inferred to be of type Double</code><br>Swift在推断浮点数的时候总是选择Double而不是Float<br>如果你合并整数和浮点数在一个表达式中，Double类型将会被推断出来：<br><code>let anotherPi = 3 + 0.14159<br>// anotherPi is also inferred to be of type Double</code></p>
<h1 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h1><p>整数字面量这可以写：<br>十进制数字，没有前缀<br>二进制数字，用0b做前缀<br>八进制数字，用0o做前缀<br>十六进制数字，用0x做前缀<br>下面所有整数字面量值都是17：<br><code>let decimalInteger = 17<br>let binaryInteger = 0b10001       // 17 in binary notation<br>let octalInteger = 0o21           // 17 in octal notation<br>let hexadecimalInteger = 0x11     // 17 in hexadecimal notation</code></p>
<p>浮点数字面量可以是十进制或者十六进制。在十进制点的两边都必须有数字。十进制浮点数也有个可选的exponent，用大小写e标明；十六进制浮点数也有exponent，用大小写的p标明。</p>
<p>用 exp 指数表示十进制数, 基础数字乘以 10exp:<br>1.25e2 意思是 1.25 x 102, 或者是 125.0.<br>1.25e-2 意思是 1.25 x 10-2, 或者是 0.0125.<br>用 exp 指数表示十六进制数, 基础数字乘以 2exp:</p>
<p>0xFp2 意思是 15 x 22, 或者是 60.0.<br>0xFp-2 意思是 15 x 2-2, 或者是 3.75.<br>下面所有这些浮点数字面量十进制数都是 12.1875:<br><code>let decimalDouble = 12.1875<br>let exponentDouble = 1.21875e1<br>let hexadecimalDouble = 0xC.3p0</code></p>
<h1 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h1><p>在你的代码中使用Int做为一般用途的整形常量和变量，尽快知道他们是非负数的。日常开发使用默认整形类型意味着整形变量和常量立即可以使用，而且它们匹配整形字面量的推断类型。</p>
<p>特别指定的工作才会使用其他的整形类型，因为指定大小的整形类型需要额外的开销。日常开发中，使用指定大小的类型帮助捕获特定值的溢出，同时记录被使用的数据。</p>
<h1 id="整形转换"><a href="#整形转换" class="headerlink" title="整形转换"></a>整形转换</h1><p>不同数值类型，存储在常量或变量中的数值范围是不同的。一个Int8常量或者变量可以存储 -128 到 127， UInt8 常量或者变量能存储 0 到 255 之间的数值。如果数值不适合指定大小的整形类型，编译后会报错。</p>
<p><code>let cannotBeNegative: UInt8 = -1<br>// UInt8 cannot store negative numbers, and so this will report an error<br>let tooBig: Int8 = Int8.max + 1<br>// Int8 cannot store a number larger than its maximum value,<br>// and so this will also report an error</code></p>
<p>为了转换一个特定数值类型，先用一个存在的值初始化一个新的想要类型的新数值。下面的例子，常量twoThousand的类型是UInt16， 而常量one的类型是UInt8.他们不能直接相加，因为类型不同。取而代之的是，这个例子调用UInt16（one）来创建一个新的Uint16，并用one初始化它，并在原来的位置使用这个值：</p>
<p><code>let twoThousand: UInt16 = 2_000<br>let one: UInt8 = 1<br>let twoThousandAndOne = twoThousand + UInt16(one)</code></p>
<p>因为加好两边的值类型都是UInt16，所以加法是进行的。输出常量推断是UInt16，因为它是两个UInt16值的和。</p>
<p>SomeType(ofInitialValue) 默认调用Swift类型的初始化函数，然后传递一个初始值。这个语句之前，UInt16有一个初始化器接受一个UInt8的值，所以这个初始化器就用存在的UInt8 创建了一个新的UInt16.这里你不能随便传入类型-必须传入UInt16初始化器接受的值。</p>
<h1 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h1><p>整数和浮点数之间的转换必须是显示的：<br><code>let three = 3<br>let pointOneFourOneFiveNine = 0.14159<br>let pi = Double(three) + pointOneFourOneFiveNine<br>// pi equals 3.14159, and is inferred to be of type Double</code></p>
<p>这里，常量three用来创建新的Double数值，现在加号两边的类型是一样的，所以可以相加。如果没有这里的转换，加法是不允许的。</p>
<p>浮点数转整数也必须是显示进行的。一个整形可以用Double 或者 Float的值来初始化：</p>
<p><code>let integerPi = Int(pi)<br>// integerPi equals 3, and is inferred to be of type Int</code><br>用这种方式初始化一个新的整形数值，浮点数会被截断。意思就是 4.75 会变成 4， -3.9会变成-3.</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>type aliases 为已知类型定一个别名。定义类型别名使用typealias关键字。</p>
<p>类型别名在你想通过名字调用一个已知类型的时候很有用，这种名字在上下文中更合适，比如使用指定大小的外部数据时：<br><code>typealias AudioSample = UInt16</code><br>定义好类型别名后，你可以在任何使用原名的地方使用它：<br><code>var maxAmplitudeFound = AudioSample.min<br>// maxAmplitudeFound is now 0</code><br>这里，AudioSample就是UInt16的别名。因为是别名，调用AudioSample.min实际上就是调用UInt16.min，这给maxAmplitudeFound变量提供一个初始值0.</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>Swift有个一基础布尔类型， 叫做 Bool。布尔值用作逻辑调用，因为它只能是true或者false。Swift提供了两个布尔常量值，true和falseL<br><code>let orangesAreOrange = true<br>let turnipsAreDelicious = false</code></p>
<p>orangesAreOrange 和 turnipsAreDelicious 的类型被推断是Bool。同上面的Int 和 Double 一样，你不需要声明常量或者变量为Bool</p>
<p>布尔值在if 语句这种条件语句中尤其有用：<br><code>if turnipsAreDelicious {<br>    print(“Mmm, tasty turnips!”)<br>} else {<br>    print(“Eww, turnips are horrible.”)<br>}<br>// Prints “Eww, turnips are horrible.”</code></p>
<p>Swift 类型安全防止非布尔值被替换成布尔值。下面的例子报一个编译错误：</p>
<p><code>let i = 1<br>if i {<br>    // this example will not compile, and will report an error<br>}</code></p>
<p>替代的例子如下：<br><code>let i = 1<br>if i == 1 {<br>    // this example will compile successfully<br>}</code></p>
<p>i==1比较的结果是Boo类型，所以第二个例子通过了类型检查。</p>
<p>和其他类型安全例子一样，这个方法避免了突发的错误，确保特别代码块推断总是清晰的。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>Tuples 包含多值到一个单独的组合值。元组里的值可以是任何类型，彼此之间可以是不同类型。</p>
<p>在这个例子中，(404, “Not Found”)是一个元组，代表Http的错误码。一个Http错误码是访问网页时网页服务器返回的特殊数值。如果你请求的网页不存在，就会返回404 Not Found的错误码。</p>
<p><code>let http404Error = (404, “Not Found”)<br>// http404Error is of type (Int, String), and equals (404, “Not Found”)</code></p>
<p>(404, “Not Found”) 元组包含了一个Int 和一个String，一个数字和一个人工可读的描述。它可以描述成一个类型为（Int, String）的元组。</p>
<p>你可以用任何变化的类型创建元组，你可以按照需要要创建不同的元组。</p>
<p>你可以分解元组到分离的常量或者变量，通常你会访问它们：</p>
<p><code>let (statusCode, statusMessage) = http404Error<br>print(“The status code is (statusCode)”)<br>// Prints “The status code is 404”<br>print(“The status message is (statusMessage)”)<br>// Prints “The status message is Not Found”</code></p>
<p>如果你只需要元组中的某些值，当你分解元组的时候可以用下划线替换忽略的部分：<br><code>let (justTheStatusCode, _) = http404Error<br>print(“The status code is (justTheStatusCode)”)<br>// Prints “The status code is 404”</code></p>
<p>或者，通过下标访问元组中单独的元素值：</p>
<p><code>print(“The status code is (http404Error.0)”)<br>// Prints “The status code is 404”<br>print(“The status message is (http404Error.1)”)<br>// Prints “The status message is Not Found”</code></p>
<p>你可以在元组定义时，给单独的原色命名：</p>
<p><code>let http200Status = (statusCode: 200, description: “OK”)</code></p>
<p>如果你在元组中命名了元素，那么，你可以在访问元素值的时候通过名字访问它们的值：</p>
<p><code>print(“The status code is (http200Status.statusCode)”)<br>// Prints “The status code is 200”<br>print(“The status message is (http200Status.description)”)<br>// Prints “The status message is OK”</code></p>
<h1 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h1><p>当一个值可能缺失的时候使用optionals。一个可选值包含两种可能：或者有一个值，你可以通过拆包访问这个值，或者根本没有值。</p>
<p>这里有一个例子，说明可选类型如何在值缺失的时候使用。Swift 的Int 类型有一个初始化器，可以把String 转换为Int 值。不过，不是每一个字符串都可以转换的。“123”可以转换为123，但是“helloworld”就不可以。</p>
<p>下面的例子使用初始化器去转换String：<br><code>let possibleNumber = “123”<br>let convertedNumber = Int(possibleNumber)<br>// convertedNumber is inferred to be of type “Int?”, or “optional Int”</code></p>
<p>因为初始化器有可能失败，所以它返回一个optional Int，而不是Int。一个可选Int写作Int？，不是Int。问号表示包含的值是可选的，意思就是它可能包含某个Int值，也可能不包含任何值。</p>
<h1 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h1><p>通过赋值nil来把可选值设置成无值状态：</p>
<p><code>var serverResponseCode: Int? = 404<br>// serverResponseCode contains an actual Int value of 404<br>serverResponseCode = nil<br>// serverResponseCode now contains no value</code></p>
<p>如果如果定义一个可选变量，但是没有提供默认值，这个变量会被自动设置为nil：<br><code>var surveyAnswer: String?<br>// surveyAnswer is automatically set to nil</code></p>
<h1 id="if语句和强制拆包"><a href="#if语句和强制拆包" class="headerlink" title="if语句和强制拆包"></a>if语句和强制拆包</h1><p>用if语句，通过与nil做比较，你可以知道一个可选项是否包含一个值，用（==）或者（！=）来做比较。如果一个可选项有值，那么它不等于ni：<br><code>if convertedNumber != nil {<br>    print(“convertedNumber contains some integer value.”)<br>}<br>// Prints “convertedNumber contains some integer value.”</code></p>
<p>一旦你确定可选项包含一个值，你可以通过在可选项的名字后面加（！）来获取它的值。这个感叹号是说：我知道这个可选项一定有值；请使用它！这就是强制拆包获取可选项的值：<br><code>if convertedNumber != nil {<br>    print(“convertedNumber has an integer value of (convertedNumber!).”)<br>}<br>// Prints “convertedNumber has an integer value of 123.”</code></p>
<h1 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h1><p>使用optional binding找出一个可选项是否包含一个值。如果这样的话，使这个值作为一个临时常量或者变量。可选绑定用if和while语句来判断可选项的值，然后提取这个值到常量或者变量，作为操作的一部分。</p>
<p>用if语句写可选绑定像下面这样：</p>
<p><code> if let constantName = someOptional {<br>    statements<br>}<br></code></p>
<p>你可以重写possibleNumber实例，通过使用可选绑定而不是强制拆包：</p>
<p><code> if let actualNumber = Int(possibleNumber) {<br>    print(“\”(possibleNumber)\” has an integer value of (actualNumber)”)<br>} else {<br>    print(“\”(possibleNumber)\” could not be converted to an integer”)<br>}<br>// Prints “”123” has an integer value of 123”</code></p>
<p>代码可以这样解释;<br>如果Int（possibleNumber）返回的可选Int包含一个值，设置一个新的常量叫actualNumber，它的值就是包含在可选项中的值。</p>
<p>如果转换成功，actualNumber 常量变的可用，执行第一个分支的语句。因为已经初始化了可选项的值，所以不需要用感叹号去拆包。</p>
<p>你可以同时使用常量和变量，如果你想操作if语句第一个分支里的actualNumber，你可能要写 if var actualNumber来替换代码，然后可选项的值会变成变量值而不是常量值。</p>
<p>你可以在单独的if语句包括尽可能多的可选绑定和布尔条件，用逗号分开即可。如果任何可选项的值为nil或者布尔条件等于false，if条件被认为是false。下面的if语句是一样的：</p>
<p><code>if let firstNumber = Int(“4”), let secondNumber = Int(“42”), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>    print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>}<br>// Prints “4 &lt; 42 &lt; 100”</code></p>
<p>if let firstNumber = Int(“4”) {<br>    if let secondNumber = Int(“42”) {<br>        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>            print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>        }<br>    }<br>}<br>// Prints “4 &lt; 42 &lt; 100”</p>
<h1 id="隐式拆包可选项"><a href="#隐式拆包可选项" class="headerlink" title="隐式拆包可选项"></a>隐式拆包可选项</h1><p>如上所述，可选项表示一个常量或者变量可以没有值。可选项可以用if语句判断是否存在值，如果不存在，可以有条件用可选绑定拆包来访问可选项的值。</p>
<p>有时候，通过程序的结构可以很清楚的知道可选项有值，然后这个值被第一次设置。这种情况，就不需要每次都判断和拆包了，因为可以安全的假设总是有值。</p>
<p>这种可选项定义为隐式拆包可选项。隐式拆包可选项的写法是，在类型后面假设感叹号而不是问号。</p>
<p>当可选项的值在首次定义后就能确定存在的事，隐式拆包可选项很有用。隐式拆包可选项主要用在类的初始化。</p>
<p>隐式拆包可选项在这种场景下，是正常可选项，但是也可以用作一个非可选项，无需每次访问都拆包。下面的例子展示了，可选字符串和隐式拆包可选项字符串作为显示String时访问它们包含的值的不同行为。</p>
<p><code>let possibleString: String? = “An optional string.”<br>let forcedString: String = possibleString! // requires an exclamation mark</code></p>
<p>let assumedString: String! = “An implicitly unwrapped optional string.”<br>let implicitString: String = assumedString // no need for an exclamation mark</p>
<p>你依然可以把隐式拆包可选项当做正常的可选项，来判断它是否包含一个值：</p>
<p><code>if assumedString != nil {<br>    print(assumedString)<br>}<br>// Prints “An implicitly unwrapped optional string.”</code></p>
<p>你可以结合可选绑定来使用隐式拆包可选项，然后在一行语句中判断和拆包它的值：</p>
<p><code>if let definiteString = assumedString {<br>    print(definiteString)<br>}<br>// Prints “An implicitly unwrapped optional string.”</code></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>使用error handling 响应程序执行中错误条件。<br>与可选项做对照，可选项用有无值来表示一个函数的成功失败，错误处理允许你检测迁走的失败原因，同时如果必要的话，会把错误传递到程序的另外一部分。</p>
<p>当函数遇到一个错误情况，它就会throws 一个错误。函数调用者可以捕获这个错并正确响应。</p>
<p><code>func canThrowAnError() throws {<br>    // this function may or may not throw an error<br>}</code></p>
<p>一个函数表明它可以通过在定义中包含throws关键词来抛出一个错误。当你调用这个可以抛出错误的函数时，你要准备try关键词。</p>
<p>Swift 自动把错误往外抛知道它被一个catch语句处理。</p>
<p><code>do {<br>    try canThrowAnError()<br>    // no error was thrown<br>} catch {<br>    // an error was thrown<br>}</code></p>
<p>do 语句创建了一个代码块，它允许错误可以传递给一个或者多个catch 项。</p>
<p>这里有一个列子，展示响应不同错误条件的错误处理方式：</p>
<p><code>func makeASandwich() throws {<br>    // …<br>}</code></p>
<p>do {<br>    try makeASandwich()<br>    eatASandwich()<br>} catch SandwichError.outOfCleanDishes {<br>    washDishes()<br>} catch SandwichError.missingIngredients(let ingredients) {<br>    buyGroceries(ingredients)<br>}</p>
<p>在这个例子里，如果没有干净的餐具可用或者任何调料确实，makeASandwich将会抛出一个错误。因为makeASandwich可以抛出错误，所以函数调用包含在try表达式。经过do语句包含处理，任何抛出的错误都会传递到catch项。</p>
<p>如果没有错误抛出，eatASandwich函数会被调用。如果一个错误抛出然后匹配SandwichError.outOfCleanDishes这个条件，那么washDishes会被调用。如果一个错误抛出然后匹配SandwichError.missingIngredients条件，那么buyGroceries会被调用</p>
<h1 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h1><p>operator 是特殊的符号或者短语，用来检查，改变，或者合并数值。比如，加号（+）用来加两个数值，比如 let = 1 + 2，逻辑与（&amp;&amp;）合并两个布尔值，比如 enteredDoorCode &amp;&amp; passedRetinaScan<br>Swift支持大部分的C语言操作符，并且提升了消除一般编码错误的能力。赋值运算符（=）不会返回一个值，用来防止错误是使用（==）。算数运算符—（+，-，*，/，%等等）监测和拒绝值溢出，为了避免值溢出造成未知的结果。你可以用Swift的溢出运算符选择值溢出行为。</p>
<p>Swift同时提供了两个范围运算符（a..&lt;b和a…b），这在C语言里没有。这些作为表达一个范围值的快捷方式。</p>
<p>这个章节介绍Swift的普通运算符。Advanced Operators 包含了Swift的高级运算符，描述如何定义你自己的运算符，然后为你自定义的类型实现标准运算符。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>运算符是一元的，二元的，或者三元的：<br>    一元运算符操作单一目标（比如-a）。一元前缀操作费直接写在目标前（比如！b），一元后缀操作费则直接出现在目标后（比如c！）。<br>    二元运算符操作两个目标（比如2+3），并且出现在两个目标的中间。<br>    三元运算符操作三个目标，跟C语言一样，Swift 只有一个三元运算符，也就是三元条件运算符（a ？b ：c）。<br>运算符作用的值是操作数。在表达式1+2里，+号是二元运算符，两个操作数分别是1和2.</p>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>assignment operator（a=b）用b的值初始化或者更新a的值。<br><code>let b = 10<br>var a = 5<br>a = b<br>// a is now equal to 10</code><br>如果赋值语句的右侧是多值的元组，它的元素可以一次分解为多个常量或者变量：</p>
<p><code>let (x, y) = (1, 2)<br>// x is equal to 1, and y is equal to 2</code><br>与C语言 和 Objective-C语言不同，Swift赋值运算符自身不返回值。下面的语句是无效的：</p>
<p><code>if x = y {<br>    // This is not valid, because x = y does not return a value.<br>}</code><br>这个特性防止=与==混淆。 让if x = y 无效, Swift 帮你避免这种错误。</p>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>Swift 对所有类型支持四种标准算术运算符:</p>
<p>加号 (+)<br>减号 (-)<br>乘号 (<em>)<br>除号 (/)<br>1 + 2       // 等于 3<br>5 - 3       // 等于 2<br>2 </em> 3       // 等于 6<br>10.0 / 2.5  // 等于 4.0<br>与C语言 和 Objective-C语言不同, Swift 算术运算符默认不允许值溢出。 你可以通过Swift溢出运算符来选择值溢出行为(例如 a &amp;+ b)。</p>
<p>加号也支持字符串连接:</p>
<p><code>“hello, “ + “world”  // 等于 “hello, world”</code></p>
<h1 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h1><p>余数运算符 (a % b) 计算a中b的倍数，并且返回余数。</p>
<p>备注</p>
<p>余数运算符 (%) 在其他语言中作为取模运算符。 不过, 在 Swift 中对负数来说, 严格来讲, 它是余数而不是一个取模运算。</p>
<p>下面演示余数运算符是如何工作的。 计算 9 % 4, 你首先算出9里有多少个4:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png"><br></div>

<p>你可以确定9里有两个4, 余数是 1 (橙色显示)。</p>
<p>在 Swift 里, 这个会写作:</p>
<p><code>9 % 4    // 等于 1</code><br>为了确定 a % b 的结果, % 运算符计算下面的方程式，然后返回余数作为输出:</p>
<p>a = (b x 倍数) + 余数</p>
<p>这里倍数是a里面b的最大倍数。</p>
<p>把 9 和 4 代入方程式值域:</p>
<p><code>9 = (4 x 2) + 1</code></p>
<p>计算负值a的余数也是用相同的方法:</p>
<p><code>-9 % 4   // 等于 -1</code><br>把 -9 和 4 代入方程式值域:</p>
<p><code>-9 = (4 x -2) + -1</code></p>
<p>活的余数 -1.</p>
<p>负值b被忽略。 意思就是 a % b 和 a % -b 结果是一样的。</p>
<h1 id="一元减法运算符"><a href="#一元减法运算符" class="headerlink" title="一元减法运算符"></a>一元减法运算符</h1><p>数值符号可以用前缀 - 连接, 也就是大家熟知的一元减法运算符:<br><code><br>let three = 3<br>let minusThree = -three       // minusThree equals -3<br>let plusThree = -minusThree   // plusThree equals 3, or “minus minus three”<br></code><br>一元减法运算符 (-) 直接放在操作数前, 没有空格。</p>
<h1 id="一元加法运算符"><a href="#一元加法运算符" class="headerlink" title="一元加法运算符"></a>一元加法运算符</h1><p>一元加法运算符 (+) 返回操作数值, 没有任何改变:<br><code><br>let minusSix = -6<br>let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6<br></code><br>尽管一元加法运算符实际上不做任何事, 你可以用它来提供对称的代码，当在代码中使用正负数的时候。</p>
<h1 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h1><p>和 C 语言相似, Swift 提供复合赋值运算符来合并赋值 (=) 和其他操作数。 一个例子就是加法赋值运算符 (+=):<br><code><br>var a = 1<br>a += 2<br>// a 现在等于 3<br></code><br>表达式 a += 2 是 a = a + 2 的快捷方式。 实际上, 加法和赋值合并进一个操作符，同时做了两件事。</p>
<p>备注</p>
<p>复合赋值运算符不返回值。 比如, 你不能这样写 let b = a += 2.</p>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>Swift 支持所有标准C语言比较运算符:</p>
<p>等于 (a == b)<br>不等于 (a != b)<br>大于 (a &gt; b)<br>小于 (a &lt; b)<br>大于等于 (a &gt;= b)<br>小于等于 (a &lt;= b)</p>
<p>备注</p>
<p>Swift 同时提供两个相等运算符 (=== and !==), 你可以用来测试两个对象引用是否引用了相同的对象实例。 更多信息参考 Classes and Structures.</p>
<p>每个比较运算符都返回一个布尔值，来表明语句是否是真的:</p>
<p>1 == 1   // 真，因为1 等于 1<br>2 != 1   // 真，因为2 不等于 1<br>2 &gt; 1    // 真，因为2 大于 1<br>1 &lt; 2    // 真，因为1 小于 2<br>1 &gt;= 1   // 真，因为1大于或者等于1<br>2 &lt;= 1   // 假，因为2不小于或者等于1<br>比较运算符通常用于条件语句, 例如if语句:<br><code><br>let name = “world”<br>if name == “world” {<br>    print(“hello, world”)<br>} else {<br>    print(“I’m sorry (name), but I don’t recognize you”)<br>}<br>// Prints “hello, world”, because name is indeed equal to “world”.<br></code><br>更多if语句, 参考 Control Flow.</p>
<p>你可以比较含有相同数量值的元组, 只要元组里的值可以比较。 例如, Int 和 String 可以比较, 意思就是 (Int, String) 可以比较。 相反, Bool 不能比较, 意思就是包含布尔值的元组不能作比较。</p>
<p>元组是从左到右做比较的, 每次一个值, 直到比较发现两个值不等为止。 这两个被比较的值, 比较的结果决定了整个元组比较的结果。 如果所有元素都相等, 那么元组就是相等的。例如:<br><code><br>(1, “zebra”) &lt; (2, “apple”)   // 真，因为1小于2; “zebra” 和 “apple” 不比较<br>(3, “apple”) &lt; (3, “bird”)    // 真，以为3等于3, “apple” 小于 “bird”<br>(4, “dog”) == (4, “dog”)      // 真，因为4等于4, “dog” 等于 “dog”<br></code><br>上面这个例子, 在第一行你可以看见从左到右比较的行为。 因为1小于2, (1, “zebra”) 被认为小于 (2, “apple”), 不用管元组里的其他值。 不管 “zebra” 是不是小于 “apple”, 因为比较已经取决于元组里的第一个元素了。 不过, 当元组第一个元素相等的时候，比较就像第二行，第三行发生的那样。</p>
<h1 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h1><p>三元条件运算符是含有三部分的特殊运算符, 样式是 <code>问题 ? 答案1 : 答案2</code>。 这是基于问题是真假对表达式之一的判断。 如果问题是真, 求 answer1 的值并返回; 否则, 求 answer2 的值并返回。</p>
<p>三元条件运算符是下面代码的简写:<br><code><br>if question {<br>    answer1<br>} else {<br>    answer2<br>}<br></code><br>这里有一个例子, 用例计算列表行高。 如果行有头部，那么行高比内容高度加50，如果没有头部，那么高度加20:<br><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight = contentHeight + (hasHeader ? 50 : 20)<br>// rowHeight is equal to 90<br></code></p>
<p><code><br>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight: Int<br>if hasHeader {<br>    rowHeight = contentHeight + 50<br>} else {<br>    rowHeight = contentHeight + 20<br>}<br>// rowHeight is equal to 90<br></code><br>第一个例子使用三元条件运算符，意味着行高可以在一行代码里正确设置, 这个比第二个例子的代码要简洁。</p>
<p>三元条件运算符提供一个简写，来决定使用两个表达式中的哪一个。 小心使用三元条件运算符。 过度使用，代码就是很难理解。 尽量避免把三元条件运算符的多个实例合并到一个符合语句。</p>
<h1 id="Nil-联合运算符"><a href="#Nil-联合运算符" class="headerlink" title="Nil-联合运算符"></a>Nil-联合运算符</h1><p>nil-联合运算符 (a ?? b) 展开一个可选项 a 如果它包含一个值的话, 或者返回一个默认值 b 如果 a 是 nil。 表达式 a 总是一个可选类型。 表达式 b 必须匹配存储在a里的值类型。</p>
<p>nil-联合运算符是下面代码的简写:</p>
<p><code>a != nil ? a! : b</code><br>上面的代码使用三元条件运算符,然后强制展开 (a!) 来获取a中的值，如果这个值不空的话, 否则返回 b 。 nil-联合运算符提供了更优雅简洁的方式来压缩这个条件判断和展开。</p>
<p>备注</p>
<p>如果值非空, b的值不会得到。 这就是人们熟知的短路估算。</p>
<p>下面的例子使用 nil-联合运算符在默认颜色名称和可选用户定义的颜色名称之间做选择:<br><code><br>let defaultColorName = “red”<br>var userDefinedColorName: String?   // 默认是 nil</code></p>
<p>var colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName 是 nil, 所以colorNameToUse 设置成默认值 “red”<br><br>userDefinedColorName 变量定义成可选的 String, 默认值是 nil. 因为 userDefinedColorName 是个可选类型, 你可以使用nil-联合运算符来获取它的值。 上面的例子, 运算符用来决定变量 colorNameToUse 的一个初始值。 因为 userDefinedColorName 是 nil,  userDefinedColorName ?? defaultColorName 表达式返回了defaultColorName 的值, 或者 “red”.</p>
<p>如果你给 userDefinedColorName 赋了一个非空的值，然后执行 nil-联合运算符再次判断, userDefinedColorName 中包含的值 就取代了默认值:<br><code><br>userDefinedColorName = “green”<br>colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName is not nil, so colorNameToUse is set to “green”<br></code></p>
<h1 id="范围运算符"><a href="#范围运算符" class="headerlink" title="范围运算符"></a>范围运算符</h1><p>Swift 有两个范围运算符, 是表达值范围的简写。</p>
<h1 id="闭合区间运算符"><a href="#闭合区间运算符" class="headerlink" title="闭合区间运算符"></a>闭合区间运算符</h1><p>闭合区间运算符 (a…b) 定义从a到b的范围, 包含a和b的值。 a的值不能比b大。</p>
<p>闭合区间运算符在范围迭代很有用，特别是你想使用所有的值的时候。例如 for-in 循环:<br><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index * 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br></code><br>更多 for-in 循环, 参考 Control Flow.</p>
<h1 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h1><p>半开区间运算符 (a..&lt;b) 定义了从a到b的范围, 但是不包含b， 之所以成为半开是因为它包含初值, 但是不包含终值。 正如闭合区间运算符, a的值不能大于b。 如果a的值等于b的值, 这个范围就会是空的。</p>
<p>半开区间在你使用类似数组这种基于零的列表时非常有用, 计算列表长度 (但是不包括) 很有帮助:<br><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>let count = names.count<br>for i in 0..<count 1="" 2="" 3="" 4="" {="" print("person="" \(i="" +="" 1)="" is="" called="" \(names[i])")="" }="" person="" anna="" alex="" brian="" jack="" <="" code=""><br>数组包含4项, 不过 0..&lt;count 只计算到3 (数组最后一项的索引), 因为是半开区间。 更多数组, 参见 Arrays.</count></code></p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>逻辑运算符改变或者合并布尔值真和假。 Swift 支持三种基于C语言的标准逻辑运算符:</p>
<p>逻辑非 (!a)<br>逻辑与 (a &amp;&amp; b)<br>逻辑或 (a || b)</p>
<h1 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h1><p>逻辑非运算符 (!a) 反转布尔值，这样真就变成假, 假变成了真。</p>
<p>逻辑非运算符是个前缀运算符, 直接写在操作数前面, 没有任何空格。 可以读作 “not a”, 下面的例子可以看到:<br><code><br>let allowedEntry = false<br>if !allowedEntry {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “ACCESS DENIED”<br></code><br>语句 if !allowedEntry 可以读作 “if not allowed entry.” 后面一行仅执行 “not allowed entry” 是 true; 也就是, if allowedEntry 是 false.</p>
<p>在这个例子中, 谨慎定义布尔常量和变量名，可以让代码具有可读性和简洁性, 同时避免双重否定或者混乱的逻辑语句。</p>
<h1 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a>逻辑与运算符</h1><p>逻辑与运算符 (a &amp;&amp; b) 创建逻辑表达式，这个表达式中两个值为真，表达式也要为真。</p>
<p>如果任何一个值为假, 表达式的结果也将是假。 事实上, 如果第一个值为假, 第二个值不会再计算, 因为它不会让所有表达式都等于真。 这就是人们熟知的短路估值。</p>
<p>这个例子有两个布尔值，只有两个值都是真的时候才允许访问:<br><code><br>let enteredDoorCode = true<br>let passedRetinaScan = false<br>if enteredDoorCode &amp;&amp; passedRetinaScan {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “ACCESS DENIED”<br></code></p>
<h1 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a>逻辑或运算符</h1><p>逻辑或运算符 (a || b) 是两个竖线组成的中间运算符。 用来创建逻辑表达式，这个表达式中只要有一个值为真，表达式的结果就是真。</p>
<p>跟上面逻辑与类似, 逻辑或使用短路估值去计算表达式。 如果逻辑或的左侧是真, 右侧就不再估值, 因为它不会改变整个表达式的结果。</p>
<p>下面的例子, 第一个布尔值 (hasDoorKey) 是假, 但是第二个布尔值 (knowsOverridePassword) 是真。 因为一个值为真, 表达式结果就是真, 所以允许访问:<br><code><br>let hasDoorKey = false<br>let knowsOverridePassword = true<br>if hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code></p>
<h1 id="合并逻辑运算符"><a href="#合并逻辑运算符" class="headerlink" title="合并逻辑运算符"></a>合并逻辑运算符</h1><p>你可以合并多个逻辑运算符来创建更长的复合表达式:<br><code><br>if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code><br>这个例子使用了多个 &amp;&amp; 和 || 运算符来创建一个更长的复合表达式。 不过, &amp;&amp; 和 || 运算符依然只能操作两个值, 所以，这实际上是三个小表达式链接起来的。 </p>
<p>备注</p>
<p>Swift 逻辑运算符 &amp;&amp; 和 || 是左联想的, 意思就是多个逻辑运算符的复合表达式，首先计算最左边的子表达式。</p>
<h1 id="显示括号"><a href="#显示括号" class="headerlink" title="显示括号"></a>显示括号</h1><p>虽然不是严格需要，但是包含括号还是有用的, 使得复杂表达式的意图很容易理解。 上述实例, 给第一部分加上括号很有用，会让它的意图很明显:<br><code><br>if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// Prints “Welcome!”<br></code><br>括号让第一部分作为独立可能的状态，这样在整个逻辑中就很清晰。 符合表达式的输出不变, 但是整体意图很清晰。 比起简洁，可读性是首选的。使用括号会让你的意图清晰明了。</p>
<h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><p>字符串是字符集合, 比如 “hello, world” 或者 “albatross”. Swift 字符串用 String 类型表示。 字符串内容有多种访问方法, 包括字符值的集合。</p>
<p>Swift的 String 和 Character 类型提供一个快速的, Unicode 方式来作用于你的文本。 字符串创建和操作的语法是轻量和可读的, 字面语法跟C类似。 字符串连接和使用加号运算符一样简单, 字符的可变性由选择常量还是变量来管理, 就像Swift中其他值。 你还可以使用字符串把常量,变量,字面量,和表达式插入更长的字符串, 在一个众所周知的字符串插值。 这让显示自定义字符串变得容易。</p>
<p>尽快语法简单, Swift的 String 类型是个快速, 现代化的字符串实现。 每个字符串有独立编码的 Unicode 字符组成, 提供用多种Unicode形式访问这些字符的支持。</p>
<h1 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h1><p>你可以在代码中为字符串预定义字符值。 字符串字面量是由（””）包围的固定的文字字符序列。</p>
<p>用字符串值作为一个常量或者变量的初始值:</p>
<p><code>let someString = “Some string literal value”</code><br>注意 Swift 推断someString 常量是一个 String 类型, 因为它用字符串值初始化。</p>
<h1 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h1><p>创建空字符串值作为更长字符串的起点, 或者给一个变量赋一个空字符串值, 或者用初始化方法来初始化一个新的字符串实例:<br><code><br>var emptyString = “”               // empty string literal<br>var anotherEmptyString = String()  // initializer syntax<br>// these two strings are both empty, and are equivalent to each other<br>Find out whether a String value is empty by checking its Boolean isEmpty property:</code></p>
<p>if emptyString.isEmpty {<br>    print(“Nothing to see here”)<br>}<br>// Prints “Nothing to see here”<br></p>
<h1 id="字符串易变性"><a href="#字符串易变性" class="headerlink" title="字符串易变性"></a>字符串易变性</h1><p>你来指定一个特定字符串能不能改变（或者突变），这种变化通过把它赋给一个变量实现。 (这种情况它是可以改变的), 或者赋值给一个常量实现 (这种情况它不能被改变):<br><code><br>var variableString = “Horse”<br>variableString += “ and carriage”<br>// variableString is now “Horse and carriage”</code></p>
<p>let constantString = “Highlander”<br>constantString += “ and another Highlander”<br>// this reports a compile-time error - a constant string cannot be modified<br></p>
<h1 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h1><p>Swift 的字符串类型是值类型。 如果你创建了一个新的字符串值, 这个字符串值在传给函数或者方法的时候被复制, 或者当它被赋值给一个常量或者变量的时候。这两种情况, 已存在字符串值的拷贝被创建, 新的拷贝被传递或者赋值, 而不是原来的字符串。 值类型在 Structures and Enumerations Are Value Types 中有描述。</p>
<p>很清楚你拥有精确的字符串值，而不用关心它从哪里来的。你可以确信传给你的字符串不会被改变,除非你自己改变它。</p>
<p>在幕后, Swift 的编译器优化了字符串的使用，这使得实际的拷贝只有真正需要的时候才会占用空间。 这就意味你使用字符串作为值类型总可以获得高性能。</p>
<h1 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h1><p>你可以用for-in 循环语句,通过它的字符属性来迭代访问每一个单独的字符:<br><code><br>for character in “Dog!🐶”.characters {<br>    print(character)<br>}<br>// D<br>// o<br>// g<br>// !<br>// 🐶<br></code></p>
<p>或者, 你可以创建一个单独的字符常量或者变量，这变量通过提供一个字符类型注释的单字符字符串值。:<br><code><br>let exclamationMark: Character = “!”<br>String values can be constructed by passing an array of Character values as an argument to its initializer:</code></p>
<p>let catCharacters: [Character] = [“C”, “a”, “t”, “!”, “🐱”]<br>let catString = String(catCharacters)<br>print(catString)<br>// Prints “Cat!🐱”<br></p>
<h1 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h1><p>字符串值可以通过加号连接成新的字符串:<br><code><br>let string1 = “hello”<br>let string2 = “ there”<br>var welcome = string1 + string2<br>// welcome now equals “hello there”<br></code><br>你也可以通过赋值运算符（+=）把字符串添加到已存在的字符串变量:<br><code><br>var instruction = “look over”<br>instruction += string2<br>// instruction now equals “look over there”<br>You can append a Character value to a String variable with the String type’s append() method:</code></p>
<p>let exclamationMark: Character = “!”<br>welcome.append(exclamationMark)<br>// welcome now equals “hello there!”<br></p>
<h1 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h1><p>String 字符串插入是构建新字符串的一种方法，这种方法通过混合常量,变量,字面量,表达式中的字面量来实现。每个你要插入的值都包括在括弧里,前面是一个反斜杠:<br><code><br>let multiplier = 3<br>let message = “(multiplier) times 2.5 is (Double(multiplier) * 2.5)”<br>// message is “3 times 2.5 is 7.5”<br></code><br>上面这个例子,  multiplier 的值以 (multiplier) 的形式插入到一个字符串。 这个占位符会被 multiplier 的实际值取代，当插值被计算创建新字符串的时候。</p>
<p>multiplier 的值是字符串后面大表达式的一部分。 这个表达式计算 Double(multiplier) <em> 2.5 的值，然后把结果 (7.5) 插入字符串。 这种情况下, 当它被包括进字符串字面量的时候，表达式就写作 (Double(multiplier) </em> 2.5) .</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode 是在不同写作体系中用作编码,表达,处理文字的一种国际标准。 让你可以用一种标准形式表示任何语言的任何字符, 在诸如文本文件或者网页等外部资源,去读写这些字符。 Swift 的字符串和字符是完全 Unicode 编译的。</p>
<h1 id="Unicode-标量"><a href="#Unicode-标量" class="headerlink" title="Unicode 标量"></a>Unicode 标量</h1><p>背后, Swift 的本地字符串类型建立于 Unicode 标量值。对应字符或者修饰符来说, 一个 Unicode 标量是唯一的一个21位数字, 例如 U+0061 是 LATIN SMALL LETTER A (“a”), 或者 U+1F425 是 FRONT-FACING BABY CHICK (“🐥”).<br>注意并非所有 21-位 Unicode 标量都会被赋值给一些给未来预留的字符标量。 分配给字符的标量通常有一个名字, 比如 LATIN SMALL LETTER A 和 FRONT-FACING BABY CHICK .</p>
<h1 id="字符串字面量里的特殊字符"><a href="#字符串字面量里的特殊字符" class="headerlink" title="字符串字面量里的特殊字符"></a>字符串字面量里的特殊字符</h1><p>字符串字面量可以包括下面的特殊字符:</p>
<p>转义字符 \0 (空字符), \ (反斜杠), \t (水平制表符), \n (换行), \r (回车), \” (双引号) and \’ (单引号)<br>任意一个 Unicode 标量, 写作 \u{n}, n 是 一个 1–8 位十六进制数字，这个数字有个和 有效的Unicode 编码点相等的值。<br>下面四个例子显示了特殊字符的编码。wiseWords 常量包括两个转义的双引号字符。 dollarSign, blackHeart, 和sparklingHeart 常量展示了Unicode 标量的格式:<br><code><br>let wiseWords = “\”Imagination is more important than knowledge\” - Einstein”<br>// “Imagination is more important than knowledge” - Einstein<br>let dollarSign = “\u{24}”        // $,  Unicode scalar U+0024<br>let blackHeart = “\u{2665}”      // ♥,  Unicode scalar U+2665<br>let sparklingHeart = “\u{1F496}” // 💖, Unicode scalar U+1F496<br></code></p>
<h1 id="扩展字形集"><a href="#扩展字形集" class="headerlink" title="扩展字形集"></a>扩展字形集</h1><p>Swift的每个字符类型的实例带包一个单独的扩展字形集。 一个扩展字形集是一个或者多个 Unicode 标量，这些标量（当合并时）生成一个人可读的字符。</p>
<p>这里有个例子。 字符 é 可以表示成单独的 Unicode 标量 é (LATIN SMALL LETTER E WITH ACUTE, 或者 U+00E9). 不过, 相同的字母也可以表示成标量集的一部分，字母 e (LATIN SMALL LETTER E, or U+0065), 后面跟着 COMBINING ACUTE ACCENT 标量 (U+0301).COMBINING ACUTE ACCENT 标量 应用于之前的标量, 在一个Unicode识别 文本渲染系统渲染的时候，把 e 变成 é.</p>
<p>在这两个例子里, 字符 é 表示为一个单独的Swift 字符值，这个值表示一个扩展字形集。 第一个例子, 集合包含一个单独的标量; 第二个例子, 是两个标量的集合:<br><code><br>let eAcute: Character = “\u{E9}”                         // é<br>let combinedEAcute: Character = “\u{65}\u{301}”          // e followed by ́<br>// eAcute is é, combinedEAcute is é<br></code><br>扩展字形集是一种灵活的方式去表示很多复杂脚本字符作为单独字符值。 比如, 来自朝鲜字母的朝鲜语音节可以表示成复合或者分离的序列。 在Swift里,这些表达都是合格的字符值:<br><code><br>let precomposed: Character = “\u{D55C}”                  // 한<br>let decomposed: Character = “\u{1112}\u{1161}\u{11AB}”   // ᄒ, ᅡ, ᆫ<br>// precomposed is 한, decomposed is 한<br></code><br>扩展字形集使得封闭标志的标量 (比如 COMBINING ENCLOSING CIRCLE, 或者 U+20DD) 可以装入其他 Unicode 标量作为一个单独字符值的一部分:<br><code><br>let enclosedEAcute: Character = “\u{E9}\u{20DD}”<br>// enclosedEAcute is é⃝<br></code><br>Unicode 局部指示器符号标量可以成对组合来生成一个单独的字符值, 比如 REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA) 和 REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8) 的组合:<br><code><br>let regionalIndicatorForUS: Character = “\u{1F1FA}\u{1F1F8}”<br>// regionalIndicatorForUS is 🇺🇸<br></code></p>
<h1 id="计算字符"><a href="#计算字符" class="headerlink" title="计算字符"></a>计算字符</h1><p>在字符串中获取字符值的数量, 可以使用字符串字符属性中的计数属性:<br><code><br>let unusualMenagerie = “Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪”<br>print(“unusualMenagerie has (unusualMenagerie.characters.count) characters”)<br>// Prints “unusualMenagerie has 40 characters”<br></code><br>注意 Swift 对字符值使用扩展字形集，意味着字符拼接和修改可能不会总是影响字符串的字符数。</p>
<p>例如, 如果你用四个字符的单词咖啡来初始化一个新字符串, 然后添加 COMBINING ACUTE ACCENT (U+0301) 到字符串的尾部, 最后字符的数量还是4, 第四个字符是 é, 而不是 e:<br><code><br>var word = “cafe”<br>print(“the number of characters in (word) is (word.characters.count)”)<br>// Prints “the number of characters in cafe is 4”</code></p>
<p>word += “\u{301}”    // COMBINING ACUTE ACCENT, U+0301</p>
<p>print(“the number of characters in (word) is (word.characters.count)”)<br>// Prints “the number of characters in café is 4”<br></p>
<h1 id="访问和修改字符串"><a href="#访问和修改字符串" class="headerlink" title="访问和修改字符串"></a>访问和修改字符串</h1><p>你可以通过方法和属性来访问和修改字符串, 或者用下标语法。</p>
<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><p>每个字符串值都有一个对应的索引类型, String.Index, 代表每个字符在字符串中的位置。</p>
<p>上面提到的,不同字符要求不等数量的内存, 所以为了决定哪个字符在一个特定的位置, 你必须从头到尾枚举每个 Unicode 标量。 因为这个原因, Swift 字符串不能通过整数值来索引。</p>
<p>使用 startIndex 属性访问字符串的首字符位置。 endIndex 属性是字符串中最后一个字符的位置。 因此, endIndex 属性不是一个字符串下标的有效参数。 如果一个字符串是空的, startIndex 和 endIndex 相等。</p>
<p>你可以用 index(before:) 和 index(after:) 字符串方法访问给定索引前后的索引, 你可以使用 index(_:offsetBy:) 方法代替多次调用这些方法。</p>
<p>你可以使用下标语法访问特定索引位置的字符。<br><code><br>let greeting = “Guten Tag!”<br>greeting[greeting.startIndex]<br>// G<br>greeting[greeting.index(before: greeting.endIndex)]<br>// !<br>greeting[greeting.index(after: greeting.startIndex)]<br>// u<br>let index = greeting.index(greeting.startIndex, offsetBy: 7)<br>greeting[index]<br>// a<br></code><br>尝试访问越界的索引和字符都会引发运行时的错误。<br><code><br>greeting[greeting.endIndex] // Error<br>greeting.index(after: greeting.endIndex) // Error<br></code><br>用字符属性中的索引属性获取字符串中的所有字符。<br><code><br>for index in greeting.characters.indices {<br>    print(“(greeting[index]) “, terminator: “”)<br>}<br>// Prints “G u t e n   T a g ! “<br></code></p>
<h1 id="插入和移除"><a href="#插入和移除" class="headerlink" title="插入和移除"></a>插入和移除</h1><p>在特定位置向字符串插入一个字符, 使用 insert(_:at:) 方法, 插入其他字符串内容到制定索引使用 insert(contentsOf:at:) 方法。<br><code><br>var welcome = “hello”<br>welcome.insert(“!”, at: welcome.endIndex)<br>// welcome now equals “hello!”</code></p>
<p>welcome.insert(contentsOf:” there”.characters, at: welcome.index(before: welcome.endIndex))<br>// welcome 现在等于 “hello there!”<br><br>从指定索引移除字符, 使用 remove(at:) 方法, 在指定范围移除一个字串, 用 removeSubrange(_:) 方法:<br><code><br>welcome.remove(at: welcome.index(before: welcome.endIndex))<br>// welcome 现在等于 “hello there”</code></p>
<p>let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endindex welcome.removesubrange(range)="" welcome="" 现在等于="" "hello"="" <="" code=""><br>备注</welcome.endindex></p>
<p>你可以使用 insert(<em>:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(</em>:) 这些方法,只要符合 RangeReplaceableCollection 协议的任何类型。 这包括 String, 还有集合类型 Array, Dictionary, 和 Set.</p>
<h1 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h1><p>Swift 提供三种方式来比较文本值: 字符串和字符等式, 前缀等式, 和后缀等式。</p>
<h1 id="字符串和字符等式"><a href="#字符串和字符等式" class="headerlink" title="字符串和字符等式"></a>字符串和字符等式</h1><p>字符串和字符等式用“equal to” 运算符 (==) 和 “not equal to” 运算符 (!=) 来判断, 在 Comparison Operators 中描述:<br><code><br>let quotation = “We’re a lot alike, you and I.”<br>let sameQuotation = “We’re a lot alike, you and I.”<br>if quotation == sameQuotation {<br>    print(“These two strings are considered equal”)<br>}<br>// Prints “These two strings are considered equal”<br></code><br>两个字符串的值 (或者两个字符的值) 如果他们的扩展字形集相同,就被认为是相等的。 扩展字形集如果有相同的语义和表现形式，就是相等的, 即使他们背后是由不同 Unicode 标量组成。</p>
<p>比如, LATIN SMALL LETTER E WITH ACUTE (U+00E9) 常规等于 LATIN SMALL LETTER E (U+0065) 加上 COMBINING ACUTE ACCENT (U+0301). 两种扩展字形集都是有效的方式来表示字符 é, 隐藏它们被认为相等:<br><code><br>// “Voulez-vous un café?” using LATIN SMALL LETTER E WITH ACUTE<br>let eAcuteQuestion = “Voulez-vous un caf\u{E9}?”</code></p>
<p>// “Voulez-vous un café?” using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT<br>let combinedEAcuteQuestion = “Voulez-vous un caf\u{65}\u{301}?”</p>
<p>if eAcuteQuestion == combinedEAcuteQuestion {<br>    print(“These two strings are considered equal”)<br>}<br>// Prints “These two strings are considered equal”<br><br>相反, LATIN CAPITAL LETTER A (U+0041, 或者 “A”), 英语中使用, 不等于俄语中使用的 CYRILLIC CAPITAL LETTER A (U+0410, 或者 “А”)。 这两个字符看上去相似, 但是语义不同:<br><code><br>let latinCapitalLetterA: Character = “\u{41}”</code></p>
<p>let cyrillicCapitalLetterA: Character = “\u{0410}”</p>
<p>if latinCapitalLetterA != cyrillicCapitalLetterA {<br>    print(“These two characters are not equivalent.”)<br>}<br>// Prints “These two characters are not equivalent.”<br><br>备注</p>
<p>字符串和字符比较在Swift中不是地区敏感的。</p>
<h1 id="前缀和后缀等式"><a href="#前缀和后缀等式" class="headerlink" title="前缀和后缀等式"></a>前缀和后缀等式</h1><p>判断字符串是否有一个特定前缀或者后缀, 调用字符串的 hasPrefix(<em>:) and hasSuffix(</em>:) 方法, 两个方法都一个 String 类型，然后返回一个布尔值。 </p>
<p>下面这个例子有一个字符串数组，用来表示场景的位置,它们来自莎士比亚的罗密欧与朱丽叶的前两个表演:<br><code><br>let romeoAndJuliet = [<br>    “Act 1 Scene 1: Verona, A public place”,<br>    “Act 1 Scene 2: Capulet’s mansion”,<br>    “Act 1 Scene 3: A room in Capulet’s mansion”,<br>    “Act 1 Scene 4: A street outside Capulet’s mansion”,<br>    “Act 1 Scene 5: The Great Hall in Capulet’s mansion”,<br>    “Act 2 Scene 1: Outside Capulet’s mansion”,<br>    “Act 2 Scene 2: Capulet’s orchard”,<br>    “Act 2 Scene 3: Outside Friar Lawrence’s cell”,<br>    “Act 2 Scene 4: A street in Verona”,<br>    “Act 2 Scene 5: Capulet’s mansion”,<br>    “Act 2 Scene 6: Friar Lawrence’s cell”<br>]<br></code><br>你可以用 hasPrefix(<em>:) 方法用 romeoAndJuliet 数组来技术表演1中的场景数:<br><code><br>var act1SceneCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasPrefix(“Act 1 “) {<br>        act1SceneCount += 1<br>    }<br>}<br>print(“There are (act1SceneCount) scenes in Act 1”)<br>// Prints “There are 5 scenes in Act 1”<br></code><br>相似的, 用 hasSuffix(</em>:) 方法来计算发生在 Capulet’s mansion 和 Friar Lawrence’s cell 的场景数:<br><code><br>var mansionCount = 0<br>var cellCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasSuffix(“Capulet’s mansion”) {<br>        mansionCount += 1<br>    } else if scene.hasSuffix(“Friar Lawrence’s cell”) {<br>        cellCount += 1<br>    }<br>}<br>print(“(mansionCount) mansion scenes; (cellCount) cell scenes”)<br>// Prints “6 mansion scenes; 2 cell scenes”<br></code></p>
<h1 id="Unicode-字符串表示"><a href="#Unicode-字符串表示" class="headerlink" title="Unicode 字符串表示"></a>Unicode 字符串表示</h1><p>当一个 Unicode 字符串写入文本文件或者别的存储时,字符串里的 Unicode 标量会以一些Unicode 定义的编码形式进行编码。 每种字符串编码在人们熟知的代码单元块中。 包括 UTF-8 编码 (把字符串编码成一个 8-位的代码单元), UTF-16 编码 (把字符串编码成一个16-位的代码单元), 和 UTF-32 编码 (把字符串编码成 32-位代码单元)</p>
<p>Swift 提供了几种不同的方式去访问字符串的Unicode 形式。你可以用for-in语句遍历字符串, 访问作为Unicode 扩展字形集的单个字符值。这个过程在 Working with Characters 描述。</p>
<p>或者, 或者用以下三种形式来访问字符串的值:</p>
<p>UTF-8 代码单元集合 (用字符串的utf8属性来访问)<br>UTF-16 代码单元集合 (用字符串的utf16属性来访问)<br>21-位 Unicode 标量值的集合, 等于字符串的 UTF-32 编码方式 (用字符串的 unicodeScalars 属性访问)<br>下面的例子展示字符串的不同表现形式,字符串由字符 D, o, g, ‼ (DOUBLE EXCLAMATION MARK, 或者 Unicode scalar U+203C), 和 🐶 字符 (DOG FACE, 或者 Unicode scalar U+1F436)组成:</p>
<p>let dogString = “Dog‼🐶”</p>
<h1 id="UTF-8-形式"><a href="#UTF-8-形式" class="headerlink" title="UTF-8 形式"></a>UTF-8 形式</h1><p>你可以通过遍历字符串的utf8属性来访问它的 UTF-8 表现形式。 这是属性是 String.UTF8View, 这是无符号的 8-位 (UInt8)值的集合, 每个字节一个:</p>
<div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png"><br></div><br><code><br>for codeUnit in dogString.utf8 {<br>    print(“(codeUnit) “, terminator: “”)<br>}<br>print(“”)<br>// 68 111 103 226 128 188 240 159 144 182<br></code><br>上面这个例子, 前三个十进制 codeUnit 值 (68, 111, 103) 代表字符 D, o, 和 g, 它们的 UTF-8 形式和它们的 ASCII 表现形式一样。 接下来三个十进制 codeUnit 值 (226, 128, 188) 是双感叹号的三个字节的 UTF-8 形式。 最后四个 codeUnit 值 (240, 159, 144, 182) 是个四个字节的 UTF-8 形式，代表小狗的脸字符。<br><br># UTF-16 形式<br><br>你可以通过遍历字符串的utf16属性来访问它的 UTF-16 形式。 这个属性是 String.UTF16View, 它是无符号16-位 (UInt16)的值的集合, 每个16-位代码单元一个:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png"><br></div><br><code><br>for codeUnit in dogString.utf16 {<br>    print(“(codeUnit) “, terminator: “”)<br>}<br>print(“”)<br>// Prints “68 111 103 8252 55357 56374 “<br></code><br>同样, 前三个 codeUnit 值 (68, 111, 103) 代表字符 D, o, 和 g, 它们的 UTF-16 代码单元和它们的 UTF-8 形式一样(因为这些 Unicode 标量表示 ASCII 字符).<br><br>第四个 codeUnit 值 (8252) 是十六进制 203C的十进制数值, 用 Unicode 标量 U+203C表示双感叹号字符。 在 UTF-16 里表示为一个单独的编码单元。<br><br>第五六个 codeUnit 值 (55357 和 56374) 狗脸字符。 这些值是高八位 U+D83D (十进制值是 55357) 和一个第八位 U+DC36 (十进制值 56374)。<br><br># Unicode 标量形式<br><br>你可以通过遍历字符串的 unicodeScalars 属性来访问它的Unicode 标量形式。 这个是属性是 UnicodeScalarView,它是类型 UnicodeScalar 值的集合。<br><br>每个 UnicodeScalar 有一个值属性，它返回这个标量的 21-位值, 用一个 UInt32 值表示:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png"><br></div><br><code><br>for scalar in dogString.unicodeScalars {<br>    print(“(scalar.value) “, terminator: “”)<br>}<br>print(“”)<br>// Prints “68 111 103 8252 128054 “<br></code><br>前三个 UnicodeScalar 值 (68, 111, 103) 再次代表 D, o, 和 g.<br><br>第四个 codeUnit 值 (8252) 是十六进制 203C 的十进制值, 是双感叹的 Unicode 标量 U+203C 。<br><br>第五个和最后一个 UnicodeScalar 值, 128054, 是十六进制 1F436的十进制值, 是狗脸字符的的 Unicode 标量 U+1F436。<br><br>作为查询它们值属性的替代, 每个 UnicodeScalar 值也可以用来构建新的字符串, 例如用做字符串插值:<br><code><br>for scalar in dogString.unicodeScalars {<br>    print(“(scalar) “)<br>}<br>// D<br>// o<br>// g<br>// ‼<br>// 🐶<br></code><br><br># 集合类型<br>Swift 提供了三个主要的集合类型, 数组, 集合, 和字典, 用来存储值的集合。 数组是有序的。 集合是唯一值的无序集。 字典是健值匹配的无序集合。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png"><br></div><br>数组, 集合, 和字典在 Swift 里总是清楚的知道存储的值的类型和能够存储的健。 这就意味着你不能往集合里插入错误类型的值。也意味着 你知道可以从集合里或者的值的类型。<br><br>备注<br><br>Swift 的数组, 集合, 和字典类型是用泛型集合实现的。更多泛型和集合, 参见 Generics.<br><br># 集合的不稳定性<br><br>如果你创建了一个数组, 一个集合, 或者一个字典, 然后赋给一个变量。创建的这个集合就是可变的。这就意味着你可以改变这个集合，方式是通过添加, 移除, 或者改变集合里的项。如果把它们赋给一个常量, 这个集合就是不可改变的, 它的大小和内容都不能改变。<br><br>备注<br><br>如果集合不需要变化，在所有情况下创建不可变的集合是个好的实践。这样做的好处是让你容易理解自己的代码,同时让编译器可以优化你创建的集合。<br><br># 数组<br><br>数组有序存储同类型的值。 相同的值可以多次出现在数组的不同位置。<br><br>备注<br><br>Swift的数组类型跟 Foundation的 NSArray 类相桥接。<br><br># 数组类型缩写语法<br><br>T数组类型的全写法是 Array<element>, 这里Element是数组运行存储的值类型。 你可以缩写数组类型为[Element]. 尽管这两种形式功能一样, 缩写是优先考虑的而且这个教程后面一直这么写。<br><br># 创建空数组<br><br>你可以用初始化语法创建一个特定类的空数组:<br><code><br>var someInts = <a href="">Int</a><br>print(“someInts is of type [Int] with (someInts.count) items.”)<br>// Prints “someInts is of type [Int] with 0 items.”<br></code><br>注意 someInts 变量的类型经过初始化类型被推断为 [Int]<br><br>或者, 如果上下文已经提供类型信息, 例如一个函数参数或者一个确定类型的变量或者常量, 你可以用空的字面量来创建空数组, 这个数组通常写作 [] (一个空的中括号对):<br><code><br>someInts.append(3)<br>// someInts now contains 1 value of type Int<br>someInts = []<br>// someInts is now an empty array, but is still of type [Int]<br></code><br># 用默认值创建数组<br><br>Swift的数组类型也提供了一初始化器来创建相同默认值固定大小的数组。 给初始化器传一个匹配类型的默认值 (调用 repeating): 然后是在新数组中需要重复的值的个数 (调用 count):<br><code><br>var threeDoubles = Array(repeating: 0.0, count: 3)<br>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]<br></code><br># 通过合并数组创建数组<br><br>你可以通过合并两个已存在的数组来创建新的数组,这两个数组只要类型匹配就可以通过加法运算符 (+)来合并。 新数组的类型从合并的数组可以推断出来:<br><code><br>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)<br>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]<br><br>var sixDoubles = threeDoubles + anotherThreeDoubles<br>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]<br></code><br># 用字面量创建数组<br><br>你也可以用字面量来初始化数组, 这是种快速写一个或者多个数组值的方式。 一个数组字面量写作一列值, 用逗号分开, 一对方括号包括起来:<br><code><br>[value 1, value 2, value 3]<br></code><br>下面的的例子创建了一个购物列表来存储字符串值:<br><code><br>var shoppingList: [String] = [“Eggs”, “Milk”]<br>// shoppingList has been initialized with two initial items<br>/code&gt;<br>购物列表变量定义为 “字符串值的数组”, 写作 [String]. 因为这个数组已经指定一个字符串类型值, 它就值运行存储字符串值。 这里, 购物列表数组用两个字符串值 (“Eggs” 和 “Milk”)来初始化, 写在数字字面量里。<br><br>备注<br><br>这个数组被声明为一个变量而不是一个常量，是因为在下面的例子将有更多的项目加入这个购物列表。<br><br>这种情况, 数组字面量只包含两个字符串值。 这个匹配购物列表变量的声明类型 (只能包括字符串值的数组), 用数组字面量赋值来初始化购物列表是被允许的一种方式。<br><br>由于 Swift 的类型推断, 如果你用相同类型的字面量来初始化数组,就不需要写出数组的类型。购物列表的初始化可以简写成以下形式:<br><code><br>var shoppingList = [“Eggs”, “Milk”]<br></code><br>因为数组里所有的值都是同样的类型, Swift 能够推断出 [String] 用作购物列表变量是正确的类型。<br><br># 访问和修改数组<br><br>你可以通过数组的方法,属性或者下标语法来访问和修改一个数组。<br><br>为了确定数组的项数, 使用只读属性count:<br><code><br>print(“The shopping list contains (shoppingList.count) items.”)<br>// Prints “The shopping list contains 2 items.”<br></code><br>使用布尔属性 isEmpty 来判断数量属性是否0:<br><code><br>if shoppingList.isEmpty {<br>    print(“The shopping list is empty.”)<br>} else {<br>    print(“The shopping list is not empty.”)<br>}<br>// Prints “The shopping list is not empty.”<br></code><br>通过调用 append(<em>:) 方法你可以在数组最后添加新项:<br><code><br>shoppingList.append(“Flour”)<br>// shoppingList now contains 3 items, and someone is making pancakes<br></code><br>或者, 使用赋值运算 (+=) 添加一个或多个符合的项:<br><code><br>shoppingList += [“Baking Powder”]<br>// shoppingList now contains 4 items<br>shoppingList += [“Chocolate Spread”, “Cheese”, “Butter”]<br>// shoppingList 现在包含 7项<br></code><br>用下标语法从数组中获取一个值, 在数组后的方括号里传入你想得到值的索引:<br><code><br>var firstItem = shoppingList[0]<br>// firstItem is equal to “Eggs”<br></code><br>备注<br><br>数组第一项的索引是0,不是1。 Swift 数组总是基于0开始索引。<br><br>你可以使用下标语法去改变给定索引下的值:<br><code><br>shoppingList[0] = “Six eggs”<br>// 第一项现在是 “Six eggs” 而不是 “Eggs”<br></code><br>你还可以通过下标语法一次改变一个范围的值, 尽管取代值跟被取代的长度不同。 下面的例子用 “Bananas” 和 “Apples” 取代了 “Chocolate Spread”, “Cheese”, 和 “Butter”:<br><code><br>shoppingList[4…6] = [“Bananas”, “Apples”]<br>// shoppingList 现在包含 6项<br></code><br>备注<br><br>你不能用下标语法添加新的项到数组最后。<br><br>在特定位置插入新项, 调用数组插入方法 insert(</em>:at:):<br><code><br>shoppingList.insert(“Maple Syrup”, at: 0)<br>// shoppingList now contains 7 items<br>// “Maple Syrup” is now the first item in the list<br></code><br>调用 insert(<em>:at:) 方法在购物列表头插入一个新的项 “Maple Syrup”, 用索引0标明。<br><br>类似的, 移除一项使用 remove(at:) 方法。 这个方法移除指定索引的项然后返回这个移除项 (尽管你可能无视这个返回值):<br><code><br>let mapleSyrup = shoppingList.remove(at: 0)<br>// 位于索引0的项被移除<br>// 购物列表现在包含6项, 没有 Maple Syrup<br>// mapleSyrup 常量现在等于被移除的 “Maple Syrup” 字符串<br></code><br>备注<br><br>如果越界访问数组的值, 你会触发运行时错误。你可以用它跟数组个数属性对比来判断索引的有效性。除了个数为0的情况 (意味着数组是空的), 最大索引值通常是数组个数 - 1, 因为数组是从0开始计数的。<br><br>一个数据项被移除数组空隙就会闭合,所以索引 0 的值再次等于 “Six eggs”:<br><code><br>firstItem = shoppingList[0]<br>// firstItem 现在等于 “Six eggs”<br></code><br>如果你想移除最后一项, 使用 removeLast() 方法而不是 remove(at:) 方法,这样就避免需要查询数组的个数属性。和 remove(at:) 方法一样, removeLast() 返回移除的项:<br><code><br>let apples = shoppingList.removeLast()<br>// 最后一项被移除<br>// 购物列表现在包含5项, 没有苹果<br>// apples 常量现在等于被移除的 “Apples” 字符串<br></code><br># 遍历数组<br><br>你可以用for-in循环来遍历数组中的所有值集:<br><code><br>for item in shoppingList {<br>    print(item)<br>}<br>// Six eggs<br>// Milk<br>// Flour<br>// Baking Powder<br>// Bananas<br></code><br>如果需要数据项的值和整数索引, 使用 enumerated() 方法来遍历数组。对于数组中的每一项, enumerated() 方法返回一个包含索引和值的元组。 整数以0开始每项递增; 如果你遍历整个数组, 这些整数匹配数据项的索引。你可以分解元组到临时的常量或者变量,来作为迭代的部分:<br><code><br>for (index, value) in shoppingList.enumerated() {<br>    print(“Item (index + 1): (value)”)<br>}<br>// Item 1: Six eggs<br>// Item 2: Milk<br>// Item 3: Flour<br>// Item 4: Baking Powder<br>// Item 5: Bananas<br></code><br><br># 集合<br><br>集合无序存储同样类型的不同值。 如果排序不重要可以选择使用集合代替数组, 或者你需要确保每项只出现一次。<br><br>备注<br><br>Swift 的 Set 类型跟 Foundation 的 NSSet 类桥接。<br><br># 集合类型的哈希值<br><br>集合里一个类型为了存储就必须可哈希—就是说, 这个类型必须提供一个方式去计算自己的哈希值。 一个哈希值是一个整型值, 这对于相等的对象都是一样的, 如果 if a == b, 那么 a.hashValue == b.hashValue.<br><br>所有 Swift 的基本类型默认都是可哈希的 (比如 String, Int, Double, 和 Bool), 可以被用作集合值类型或者字典建类型。 枚举case 值没有相应的值默认也是可哈希的。<br><br>备注<br><br>你可以使用自定义类型作为集合值类型或者字典健类型,通过让它们遵守Swift 标准库中的 Hashable 协议。 符合协议的类型必须提供一个可获取的整形属性 hashValue. 在相同程序中的不同执行,或者在不同程序中, 类型的哈希属性返回的值不要求相同。<br><br>因为 Hashable 协议符合 Equatable, 符合类型必须提等号运算符 (==)的实现。 Equatable 协议要求任何符合==实现的都是一个相等关系。 就是说, ==  的实现必须满足下面的条件, 对于 a, b, 和 c 所有值:<br><br>a == a (自反性)<br><br>a == b 表示 b == a (对称性)<br><br>a == b &amp;&amp; b == c 表示 a == c (传递性)<br><br># 集合类型语法<br><br>集合类型写作 Set<element>, 这里 Element 是集合允许存储的类型。 跟数组不同, 集合没有等价的缩写形式。<br><br># 创建和初始化空集合<br><br>你可以通过使用初始化器语法创建特定类型的空集合:<br><code><br>var letters = Set<character>()<br>print(“letters is of type Set<character> with (letters.count) items.”)<br>// 打印 “letters is of type Set<character> with 0 items.”<br></character></character></character></code><br>备注<br><br>letters 变量的类型推断为 Set<character>, 通过初始化器的类型。<br><br>或者, 如果上下文已经提供了类型信息, 比如一个函数参数或者一个已经指定类型的变量和常量, 你可以用一个空的数组字面量来创建一个空集合:<br><code><br>letters.insert(“a”)<br>// letters 现在包含了一个字符类型的值<br>letters = []<br>// letters 现在是一个空集合, 但是依然是 Set<character> 类型<br></character></code><br># 用数组字面量创建集合<br><br>你可以用数组字面量初始化一个集合, 这是一个速写方式来给一个集合赋值。<br><br>下面的例子创建一个存储字符串值的集合 favoriteGenres:<br><code><br>var favoriteGenres: Set<string> = [“Rock”, “Classical”, “Hip hop”]<br>// favoriteGenres 有了三个初始值<br></string></code><br>favoriteGenres 变量声明成 “字符串值的集合”, 写作 Set<string>. 因为这个集合指定了一个字符串的值类型, 它只允许存储字符串值, favoriteGenres 集合用三个字符串 (“Rock”, “Classical”, 和 “Hip hop”)来初始化, 写在一个数组字面量里。<br><br>备注<br><br>favoriteGenres 集合声明成一个变量而不是一个常量, 这是因为添加和移除的项在下面的示例里。<br><br>集合通过数组字面量不能推断出类型, 所以类型必须显示声明。 不过, 由于Swift的类型推断, 如果数组字面量包含的值类型相同,你就不需要写集合的类型。favoriteGenres 初始化可以简写如下:<br><code><br>var favoriteGenres: Set = [“Rock”, “Classical”, “Hip hop”]<br></code><br>因为数组字面量里的值都是同样类型, Swift 可以推断 Set<string> 用作favoriteGenres 变量是正确的类型。<br><br># 访问和修改集合<br><br>你可以通过集合的方法和属性来访问和修改它。<br><br>为了得到集合的项数, 使用只读的 count 属性:<br><code><br>print(“I have (favoriteGenres.count) favorite music genres.”)<br>// 打印 “I have 3 favorite music genres.”<br></code><br>使用布尔属性 isEmpty 快速判断 count 属性是否等于 0:<br><code><br>if favoriteGenres.isEmpty {<br>    print(“As far as music goes, I’m not picky.”)<br>} else {<br>    print(“I have particular music preferences.”)<br>}<br>// 打印 “I have particular music preferences.”<br></code><br>调用集合的 insert(</string></string></character></element></em>:) 方法插入一个新项:<br><code><br>favoriteGenres.insert(“Jazz”)<br>// favoriteGenres 现在包含 4 项<br></code><br>你可以用集合的 remove(<em>:) 方法从集合里移除项, 如果它是集合一员的话, 然后返回被移除的项, 如果集合不包含这项就返回nil。 或者, 移除所有项可以用 removeAll() 方法。<br><code><br>if let removedGenre = favoriteGenres.remove(“Rock”) {<br>    print(“(removedGenre)? I’m over it.”)<br>} else {<br>    print(“I never much cared for that.”)<br>}<br>// 打印 “Rock? I’m over it.”<br></code><br>检查集合是否包含特定项, 用 contains(</em>:) 方法。<br><code><br>if favoriteGenres.contains(“Funk”) {<br>    print(“I get up on the good foot.”)<br>} else {<br>    print(“It’s too funky in here.”)<br>}<br>// 打印 “It’s too funky in here.”<br></code><br># 遍历集合<br><br>你可以用for-in循环遍历集合的值。<br><code><br>for genre in favoriteGenres {<br>    print(“(genre)”)<br>}<br>// Jazz<br>// Hip hop<br>// Classical<br></code><br><br>Swift 的集合类型是无序的。以特定顺序去遍历集合的值, 使用 sorted() 方法, 这个方法返回一个值数组,按照小于运算符排序。<br><code><br>for genre in favoriteGenres.sorted() {<br>    print(“(genre)”)<br>}<br>// Classical<br>// Hip hop<br>// Jazz<br></code><br># 集合操作<br><br>你可以有效进行基础的集合操作, 比如合并两个集合, 判断两个集合是否有共同值, 或者判读两个集合是否包含所有,几个,或者没有任何相同值。<br><br># 基本集合操作<br><br>下面的图描述了两个集合a 和 b, 共享区域表示集合操作结果。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png"><br></div><br>用 intersection(<em>:) 方法创建交集。<br>用 symmetricDifference(</em>:) 方法创建交集之外的集合。<br>用 union(<em>:) 方法创建并集。<br>用 subtracting(</em>:) 方法创建去掉指定集合的集合。<br><code><br>let oddDigits: Set = [1, 3, 5, 7, 9]<br>let evenDigits: Set = [0, 2, 4, 6, 8]<br>let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]<br><br>oddDigits.union(evenDigits).sorted()<br>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>oddDigits.intersection(evenDigits).sorted()<br>// []<br>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()<br>// [1, 9]<br>oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()<br>// [1, 2, 9]<br></code><br># 集合成语和等式<br><br>下面的图描述了三个集合 a, b 和 c, 重叠区域表示集合共享的元素。 集合a是集合b的超集, 因为a包含b的所有元素。 相反, 集合b是集合a的子集, 因为b中的元素都包含在集合a中。 集合b与集合c不相交, 因为它们没有共同的元素。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png"><br></div><br>用相等运算符 (==) 判断两个集合是否所有值都相同。<br>用 isSubset(of:) 方法判断一个集合是否是另外一个集合的字集。<br>用 isSuperset(of:) 方法判断一个集合是否是另外一个集合的超集。<br>用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法判断一个集合是否是一个子集或者超集, 但是不等于一个指定的集合。用 isDisjoint(with:) 方法判断是否两个集合不相交。<br><code><br>let houseAnimals: Set = [“🐶”, “🐱”]<br>let farmAnimals: Set = [“🐮”, “🐔”, “🐑”, “🐶”, “🐱”]<br>let cityAnimals: Set = [“🐦”, “🐭”]<br><br>houseAnimals.isSubset(of: farmAnimals)<br>// true<br>farmAnimals.isSuperset(of: houseAnimals)<br>// true<br>farmAnimals.isDisjoint(with: cityAnimals)<br>// true<br></code><br># 字典<br><br>字典无序存储匹配的同类型的健值。每个值对应一个唯一的健, 它作为值在字典里的标识符。 跟数组项不同, 字典里的项是无序的。如果基于标识符查找值你可以用字典, 很像真实世界字典的用法。<br><br># 字典类型速记语法<br><br>Swift 字典类型完整写法是 Dictionary<key, value="">, Key 是可以用作字典值的值类型, Value 是字典为健存储的值类型。<br><br>备注<br><br>字典 Key 类型一定要符合 Hashable 协议, 跟集合值类型一样。<br><br>你也可以字典类型的简写形式 [Key: Value]. 尽管两个形式功能一样, 简写形式优先使用并贯穿整个教程。<br><br># 创建一个空字典<br><br>跟数组一样, 你可用用初始化语法创建一个特定类型的字典:<br><code><br>var namesOfIntegers = <a href="">Int: String</a><br>// namesOfIntegers is an empty [Int: String] dictionary<br></code><br>这个例子定义了一个空字典,类型是 [Int: String],用来存储人类可读的整数名字。健是整形, 值是字符串类型。<br><br>如果上下文已经提供了类型信息, 你可以用一个空的字典字面量来创建一个空字典, 写作 [:] (一对中括号中间一个冒号):<br><code><br>namesOfIntegers[16] = “sixteen”<br>// namesOfIntegers 现在包含 1 key-value pair<br>namesOfIntegers = [:]<br>// namesOfIntegers 再次成为空,类型是[Int: String]<br></code><br># 用字面量创建字典<br><br>你还可以用字面量来初始化一个字典, 跟早前数组字面量语法相似。字典字面量是定义一个或者多个键值对集合的速写方法。<br><br>键值对是健和值的组合。 在一个字典字面量里, 健和值在键值对里用冒号分开。 键值对写作一个列表, 用逗号分开, 包含在一对中括号里:<br><code><br>[key 1: value 1, key 2: value 2, key 3: value 3]<br></code><br>下面的例子创建一个字典来存储国际机场名字。在这个字典里, 健是三个字母的国际航空公司编码, 值是机场名:<br><code><br>var airports: [String: String] = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br></code><br>airports 字典类型是 [String: String], 意思是 “一个字典健值都是字符串类型”.<br><br>备注<br><br>airports 字典声明成一个变量而非常量, 因为下面的例子需要添加更多机场进去。<br><br>airports 用两个键值对字面量初始化。第一个键值对有一个健 “YYZ” 和一个值 “Toronto Pearson”. 第二个键值对有一个健 “DUB” 和一个值”Dublin”.<br><br>字面量包含两个 String: String 对。 简直类型匹配机场类型的变量声明 (一个字典只有字符串健和字符串值), 所以字面量赋值是允许的,可以用来初始化机场字典。<br><br>跟数组一样, 如果你用相同类型的键值字典初始化，你就不需要写出字典的声明类型。初始化方法可以简写如下:<br><code><br>var airports = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br></code><br>因为字面量的所有健类型都是一样的, 同样所有的值也是, Swift 可以推断出来 [String: String] 是正确的类型声明。<br><br># 访问和修改字典<br><br>你可以通过字典的方法和属性来访问和修改它, 或者使用下标语法。<br><br>跟数组一样, 使用count 属性获取字典的项数:<br><code><br>print(“The airports dictionary contains (airports.count) items.”)<br>// 打印 “The airports dictionary contains 2 items.”<br></code><br>用 isEmpty 属性判断count 属性是否等于 0:<br><code><br>if airports.isEmpty {<br>    print(“The airports dictionary is empty.”)<br>} else {<br>    print(“The airports dictionary is not empty.”)<br>}<br>// 打印 “The airports dictionary is not empty.”<br></code><br>你可以用下标语法往字典添加新项。 使用对应的类型的键作为下标索引, 并赋一个对应的新值:<br><code><br>airports[“LHR”] = “London”<br>// airports 现在包含 3 项<br></code><br>你可以用下标语法改变指定键对应的值:<br><code><br>airports[“LHR”] = “London Heathrow”<br>// “LHR” 的值已经变成”London Heathrow”<br></code><br>作为下标的替代方案, 用字典的 updateValue(<em>:forKey:) 方法设置或者更新指定键的值。 跟上面下标实例一样,  updateValue(</em>:forKey:) 方法在键不存在时设置值, 如果键存在则进行更新。和下标不像的是, updateValue(<em>:forKey:) 方法在执行更新后返回老的值。 这个可以让你知道更新是否生效。<br><br>updateValue(</em>:forKey:) 方法返回可选类型的值。对个存储字符串值的字典来说, 比如, 这个方法返回 String?, 或者 “optional String”. 可选值包括未更新前存在的键对应的老值, 如果值不存在则包括nil:<br><code><br>if let oldValue = airports.updateValue(“Dublin Airport”, forKey: “DUB”) {<br>    print(“The old value for DUB was (oldValue).”)<br>}<br>// 打印 “The old value for DUB was Dublin.”<br></code><br>你可以用下标语法获取特定键对应的值。因为有可能去请求不存在值的键, 字典的下标就会返回一个可选值。 如果字典包含请求键对应的值, 下标就返回一个可选值，这个值包含这个键对应的存在的值。否则返回 nil:<br><code><br>if let airportName = airports[“DUB”] {<br>    print(“The name of the airport is (airportName).”)<br>} else {<br>    print(“That airport is not in the airports dictionary.”)<br>}<br>// 打印 “The name of the airport is Dublin Airport.”<br></code><br>你可以通过把键对应的值赋空的方式,用下标语法从字典移除一个键值对:<br><code><br>airports[“APL”] = “Apple International”<br>// “Apple International” is not the real airport for APL, so delete it<br>airports[“APL”] = nil<br>// APL 现在已经从字典移除<br></code><br>或者, 用 removeValue(forKey:) 这个方法来移除。 这个方法移除的键值对如果存在返回被移除的值,否则返回nil:<br><code><br>if let removedValue = airports.removeValue(forKey: “DUB”) {<br>    print(“The removed airport’s name is (removedValue).”)<br>} else {<br>    print(“The airports dictionary does not contain a value for DUB.”)<br>}<br>// Prints “The removed airport’s name is Dublin Airport.”<br></code><br># 遍历字典<br><br>你用for-in 循环来遍历字典。 字典中的每一项都以 (key, value) 元组形式返回, 你可以分解元组到临时的变量或者常量:<br><code><br>for (airportCode, airportName) in airports {<br>    print(“(airportCode): (airportName)”)<br>}<br>// YYZ: Toronto Pearson<br>// LHR: London Heathrow<br></code><br><br>你可以通过访问字典的键值属性来获取键值的集合:<br><code><br>for airportCode in airports.keys {<br>    print(“Airport code: (airportCode)”)<br>}<br>// Airport code: YYZ<br>// Airport code: LHR<br>for airportName in airports.values {<br>    print(“Airport name: (airportName)”)<br>}<br>// Airport name: Toronto Pearson<br>// Airport name: London Heathrow<br></code><br>如果你想使用字典的键值的数组实例, 用键值来初始化一个新的数组:<br><code><br>let airportCodes = <a href="airports.keys">String</a><br>// airportCodes is [“YYZ”, “LHR”]<br><br>let airportNames = <a href="airports.values">String</a><br>// airportNames 是 [“Toronto Pearson”, “London Heathrow”]<br></code><br>Swift的字典类型无序的。 为了用特定顺序去遍历字典的键值, 用这个 sorted() 方法。<br><br># 控制流<br>Swift 提供了一系列控制流语句。 包括 while 循环来执行多次任务; if, guard, 金额 switch 语句来再不同条件这些不同代码; 还有 break 和 continue 来转移控制流。<br><br>Swift 同时提供了 for-in 循环使得遍历数组, 字典, 范围, 字符串, 和其他序列变得容易。<br><br>Swift的 switch 语句比多数类C语言相同语句更加高效有力。 因为Swift 的 switch 语句的分支不会落到下一分支, 这就避免了C常见的错误。 分支可以匹配不同的模式, 包括区间匹配, 元组, 转换成指定类型。 switch 分支匹配的值可以绑定到临时的变量或者常量。每个分支可以用where 族来表达符合匹配条件。<br><br># For-In 循环<br><br>你使用 for-in 循环来遍历序列, 比如数值范围, 数组中的项, 字符串中的字符。<br><br>下面的例子是五倍乘法表的前几个条目:<br><code><br>for index in 1…5 {<br>    print(“(index) times 5 is (index <em> 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br></em></code><br>遍历的序列是1 到 5的数值范围, 包括1和5,使用闭合区间运算符 (…)提到过。索引值设置给 range (1)的第一个数, 然后循环体中的语句就会执行。 这种情况, 循环体只有一个语句, 打印当前索引值5的倍数。 这个语句执行后, 索引值更新为包含在 range (2) 中的第二个值, print(<em>:separator:terminator:) 函数再次调用。 这个过程直到区间结束。<br><br>上面的例子, 索引值是常量而且自动设置。 像这样, 索引在使用前不必声明。 在循环声明中隐式声明, 不需要let关键字。<br><br>如果你不需要序列中的所有值, 可以在变量名位置处使用下划线来忽略这个值。<br><code><br>let base = 3<br>let power = 10<br>var answer = 1<br>for </code></em> in 1…power {<br>    answer = base<br>}<br>print(“(base) to the power of (power) is (answer)”)<br>// 打印 “3 to the power of 10 is 59049”<br></key,></code><br>上面的例子计算一个数的幂(这个例子里, 3 的10次幂)。 它乘以一个初始值 1 (就是 3 的0次幂), 十次, 使用一个闭合区间,1开始10结束。下划线用在这里,使得单个值被忽略同时不会在遍历过程中访问当前值。<br><br>使用 for-in 循环来遍历数组的项。<br><code><br>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>for name in names {<br>    print(“Hello, (name)!”)<br>}<br>// Hello, Anna!<br>// Hello, Alex!<br>// Hello, Brian!<br>// Hello, Jack!<br></code><br>你还可以遍历一个字典来遍历它的键值对。 字典遍历时每次返回一个 (key, value) 元组, 你可以在for-in循环中显示分解元组的值给常量赋值。这里, 字典的键分解给animalName 常量, 字典的值分配给了 legCount 常量。<br><code><br>let numberOfLegs = [“spider”: 8, “ant”: 6, “cat”: 4]<br>for (animalName, legCount) in numberOfLegs {<br>    print(“(animalName)s have (legCount) legs”)<br>}<br>// ants have 6 legs<br>// spiders have 8 legs<br>// cats have 4 legs<br></code><br>字典项遍历的顺序不需要和插入顺序一致。 字典内容是无序的, 遍历时不能保证获取的顺序。<br><br># While 循环<br><br>while 循环执行一组语句,直到条件失败。 首次遍历前,遍历次数不知道的时候使用这种方式是最好的。Swift 提供两种 while 循环:<br><br>while 每次循环前评估条件。<br>repeat-while 每次循环后评估条件。<br># While<br><br>while 循环从评估条件开始。 如果条件是真的, 一组语句会重复执行直到条件变成假的。<br><br>这是while 循环的基本形式:<br><code><br>while condition {<br>    statements<br>}<br></code><br>这个例子是个蛇与梯子的游戏:<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png"><br></div><br>游戏规则如下:<br><br>棋盘有25个方格, 目标是占据或者超过25。<br>每次, 摇一个6边的骰子然后移动对应数目方格, 沿着上图的点箭头的水平路径移动。<br>如果位于梯子底部, 往梯子上方移动。<br>如果位于蛇头, 往蛇下方移动。<br>游戏棋盘用整形值数组表示。大小基于 finalSquare 常量, 用来初始化数组并且判断取胜的条件。 棋盘用26个0值初始化, 而不是25 (每个索引从0到25)。<br><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br></code><br>一些方格会为蛇和梯子设置更多的指定值。梯子方格是正数,蛇方格是负数。<br><code><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br></code><br>方格 3 包含了梯子的底部,可以爬到方格11。 为了表示这个, board[03] 等于 +08, 这等于整数值8 (3和11的差值) 加号 (+i) 和减号 (-i)相等, 数值低于10的用0填充,这样所以棋盘都被定义了。<br><br>玩家开始方格是 “方格0”, 靠着棋盘的左下角。 第一次摇骰子总是让玩家进入棋盘。<br><code><br>var square = 0<br>var diceRoll = 0<br>while square &lt; finalSquare {<br>    // roll the dice<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // move by the rolled amount<br>    square += diceRoll<br>    if square &lt; board.count {<br>        // if we’re still on the board, move up or down for a snake or a ladder<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br></code><br>上面的例子用了一个很简单方法去摇骰子。 不用随机数, 用一初始值为0的 diceRoll。 每次循环, diceRoll 加一然后判断它是否过大。 当返回值等于7, 骰子值过大然后重置为1。diceRoll 值总是 1, 2, 3, 4, 5, 6, 1, 2 然后不停循环。<br><br>摇完筛子, 往前移动 diceRoll 方格。 如果移动超过25, 游戏结束。考虑边界安全，在操作方格的时候。<br><br>备注<br><br>没有这个判断, board[square] 可能会越界访问棋盘数组的值, 这会触发一个错误。 如果方格等于 26, 代码会判断board[26] 的值, 这会超过数组的大小。<br><br>当前while 循环执行然后结束, 然后循环的条件会被判断是否再次执行。如果玩家已经移动或者超过25, 循环的条件变成假然后游戏就结束。<br><br>while 循环适合这个例子, 因为开始循环的时候游戏的长度并不清楚。 相反, 一个特定条件满足后循环被执行了。<br><br># Repeat-While<br><br>另外一种while循环的变种, 就是 repeat-while 循环, 先执行一次循环, 然后再考虑循环的条件。 然后继续执行直到条件变成假。<br><br>备注<br><br>Swift 里的 repeat-while 循环类似其他语言里的 do-while 循环。<br><br>这里是 repeat-while 循环的基本样式:<br><code><br>repeat {<br>    statements<br>} while condition<br></code><br>这里还是蛇与梯子的例子, 用 repeat-while 循环来写而不是 while 循环。 finalSquare, board, square, 和 diceRoll的值初始化方式跟while循环一样。<br><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br></code><br>这个游戏版本, 第一步是判断梯子和蛇。 没有梯子带着玩家直接去方格25, 因为不太可能通过爬梯子去赢得游戏。因此, 判断有没有蛇和梯子是很安全的。<br><br>游戏开始, 玩家在 “square zero”. board[0] 总是等于0没有影响。<br><code><br>repeat {<br>    // move up or down for a snake or ladder<br>    square += board[square]<br>    // roll the dice<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // move by the rolled amount<br>    square += diceRoll<br>} while square &lt; finalSquare<br>print(“Game over!”)<br></code><br>蛇与梯子判断后, 摇动筛子玩家往前移动 diceRoll 方格。 当前循环执行然后结束。<br><br>循环条件 (while square &lt; finalSquare) 和以前一样, 不过这次开始不评估,直到第一次循环结束才评估。repeat-while 循环比 while loop 循环更适合这个游戏。上面的 repeat-while 循环, 当条件确认方格还在棋盘上后, square += board[square] 总是立即执行。 这就不需要像之前那样判断数组边界。<br><br># 条件语句<br><br>基于特定条件执行不同代码片段经常用到。 在碰到错误时你可能想运行额外的代码片段, 或者在数值变得太高或者太低的时候也是。为了做这件事, 你让部分代码带有条件性。<br><br>Swift 提供两种方式给你的代码添加条件分支: if 语句和 switch 语句。你用 if 语句评估条件会有一些可能的结果。 switch 语句在比较复杂的多个排列时很有用, 在模式匹配可以帮助选择合适代码分支执行的情况也是。<br><br># If<br><br>最简单的形式, if 语句有一个单一条件。 条件为真执行一个语句集合。<br><code><br>var temperatureInFahrenheit = 30<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>}<br>// 打印 “It’s very cold. Consider wearing a scarf.”<br></code><br>上面的例子判断文档是否小于等于华氏32度 (冰点)。 如果是, 打印一条信息。 否则, 不打印消息, 代码在大括号后继续执行。<br><br>if 语句还可以提供一个替代语句集合, 就是 else 字句, 针对条件是假的情况。 这些语句用else 关键字表示。<br><code><br>temperatureInFahrenheit = 40<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 打印 “It’s not that cold. Wear a t-shirt.”<br></code><br>两个分支之一总会执行。 因为温度已经增长到华氏40度, 这不够冷到戴围巾,因此else分支被触发了。<br><br>你可以链接多个if语句来考虑额外的语句。<br><code><br>temperatureInFahrenheit = 90<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 打印 “It’s really warm. Don’t forget to wear sunscreen.”<br></code><br>在这个库, 额外的if语句用来响应特别温暖的温度。 最后的else语句保留, 它响应既不太热也不太冷的情况。<br><br>最后的else语句是可选的, 不过, 如果不需要执行可以去掉。<br><code><br>temperatureInFahrenheit = 72<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>}<br></code><br>因为这个温度既不太冷也不太热,所以不会触发if或者else语句,没有打印信息。<br><br># Switch<br><br>switch 语句设想一个值,然后跟一些可能的匹配模式比较。然后执行合适的代码, 基于第一次匹配成功。switch 语句提供了if语句的替代方法来响应多种潜在状态的情况。<br><br>最简单的形式, 一个 switch 语句用一个值跟一个或者多个同类型的值相比较。<br><code><br>switch some value to consider {<br>case value 1:<br>    respond to value 1<br>case value 2,<br>     value 3:<br>    respond to value 2 or 3<br>default:<br>    otherwise, do something else<br>}<br></code><br>每个 switch 语句由多个case分支组成, 每个分支以case 关键字开始。 除了跟指定值比较外, Swift 为case分支提供了指定更复杂匹配模式的方法。这些选项本章后面会描述。<br><br>跟if语句体很像, 每个 case 是代码执行的单独分支。 switch 语句决定是否选择这个分支。这个过程叫分发。<br><br>每个switch 语句务必是详尽的。 就是说, 每个能想到的类型值都要case匹配。 为每个可能值都提供case是不合适的。你可以定义一个默认case覆盖没有显示处理的值。 默认case使用default关键字指明, 必须总是出现在最后。<br><br>这个例子使用一个 switch 语句来出处理一个小写字母someCharacter:<br><code><br>let someCharacter: Character = “z”<br>switch someCharacter {<br>case “a”:<br>    print(“The first letter of the alphabet”)<br>case “z”:<br>    print(“The last letter of the alphabet”)<br>default:<br>    print(“Some other character”)<br>}<br>// 打印 “The last letter of the alphabet”<br></code><br>switch 语句第一个case匹配英文字母表第一个字母 a, 第二个case匹配最后一个字母 z. 因为 switch 语句对于每个可能的字符都要有case, 不是每个字母表字符都需要。这个switch 语句使用了一个default case 去处理a 和 z之外的其他所有字母。这保证了switch语句的详细性。<br><br># 非隐式 Fallthrough<br><br>和C 与 objective-C 的switch语句对比, Swift 中的switch语句不会 fall through case底部并且跳到下一个case。 相反, 在第一次匹配到case后整个switch语句执行就完成了。不要求显示的break语句。 这使得switch语句更安全,更容易使用,而且避免执行多个case的错误。<br><br>备注<br><br>尽管Swift 不要求break, 你仍然可以在Swift中使用。 具体可以参见 Break in a Switch Statement.<br><br>case 体必须包含至少一句可执行语句。下面的代码的无效的, 因为第一个case是空的:<br><code><br>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”: // Invalid, the case has an empty body<br>case “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// 这会报一个编译期错误<br></code><br>跟C中的switch语句不同, 这个 switch 语句不能同时匹配 “a” 和 “A”. 相反, 它会报一个编译期错误,因为case “a”: 没有任何可以执行的语句。这个方法避免了突然从一个case跳入另外一个case, 让代码意图清晰安全。<br><br>如果要用一个case同时匹配”a” 和 “A”, 把这两个值合并到一个case语句, 用逗号把它们分开。<br><code><br>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”, “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// Prints “The letter A”<br></code><br>为了可读性, 复合case也可以写作多行。 具体参见 Compound Cases.<br><br>备注<br><br>为了显式fall through 到某个case下面, 使用 fallthrough 关键字。<br><br># 区间匹配<br><br>switch case里面的值可以包含在区间里判断。 这个例子使用数字区间来提供一个对任何数字大小的自然语言统计。<br><code><br>let approximateCount = 62<br>let countedThings = “moons orbiting Saturn”<br>var naturalCount: String<br>switch approximateCount {<br>case 0:<br>    naturalCount = “no”<br>case 1..<5: naturalcount="a few" case="" 5..<12:="" 12..<100:="" 100..<1000:="" default:="" }="" print("there="" are="" \(naturalcount)="" \(countedthings).")="" prints="" "there="" dozens="" of="" moons="" orbiting="" saturn."="" <="" code=""><br>上面的例子, approximateCount 在switch语句里估算。 每个case把这个值跟一个数字或者区间进行比较。因为 approximateCount 值落在 12 和 100之间, naturalCount 被赋值为 “dozens of”, 然后代码执行跳出switch语句继续执行。<br><br># 元组<br><br>你可以在switch语句中使用元组测试多值。元组元素可以跟一个不同值或者值区间进行测试。或者, 使用通配下划线 (<em>) 去匹配可能的值。<br><br>下面的例子有一个 (x, y) 点, 用一个简单的元组类型 (Int, Int) 表示, 并且在下面的图表中标示。<br><code><br>let somePoint = (1, 1)<br>switch somePoint {<br>case (0, 0):<br>    print(“(0, 0) is at the origin”)<br>case (</code></em>, 0):<br>    print(“((somePoint.0), 0) is on the x-axis”)<br>case (0, _):<br>    print(“(0, (somePoint.1)) is on the y-axis”)<br>case (-2…2, -2…2):<br>    print(“((somePoint.0), (somePoint.1)) is inside the box”)<br>default:<br>    print(“((somePoint.0), (somePoint.1)) is outside of the box”)<br>}<br>// 打印 “(1, 1) is inside the box”<br></5:></code><br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png"><br></div><br>switch 语句决定这个点是否位于原点 (0, 0), 红色的 x-轴, 橙色 y-轴, 在蓝色 4-by-4 方块里原点在中心, 或者在方块之外。<br><br>跟 C 不同, Swift 允许多个case 去处理相同的值。 事实上, (0, 0)点可以满足例子的四个case。不过, 如果多个匹配都可能, 第一个匹配上的总是执行。 (0, 0) 点首先匹配case (0, 0), 其他所有匹配的case都会被忽略。<br><br># 值绑定<br><br>一个 switch case 可以绑定值到临时的常量或者变量, 用在case 体中。这个就是值绑定, 因为值绑定到case 体中的临时常量或者变量上。<br><br>下面这个例子有一个(x, y) 点, 是元组类型 (Int, Int), 在下面的图表中标示:<br><code><br>let anotherPoint = (2, 0)<br>switch anotherPoint {<br>case (let x, 0):<br>    print(“on the x-axis with an x value of (x)”)<br>case (0, let y):<br>    print(“on the y-axis with a y value of (y)”)<br>case let (x, y):<br>    print(“somewhere else at ((x), (y))”)<br>}<br>// Prints “on the x-axis with an x value of 2”<br></code><br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png"><br></div><br>switch 语句判断这个点是在红色的 x-轴, 橙色的 y-轴, 还是其他什么地方 (不在轴上)。<br><br>这三个 switch case声明了占位符常量 x 和 y, 临时存放来自 anotherPoint 的一个或者两个元组值。第一个 case, case (let x, 0), 匹配任何y值为0 然后把坐标点x的值赋给临时常量 x. 类似的, 第二个case, case (0, let y), 匹配任何x值为0,然后把坐标点y值赋给临时常量y.<br><br>临时常量声明后, 它们就可以用在case 体中。在这里, 它们用来打印这个点的标示。<br><br>这个 switch 语句没有默认的default case. 最后一个case, case let (x, y), 声明了带有两个占位符常量的元组,它可以匹配任何值。因为 anotherPoint 总是两个值的元组, 这个case 匹配所有可能的剩余值, 所以默认的default case 是不需要的。<br><br># Where<br><br>一个 switch case 可以用 where 字句来判断额外的条件。<br><br>下面的例子在下面的图表中标示一个(x, y) 点:<br><code><br>let yetAnotherPoint = (1, -1)<br>switch yetAnotherPoint {<br>case let (x, y) where x == y:<br>    print(“((x), (y)) is on the line x == y”)<br>case let (x, y) where x == -y:<br>    print(“((x), (y)) is on the line x == -y”)<br>case let (x, y):<br>    print(“((x), (y)) is just some arbitrary point”)<br>}<br>// 打印 “(1, -1) is on the line x == -y”<br></code><br><br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png"><br></div><br>switch 语句确定这个点是否在x == y这个绿色对角线上, 或者是x == -y这个紫色对角线上,或者两者都不在。<br><br>三个 switch case 都声明了占位符常量 x 和 y, 临时接受来自 yetAnotherPoint 两个元组值。这些常量用作where字句的一部分, 去创建一个动态的过滤器。case 匹配坐标点的当前值,如果where字句条件为真的话。<br><br>和前面一个例子一样, 最后的case 匹配所有剩余值, 不再需要 default case<br><br># 复合 Cases<br><br>共享相同代码块的多个switch case 分支可以合并, 写在case后用逗号分开。如果任何模式匹配, 这个case 就被认为匹配。如果列表很长可以写作多行。如下：<br><code><br>let someCharacter: Character = “e”<br>switch someCharacter {<br>case “a”, “e”, “i”, “o”, “u”:<br>    print(“(someCharacter) is a vowel”)<br>case “b”, “c”, “d”, “f”, “g”, “h”, “j”, “k”, “l”, “m”,<br>     “n”, “p”, “q”, “r”, “s”, “t”, “v”, “w”, “x”, “y”, “z”:<br>    print(“(someCharacter) is a consonant”)<br>default:<br>    print(“(someCharacter) is not a vowel or a consonant”)<br>}<br>// 打印 “e is a vowel”<br></code><br>第一个case 匹配英文中五个小写元音字母。 类似的, 第二个case匹配所有小写辅音字母。最后, default case 匹配其余的字母。<br><br>符合 case 可以包含值绑定。 符合case所有形式必须包括相同的值绑定集合, 每个绑定必须获取一个相同类型的值。这个确保, 无论复合case哪个部分匹配, case 代码总是访问一个绑定值,而且这个值总有相同类型。<br><code><br>let stillAnotherPoint = (9, 0)<br>switch stillAnotherPoint {<br>case (let distance, 0), (0, let distance):<br>    print(“On an axis, (distance) from the origin”)<br>default:<br>    print(“Not on an axis”)<br>}<br>// 打印 “On an axis, 9 from the origin”<br></code><br>上面的case有两种形式: (let distance, 0) 匹配x轴上的点, (0, let distance) 匹配y轴上点。两个形式都绑定了一个距离值,两种形式下距离都是整形,这就意味着case代码总是可以访问距离的值。<br><br># 控制转移语句<br><br>控制转移语句改变代码执行的顺序, 通过转移控制从一块代码到另外一块代码。Swift 有五个控制转移语句:<br><br>continue<br>break<br>fallthrough<br>return<br>throw<br>continue, break, 和 fallthrough 下面描述。return 语句在函数部分描述, throw 语句在 Propagating Errors Using Throwing Functions 部分描述。<br><br># Continue<br><br>continue 语句告诉当前循环停止,然后开始下一次循环。它说 “我在当前循环迭代” 没有离开当前的循环。<br><br>下面的例子从一个小写字符串移除所有的元音字母和空格,来创建一个谜语:<br><code><br>let puzzleInput = “great minds think alike”<br>var puzzleOutput = “”<br>let charactersToRemove: [Character] = [“a”, “e”, “i”, “o”, “u”, “ “]<br>for character in puzzleInput.characters {<br>    if charactersToRemove.contains(character) {<br>        continue<br>    } else {<br>        puzzleOutput.append(character)<br>    }<br>}<br>print(puzzleOutput)<br>// 打印 “grtmndsthnklk”<br></code><br>上面的代码遇见元音或者空格就会调用 continue 关键字, 当前迭代立即结束然后进入下一次迭代。<br><br># Break<br><br>break 立即结束整个控制流语句的执行。break 语句可以用在一个 switch 语句或者循环语句,如果你想早点结束执行的话。<br><br># Break 在循环语句<br><br>用在循环语句时, break 立即结束循环,然后跳出循环所在的大括号。<br><br># Break 在Switch 语句<br><br>用在switch 语句时, break 终止 switch 语句的执行,然后跳出switch语句所在的大括号。<br><br>这种行为可以在switch语句中用来匹配或者忽略一个或者多个case. 因为 Swift 的 switch 语句是详尽的而且不允许有空 case, 有时候需要故意匹配和忽略一个case,为了让你的意图明显。整个case写一个break就可以忽略。当case 匹配时, case 里的break语句立即终止switch语句的执行。<br><br><br>下面的例子转换一个字符值,然后判断它在四种语言之一是否表示一个数字, 单个switch case 覆盖了多个值。<br><code><br>let numberSymbol: Character = “三”  // Chinese symbol for the number 3<br>var possibleIntegerValue: Int?<br>switch numberSymbol {<br>case “1”, “١”, “一”, “๑”:<br>    possibleIntegerValue = 1<br>case “2”, “٢”, “二”, “๒”:<br>    possibleIntegerValue = 2<br>case “3”, “٣”, “三”, “๓”:<br>    possibleIntegerValue = 3<br>case “4”, “٤”, “四”, “๔”:<br>    possibleIntegerValue = 4<br>default:<br>    break<br>}<br>if let integerValue = possibleIntegerValue {<br>    print(“The integer value of (numberSymbol) is (integerValue).”)<br>} else {<br>    print(“An integer value could not be found for (numberSymbol).”)<br>}<br>// 打印 “The integer value of 三 is 3.”<br></code><br>上面的例子判断 numberSymbol 是不是拉丁语, 阿拉伯语, 汉语, 或者泰语中的1到4。如果匹配到, switch中的一个case会赋值给可选类型变量 possibleIntegerValue 一个合适的整数值。<br><br>在 switch 语句执行完成之后, 例子中使用可选绑定去判断一个值是否找到。possibleIntegerValue 变量是一个可选类型有一个初始值nil, 如果四个case之一给possibleIntegerValue 设置了一个实际值,这个可选绑定就成功了。<br><br>因为不可能列出所有的可能字符, 一个默认的case 用来处理其他没匹配的字符。默认case不需要做任何事, 所以它只有一个break语句。当默认case被匹配后, break 语句就结束switch语句的执行n, 代码开始从 if let 语句处继续执行。<br><br># Fallthrough<br><br>Swift 的 Switch 语句不会 fall through 到下一个case。 相反, 只有第一个匹配到的case语句执行完成,整个switch语句就完成了执行。不同的是, C 语言要求每个case后面都要加上break 语句,防止 fallthrough. 明显Swift 更加简洁和安全。<br><br>如果你想要C语言那种效果的 fallthrough, 你可以选择在case后面加上 fallthrough 关键字。 下面的例子使用fallthrough 创建一个数字的文字描述。<br><code><br>let integerToDescribe = 5<br>var description = “The number (integerToDescribe) is”<br>switch integerToDescribe {<br>case 2, 3, 5, 7, 11, 13, 17, 19:<br>    description += “ a prime number, and also”<br>    fallthrough<br>default:<br>    description += “ an integer.”<br>}<br>print(description)<br>// 打印 “The number 5 is a prime number, and also an integer.”<br></code><br>上例声明了一个字符串变量 description ,然后赋了一个初始值。后面的函数在switch语句中用了这个值 integerToDescribe. 如果 integerToDescribe 的是列表中的一个素数, 函数就把一段文本添加到 description 的后面, 去备注说这个数字是素数。然后用了fallthrough 关键字进入默认的case. 默认的case添加一段额外的文本到 description 之后, 然后switch语句就结束了。<br><br>除非integerToDescribe 的值在已知素数列表里, 否则第一个case就不会匹配。 因为没有其他case, integerToDescribe 会被默认的case 匹配。<br><br>switch 语句执行完后, 使用 print(_:separator:terminator:) 函数打印description。 这个例子里, 数字5就是一个素数。<br><br># 标签语句<br><br>在 Swift 里, 你可以在循环和条件语句种内嵌循环和条件语句,来创建更复杂的控制流结构。不过, 循环和条件语句都可以使用break 语句来提前结束执行。因此, 有时候这很有用,当你决定哪个循环或者条件语句要用break来终止执行。类似的, 如果你有多个嵌套的循环, 它也是有用的,可以明确哪个循环语句继续有效。<br><br>为了达到这些目的, 你可以用一个语句标签来标记一个循环或者条件语句。对于条件语句, 你可以使用带着break语句的语句标签来结束标签的语句。对于循环语句, 你可以用带着break或者continue的语句标签来结束或者继续标签语句的执行。<br><br>一个标签语句通过放置一个标签来指示,标签放在相同行作为语句的关键字。跟着是一个冒号。 这里有一个while循环语法的例子, 对于所有的循环和switch语句都是相当的规则:<br><code><br>label name: while condition {<br>    statements<br>}<br></code><br>下面的例子使用带着标签的break和continue语句,这次游戏有了一个额外的规则:<br><br>想要赢,你就要登上方格25<br>如果掷骰子让你超过了方格25, 你必须重掷,直到投出能够登上方格25的数字为止。<br><br>游戏的棋盘和原来一样。<br><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png"><br></div>

<p>finalSquare, board, square, 和 diceRoll 初始化方式跟以前一样:<br><code><br>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="external">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br></code><br>这个版本的游戏使用了一个 while 循环和一个switch 语句来实现游戏的逻辑。 while 循环有一个语句标签 gameLoop 用来表示它是游戏的主要循环。</p>
<p>while 循环的条件是是 while square != finalSquare, 告诉你必须登上方格25。<br><code><br>gameLoop: while square != finalSquare {<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    switch square + diceRoll {<br>    case finalSquare:<br>        // diceRoll will move us to the final square, so the game is over<br>        break gameLoop<br>    case let newSquare where newSquare &gt; finalSquare:<br>        // diceRoll will move us beyond the final square, so roll again<br>        continue gameLoop<br>    default:<br>        // this is a valid move, so find out its effect<br>        square += diceRoll<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br></code><br>每次循环开始摇色子。 循环使用了一个switch语句来考虑移动的结果和是否允许移动,而不是立即用的玩家的位置:</p>
<p>如果摇色子使得玩家移动到最后的方格,那么游戏就结束了。break gameLoop 语句转移控制到整个循环的外面的第一行代码, 结束游戏。<br>如果摇色子使得玩家超出了最后的方格, 那么移动无效,玩家需要重新摇色子。continue gameLoop 语句结束当前的迭代然后开始下一次迭代。<br>其他所有情况, 摇色子都是有效的移动。 玩家往前移动 diceRoll 方格, 游戏逻辑检查所有的蛇与梯子。 循环结束, 控制返回条件判断,决定是否需要再来一次。<br>备注</p>
<p>如果break 语句不使用 gameLoop 标签, 它只会跳出switch 语句,而不会跳出while 语句。使用 gameLoop 标签清楚知道要终止哪个控制语句。</p>
<p>不是必须用 gameLoop 标签,当调用 continue gameLoop 来跳到下一次循环迭代。游戏里只有一个循环。continue 语句影响哪个循环是很清楚的。不过, 使用 gameLoop 标签也没有坏处。这样做是为了和break 标签使用一致,并且让逻辑更加轻易阅读和理解。</p>
<h1 id="尽早退出"><a href="#尽早退出" class="headerlink" title="尽早退出"></a>尽早退出</h1><p>guard 语句, 很像 if 语句, 根据表达式布尔值执行语句。 使用guard 语句要求条件必须为真。和 if 语句不同, guard 语句总有一个else 字句—如果条件是假 else 会执行。<br><code><br>func greet(person: [String: String]) {<br>    guard let name = person[“name”] else {<br>        return<br>    }</code></p>
<pre><code>print(&quot;Hello \(name)!&quot;)

guard let location = person[&quot;location&quot;] else {
    print(&quot;I hope the weather is nice near you.&quot;)
    return
}

print(&quot;I hope the weather is nice in \(location).&quot;)
</code></pre><p>}</p>
<p>greet(person: [“name”: “John”])<br>// 打印 “Hello John!”<br>// 打印 “I hope the weather is nice near you.”<br>greet(person: [“name”: “Jane”, “location”: “Cupertino”])<br>// 打印 “Hello Jane!”<br>// 打印 “I hope the weather is nice in Cupertino.”<br><br>如果 guard 语句的条件满足, 代码继续在guard 语句的大括号后执行。所有变量或者常量使用一个可选绑定赋值,它们作为条件的一部分。<br>如果条件没有满足, else 分支会执行。这个分支转移控制跳出guard 语句所在的代码块。可以使用控制转移语句 return, break, continue, 或者 throw, 或者也可以调用不返回的函数或者方法, 比如 fatalError(_:file:line:).</p>
<p>跟 if 语句做同样的判断比较,使用 guard 语句为了提高代码的可读性。它让你可以写通常不在else 快执行的代码, 同时让你保持代码,来处理违法要求的要求。</p>
<h1 id="判断-API-可用性"><a href="#判断-API-可用性" class="headerlink" title="判断 API 可用性"></a>判断 API 可用性</h1><p>Swift 支持判断 API 的有效性, 这样可以保证你不会在给定设备上使用不可用的API。</p>
<p>编译器使用SDK中的有效性信息来判断你代码中的所有API。 如果你使用不可用的API,Swift 会报一个编译错误。</p>
<p>在if或者guard语句中使用一个可用性条件去执行一块代码, 取决于你用的API是否运行时可用。一旦编译器验证API在代码块可以用,它就会用这些信息。<br><code><br>if #available(iOS 10, macOS 10.12, <em>) {<br>    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS<br>} else {<br>    // Fall back to earlier iOS and macOS APIs<br>}<br></em></code><br>上面的可用性条件指出, 对于iOS, if 语句只能在 iOS 10 和以后的版本上执行; 对于 macOS, 只能用在 macOS 10.12 和以后的版本。 最后一个参数, , 是需要的,用来指定其他平台。if 语句执行在你指定的最小部署设备上。</p>
<p>一般形式中, 可用性条件带着一列平台名和版本号。平台名例如 iOS, macOS, watchOS, 和 tvOS—完整列表, 除了指定大版本号比如 iOS 8, 你还可以指定小版本号比如 iOS 8.3 和 macOS 10.10.3.<br><code><br>if #available(platform name version, …, *) {<br>    statements to execute if the APIs are available<br>} else {<br>    fallback statements to execute if the APIs are unavailable<br>}<br></code></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数包含执行特定任务的代码块。你给出一个函数名来表明它是做什么的, 需要时使用函数名来调用。</p>
<p>Swift 统一的函数语法是很灵活的, 可以像C语言一样没有参数名,也可以像objective-C一样带有名称和参数标签。参数可以提供默认值给简单的函数调用,同时可以作为输入输出参数传入。一旦函数调用就会修改传入的变量。</p>
<p>Swift 中的函数都有类型, 由参数类型和返回类型组成。你可以像使用其他类型一样使用这个类型, 这个让传递函数作为参数变得容易, 也可以从函数返回函数。 函数可以写在其他函数里, 在一个内嵌函数范围封装哟有用的功能。</p>
<h1 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h1><p>当你定义一个函数时, 你可以定义一个或者多个命名, 函数的类型值作为输入, 也就是参数。你还可以定义一个值类型,函数执行完传回值。也就是返回值。</p>
<p>每个函数都有名字, 用来描述函数执行的任务。 为了使用一个函数, 你通过名字调用函数,传给它输入值 (参数) 匹配函数参数的类型。函数参数按照相同顺序提供。</p>
<p>下面例子里的函数叫 greet(person:), 因为它做的事情—它输入一个人的名字然后返回一个问候。为了完成这个, 你定义一个输入参数—一个字符串类型 person—然后返回一个字符串类型, 它包含了对这个人问候语。<br><code><br>func greet(person: String) -&gt; String {<br>    let greeting = “Hello, “ + person + “!”<br>    return greeting<br>}<br></code><br>所有信息都在函数里, 前缀是func 关键字。函数的返回类型用返回箭头-&gt; (连字符跟着一个右方向箭头), 箭头后是返回的类型名。</p>
<p>定义描述了函数的功能, 希望接收的参数, 执行完成返回的值。 定义使得函数在代码各处可以清晰明确的调用:<br><code><br>print(greet(person: “Anna”))<br>// Prints “Hello, Anna!”<br>print(greet(person: “Brian”))<br>// Prints “Hello, Brian!”<br></code><br>在person 标签后出入一个字符串类型,调用 greet(person:) 函数, 比如 greet(person: “Anna”). 因为这个函数返回一个字符串类型, greet(person:) 可以被 print(_:separator:terminator:) 函数调用去打印返回值。</p>
<p>备注</p>
<p>print(_:separator:terminator:) 函数第一个参数没有标签, 其他参数是可选的,因为他们有默认值。这些函数语法的变化在下面函数参数标签、参数名和默认参数值中描述。</p>
<p>greet(person:) 函数体先是定义了一个新的字符串常量 greeting,然后设置一个简单的问候信息。然后 greeting 作为返回值传出。函数结束执行然后返回greeting 的当前值。</p>
<p>你可以输入不同值多次调用 greet(person:) 函数。上面的例子展示了输入”Anna” 和 “Brian” 发生了什么。函数返回了定制的问候语。</p>
<p>为了让函数体变短, 你可以合并信息创建和返回语句到一行代码:<br><code><br>func greetAgain(person: String) -&gt; String {<br>    return “Hello again, “ + person + “!”<br>}<br>print(greetAgain(person: “Anna”))<br>// 打印 “Hello again, Anna!”<br></code></p>
<h1 id="函数参数和返回值"><a href="#函数参数和返回值" class="headerlink" title="函数参数和返回值"></a>函数参数和返回值</h1><p>Swift 中函数的参数和返回值非常灵活。 你可以定义任何,从带有不具名参数的简单工具函数到具有表达式参数名和不同参数选项的复杂函数。</p>
<h1 id="没有参数的函数"><a href="#没有参数的函数" class="headerlink" title="没有参数的函数"></a>没有参数的函数</h1><p>函数不要求有输入参数。 这里有个没有输入参数的函数, 调用的时候总是返回相同字符串信息:<br><code><br>func sayHelloWorld() -&gt; String {<br>    return “hello, world”<br>}<br>print(sayHelloWorld())<br>// 打印 “hello, world”<br></code><br>函数定义是还是需要再函数名后加括号, 尽管它没有任何参数。函数调用的时候函数名后面还是跟着一堆括号。</p>
<h1 id="多个参数的函数"><a href="#多个参数的函数" class="headerlink" title="多个参数的函数"></a>多个参数的函数</h1><p>函数可以有多个输入参数, 写在函数的括号里, 用逗号分开。</p>
<p>这个函数有两个参数,一个人名和是否他们已经被问候过。然后返回对这个人的问候语:<br><code><br>func greet(person: String, alreadyGreeted: Bool) -&gt; String {<br>    if alreadyGreeted {<br>        return greetAgain(person: person)<br>    } else {<br>        return greet(person: person)<br>    }<br>}<br>print(greet(person: “Tim”, alreadyGreeted: true))<br>// 打印 “Hello again, Tim!”<br></code><br>你调用 greet(person:alreadyGreeted:) 函数,传入两个参数,一个是带有person标签的字符串值,一个是带有alreadyGreeted标签的布尔值。用逗号分开。注意这个函数跟上面的 greet(person:) 函数不同。 尽管两个函数名字一样,  greet(person:alreadyGreeted:) 函数有两个参数而 greet(person:) 函数只有一个参数。</p>
<h1 id="没有返回值的函数"><a href="#没有返回值的函数" class="headerlink" title="没有返回值的函数"></a>没有返回值的函数</h1><p>函数不要求必须有返回值。 这里有个版本的 greet(person:) 函数, 它打印自己的字符串而不是返回字符串:<br><code><br>func greet(person: String) {<br>    print(“Hello, (person)!”)<br>}<br>greet(person: “Dave”)<br>// 打印 “Hello, Dave!”<br></code><br>因为不需要返回一个值, 所以函数定义没有返回箭头 (-&gt;) 或者一个返回值。</p>
<p>备注</p>
<p>严格来说, 这个版本的 greet(person:) 函数依然返回一个值, 尽管返回值没有定义。函数没有返回值是返回了一个特殊的类型 Void. 就是一个简单的空元组, 写作 ().</p>
<p>函数调用的时候返回值被忽略:<br><code><br>func printAndCount(string: String) -&gt; Int {<br>    print(string)<br>    return string.characters.count<br>}<br>func printWithoutCounting(string: String) {<br>    let _ = printAndCount(string: string)<br>}<br>printAndCount(string: “hello, world”)<br>// 打印 “hello, world” and returns a value of 12<br>printWithoutCounting(string: “hello, world”)<br>// 打印 “hello, world” but does not return a value<br></code><br>第一个函数, printAndCount(string:), 打印一个字符串, 然后返回它的字符数。 第二个函数, printWithoutCounting(string:), 调用第一个函数, 不过忽略了它的返回值。一旦第二个函数被调用, 依然由第一个函数打印信息,但是不用返回值。</p>
<p>备注</p>
<p>返回值可以忽略, 但是如果函数说要返回值就一直要这么做。带有返回值的函数禁止控制流跳出函数底部,如果没有返回一个值的话。如果坚持这么做会导致编译错误。</p>
<h1 id="带有多返回值的函数"><a href="#带有多返回值的函数" class="headerlink" title="带有多返回值的函数"></a>带有多返回值的函数</h1><p>你可以用元组做为函数的返回值,来实现返回多个值。</p>
<p>下面的例子定义了一个函数 minMax(array:), 用来茶盅整形数组里面的最小值和最大值:<br><code><br>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {<br>    var currentMin = array[0]<br>    var currentMax = array[0]<br>    for value in array[1..<array.count] {="" if="" value="" <="" currentmin="" }="" else=""> currentMax {<br>            currentMax = value<br>        }<br>    }<br>    return (currentMin, currentMax)<br>}<br></array.count]></code><br>minMax(array:) 函数返回包含两个整数值的元组。这些值用最小和最大标签表明,这个可以在查询函数返回值的时候通过名字访问它们。</p>
<p>minMax(array:) 函数体开始时设置两个变量currentMin 和 currentMax值为数组第一项的值。然后函数开始遍历剩下的值,然后重复和 currentMin 和 currentMax 值进行大小比较。 最后, 最大值和最小值作为一个元组返回。</p>
<p>因为元组的成员值作为函数返回值被命名, 所以可以点语法来访问最大值和最小值:<br><code><br>let bounds = minMax(array: [8, -6, 2, 109, 3, 71])<br>print(“min is (bounds.min) and max is (bounds.max)”)<br>// 打印 “min is -6 and max is 109”<br></code><br>注意函数返回元组时,元组的成员不需要命名, 因为它们的名字作为函数返回类型已经被指定了。</p>
<h1 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h1><p>如果函数返回的元组类型有可能不存在值,你可以使用一个可选元组返回类型来反应整个元组可能为nil。一个可选元组返回类型括号后面跟着一个问号, 比如 (Int, Int)? 或者 (String, Int, Bool)?.</p>
<p>备注</p>
<p>可选元组类型比如s (Int, Int)? 不同于元组中包含可选类型比如 (Int?, Int?). 有一个可选元组类型, 整个元组都是可选的, 不单单是元组里的值。</p>
<p>minMax(array:) 函数返回的元组包含两个整数值。 然而, 函数不会对传入的数组做任何安全检查。 如果数组包含空数组, minMax(array:) 函数, 上面定义的, 尝试访问 array[0] 会触发运行时错误。</p>
<p>为了处理这种情况, minMax(array:) 函数返回值写成可选元组返回类型,如果数组为空则返回nil:<br><code><br>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {<br>    if array.isEmpty { return nil }<br>    var currentMin = array[0]<br>    var currentMax = array[0]<br>    for value in array[1..<array.count] {="" if="" value="" <="" currentmin="" }="" else=""> currentMax {<br>            currentMax = value<br>        }<br>    }<br>    return (currentMin, currentMax)<br>}<br></array.count]></code><br>你可以用一个可选绑定来判断, 这个版本的 minMax(array:) 函数是返回一个实际元组值还是nil:<br><code><br>if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {<br>    print(“min is (bounds.min) and max is (bounds.max)”)<br>}<br>// 打印 “min is -6 and max is 109”<br></code></p>
<h1 id="函数参数标签和参数名"><a href="#函数参数标签和参数名" class="headerlink" title="函数参数标签和参数名"></a>函数参数标签和参数名</h1><p>每个函数参数既有参数标签也有参数名。参数标签在调用函数时使用; 函数中的每个参数调用时使用它们的标签。 参数名用于函数的实现。 默认情况, 参数使用参数名作为标签。<br><code><br>func someFunction(firstParameterName: Int, secondParameterName: Int) {<br>    // In the function body, firstParameterName and secondParameterName<br>    // refer to the argument values for the first and second parameters.<br>}</code></p>
<p>someFunction(firstParameterName: 1, secondParameterName: 2)<br><br>所有参数名必须唯一。 尽管多个参数可能有相同的标签, 唯一的参数标签会让你的代码更有可读性。</p>
<h1 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h1><p>参数标签写在参数名之前, 用空格分开:<br><code><br>func someFunction(argumentLabel parameterName: Int) {<br>    // In the function body, parameterName refers to the argument value<br>    // for that parameter.<br>}<br></code><br>这里有一个 greet(person:) 函数的变种,接受一个人名和家乡然后返回一个问候:<br><code><br>func greet(person: String, from hometown: String) -&gt; String {<br>    return “Hello (person)!  Glad you could visit from (hometown).”<br>}<br>print(greet(person: “Bill”, from: “Cupertino”))<br>// 打印 “Hello Bill!  Glad you could visit from Cupertino.”<br></code><br>参数标签的使用允许函数用表达方式调用, 像句子一样。</p>
<h1 id="省略参数标签"><a href="#省略参数标签" class="headerlink" title="省略参数标签"></a>省略参数标签</h1><p>如果你不想要参数标签, 写一个下划线代替显式的参数标签。<br><code><br>func someFunction(_ firstParameterName: Int, secondParameterName: Int) {<br>    // In the function body, firstParameterName and secondParameterName<br>    // refer to the argument values for the first and second parameters.<br>}<br>someFunction(1, secondParameterName: 2)<br></code><br>如果一个参数有参数标签, 那么调用函数的时候参数必须带上标签。</p>
<h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h1><p>你可以给函数参数赋一个默认值,写在类型的后面。如果定义了默认值, 调用函数时你就可以忽略这个参数。<br><code><br>func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {<br>    // If you omit the second argument when calling this function, then<br>    // the value of parameterWithDefault is 12 inside the function body.<br>}<br>someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6<br>someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12<br></code><br>没有默认值的参数放在函数参数列表前, 带有默认值的放在后面。没有默认值的参数通常更重要—首先写它们更容易知道相同的函数被调用, 不用管默认参数是否被忽略。</p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>可变参数接受零个或者多个指定类型的值。你用可变参数指定函数调用时可以传入不同个数的输入值。可变参数写法是在参数类型名后写三个点。</p>
<p>传入可变参数的值在函数体中作为对应类型的数组是可用的。 例如, 带有数字名的可变参数和 Double… 在函数中作为常量数组 [Double]是可用的。</p>
<p>下面的例子计算任意长度的数字的平均数:<br><code><br>func arithmeticMean(_ numbers: Double…) -&gt; Double {<br>    var total: Double = 0<br>    for number in numbers {<br>        total += number<br>    }<br>    return total / Double(numbers.count)<br>}<br>arithmeticMean(1, 2, 3, 4, 5)<br>// returns 3.0, which is the arithmetic mean of these five numbers<br>arithmeticMean(3, 8.25, 18.75)<br>// returns 10.0, which is the arithmetic mean of these three numbers<br></code><br>备注</p>
<p>一个函数最多有一个可变参数。</p>
<h1 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h1><p>函数参数默认是常量。 尝试改变会导致编译期错误。这就意味着你不能错误的改变参数值。如果你想函数改变参数值, 想要这些改变持续到函数调用结束, 你可以定义输入输出参数来代替。</p>
<p>通过把 in-out 关键字写在参数类型前面来写一个输入输出参数。 输入输出参数有一个传入函数的值, 会被函数修改, 然后传出函数取代原有的值。 详情请参照 In-Out Parameters.</p>
<p>你可以只传入一个变量作为输入输出参数。 你不能传入一个常量或者字面值作为参数, 因为常量和字面量不能改变。当你使用它作为输入输出参数时,你可以直接在变量名前加上 (&amp;), 来表示它可以被函数改变。</p>
<p>备注</p>
<p>输入输出参数不能有默认值, 可变参数不能标记为输入输出的。</p>
<p>这里有一个函数 swapTwoInts(<em>:</em>:), 有两个输入输出整形参数 a 和 b:<br><code><br>func swapTwoInts(<em> a: inout Int, </em> b: inout Int) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}<br></code><br>swapTwoInts(<em>:</em>:) 函数简单的交换a和b的值,这个函数通过把a的值存储到一个临时的常量temporaryA 来实现交换, 把b的值赋给a, 然后把 temporaryA 的值赋给b.</p>
<p>你可以调用 swapTwoInts(<em>:</em>:) 函数交换两个整形变量的值。 注意 someInt 和 anotherInt 在传给函数的时候前面都加上了 &amp;:<br><code><br>var someInt = 3<br>var anotherInt = 107<br>swapTwoInts(&amp;someInt, &amp;anotherInt)<br>print(“someInt is now (someInt), and anotherInt is now (anotherInt)”)<br>// 打印 “someInt is now 107, and anotherInt is now 3”<br></code><br>上面例子展示 someInt 和 anotherInt 的原始值被 swapTwoInts(<em>:</em>:) 函数改变, 尽管它们定义在函数之外。</p>
<p>备注</p>
<p>输入输出参数与函数返回值不一样。swapTwoInts 没有定义一个返回值或者返回一个值。但是它依然改变了 someInt 和 anotherInt 的值。 输入输出参数是函数影响外部的一种备选方式。</p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>每个函数都有一个指定的函数类型, 由参数类型和返回值类型组成。</p>
<p>例如:<br><code><br>func addTwoInts(<em> a: Int, </em> b: Int) -&gt; Int {<br>    return a + b<br>}<br>func multiplyTwoInts(<em> a: Int, </em> b: Int) -&gt; Int {<br>    return a * b<br>}<br></code><br>这个例子定义了两个简单的数学函数 addTwoInts 和 multiplyTwoInts. 两个函数都接受两个整形值, 然后返回一个整形值, 执行合适的数学运算会得出这个结果。</p>
<p>两个函数的类型都是(Int, Int) -&gt; Int. 可以解读为:</p>
<p>“一个函数类型有两个参数, 两个都是整数类型t, 然后返回一个整形值”</p>
<p>这里有另外一个例子, 一个没有参数和返回值的函数:<br><code><br>func printHelloWorld() {<br>    print(“hello, world”)<br>}<br></code><br>这个函数类型是 () -&gt; Void, 或者 “一个函数没有参数,返回 Void.”</p>
<h1 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h1><p>使用函数类型跟Swift中其他类型很像。例如, 你可以定义一个函数的常量或者变量,然后把一个函数赋值给这个变量:<br><code><br>var mathFunction: (Int, Int) -&gt; Int = addTwoInts<br></code><br>这段代码可以解读为:</p>
<p>“定义一个变量 mathFunction, 带有两个整形值的函数类型, 然后返回一个整形值。’ 调用函数 addTwoInts 给这个变量设置值。”</p>
<p>addTwoInts(<em>:</em>:) 函数和 mathFunction 变量一样有相同的类型, 所有赋值是允许的。</p>
<p>你现在可以使用 mathFunction 名字调用赋值函数:<br><code><br>print(“Result: (mathFunction(2, 3))”)<br>// 打印 “Result: 5”<br></code><br>有相同匹配类型的不同函数也可以赋值给相同的变量, 和非函数类型一样:<br><code><br>mathFunction = multiplyTwoInts<br>print(“Result: (mathFunction(2, 3))”)<br>// 打印 “Result: 6”<br></code><br>其他任何类型, 当你把函数赋值给一个常量或者变量时,你可以留给 Swift 去推断函数类型:<br><code><br>let anotherMathFunction = addTwoInts<br>// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int<br></code></p>
<h1 id="函数类型作为参数类型"><a href="#函数类型作为参数类型" class="headerlink" title="函数类型作为参数类型"></a>函数类型作为参数类型</h1><p>你可以使用一个函数类型比如 (Int, Int) -&gt; Int 作为另外一个函数的参数。当函数调用的时候,你可以把函数实现的一部分留给调用者。</p>
<p>这里有个一个例子打印上面数学函数的结果:<br><code><br>func printMathResult(<em> mathFunction: (Int, Int) -&gt; Int, </em> a: Int, <em> b: Int) {<br>    print(“Result: (mathFunction(a, b))”)<br>}<br>printMathResult(addTwoInts, 3, 5)<br>// 打印 “Result: 8”<br></em></code><br>这个例子定义了一个函数 printMathResult(:<em>:</em>:), 有三个参数。第一个参数是 mathFunction, 类型 (Int, Int) -&gt; Int. 你可以传递任何这种类型的函数作为第一个参数。 第二个和第三个参数是 a 和 b, 都是整型, 用来作为数学函数的输入值。</p>
<p>当 printMathResult(<em>:</em>:<em>:) 调用时, 传入 addTwoInts(</em>:_:) 函数, 和整数 3 和 5. 调用提供的函数, 然后打印结果 8.</p>
<p>printMathResult(<em>:</em>:<em>:) 任务就是打印特定类型数学函数的结果。它不关心函数的实际实现—它只关心函数类型是否正确。 这使得 printMathResult(</em>:<em>:</em>:) 以一种类型安全的方式放手一些功能给函数的调用者。</p>
<h1 id="函数类型和返回值"><a href="#函数类型和返回值" class="headerlink" title="函数类型和返回值"></a>函数类型和返回值</h1><p>你可以用一个函数类型作为另外一个函数的返回类型。把一个完整的函数类型写在返回箭头后面就可以了。</p>
<p>下一个例子定义了两个简单的函数 stepForward(<em>:) 和 stepBackward(</em>:). stepForward(<em>:) 函数返回一个比输入值大一的值, stepBackward(</em>:) 函数返回一个比输入值小一的值。两个函数都有一个类型 (Int) -&gt; Int:<br><code><br>func stepForward(<em> input: Int) -&gt; Int {<br>    return input + 1<br>}<br>func stepBackward(</em> input: Int) -&gt; Int {<br>    return input - 1<br>}<br></code><br>这里有一个函数 chooseStepFunction(backward:), 返回类型是 (Int) -&gt; Int. chooseStepFunction(backward:) 函数基于一个布尔参数backward 来返回 stepForward(<em>:) 函数或 stepBackward(</em>:) 函数:<br><code><br>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {<br>    return backward ? stepBackward : stepForward<br>}<br></code><br>现在你可以使用 chooseStepFunction(backward:) 去获取一个函数, 然后往前走或者往后走:<br><code><br>var currentValue = 3<br>let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)<br>// moveNearerToZero 调用 stepBackward() 函数<br></code><br>前面的例子决定是否需要一个负数或者正数步去移动currentValue ,让它逐渐趋近于0. currentValue 有个初始值3, 意味着 currentValue &gt; 0 返回真, chooseStepFunction(backward:) 会返回 stepBackward(_:) 函数。 引用的返回函数存储在一个常量 moveNearerToZero.</p>
<p>moveNearerToZero 指向恰当的函数, 它可以用来计步到0:<br><code><br>print(“Counting to zero:”)<br>// Counting to zero:<br>while currentValue != 0 {<br>    print(“(currentValue)… “)<br>    currentValue = moveNearerToZero(currentValue)<br>}<br>print(“zero!”)<br>// 3…<br>// 2…<br>// 1…<br>// zero!<br></code></p>
<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>到目前为止,你在本章看见的函数都是全局的示例, 它们定义在全局范围。你也可以在其他函数体内定义函数,这就是嵌套函数。</p>
<p>嵌套函数默认对外界隐藏, 但是对于它们的封闭函数依然可以使用。封闭函数可以返回一个嵌套函数, 并允许它给外部使用。</p>
<p>你可以重写上面的 chooseStepFunction(backward:) 例子来使用和返回嵌套函数:<br><code><br>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {<br>    func stepForward(input: Int) -&gt; Int { return input + 1 }<br>    func stepBackward(input: Int) -&gt; Int { return input - 1 }<br>    return backward ? stepBackward : stepForward<br>}<br>var currentValue = -4<br>let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)<br>// moveNearerToZero now refers to the nested stepForward() function<br>while currentValue != 0 {<br>    print(“(currentValue)… “)<br>    currentValue = moveNearerToZero(currentValue)<br>}<br>print(“zero!”)<br>// -4…<br>// -3…<br>// -2…<br>// -1…<br>// zero!<br></code></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是自包含的功能块,可以传递和用在代码中。Swift 中的闭包和C 和 Objective-C 中的相似。</p>
<p>闭包可以捕获和存储上下文定义的任何常量和变量的引用。这就是关闭了常量和变量。Swift 替你处理闭包的所有内存管理。</p>
<p>备注</p>
<p>如果不熟悉闭包的概念不用担心。 下面会详细描述。</p>
<p>全局和嵌套函数实际上是一种特殊的闭包。闭包通常是下面三种形式之一:</p>
<p>全局函数是闭包,没有名字也不捕获任何值。<br>嵌套函数是闭包,有一个名字也可以从封闭函数中捕获值。<br>闭包表达式是匿名闭包,使用轻量级语法书写,可以捕获上下文的值。<br>Swift 的闭包表达式有一个清楚清晰的风格, 鼓励简洁,整齐的语法优化。这些优化包括:</p>
<p>从上下文推断参数和返回值的类型<br>从单个表达式闭包隐式返回<br>简约参数名<br>尾部闭包语法</p>
<h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><p>嵌套函数, 是一个方便的命名方法,也是在较大函数中定义自包含代码块的方式。不过, 有时候写一个更短的版本很有用, 它很像函数但是没有完整的声明和名字。函数作为参数的时候这个尤其有用。</p>
<p>闭包表达式是内联闭包的一种简写。 闭包表达式提供一些语法优化,以更短的样式书写闭包,但不失清晰和目的性。下面的闭包实例通过精炼一个排序函数来展示这些优化, 每个表达式功能一样,只是更简洁。</p>
<h1 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h1><p>Swift 标准库提供了一个方法 sorted(by:), 对已知类型数组值进行排序, 基于你提供的排序闭包输出。一旦排序完成, sorted(by:) 方法就会返回一个跟旧数组相同类型相同大小的新数组, 数组元素按照正确的顺序。原来的数组并没有被排序方法改变。</p>
<p>下面的闭包表达式使用 sorted(by:) 方法按照字母表倒序排列一个字符串数组。这是要排序的原来的数组:<br><code><br>let names = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]<br></code><br>sorted(by:) 方法接受带有两个相同类型参数的闭包,作为数组的内容。然后返回一个布尔值,来说明排序后第一个值是出现在第二个值的前面还是后面。</p>
<p>这个例子是排序一个字符串值的数组, 所以排序闭包需要是一个函数类型 (String, String) -&gt; Bool.</p>
<p>提供排序闭包的一个方式是写一个正确类型的函数, 然后把它作为参数传给 sorted(by:) 方法:<br><code><br>func backward(<em> s1: String, </em> s2: String) -&gt; Bool {<br>    return s1 &gt; s2<br>}</code></p>
<p>var reversedNames = names.sorted(by: backward)<br>// reversedNames is equal to [“Ewa”, “Daniella”, “Chris”, “Barry”, “Alex”]<br><br>如果第一个字符串 (s1) 大于第二个字符串 (s2), backward(<em>:</em>:) 函数返回真, 表明在排序后数组中 s1 应该出现在 s2 前面。 对于字符串中字符, “大于” 意思是 “字母表中出现较晚”。 也就说字母 “B” 大于字母 “A”, 字符串”Tom” 大于字符串 “Tim”. 这是提供了一个字母表的倒序, “Barry” 排在 “Alex”前面, 等等。</p>
<p>不过, 这种写法很冗长,它本质上是个单一表达式函数 (a &gt; b). 这个例子里, 写成内联排序闭包更可取, 使用闭包表达式语法。</p>
<h1 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h1><p>闭包表达式一般是下面这种形式:<br><code><br>{ (parameters) -&gt; return type in<br>    statements<br>}<br></code><br>闭包表达式语法参数可以是输入输出参数, 但是它们不能有默认值。 如果你命名可变参数,那么可变参数也是可以用的。元组也可以用作参数和返回类型。</p>
<p>下面的例子展示了之前 backward(<em>:</em>:) 函数的闭包表达式版本:<br><code><br>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in<br>    return s1 &gt; s2<br>})<br></code><br>内联闭包的参数和返回类型声明跟backward(<em>:</em>:)函数的声明一样。两种情况下, 它写作 (s1: String, s2: String) -&gt; Bool. 不过, 对于内联闭包表达式, 参数和返回类型都写作花括号里,而不是外部。</p>
<p>闭包体以关键字in 开始。这个关键词的意思是闭包参数和返回类型的定义完成了, 闭包体开始了。</p>
<p>因为闭包体太短, 它甚至可以写成一行:<br><code><br>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )</code><br>这个说明 sorted(by:) 方法调用还是一样的。一对括号包括方法的所有参数。 只不过,现在参数在一个内联闭包里。</p>
<h1 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h1><p>由于排序闭包作为参数传给函数, Swift 可以推断它的参数类型和返回值类型。sorted(by:) 方法被字符串数组调用, 所以它的参数类型是一个函数类型 (String, String) -&gt; Bool. 这就是说 (String, String) 和 Bool 类型无需写出来作为闭包表达式定义的一部分。因为所有的类型都可以推断, 返回箭头 (-&gt;) 和参数名字外的括号都可以被忽略:<br><code><br>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )</code><br>当把闭包传给一个函数或者方法作为内联闭包表达式时,总是可能要推断参数类型和返回类型。结果是, 一旦这个闭包用作函数或者方法参数,你就不需要用完整的形式书写内联闭包。</p>
<p>尽管如此, 如果你想你依然可以显式说明类型, 如果可以避免代码的二义性,这样做是鼓励的。sorted(by:) 方法这种情况, 闭包的目的很清晰,就是排序。读者假设这个闭包可能作用于字符串值是安全的。因为它帮助字符串数组的排序。</p>
<h1 id="从单一表达式闭包隐式返回"><a href="#从单一表达式闭包隐式返回" class="headerlink" title="从单一表达式闭包隐式返回"></a>从单一表达式闭包隐式返回</h1><p>通过忽略声明的返回关键字,单一表达式闭包可以隐式返回它们单一表达式的结果, 就像前一个例子的版本:<br><code><br>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )</code><br>这里, sorted(by:) 函数的方法参数清晰表明闭包要返回一个布尔值。因为闭包体包含了单一表达式(s1 &gt; s2) ,而且返回值是布尔值, 这里没有二义性, 而且返回值可以忽略。</p>
<h1 id="速记参数名"><a href="#速记参数名" class="headerlink" title="速记参数名"></a>速记参数名</h1><p>Swift 自动提供速记参数名给内联闭包, 可以用 $0, $1, $2, 来调用闭包参数值</p>
<p>如果你在闭包表达式使用这些速记参数名, 你可以忽略闭包定义的参数列表和个数,然后速记参数名类型会被期望的函数类型推断出来。 关键字in 也可以被忽略, 因为闭包表达式由它的整个包体组成。<br><code><br>reversedNames = names.sorted(by: { $0 &gt; $1 } )</code><br>这里, $0 和 $1 调用闭包的第一个和第二个字符串参数。</p>
<h1 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h1><p>这里其实有一个更短的方式去写上面的闭包。 Swift 的字符串类型定义了它特有的大于号的实现, 是带有两个字符串类型参数的方法,然后返回一个布尔类型。这很符合 the sorted(by:) 方法的类型需要。因此, 你可以简单的传入大于号, 然后 Swift 会推断你想要用它的字符串特有的实现:<br><code><br>reversedNames = names.sorted(by: &gt;)</code></p>
<h1 id="尾闭包"><a href="#尾闭包" class="headerlink" title="尾闭包"></a>尾闭包</h1><p>如果你需要传给函数一个闭包表达式作为最后的参数并且闭包表达式很长的话, 用尾闭包代替是很有用的。尾闭包写在函数调用的括号后面, 尽管它依然是函数的一个参数。 当你使用尾闭包语法时, 作为函数调用部分,你不要给闭包写参数标签。<br><code><br>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {<br>    // function body goes here<br>}</code></p>
<p>// 不使用尾闭包调用函数:</p>
<p>someFunctionThatTakesAClosure(closure: {<br>    // closure’s body goes here<br>})</p>
<p>// 使用尾闭包调用函数:</p>
<p>someFunctionThatTakesAClosure() {<br>    // trailing closure’s body goes here<br>}<br><br>字符串排序闭包也可以使用尾闭包:<br><code><br>reversedNames = names.sorted() { $0 &gt; $1 }</code><br>如果闭包表达式是作为函数或者方法的唯一参数,并且你使用这个表达式作为尾闭包的话, 你调用这个函数的时候可以不用在函数名后写括号:<br><code><br>reversedNames = names.sorted { $0 &gt; $1 }</code><br>当闭包太长无法写成内联单行的时候, 使用尾闭包是最有用的。有一个例子, Swift 数组类型有个方法 map(_:) ,带有一个闭包表达式作为它的单一参数。数组中的每一项都会调用它一次, 为每项返回一个替代映射值 (可能是其他类型)。映射的性质和返回值的类型由闭包决定。</p>
<p>对每个数组元素应用提供的闭包后, map(_:) 方法返回包含新的映射值的新数组, 和原有数组对应值的顺序一致。</p>
<p>这里展示使用带尾闭包的 map(_:) 方法如何把整型值数组转换为字符串值数组。数组 [16, 58, 510] 用来创建新数组 [“OneSix”, “FiveEight”, “FiveOneZero”]:<br><code><br>let digitNames = [<br>    0: “Zero”, 1: “One”, 2: “Two”,   3: “Three”, 4: “Four”,<br>    5: “Five”, 6: “Six”, 7: “Seven”, 8: “Eight”, 9: “Nine”<br>]<br>let numbers = [16, 58, 510]</code><br>上面的代码创建了一个字典,在整数字和英文名之间建立迎神。同时定义了一个整数数组, 准备转换为字符串数组。</p>
<p>现在你可以用这个数字数组来创建一个字符串数组, 把闭包表达式作为尾闭包传入数组的 map(<em>:) 方法即可:<br><code><br>let strings = numbers.map {<br>    (number) -&gt; String in<br>    var number = number<br>    var output = “”<br>    repeat {<br>        output = digitNames[number % 10]! + output<br>        number /= 10<br>    } while number &gt; 0<br>    return output<br>}<br>// strings is inferred to be of type [String]<br>// its value is [“OneSix”, “FiveEight”, “FiveOneZero”]<br></code><br>数组每个元素调用一次 map(</em>:) 方法。 你不需要指定闭包输入参数的类型, number, 因为这个值可以被推断出来。</p>
<p>这个例子里, 变量 number 用闭包的 number 参数值来初始化, 所以这个值可以在闭包中修改。 (函数和闭包的参数总是常量的) 闭包表达式指定了一个字符串返回值类型, 来说明存储在映射输出数组中的类型。</p>
<p>每次调用闭包表达式创建一个字符串 output. 它使用余数运算符结算数字的最后一位 (number % 10), 然后用这个位去字典中查找对应的字符串。这个闭包可以用来创建任何大于0数字的字符串表示。</p>
<p>备注</p>
<p>调用字典下标后面跟着感叹号 (!), 因为字典下标返回一个可选值来表示如果键不存在查找就会失败。上面的例子里, 可以保证每次能找到有效的下标键, 所以感叹号用来强制解包存在的值。</p>
<p>从字典获取的字符串会加到 output 前, 有效的建立了倒序的数字字符串版本。</p>
<p>然后数字变量除以10, 因为它是一个整数, 因为取整数倍, 所以 16 变成 1, 58 变成 5, 510 变成 51.</p>
<p>这个过程直到nubmer等于0, 这时闭包返回输出字符串, 然后通过 map(_:) 方法添加到数组。</p>
<p>上例尾闭包语法的使用,完整封装了闭包的功能。不要把整个闭包包含在 map(_:) 方法的method 外面括弧里。</p>
<h1 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h1><p>闭包可以在其定义的上下文中捕获常量和变量值。闭包可以在包体内调用和修改这些常量和变量值, 即使定义常量和变量的原来的范围不存在了。</p>
<p>在 Swift 中, 可以捕获值的最简单的闭包形式是一个内嵌函数, 写在另外一个函数体内。 内嵌函数可以捕获它外部函数的任何参数,而且可以捕获定义在外部函数的任何常量和变量。</p>
<p>这里有函数实例 makeIncrementer, 包含了一个内嵌函数 incrementer. 内嵌函数从它的上下文 incrementer() 捕获两个值, runningTotal 和 amount. 捕获这两个值以后, incrementer 被 makeIncrementer 作为闭包返回, 这个闭包每次调用时会把 runningTotal 增加 amount.<br><code><br>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br>    var runningTotal = 0<br>    func incrementer() -&gt; Int {<br>        runningTotal += amount<br>        return runningTotal<br>    }<br>    return incrementer<br>}</code><br>makeIncrementer 的返回类型是 () -&gt; Int. 意思就是返回一个函数, 而不是一个简单值。返回的函数没有参数, 每次调用有一个整型值。</p>
<p>makeIncrementer(forIncrement:) 函数定义了一个整型变量 runningTotal, 用来保存incrementer 返回的增加的总步数。这个变量初始化值是 0.</p>
<p>makeIncrementer(forIncrement:) 有一个整型参数带有forIncrement 标签, 和一个变量名 amount. 这个参数传给指定 runningTotal 应该增加多少步数。makeIncrementer 定义了一个内嵌函数incrementer, 用来执行实际的递增操作。 这个函数简单把 amount 加到 runningTotal 上去然后返回结果。</p>
<p>单独拿出来, 内嵌函数 incrementer() 不太寻常:<br><code><br>func incrementer() -&gt; Int {<br>    runningTotal += amount<br>    return runningTotal<br>}</code><br>incrementer() 函数没有任何参数, 然而它从函数体内部调用runningTotal 和 amount。 它从包围它的函数里捕获 runningTotal 和 amount. 引用捕获确保 runningTotal 和 amount 在调用 makeIncrementer 结束后不会消失, 也确保了 runningTotal 在下一次调用 incrementer 函数时依然有效。</p>
<p>备注</p>
<p>作为一个优化, 如果闭包修改一个值, 而且闭包创建后这个值没有改变的话,Swift 可能会不会捕获和保存这个值的副本。</p>
<p>Swift 同时处理了变量释放后的所有的内存管理。</p>
<p>这里有一个 makeIncrementer 活动的例子:<br><code><br>let incrementByTen = makeIncrementer(forIncrement: 10)</code><br>这个例子设置了一个常量 incrementByTen,它调用增量器函数,这个函数每次调用把 runningTotal 变量加10. 多次调用效果如下:<br><code><br>incrementByTen()<br>// returns a value of 10<br>incrementByTen()<br>// returns a value of 20<br>incrementByTen()<br>// returns a value of 30<br></code><br>如果你再创建一个增量器, 它会有自己新的单独的runningTotal 变量:<br><code><br>let incrementBySeven = makeIncrementer(forIncrement: 7)<br>incrementBySeven()<br>// returns a value of 7<br></code><br>调用原先的增量器(incrementByTen) 继续增加它的 runningTotal 变量, 不会影响 incrementBySeven 捕获的变量:<br><code><br>incrementByTen()<br>// returns a value of 40</code><br>备注</p>
<p>如果你把闭包赋值给一个类实例的属性, 然后闭包会通过引用这个实例或者它的成员来捕获这个实例。你将在闭包和实例之间建立一个强引用循环。 Swift 使用捕获列表来打破这种强引用循环。</p>
<h1 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h1><p>上面的例子, incrementBySeven 和 incrementByTen 都是常量, 但是这些常量引用的闭包依然可以改变它们已经捕获的 runningTotal 变量。 这是因为函数和闭包是引用类型。</p>
<p>每当你赋值函数或者闭包给一个常量或者变量, 实际上你是设置常量或者变量去引用函数或者闭包。上面的例子, incrementByTen 引用的闭包选择是常量, 而不是闭包本身的内容。</p>
<p>这也意味着如果你把一个闭包赋值给两个不同的常量或者变量,它们引用的是相同的闭包:<br><code><br>let alsoIncrementByTen = incrementByTen<br>alsoIncrementByTen()<br>// returns a value of 50<br></code></p>
<h1 id="逃离闭包"><a href="#逃离闭包" class="headerlink" title="逃离闭包"></a>逃离闭包</h1><p>闭包被传给函数作为参数的事据说会逃离, 但是会在函数返回时调用。 一旦你定义带有闭包作为参数的函数, 你可以在参数类型前书写 @escaping 来表示这个闭包允许逃离。</p>
<p>闭包逃离的方式之一是,通过存储在定义在函数外部的变量中。作为一个例子, 很多函数用闭包参数作为一个完成处理器来异步工作。 任务开始时函数返回, 但是函数完成之前闭包不会调用—这个闭包需要逃离, 后面再调用。例如:<br><code><br>var completionHandlers: [() -&gt; Void] = []<br>func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {<br>    completionHandlers.append(completionHandler)<br>}<br></code><br>someFunctionWithEscapingClosure(_:) 函数接受一个闭包作为参数,并且把它添加到外部定义的数组。如果你不把这个参数标记为 @escaping, 你会收到一个编译错误。</p>
<p>标记 @escaping 意思是你必须在闭包里显式引用self。例如, 下面的代码, 传给 someFunctionWithEscapingClosure(<em>:) 的闭包是一个逃离闭包, 意思是需要显式引用self。 相反, 传给 someFunctionWithNonescapingClosure(</em>:) 的闭包是非逃离的, 意思是可以隐式引用self.<br><code><br>func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {<br>    closure()<br>}</code></p>
<p>class SomeClass {<br>    var x = 10<br>    func doSomething() {<br>        someFunctionWithEscapingClosure { self.x = 100 }<br>        someFunctionWithNonescapingClosure { x = 200 }<br>    }<br>}</p>
<p>let instance = SomeClass()<br>instance.doSomething()<br>print(instance.x)<br>// Prints “200”</p>
<p>completionHandlers.first?()<br>print(instance.x)<br>// Prints “100”<br></p>
<h1 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h1><p>自动闭包是自动创建的闭包, 它包含了作为参数传入函数的表达式。它没有任何参数, 并且被调用时, 它会返回表达式的值。 这个语法便利让你可以忽略函数参数的花括号,只要写一个正常的表达式替代显式的闭包。</p>
<p>调用带有自动闭包的函数很常见, 但是实现那种函数却不常见。例如, assert(condition:message:file:line:) 函数为它的 condition 和 message 参数带了一个自动闭包; 它的condition 参数只在调试模式执行, message 参数则在 condition 是假的时候执行。</p>
<p>自动闭包让你延迟执行, 直到你调用闭包内部代码才会运行。延迟作用对于边界影响和昂贵计算代码很有用, 因为它可以让控制代码什么时候执行。 下面的代码展示闭包的延迟执行。<br><code><br>var customersInLine = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]<br>print(customersInLine.count)<br>// Prints “5”</code></p>
<p>let customerProvider = { customersInLine.remove(at: 0) }<br>print(customersInLine.count)<br>// Prints “5”</p>
<p>print(“Now serving (customerProvider())!”)<br>// Prints “Now serving Chris!”<br>print(customersInLine.count)<br>// Prints “4”<br><br>尽管 customersInLine 数组第一个元素被闭包内的代码给移除了, 但是直到这个闭包实际被调用,数组的元素才会被移除。如果闭包永不调用, 闭包内的表达式永远不会执行, 也就是说数组元素永不会被移除。注意 customerProvider 类型不是 String 而是 () -&gt; String—不带参数的函数只是返回一个字符串。</p>
<p>当你把闭包传给函数时,你会得到相同的延迟执行效果。<br><code><br>// customersInLine is [“Alex”, “Ewa”, “Barry”, “Daniella”]<br>func serve(customer customerProvider: () -&gt; String) {<br>    print(“Now serving (customerProvider())!”)<br>}<br>serve(customer: { customersInLine.remove(at: 0) } )<br>// Prints “Now serving Alex!”<br></code><br>serve(customer:) 函数有一个显式闭包用户返回一个用户名。 下面版本的 serve(customer:) 做了相同的操作,不过, 不是接受一个显式闭包, 而是在参数类型前用了 @autoclosure 属性。 现在你可以调用这个函数,好像他是带有一个String 参数而不是一个闭包。这个参数会自动转换为闭包,因为 customerProvider 参数类型已经标记为 @autoclosure .<br><code><br>// customersInLine is [“Ewa”, “Barry”, “Daniella”]<br>func serve(customer customerProvider: @autoclosure () -&gt; String) {<br>    print(“Now serving (customerProvider())!”)<br>}<br>serve(customer: customersInLine.remove(at: 0))<br>// 打印 “Now serving Ewa!”<br></code><br>备注</p>
<p>过度使用自动闭包会让你的代码很难理解。 上下文和函数名字应该让人知道执行推迟了。</p>
<p>如果你想让自动闭包可以逃离, 同时使用 @autoclosure 和 @escaping 属性。<br><code><br>// customersInLine is [“Barry”, “Daniella”]<br>var customerProviders: [() -&gt; String] = []<br>func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {<br>    customerProviders.append(customerProvider)<br>}<br>collectCustomerProviders(customersInLine.remove(at: 0))<br>collectCustomerProviders(customersInLine.remove(at: 0))</code></p>
<p>print(“Collected (customerProviders.count) closures.”)<br>// Prints “Collected 2 closures.”<br>for customerProvider in customerProviders {<br>    print(“Now serving (customerProvider())!”)<br>}<br>// 打印 “Now serving Barry!”<br>// 打印 “Now serving Daniella!”<br><br>上面的代码, 不是调用作为 customerProvider 参数的闭包, collectCustomerProviders(_:) 函数添加闭包到 customerProviders 数组。 数组在函数外部声明, 意味着函数返回后数组中的闭包会执行。 结果就是, customerProvider 参数值必须被允许逃离函数范围。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>一个枚举定义一组相关的常见类型的值, 让你在代码中用一个类型安全的方式工作。</p>
<p>如果你熟悉 C, 你就会知道 C 枚举会给相关的名字赋值一组整型值。 Swift 中的 枚举更加灵活, 不需要给每个枚举分支赋值。 如果提供一个值 ( “raw” 值), 这个值可以是字符串,字符,或者任意一个整型或者浮点型的值。</p>
<p>另外, 枚举的不同分支可以指定任何类型对应值。很像其他语言的 unions 或者 variants. 你可以定义一个常见的相关的case集合来作为枚举的一部分。每部分都有相应的值对应它们。</p>
<p>Swift 的枚举是第一等类型。它们采用传统上只有类才支持的多种特性, 例如计算属性来提供关于枚举当前值的额外信息, 实例方法来提供有关枚举表示值的功能。枚举还可以用初始化来定义初始化值; 可以扩大它们原有实现的功能; 并且可以遵守协议去提供标准功能。</p>
<h1 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h1><p>用enum关键字引入枚举,在大括号中定义整个枚举:<br><code><br>enum SomeEnumeration {<br>    // enumeration definition goes here<br>}</code><br>这里有个指南者四个方位的例子:<br><code><br>enum CompassPoint {<br>    case north<br>    case south<br>    case east<br>    case west<br>}</code><br>定义在枚举中的值就是枚举case (比如 north, south, east, and west) 你可以用case 关键之来引入新的枚举case.</p>
<p>备注</p>
<p>不像 C 和 Objective-C, Swift 枚举case创建时不设一个默认的整数值。上面的 CompassPoint 例子, north, south, east 和 west 不会隐式等于 0, 1, 2 和 3. 相反, 不同的枚举case 在右方都有值t, 有一个显式定义的 CompassPoint 类型。</p>
<p>多个case可以出现在一行,用逗号分开:<br><code><br>enum Planet {<br>    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune<br>}</code><br>每个枚举定义定义了一个全新的类型。 像Swift中的其他类型一样,它们的名字 (比如 CompassPoint 和 Planet) 应该以大写字母开始。 用单数名而不是复数名:<br><code><br>var directionToHead = CompassPoint.west</code><br>directionToHead 类型在初始化时推断类型。只要 directionToHead 声明为 CompassPoint, 你可以用一个短的点语法来给它设置一个不同的 CompassPoint 值:<br><code><br>directionToHead = .east</code><br>directionToHead 类型已经知道了, 所以设置值的时候可以丢掉类型了。使用显式类型枚举值时这个会让代码高度可读。</p>
<h1 id="用Switch语句匹配枚举值"><a href="#用Switch语句匹配枚举值" class="headerlink" title="用Switch语句匹配枚举值"></a>用Switch语句匹配枚举值</h1><p>你可以用一个switch语句来匹配单个枚举值:<br><code><br>directionToHead = .south<br>switch directionToHead {<br>case .north:<br>    print(“Lots of planets have a north”)<br>case .south:<br>    print(“Watch out for penguins”)<br>case .east:<br>    print(“Where the sun rises”)<br>case .west:<br>    print(“Where the skies are blue”)<br>}<br>// 打印 “Watch out for penguins”<br></code><br>你可以这样解读代码:</p>
<p>“考察 directionToHead 的值。等于 .north, 打印 “Lots of planets have a north”. 等于 .south, 打印 “Watch out for penguins”.”</p>
<p>…等等。</p>
<p>控制流里描述过, switch 语句考察枚举case 时一定要详尽。 如果 .west case 忽略掉, 代码会编译不过, 因为它没有完整考察 CompassPoint 所有case. 要求详尽保证枚举case不会被疏忽掉。</p>
<p>如果提供所有的case 不合适, 你可以提供一个默认case来覆盖没有显式指明的case:<br><code><br>let somePlanet = Planet.earth<br>switch somePlanet {<br>case .earth:<br>    print(“Mostly harmless”)<br>default:<br>    print(“Not a safe place for humans”)<br>}<br>// 打印 “Mostly harmless”<br></code></p>
<h1 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h1><p>上部分实例展示枚举case是一个定义值（类型值）。 你可以把一个常量或者变量设置成 Planet.earth, 然后稍晚再判断这个值。 不过, 有时候存储其他类型的对应值是很有用的。这让你可以随着case存储其他自定义信息。</p>
<p>你可以定义 Swift 枚举来存储给定类型的对应值, 如果需要每个case的值类型可以不同。枚举和其他语言的可辨识联合，标签联合或者变体很类似。</p>
<p>例如, 假设库存跟踪系统需要用两种不同类型的条形码来追踪产品。一些产品用UPC格式标记为 1D 条形码, 这些使用数字 0 到 9. 每个条形码有一个“数字系统” 位, 后面是5个 “制造商码” 位然后是5个“产品码”位。 最后是“校验” 位来校验扫码正确性:</p>
<p><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png"><br></div><br>其他产品用二维码标记, 它使用任意的 ISO 8859-1 字符并且可以编码2953个字符长度:</p>
<p><div style="text-align:center"><br><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png"><br></div><br>这就方便库存跟踪系统能够用四个整数元组存储 UPC 条形码, 用一个任意长度的字符串存储二维码。</p>
<p>在 Swift 里, 枚举定义两种类型条形码可能如下所示:<br><code><br>enum Barcode {<br>    case upc(Int, Int, Int, Int)<br>    case qrCode(String)<br>}</code><br>可以这样解读:</p>
<p>“定义一个枚举类型 Barcode, 有一个upd的值对应 (Int, Int, Int, Int)类型, 和一个 qrCode 值对应 String 类型。”</p>
<p>定义没有提供任何实际的 Int 或者 String 值—它仅仅定义了对应值的类型。</p>
<p>新的条形码可以用任何一个类型来创建:<br><code><br>var productBarcode = Barcode.upc(8, 85909, 51226, 3)</code><br>这个例子创建了一个新的变量 productBarcode 然后用一个元组值(8, 85909, 51226, 3)赋给它一个 Barcode.upc值。</p>
<p>相同的产品可以指定一个不同的二维码类型:<br><code><br>productBarcode = .qrCode(“ABCDEFGHIJKLMNOP”)</code><br>这时候, 原先的 Barcode.upc 和它的整数值被新的 Barcode.qrCode 和它的字符串值取代。类型的常量或者变量可以存储 .upc 或者 .qrCode (带着对应的值), 不过在给定时间它们只能存储其中之一。</p>
<p>可以用一个switch语句判断不同的条形码类型。 这次, 无论如何, 对应的值被提取作为switch语句的部分。提取的值作为常量或者变量在switch语句的case中使用:<br><code><br>switch productBarcode {<br>case .upc(let numberSystem, let manufacturer, let product, let check):<br>    print(“UPC: (numberSystem), (manufacturer), (product), (check).”)<br>case .qrCode(let productCode):<br>    print(“QR code: (productCode).”)<br>}<br>// 打印 “QR code: ABCDEFGHIJKLMNOP.”<br></code><br>如果一个case的所有对应值都提取成常量或者变量, 或者都提取成变量, 你可以在这个case 名字前单独放一个let 或者 var, 为简洁性考虑:<br><code><br>switch productBarcode {<br>case let .upc(numberSystem, manufacturer, product, check):<br>    print(“UPC : (numberSystem), (manufacturer), (product), (check).”)<br>case let .qrCode(productCode):<br>    print(“QR code: (productCode).”)<br>}<br>// 打印 “QR code: ABCDEFGHIJKLMNOP.”<br></code></p>
<h1 id="Raw-Values"><a href="#Raw-Values" class="headerlink" title="Raw Values"></a>Raw Values</h1><p>Associated Values 中的条形码例子展示枚举case如何声明它们存储的不同类型的对应值。作为关联值的替代方式, 枚举case 可以填充默认值 (raw values), 它们都是相同的类型。</p>
<p>这里有个例子,在指定的枚举case 旁存储 raw ASCII 值:<br><code><br>enum ASCIIControlCharacter: Character {<br>    case tab = “\t”<br>    case lineFeed = “\n”<br>    case carriageReturn = “\r”<br>}<br></code><br>这里, 枚举 ASCIIControlCharacter 的raw 值定义为字符类型, 设成成一些比较常见的 ASCII 控制字符。</p>
<p>Raw 值可以是字符串, 字符, 或者任意整型或者浮点型数字类型。 每个raw 值在枚举声明里必须是唯一的。</p>
<p>备注</p>
<p>Raw 值作为对应值是不相同的。Raw 值用来在首次声明枚举时填充值, 就像上面三个 ASCII 码。特定case 的raw 值总是相同的。基于枚举case之一创建一个新的常量或者变量时设置关联值, 每次设置都可以不同。</p>
<h1 id="隐式赋-Raw-值"><a href="#隐式赋-Raw-值" class="headerlink" title="隐式赋 Raw 值"></a>隐式赋 Raw 值</h1><p>使用存储整型或者字符串类型的raw值时, 你不需要显式为每个case指定一个raw 值。如果你不设置, Swift 会为你自动指定值。</p>
<p>例如, 当整型用作raw 值时, 每个case 的隐式值比前一个case多一。如果第一个case没有设置值, 它的值是0.</p>
<p>下面的枚举是早期 Planet 枚举的细化版本, 带有整数 raw 值来代表距离每个星球距离太阳的顺序:<br><code><br>enum Planet: Int {<br>    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune<br>}</code><br>上面的例子, Planet.mercury有个显式的raw 值1, Planet.venus 有个显式的值 2, 以此类推。</p>
<p>字符串用作raw 值时, 每个case的隐式值是case 名字的文本字符串。</p>
<p>下面的枚举是早期 CompassPoint 枚举的细化版本, 使用字符串raw 值表示每个方向的名字:<br><code><br>enum CompassPoint: String {<br>    case north, south, east, west<br>}</code><br>上面的例子, CompassPoint.south 有个隐式的raw 值 “south”, 以此类推。</p>
<p>使用 rawValue 属性来访问枚举case的raw 值:<br><code><br>let earthsOrder = Planet.earth.rawValue<br>// earthsOrder is 3</code></p>
<p>let sunsetDirection = CompassPoint.west.rawValue<br>// sunsetDirection is “west”<br></p>
<h1 id="用-Raw-值初始化"><a href="#用-Raw-值初始化" class="headerlink" title="用 Raw 值初始化"></a>用 Raw 值初始化</h1><p>如果你用raw-值类型定义一个枚举, 枚举自动得到一个初始化方法, 这个初始化方法有一个raw值类型 (参数 rawValue) 并且返回一个枚举case或者nil. 你可以用这个初始化方法试着创建新的枚举实例。</p>
<p>这个例子用raw 值7标识 Uranus :<br><code><br>let possiblePlanet = Planet(rawValue: 7)<br>// possiblePlanet 是 Planet?类型并且等于Planet.uranus<br></code><br>不是所有的整数值都能找到一个对应的星球, 不过。 因为如此, raw 值初始化方法总是返回一个可选的枚举case. 上面的例子, possiblePlanet 是Planet?类型, 或者 “可选的 Planet.”</p>
<p>备注</p>
<p>raw 值初始化方法是灵活的, 因为不是每个raw 值都会返回一个枚举case.</p>
<p>如果尝试查找位置是11的星球, raw值初始化方法返回的 Planet 值为nil:<br><code><br>let positionToFind = 11<br>if let somePlanet = Planet(rawValue: positionToFind) {<br>    switch somePlanet {<br>    case .earth:<br>        print(“Mostly harmless”)<br>    default:<br>        print(“Not a safe place for humans”)<br>    }<br>} else {<br>    print(“There isn’t a planet at position (positionToFind)”)<br>}<br>// 打印 “There isn’t a planet at position 11”<br></code><br>这个例子使用可选绑定访问raw值是11的星球。 语句 <code>if let somePlanet = Planet(rawValue: 11) </code>创建了一个可选的 Planet, 然后设置 somePlanet 值为这个可选绑定的 Planet. 这种情况, 不可能获取到位置是11的星球, 所有else分支被执行了。</p>
<h1 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h1><p>递归枚举是这样一种枚举,它有另外一个枚举的实例,这个实例作为一个或者多个case的关联值。通过在枚举case 前书写indirect 来标明枚举是递归的。告诉编译器插入必要的间接层。</p>
<p>例如, 这里有一个枚举存储了简单的算术表达式:<br><code><br>enum ArithmeticExpression {<br>    case number(Int)<br>    indirect case addition(ArithmeticExpression, ArithmeticExpression)<br>    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)<br>}<br></code><br>你也可以在枚举开始写 indirect, 来保证所有需要的枚举case 是间接的:<br><code><br>indirect enum ArithmeticExpression {<br>    case number(Int)<br>    case addition(ArithmeticExpression, ArithmeticExpression)<br>    case multiplication(ArithmeticExpression, ArithmeticExpression)<br>}<br></code><br>这个枚举可以存储三种算术表达式: 一个简单数字, 两个表达式相加, 两个表达式相乘。 加法和乘法分支对应值也是算术表达式—内嵌表达式。 例如, 表达式 (5 + 4) <em> 2 乘法右边有一个数字,乘法左边有一个表达式。 因为数据是嵌套的, 枚举存储这个数据也需要支持嵌套—意思就是说枚举需要递归。 下面的代码展示为(5 + 4) </em> 2创建了一个递归枚举 ArithmeticExpression :<br><code><br>let five = ArithmeticExpression.number(5)<br>let four = ArithmeticExpression.number(4)<br>let sum = ArithmeticExpression.addition(five, four)<br>let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))<br></code><br>递归函数直接使用具有递归结构的数据。例如, 这里有个函数执行一个算术表达式:<br><code><br>func evaluate(_ expression: ArithmeticExpression) -&gt; Int {<br>    switch expression {<br>    case let .number(value):<br>        return value<br>    case let .addition(left, right):<br>        return evaluate(left) + evaluate(right)<br>    case let .multiplication(left, right):<br>        return evaluate(left) * evaluate(right)<br>    }<br>}</code></p>
<p>print(evaluate(product))<br>// 打印 “18”<br><br>这个函数通过返回关联值执行一个简单的数字。它执行一个加法和一个乘法,执行左边的表达式和右边的表达式,然后相加或者相乘它们。</p>
<h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><p>类和结构体是通用的,灵活的结构, 成为你程序代码的构建块。通过对常量,变量,函数使用相同的语法,你定义属性和方法来给类和结构体添加功能</p>
<p>跟其他语言不一样, Swift 不要你给类和结构体创建单独的接口和实现文件。在 Swift里, 你在一个单独的文件中定义类和结构体。 这些类和结构的对外接口对于其他代码是自动可用的。</p>
<p>备注</p>
<p>类的实例一般认为是一个对象。 不过, Swift 的类和结构体在功能上比其他语言更加接近, 这种描述的功能即可用在类的实例也可以用在结构体的实例上。因为如此, 更多通用术语实例被使用了。</p>
<h1 id="比较类和结构体"><a href="#比较类和结构体" class="headerlink" title="比较类和结构体"></a>比较类和结构体</h1><p>在Swift里类和结构体有很多相同的地方,它们都可以:</p>
<p>定义属性来存储值<br>定义函数提供功能<br>定义下标,提供下标语法访问值<br>定义初始化方法来设定初始状态<br>扩展默认实现的功能<br>遵守协议提供特定类型的标准功能</p>
<p>类具备结构体没有的额外能力:</p>
<p>继承,让一个类继承另外一个类的特征。<br>类型转换,类型转换让你可以在运行是判断和解释类的实例。<br>析构器可以释放类实例分配的任何资源。<br>引用计数允许对类实例的多次引用。</p>
<p>备注</p>
<p>结构体传值时都是拷贝,它不使用引用计数。</p>
<h1 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h1><p>类和结构体有相同的定义语法。 使用class 关键字引入类,使用struct关键字引入结构体。两者都把全部定义放在一堆大括号内:<br><code><br>class SomeClass {<br>// class definition goes here<br>}<br>struct SomeStructure {<br>// structure definition goes here<br>}</code><br>备注</p>
<p>一旦你定义了一个新的类或者结构体, 你就有效定义了一个全新的Swift类型。给一个大写驼峰式命名 (比如 SomeClass 和 SomeStructure here) 来匹配标准 Swift 类型大写。(比如 String, Int, 和 Bool). 相反, 属性和方法总是小写驼峰式命名 (比如 frameRate 和 incrementCount)</p>
<p>这里有一个结构体和一个类定义的例子:<br><code><br>struct Resolution {<br>var width = 0<br>var height = 0<br>}<br>class VideoMode {<br>var resolution = Resolution()<br>var interlaced = false<br>var frameRate = 0.0<br>var name: String?<br>}</code><br>上面的例子定义了一个新的结构体 Resolution, 描述一个基于像素的显示器解决方案。 这个结构体有两个存储属性 width 和 height. 存储属性是常量或者变量,捆绑存储作为类或者结构体的一部分。这两个属性因为初始值为0而被推断为整型。</p>
<p>上面的例子同时定义了一个新类 VideoMode, 来描述一个指定的视频模式用来视频显示。 这个类有四个变量存储属性。 第一个是 resolution, 用一个新的 Resolution 结构体实例来初始化, 推断为 Resolution 属性类型。 其他三个属性, new VideoMode instances will be initialized with an interlaced setting of false (meaning “noninterlaced video”), a playback frame rate of 0.0, and an optional String value called name. The name property is automatically given a default value of nil, or “no name value”, because it is of an optional type.</p>
<p>Class and Structure Instances</p>
<p>The Resolution structure definition and the VideoMode class definition only describe what a Resolution or VideoMode will look like. They themselves do not describe a specific resolution or video mode. To do that, you need to create an instance of the structure or class.</p>
<p>The syntax for creating instances is very similar for both structures and classes:</p>
<p>let someResolution = Resolution()<br>let someVideoMode = VideoMode()<br>Structures and classes both use initializer syntax for new instances. The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as Resolution() or VideoMode(). This creates a new instance of the class or structure, with any properties initialized to their default values. Class and structure initialization is described in more detail in Initialization.</p>
<p>Accessing Properties</p>
<p>You can access the properties of an instance using dot syntax. In dot syntax, you write the property name immediately after the instance name, separated by a period (.), without any spaces:</p>
<p>print(“The width of someResolution is (someResolution.width)”)<br>// Prints “The width of someResolution is 0”<br>In this example, someResolution.width refers to the width property of someResolution, and returns its default initial value of 0.</p>
<p>You can drill down into sub-properties, such as the width property in the resolution property of a VideoMode:</p>
<p>print(“The width of someVideoMode is (someVideoMode.resolution.width)”)<br>// Prints “The width of someVideoMode is 0”<br>You can also use dot syntax to assign a new value to a variable property:</p>
<p>someVideoMode.resolution.width = 1280<br>print(“The width of someVideoMode is now (someVideoMode.resolution.width)”)<br>// Prints “The width of someVideoMode is now 1280”<br>NOTE</p>
<p>Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly. In the last example above, the width property of the resolution property of someVideoMode is set directly, without your needing to set the entire resolution property to a new value.</p>
<p>Memberwise Initializers for Structure Types</p>
<p>All structures have an automatically-generated memberwise initializer, which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</p>
<p>let vga = Resolution(width: 640, height: 480)<br>Unlike structures, class instances do not receive a default memberwise initializer. Initializers are described in more detail in Initialization.</p>
<p>Structures and Enumerations Are Value Types</p>
<p>A value type is a type whose value is copied when it is assigned to a variable or constant, or when it is passed to a function.</p>
<p>You’ve actually been using value types extensively throughout the previous chapters. In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</p>
<p>All structures and enumerations are value types in Swift. This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</p>
<p>Consider this example, which uses the Resolution structure from the previous example:</p>
<p>let hd = Resolution(width: 1920, height: 1080)<br>var cinema = hd<br>This example declares a constant called hd and sets it to a Resolution instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).</p>
<p>It then declares a variable called cinema and sets it to the current value of hd. Because Resolution is a structure, a copy of the existing instance is made, and this new copy is assigned to cinema. Even though hd and cinema now have the same width and height, they are two completely different instances behind the scenes.</p>
<p>Next, the width property of cinema is amended to be the width of the slightly-wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):</p>
<p>cinema.width = 2048<br>Checking the width property of cinema shows that it has indeed changed to be 2048:</p>
<p>print(“cinema is now (cinema.width) pixels wide”)<br>// Prints “cinema is now 2048 pixels wide”<br>However, the width property of the original hd instance still has the old value of 1920:</p>
<p>print(“hd is still (hd.width) pixels wide”)<br>// Prints “hd is still 1920 pixels wide”<br>When cinema was given the current value of hd, the values stored in hd were copied into the new cinema instance. The end result is two completely separate instances, which just happened to contain the same numeric values. Because they are separate instances, setting the width of cinema to 2048 doesn’t affect the width stored in hd.</p>
<p>The same behavior applies to enumerations:</p>
<p>enum CompassPoint {<br>case north, south, east, west<br>}<br>var currentDirection = CompassPoint.west<br>let rememberedDirection = currentDirection<br>currentDirection = .east<br>if rememberedDirection == .west {<br>print(“The remembered direction is still .west”)<br>}<br>// Prints “The remembered direction is still .west”<br>When rememberedDirection is assigned the value of currentDirection, it is actually set to a copy of that value. Changing the value of currentDirection thereafter does not affect the copy of the original value that was stored in rememberedDirection.</p>
<p>Classes Are Reference Types</p>
<p>Unlike value types, reference types are not copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used instead.</p>
<p>Here’s an example, using the VideoMode class defined above:</p>
<p>let tenEighty = VideoMode()<br>tenEighty.resolution = hd<br>tenEighty.interlaced = true<br>tenEighty.name = “1080i”<br>tenEighty.frameRate = 25.0<br>This example declares a new constant called tenEighty and sets it to refer to a new instance of the VideoMode class. The video mode is assigned a copy of the HD resolution of 1920 by 1080 from before. It is set to be interlaced, and is given a name of “1080i”. Finally, it is set to a frame rate of 25.0 frames per second.</p>
<p>Next, tenEighty is assigned to a new constant, called alsoTenEighty, and the frame rate of alsoTenEighty is modified:</p>
<p>let alsoTenEighty = tenEighty<br>alsoTenEighty.frameRate = 30.0<br>Because classes are reference types, tenEighty and alsoTenEighty actually both refer to the same VideoMode instance. Effectively, they are just two different names for the same single instance.</p>
<p>Checking the frameRate property of tenEighty shows that it correctly reports the new frame rate of 30.0 from the underlying VideoMode instance:</p>
<p>print(“The frameRate property of tenEighty is now (tenEighty.frameRate)”)<br>// Prints “The frameRate property of tenEighty is now 30.0”<br>Note that tenEighty and alsoTenEighty are declared as constants, rather than variables. However, you can still change tenEighty.frameRate and alsoTenEighty.frameRate because the values of the tenEighty and alsoTenEighty constants themselves do not actually change. tenEighty and alsoTenEighty themselves do not “store” the VideoMode instance—instead, they both refer to a VideoMode instance behind the scenes. It is the frameRate property of the underlying VideoMode that is changed, not the values of the constant references to that VideoMode.</p>
<p>Identity Operators</p>
<p>Because classes are reference types, it is possible for multiple constants and variables to refer to the same single instance of a class behind the scenes. (The same is not true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)</p>
<p>It can sometimes be useful to find out if two constants or variables refer to exactly the same instance of a class. To enable this, Swift provides two identity operators:</p>
<p>Identical to (===)<br>Not identical to (!==)<br>Use these operators to check whether two constants or variables refer to the same single instance:</p>
<p>if tenEighty === alsoTenEighty {<br>print(“tenEighty and alsoTenEighty refer to the same VideoMode instance.”)<br>}<br>// Prints “tenEighty and alsoTenEighty refer to the same VideoMode instance.”<br>Note that “identical to” (represented by three equals signs, or ===) does not mean the same thing as “equal to” (represented by two equals signs, or ==):</p>
<p>“Identical to” means that two constants or variables of class type refer to exactly the same class instance.<br>“Equal to” means that two instances are considered “equal” or “equivalent” in value, for some appropriate meaning of “equal”, as defined by the type’s designer.<br>When you define your own custom classes and structures, it is your responsibility to decide what qualifies as two instances being “equal”. The process of defining your own implementations of the “equal to” and “not equal to” operators is described in Equivalence Operators.</p>
<p>Pointers</p>
<p>If you have experience with C, C++, or Objective-C, you may know that these languages use pointers to refer to addresses in memory. A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but is not a direct pointer to an address in memory, and does not require you to write an asterisk (*) to indicate that you are creating a reference. Instead, these references are defined like any other constant or variable in Swift.</p>
<p>Choosing Between Classes and Structures</p>
<p>You can use both classes and structures to define custom data types to use as the building blocks of your program’s code.</p>
<p>However, structure instances are always passed by value, and class instances are always passed by reference. This means that they are suited to different kinds of tasks. As you consider the data constructs and functionality that you need for a project, decide whether each data construct should be defined as a class or as a structure.</p>
<p>As a general guideline, consider creating a structure when one or more of these conditions apply:</p>
<p>The structure’s primary purpose is to encapsulate a few relatively simple data values.<br>It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.<br>Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.<br>The structure does not need to inherit properties or behavior from another existing type.<br>Examples of good candidates for structures include:</p>
<p>The size of a geometric shape, perhaps encapsulating a width property and a height property, both of type Double.<br>A way to refer to ranges within a series, perhaps encapsulating a start property and a length property, both of type Int.<br>A point in a 3D coordinate system, perhaps encapsulating x, y and z properties, each of type Double.<br>In all other cases, define a class, and create instances of that class to be managed and passed by reference. In practice, this means that most custom data constructs should be classes, not structures.</p>
<p>Assignment and Copy Behavior for Strings, Arrays, and Dictionaries</p>
<p>In Swift, many basic data types such as String, Array, and Dictionary are implemented as structures. This means that data such as strings, arrays, and dictionaries are copied when they are assigned to a new constant or variable, or when they are passed to a function or method.</p>
<p>This behavior is different from Foundation: NSString, NSArray, and NSDictionary are implemented as classes, not structures. Strings, arrays, and dictionaries in Foundation are always assigned and passed around as a reference to an existing instance, rather than as a copy.</p>
<p>NOTE</p>
<p>The description above refers to the “copying” of strings, arrays, and dictionaries. The behavior you see in your code will always be as if a copy took place. However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.</p>
</element>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1） | 跳跳魔王的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/09/21/熙健-掌上心电获千万元A轮融资/"  title="熙健-掌上心电获千万元A轮融资">
 <strong>下一篇：</strong><br/> 
 <span>熙健-掌上心电获千万元A轮融资
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/10/28/Swift-编程语言（Swift-3-0-1）/" data-title="Swift 编程语言（Swift 3.0.1）" data-url="http://yoursite.com/2016/10/28/Swift-编程语言（Swift-3-0-1）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常量和变量"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注释"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">4.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数"><span class="toc-number">5.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数边界"><span class="toc-number">6.</span> <span class="toc-text">整数边界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Int"><span class="toc-number">7.</span> <span class="toc-text">Int</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UInt"><span class="toc-number">8.</span> <span class="toc-text">UInt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浮点数"><span class="toc-number">9.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型安全与推断"><span class="toc-number">10.</span> <span class="toc-text">类型安全与推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值字面量"><span class="toc-number">11.</span> <span class="toc-text">数值字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值类型转换"><span class="toc-number">12.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整形转换"><span class="toc-number">13.</span> <span class="toc-text">整形转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数和浮点数转换"><span class="toc-number">14.</span> <span class="toc-text">整数和浮点数转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">15.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布尔值"><span class="toc-number">16.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元组"><span class="toc-number">17.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选类型"><span class="toc-number">18.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nil"><span class="toc-number">19.</span> <span class="toc-text">nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if语句和强制拆包"><span class="toc-number">20.</span> <span class="toc-text">if语句和强制拆包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选绑定"><span class="toc-number">21.</span> <span class="toc-text">可选绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式拆包可选项"><span class="toc-number">22.</span> <span class="toc-text">隐式拆包可选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">23.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础运算符"><span class="toc-number">24.</span> <span class="toc-text">基础运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#术语"><span class="toc-number">25.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#赋值运算符"><span class="toc-number">26.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算术运算符"><span class="toc-number">27.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#余数运算符"><span class="toc-number">28.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元减法运算符"><span class="toc-number">29.</span> <span class="toc-text">一元减法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一元加法运算符"><span class="toc-number">30.</span> <span class="toc-text">一元加法运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合赋值运算符"><span class="toc-number">31.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较运算符"><span class="toc-number">32.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三元条件运算符"><span class="toc-number">33.</span> <span class="toc-text">三元条件运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nil-联合运算符"><span class="toc-number">34.</span> <span class="toc-text">Nil-联合运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#范围运算符"><span class="toc-number">35.</span> <span class="toc-text">范围运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭合区间运算符"><span class="toc-number">36.</span> <span class="toc-text">闭合区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#半开区间运算符"><span class="toc-number">37.</span> <span class="toc-text">半开区间运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">38.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑非运算符"><span class="toc-number">39.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑与运算符"><span class="toc-number">40.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逻辑或运算符"><span class="toc-number">41.</span> <span class="toc-text">逻辑或运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并逻辑运算符"><span class="toc-number">42.</span> <span class="toc-text">合并逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示括号"><span class="toc-number">43.</span> <span class="toc-text">显示括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符"><span class="toc-number">44.</span> <span class="toc-text">字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量"><span class="toc-number">45.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化空字符串"><span class="toc-number">46.</span> <span class="toc-text">初始化空字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串易变性"><span class="toc-number">47.</span> <span class="toc-text">字符串易变性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串是值类型"><span class="toc-number">48.</span> <span class="toc-text">字符串是值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用字符"><span class="toc-number">49.</span> <span class="toc-text">使用字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接字符串和字符"><span class="toc-number">50.</span> <span class="toc-text">连接字符串和字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串插入"><span class="toc-number">51.</span> <span class="toc-text">字符串插入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode"><span class="toc-number">52.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-标量"><span class="toc-number">53.</span> <span class="toc-text">Unicode 标量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串字面量里的特殊字符"><span class="toc-number">54.</span> <span class="toc-text">字符串字面量里的特殊字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩展字形集"><span class="toc-number">55.</span> <span class="toc-text">扩展字形集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算字符"><span class="toc-number">56.</span> <span class="toc-text">计算字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问和修改字符串"><span class="toc-number">57.</span> <span class="toc-text">访问和修改字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串索引"><span class="toc-number">58.</span> <span class="toc-text">字符串索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入和移除"><span class="toc-number">59.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较字符串"><span class="toc-number">60.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串和字符等式"><span class="toc-number">61.</span> <span class="toc-text">字符串和字符等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀和后缀等式"><span class="toc-number">62.</span> <span class="toc-text">前缀和后缀等式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unicode-字符串表示"><span class="toc-number">63.</span> <span class="toc-text">Unicode 字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UTF-8-形式"><span class="toc-number">64.</span> <span class="toc-text">UTF-8 形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尽早退出"><span class="toc-number">65.</span> <span class="toc-text">尽早退出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判断-API-可用性"><span class="toc-number">66.</span> <span class="toc-text">判断 API 可用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">67.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义和调用函数"><span class="toc-number">68.</span> <span class="toc-text">定义和调用函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数和返回值"><span class="toc-number">69.</span> <span class="toc-text">函数参数和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有参数的函数"><span class="toc-number">70.</span> <span class="toc-text">没有参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个参数的函数"><span class="toc-number">71.</span> <span class="toc-text">多个参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#没有返回值的函数"><span class="toc-number">72.</span> <span class="toc-text">没有返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带有多返回值的函数"><span class="toc-number">73.</span> <span class="toc-text">带有多返回值的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可选元组返回类型"><span class="toc-number">74.</span> <span class="toc-text">可选元组返回类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数参数标签和参数名"><span class="toc-number">75.</span> <span class="toc-text">函数参数标签和参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指定参数标签"><span class="toc-number">76.</span> <span class="toc-text">指定参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#省略参数标签"><span class="toc-number">77.</span> <span class="toc-text">省略参数标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认参数值"><span class="toc-number">78.</span> <span class="toc-text">默认参数值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可变参数"><span class="toc-number">79.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#输入输出参数"><span class="toc-number">80.</span> <span class="toc-text">输入输出参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型"><span class="toc-number">81.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用函数类型"><span class="toc-number">82.</span> <span class="toc-text">使用函数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型作为参数类型"><span class="toc-number">83.</span> <span class="toc-text">函数类型作为参数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数类型和返回值"><span class="toc-number">84.</span> <span class="toc-text">函数类型和返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套函数"><span class="toc-number">85.</span> <span class="toc-text">嵌套函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">86.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式"><span class="toc-number">87.</span> <span class="toc-text">闭包表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序函数"><span class="toc-number">88.</span> <span class="toc-text">排序函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包表达式语法"><span class="toc-number">89.</span> <span class="toc-text">闭包表达式语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#根据上下文推断类型"><span class="toc-number">90.</span> <span class="toc-text">根据上下文推断类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从单一表达式闭包隐式返回"><span class="toc-number">91.</span> <span class="toc-text">从单一表达式闭包隐式返回</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#速记参数名"><span class="toc-number">92.</span> <span class="toc-text">速记参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运算符方法"><span class="toc-number">93.</span> <span class="toc-text">运算符方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾闭包"><span class="toc-number">94.</span> <span class="toc-text">尾闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#捕获值"><span class="toc-number">95.</span> <span class="toc-text">捕获值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包是引用类型"><span class="toc-number">96.</span> <span class="toc-text">闭包是引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#逃离闭包"><span class="toc-number">97.</span> <span class="toc-text">逃离闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自动闭包"><span class="toc-number">98.</span> <span class="toc-text">自动闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">99.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举语法"><span class="toc-number">100.</span> <span class="toc-text">枚举语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用Switch语句匹配枚举值"><span class="toc-number">101.</span> <span class="toc-text">用Switch语句匹配枚举值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联值"><span class="toc-number">102.</span> <span class="toc-text">关联值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Raw-Values"><span class="toc-number">103.</span> <span class="toc-text">Raw Values</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#隐式赋-Raw-值"><span class="toc-number">104.</span> <span class="toc-text">隐式赋 Raw 值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用-Raw-值初始化"><span class="toc-number">105.</span> <span class="toc-text">用 Raw 值初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归枚举"><span class="toc-number">106.</span> <span class="toc-text">递归枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和结构体"><span class="toc-number">107.</span> <span class="toc-text">类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#比较类和结构体"><span class="toc-number">108.</span> <span class="toc-text">比较类和结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义语法"><span class="toc-number">109.</span> <span class="toc-text">定义语法</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mhealth365.cn/" target="_blank" title="一款温暖的心电监测设备">熙健-掌上心电</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m an iOS engineer <br/>
			Hala Madrid</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2779746325" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="跳跳魔王">跳跳魔王</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ecgbao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
