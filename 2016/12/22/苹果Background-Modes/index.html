
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>苹果Background Modes | 跳跳魔王的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="跳跳魔王">
    

    
    <meta name="description" content="开发人员和用户经常很困惑,iOS的多任务系统到底允许做什么事。苹果限制后台操作的使用位置,为了提升用户体验和延长电池的使用。你的应用只允许在某些场景下运行在后台。例如, 播放音频, 获取位置更新, 或者从服务器获取最新的内容。如果你的工作不是属于上述分类。超出范围使用后台模式,应用审核时会被苹果拒绝。

开始进入工程前, 这里有个在iOS中可用的后台模式的预览。 在 Xcode 8里, 你可以在应">
<meta property="og:type" content="article">
<meta property="og:title" content="苹果Background Modes">
<meta property="og:url" content="http://yoursite.com/2016/12/22/苹果Background-Modes/index.html">
<meta property="og:site_name" content="跳跳魔王的博客">
<meta property="og:description" content="开发人员和用户经常很困惑,iOS的多任务系统到底允许做什么事。苹果限制后台操作的使用位置,为了提升用户体验和延长电池的使用。你的应用只允许在某些场景下运行在后台。例如, 播放音频, 获取位置更新, 或者从服务器获取最新的内容。如果你的工作不是属于上述分类。超出范围使用后台模式,应用审核时会被苹果拒绝。

开始进入工程前, 这里有个在iOS中可用的后台模式的预览。 在 Xcode 8里, 你可以在应">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BackgroundModes-feature.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/EnableBackgroundCapability.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SetDevTeam.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-StarterProjectTabs.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AudioScreen.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableAudioInBG.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableLocationInBG.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AddLocationPrivacyMessage.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AllowLocationAccess.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-LocationUpdatesOnMap.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DebugLocationSimulation.png">
<meta property="og:image" content="http://cdn3.raywenderlich.com/wp-content/uploads/2013/04/Whatever_cheers.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-RunningWhatever.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-FetchNotUpdated.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableBackgroundFetch.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SimulateBGFetch.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ContinueDebugger.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ManageSchemes.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DuplicateScheme.png">
<meta property="og:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ConfigureNewScheme.png">
<meta property="og:updated_time" content="2017-01-12T09:29:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苹果Background Modes">
<meta name="twitter:description" content="开发人员和用户经常很困惑,iOS的多任务系统到底允许做什么事。苹果限制后台操作的使用位置,为了提升用户体验和延长电池的使用。你的应用只允许在某些场景下运行在后台。例如, 播放音频, 获取位置更新, 或者从服务器获取最新的内容。如果你的工作不是属于上述分类。超出范围使用后台模式,应用审核时会被苹果拒绝。

开始进入工程前, 这里有个在iOS中可用的后台模式的预览。 在 Xcode 8里, 你可以在应">
<meta name="twitter:image" content="https://koenig-media.raywenderlich.com/uploads/2016/09/BackgroundModes-feature.png">

    
    <link rel="alternative" href="/atom.xml" title="跳跳魔王的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="跳跳魔王的博客">跳跳魔王的博客</a></h1>
				<h2 class="blog-motto">每天进步一点点</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/22/苹果Background-Modes/" title="苹果Background Modes" itemprop="url">苹果Background Modes</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="跳跳魔王" target="_blank" itemprop="author">跳跳魔王</a>
		
  <p class="article-time">
    <time datetime="2016-12-22T08:12:31.000Z" itemprop="datePublished"> 发表于 2016-12-22</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开始"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#播放音频"><span class="toc-number">2.</span> <span class="toc-text">播放音频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取位置更新"><span class="toc-number">3.</span> <span class="toc-text">获取位置更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Executing-a-Finite-Length-Task-in-the-Background"><span class="toc-number">4.</span> <span class="toc-text">Executing a Finite-Length Task in the Background.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Background-Fetch"><span class="toc-number">5.</span> <span class="toc-text">Background Fetch</span></a></li></ol>
		
		</div>
		
		<p>开发人员和用户经常很困惑,iOS的多任务系统到底允许做什么事。苹果限制后台操作的使用位置,为了提升用户体验和延长电池的使用。你的应用只允许在某些场景下运行在后台。例如, 播放音频, 获取位置更新, 或者从服务器获取最新的内容。<br>如果你的工作不是属于上述分类。超出范围使用后台模式,应用审核时会被苹果拒绝。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BackgroundModes-feature.png" height="250"><br></div></p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>进入工程前, 这里有个在iOS中可用的后台模式的预览。 在 Xcode 8里, 你可以在应用目标的 Capabilities 标签下看到这个列表。它看起来是这样的:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/EnableBackgroundCapability.png" width="480" height="262"><br></div><br>要获取后台模式能力列表,你 (1) 从 Project Navigator 选择工程, (2) 选择应用 target, (3) 选择 Capabilities 标签, 然后 (4) 打开 Background Modes 开关。<br>在这个教程里,你会研究四种后台处理方式。</p>
<ul><br><li><em>播放音频</em>: 应用可以在后台继续播放或者录制音频。</li><br><li><em>获取位置更新</em>: 设备位置变化时,应用可以继续获取反馈。</li><br><li><em>执行有限时长的任务</em>: 应用运行代码一段时间。</li><br><li><em>后台获取</em>: 获取iOS预定的最新内容。</li><br></ul>

<p>下载工程开始。开始运行工程前,设置一下开发团队, 如下所示:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SetDevTeam.png" width="650" height="349"><br></div><br>运行实例程序感受一下。这里有4个标签; 分别对应一种模式:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-StarterProjectTabs.png" width="372" height="110"><br></div><br><em>备注:</em> 为了效果完整, 你应该使用真实的设备。以我的经验, 如果忘记配置, 应用可能在模拟器后台运行良好。不过, 当你换到真实设备时, 它完全不工作。</p>
<h1 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h1><p>首先, 后台音频。<br>在iOS上有几种播放音频的方法, 大多数方法要求回调来提供更多的播放数据。<br>如果你想用流数据播放音频, 你可以启动网络连接, 连接回调会提供连续的音频数据。<br>当你激活音频后台模式后, 即使应用不是当前激活的应用,iOS 也会继续这些回调。事实上,音频后面模式是自动的。你只需要激活它然后提供合适的处理。<br>在这个部分,你会审查应用里的音频播放器, 验证后台模式不起作用, 打开音频后台模式能力, 然后显示它起作用了。<br>打开 AudioViewController.swift 看看。<br>这个应用使用 AVQueuePlayer 来排队歌曲然后依次播放它们。视图控制器通过观察播放器的 currentItem 值来提供更新。<br>启动器工程包含了来自 incompetech.com 的音频文件, 一个最受欢迎的免版税的音乐网站。<br>当应用处于激活状态时, 音乐标题会显示,如果在后台,控制台会打印这个标题。在后台的时候,标题依然会更新。但是这里只是展示,当你的应用在后台时,它依然可以收到回调。<br>编译运行,你会看到这个:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AudioScreen.png" width="273" height="500"><br></div><br>现在点击播放,音乐就开始了。好棒!<br>测试一下后台。当在真实设备运行的时候,点击home键,音乐就会停止。为什么? 好吧, 这里还缺少关键部分!<br>返回 Xcode, 按照下面这样做:</p>
<p><ol></ol></p>
<p><li>在 <em>Project Navigator</em>下点击工程;</li></p>
<p><li>点击 <em>TheBackgrounder</em> 目标;</li></p>
<p><li>点击 <em>Capabilities</em> 标签;</li></p>
<p><li>到 <em>Background Modes</em> 打开开关;</li></p>
<p><li>选择 <em>Audio, AirPlay and Picture in Picture</em>.</li><br></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableAudioInBG.png" width="650" height="354"><br></div><br>再次编译运行。播放音乐并按home键, 这时,即使应用在后台,你也可能听见音乐了。<br>你也可以在Xcode控制台看见时间在更新, 证明代码在后台也是工作的。<br>喔, 如果你已经有了一个音频播放器, 后台播放就很容易了!</p>
<h1 id="获取位置更新"><a href="#获取位置更新" class="headerlink" title="获取位置更新"></a>获取位置更新</h1><p>在位置后台模式, 应用依然可以接收到用户位置更新的代理信息。在后台时,你可以控制位置更新的精度,甚至可以修改它。<br>第二个标签是位置更新, 所以打开 LocationViewController.swift 看一下。 和后台音频例子很像, 如果你的应用有了位置功能, 位置后台模式很容易建立和运行!<br>在这个控制器里,你可以找到 CLLocationManager. 它用来接收你创建的位置信息,并且配置 CLLocationManager 实例。在这种情况下,当屏幕 UISwitch 开关激活时,应用会监视位置。当位置更新时, 应用会在地图上绘制大头针。如果应用是在后台, 你会在Xcode的控制台看见位置更新的日志。<br>CLLocationManager 实例调用 requestAlwaysAuthorization() 这行需要注意。这是 iOS 8 开始后的要求, 然后会弹出一个对话框,请求后台接收位置的许可。<br>既然你熟悉了后台模式, 你就不会犯以前同样的错误了! 确认对话框,让 iOS 知道你的应用需要在后台接收位置更新。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableLocationInBG.png" width="650" height="354"><br></div><br>除了确认对话框, iOS 8 及以上会要求你在Info.plist中设置一个键来向用户说明为什么需要位置更新。如果你没有这个, 位置请求就会失败。</p>
<p><ul></ul></p>
<p><li> 在 Xcode中选择project.</li></p>
<p><li> 在 <em>TheBackgrounder</em> 目标下选择<em>Info</em>.</li></p>
<p><li> 选择已经存在的一行.</li></p>
<p><li> 点击 + 按钮添加一个新的键.</li></p>
<p><li> 添加键 <em>Privacy &#8211; Location Always Usage Description</em>.</li></p>
<p><li> 写一个简短说明,解释为什么需要在后台请求位置.</li><br></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AddLocationPrivacyMessage.png" width="650" height="354"><br></div><br>现在编译运行! 切换到第二个标签然后打开开关。<br>在你第一次这么做时, 你会看到你写的位置隐私原因。点击允许,然后走出办公室。你就可以看见位置更新了, 模拟器也可以。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AllowLocationAccess.png" width="281" height="500"><br></div><br>过一会, 你会看到类似这样的:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-LocationUpdatesOnMap.png" width="272" height="500"><br></div><br>如果你把应用切到后台, 你可以在控制台看见应用在更新位置的日志。再次打开应用, 你能看到所有在后台更新的位置的大头针。<br>如果你用模拟器, 你可以可以用它模拟移动! 选择 Debug \ Location 菜单:</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DebugLocationSimulation.png" width="492" height="366"><br></div><br>试着设置位置为 Freeway Drive 然后点击home键。你会看到控制台日志,打印出你在加州高速公路的移动过程:</p>
<p><div class="wp_codebox"><table><tr id="p1431281"><td class="code" id="p143128code1"><pre class="console" style="font-family:monospace;">App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time<br>App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time<br>App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time</pre></td></tr></table></div><br>没问题,对吧?! 来到第三个标签,第三个后台模式!<br>下一个模式官方叫做 </p>
<h1 id="Executing-a-Finite-Length-Task-in-the-Background"><a href="#Executing-a-Finite-Length-Task-in-the-Background" class="headerlink" title="Executing a Finite-Length Task in the Background."></a>Executing a Finite-Length Task in the Background.</h1><p>从技术上说, 这个根本不是后台模式, 你不用在Capabilities里使用这个模式。相反, 它只是一个 API,让你在后台执行一段时间的代码。<br>在过去, 这个模式用来完成上传和下载,提供大概10分钟的时间（不能保证）来完成这些任务。不过,如果连接很慢,这个过程没有完成呢? 你的程序会处于奇怪的状态, 而你必须提供大量的错误处理代码来保证任务稳定进行。因为这个原因, Apple 引入了 NSURLSession.<br>尽管它不是这个教程的主题, NSURLSession 面对后台是稳健的, 高效的,即使设备重启。如果你需要处理大量的下载, 可以查看 NSURLSession 教程。<br>后台模式一个很有效的用途是完成一些长任务, 例如渲染和写视频到相机胶卷中。</p>
<p><div style="text-align:center"><br><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/04/Whatever_cheers.png" width="480" height="177"><br></div><br>不过这只是一个例子。因为你可以运行任意代码, 你可以用这个 API 做很多事: 执行长时间的计算, 对图片使用滤镜, 渲染复杂的 3D 网!<br>退到后台,你能获得多少时间取决于 iOS. 获取的时间是没有保证的, 不过你可以一直在 UIApplication里 判断。 这个会告诉你还有多少时间可用。<br>一般来说, 基于观察的共识是,你可以获得三分钟。再说一次, 这个不保证,而且 API 也没有说大约多少数 – 所以不要信赖这个数字。你也可能获得5分钟或者5秒钟, 所以你的应用需要…<br>这里有个 CS 学生都很熟悉的基本任务: 计算斐波拉契序列的个数。这里要在后台计算这个数字!<br>打开 WhateverViewController.swift 看一下已经有了什么。按照目前情况, 这个视图会按照序列计算斐波拉契数字并显示结果。如果你要在真实设备挂起这个应用, 计算会停止,应用激活后再次计算。你的任务是创建一个后台任务,这样计算可以一直保持运行,直到 iOS 说, ‘不用了!’<br>首先你要给 WhateverViewController 添加下面的属性。</p>
<p><div class="wp_codebox"><table><tr id="p1431282"><td class="code" id="p143128code2"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">var</span> backgroundTask<span style="color: #002200;">:</span> UIBackgroundTaskIdentifier <span style="color: #002200;">=</span> UIBackgroundTaskInvalid</pre></td></tr></table></div><br>这个属性用来标示任务在后台运行的请求。<br>然后给 WhateverViewController 添加下面的方法。</p>
<p><div class="wp_codebox"><table><tr id="p1431283"><td class="code" id="p143128code3"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> registerBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  backgroundTask <span style="color: #002200;">=</span> <span style="color: #400080;">UIApplication</span>.shared.beginBackgroundTask <span style="color: #002200;">&#123;</span> <span style="color: #002200;">&#91;</span>weak <span style="color: #a61390;">self</span><span style="color: #002200;">&#93;</span> <span style="color: #a61390;">in</span><br>    <span style="color: #a61390;">self</span>?.endBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br>  <span style="color: #a61390;">assert</span><span style="color: #002200;">&#40;</span>backgroundTask <span style="color: #002200;">!=</span> UIBackgroundTaskInvalid<span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span><br>&nbsp;<br><span style="color: #a61390;">func</span> endBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">print</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Background task ended.&quot;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #400080;">UIApplication</span>.shared.endBackgroundTask<span style="color: #002200;">&#40;</span>backgroundTask<span style="color: #002200;">&#41;</span><br>  backgroundTask <span style="color: #002200;">=</span> UIBackgroundTaskInvalid<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br>registerBackgroundTask() 告诉 iOS 你需要更多的时间在后台做事情。调用之后, 如果你的应用还在后台, 它会一直获取 CPU 时间,直到你调用 endBackgroundTask().<br>如果在后台一段时间后,你不调用 endBackgroundTask(), 当你调用beginBackgroundTask(expirationHandler:)时,iOS 会调用定义的关闭方法,给你一个机会来停止代码的执行。所以最好调用 endBackgroundTask() 来告诉 OS 你要做什么。如果你不这样做,然后继续执行,你的应用会被终止!<br>现在是重要的部分, 你需要更新 didTapPlayPause(_:) 来注册后台任务和结束任务。这里有两个注释。<br>在 “register background task” 注释下面调用registerBackgroundTask() .</p>
<p><table><tr id="p1431284"><td class="code" id="p143128code4"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// register background task</span><br>registerBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span></pre></td></tr></table><br>registerBackgroundTask() 当计算开始时调用,因此你可以在后台继续计算数字。<br>在 “end background task” 注释下面添加下面的block.</p>
<p><table><tr id="p1431285"><td class="code" id="p143128code5"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// end background task</span><br><span style="color: #a61390;">if</span> backgroundTask <span style="color: #002200;">!=</span> UIBackgroundTaskInvalid <span style="color: #002200;">&#123;</span><br>  endBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>endBackgroundTask() 调用,计算停止,向iOS表明你不需要额外的 CPU 时间了。<br>每次调用beginBackgroundTask(expirationHandler:) 时记得调用endBackgroundTask()非常重要。 如果你调用beginBackgroundTaskWithExpirationHandler(_:) 两次,但是只调用 endBackgroundTask() 一次, 只有你再次调用endBackgroundTask(), 你才会停止获取 CPU 时间。<br>现在更新 calculateNextNumber() 方法, 让它基于程序的不同状态有不同的表现。<br>用下面的代码替换最后一行, resultsLabel.text = resultsMessage:</p>
<p><div class="wp_codebox"><table><tr id="p1431286"><td class="code" id="p143128code6"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">switch</span> <span style="color: #400080;">UIApplication</span>.shared.applicationState <span style="color: #002200;">&#123;</span><br><span style="color: #a61390;">case</span> .active<span style="color: #002200;">:</span><br>  resultsLabel.text <span style="color: #002200;">=</span> resultsMessage<br><span style="color: #a61390;">case</span> .background<span style="color: #002200;">:</span><br>  <span style="color: #a61390;">print</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;App is backgrounded. Next number = <span style="color: #2400d9;">(</span>resultsMessage)&quot;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #a61390;">print</span><span style="color: #002200;">&#40;</span><span style="color: #bf1d1a;">&quot;Background time remaining = <span style="color: #2400d9;">(</span>UIApplication.shared.backgroundTimeRemaining) seconds&quot;</span><span style="color: #002200;">&#41;</span><br><span style="color: #a61390;">case</span> .inactive<span style="color: #002200;">:</span><br>  break<br><span style="color: #002200;">&#125;</span></pre></td></tr></table></div><br>只有程序激活标签才会更新。程序在后台时,控制台会打印一条消息来代替。表示新结果是什么,还有多少后台时间。<br>编译运行, 然后切换到第三个标签。</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-RunningWhatever.png" width="281" height="500"><br></div><br>点击 Play 你会看到应用在计算数值。现在点击home键,然后看 Xcode 控制台的输出。你会看到时间在走,数值也在更新。<br>在大多数情况下, 这个时间以180开始 (180 seconds = 3 minutes) 然后走到 5 秒。到5秒时, 如果你等着过期, 过期 block 会调用,然后应用停止输出。这时如果你回到应用, 定时器会重新开始,整个过程会继续。<br>这个代码里只有一个 bug. 设想你的应用在后台,然后等到分配的时间耗尽。在这种情况下, 你的应用会调用 endBackgroundTask(), 结束后台时间的需求。<br>如果这是你回到应用, 定时器会继续启动。如果你再次离开应用, 你就不会再有后台时间。为什么? 因为在过期和回到后台之间,没地方调用beginBackgroundTaskWithExpirationHandler(_:).<br>你怎么解决这个问题? 有很多方法,其中之一就是使用状态改变的通知。<br>你可以在苹果的 App States for Apps 文档里看到所有响应状态变化的细节。<br>是时候修复 bug 了。首先, 添加一个新方法 reinstateBackgroundTask().</p>
<p><table><tr id="p1431287"><td class="code" id="p143128code7"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">func</span> reinstateBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">if</span> updateTimer <span style="color: #002200;">!=</span> <span style="color: #a61390;">nil</span> <span style="color: #002200;">&amp;&amp;</span> <span style="color: #002200;">&#40;</span>backgroundTask <span style="color: #002200;">==</span> UIBackgroundTaskInvalid<span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>    registerBackgroundTask<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>如果存在一个定时器在运行并且后台任务是无效的,你只需要去恢复一下。你只要简单的调用 registerBackgroundTask().<br>现在重写 viewDidLoad(), 然后添加下面的代码来订阅 UIApplicationDidBecomeActiveNotification:</p>
<p><table><tr id="p1431288"><td class="code" id="p143128code8"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">override</span> <span style="color: #a61390;">func</span> viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">super</span>.viewDidLoad<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>  NotificationCenter.<span style="color: #a61390;">default</span>.addObserver<span style="color: #002200;">&#40;</span><span style="color: #a61390;">self</span>, selector<span style="color: #002200;">:</span> <span style="color: #6e371a;">#selector(reinstateBackgroundTask), name: NSNotification.Name.UIApplicationDidBecomeActive, object: nil)</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>当程序激活的时候, 就会调用你的新方法reinstateBackgroundTask().<br>一旦你订阅通知, 你应该考虑在哪里取消订阅。使用 deinit 来做这件事。添加如下代码:</p>
<p><table><tr id="p1431289"><td class="code" id="p143128code9"><pre class="swift" style="font-family:monospace;"><span style="color: #a61390;">deinit</span> <span style="color: #002200;">&#123;</span><br>  NotificationCenter.<span style="color: #a61390;">default</span>.removeObserver<span style="color: #002200;">&#40;</span><span style="color: #a61390;">self</span><span style="color: #002200;">&#41;</span><br><span style="color: #002200;">&#125;</span></pre></td></tr></table><br>现在你有了这个, 你可以做想做的任何事了, 至少只要iOS说它是ok的就行。<br>本教程最后一个后台模式: Background Fetching.</p>
<h1 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h1><p>Background fetch 是 iOS 7 引入的模式, 它可以让你的应用总显示最新的信息, 同时减小对电池的影响。设想一下, 例如, 你正在实现一个新闻提要。后台获取之前, you might do this by getting new data in viewWillAppear(_:).<br>The problem with this solution is that your user is looking at the old data for at least several seconds until the new data comes in. Wouldn’t it be better if right when they opened your app the new data was magically there? This is what background fetch gives you.<br>When enabled, the system uses usage patterns to determine when to best fire off a background fetch. For example, if your user opens the app at 9 AM each morning, it is likely that a background fetch will be scheduled sometime before that time. The system decides the best time to issue a background fetch and for this reason you should not use it to do critical updates.<br>In order to implement background fetch there are three things you must do:</p>
<p><ul></ul></p>
<p><li>Check the box <em>Background fetch</em> in the <em>Background Modes</em> of your app’s <em>Capabilities</em>.</li></p>
<p><li>Use <code>setMinimumBackgroundFetchInterval(_:)</code> to set a time interval appropriate for your app.</li></p>
<p><li>Implement <code>application(<em>:performFetchWithCompletionHandler:)</em></code> in your app delegate to handle the background fetch.</li><br><br>As the name implies, background fetch normally involves fetching information from an external source like a network service. For the purposes of this background modes tutorial, you won’t use the network but just fetch the current time. This simplification will let you understand everything required to perform a background fetch and test it without worrying about an external service.<br>In contrast to finite-length tasks, you only have seconds to operate when doing a background fetch – the consensus figure is a maximum of 30 seconds, but shorter is better. If you need to download large resources as part of the fetch, this is where you need to use NSURLSession‘s background transfer service.<br>Time to get started. First, open FetchViewController.swift and take a look at what this does, there’s not much to it.<br>The fetch(:) method is a simplified replacement of what you might actually do to fetch some data from an external source (such as a JSON or XML RESTful service). Since it might take several seconds to fetch and parse the data, you pass a completion handler that gets called when the process is done. You will see why this is important a little later.<br>updateUI() formats the time and shows it. The guard statement around updateLabel is to ensure that the view has actually been loaded. time is an optional type so if it is not set, it shows the message “Not updated yet”.<br>When the view is first loaded (in viewDidLoad()) you don’t fetch, but go straight to updateUI() which means the message “Not yet updated” will appear first. Finally, when the Update button is tapped it performs a fetch and as a completion updates the UI.<br>The view controller is working. There’s nothing you need to do to it.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-FetchNotUpdated.png" width="281" height="500"><br></div><br>However, background fetching is not enabled.<br>The first step to enabling background fetching is to check Background fetch in the Capabilities tab of your app. By now this should be old hat. Go ahead and do this.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableBackgroundFetch.png" width="650" height="363"><br></div><br>Next, open AppDelegate.swift add the following to application(_:didFinishLaunchingWithOptions:):</p>
<p><div class="wp_codebox"><table><tr id="p14312810"><td class="code" id="p143128code10"><pre class="swift" style="font-family:monospace;"><span style="color: #400080;">UIApplication</span>.shared.setMinimumBackgroundFetchInterval<span style="color: #002200;">&#40;</span>UIApplicationBackgroundFetchIntervalMinimum<span style="color: #002200;">&#41;</span></pre></td></tr></table></div><br>This requests background fetches by setting the minimum background fetch interval. The default interval is UIApplicationBackgroundFetchIntervalNever, which you might want to switch back to, if, for example, your user logs out and no longer needs updates. You can also set a specific interval in seconds. The system will wait at least that many seconds before issuing a background fetch.<br>Be careful not to set the value too small because it may chew through battery unnecessarily as well as hammer your server. In the end the exact timing of the fetch is up to the system but will wait at least this interval before performing it. Generally, UIApplicationBackgroundFetchIntervalMinimum is a good default value to use.<br>Finally, to enable background fetch you must implement application(_:performFetchWithCompletionHandler:). Add that now to AppDelegate:</p>
<p><div class="wp_codebox"><table><tr id="p14312811"><td class="code" id="p143128code11"><pre class="swift" style="font-family:monospace;"><span style="color: #11740a; font-style: italic;">// Support for background fetch</span><br><span style="color: #a61390;">func</span> application<span style="color: #002200;">&#40;</span><em> application<span style="color: #002200;">:</span> <span style="color: #400080;">UIApplication</span>, performFetchWithCompletionHandler completionHandler<span style="color: #002200;">:</span> @escaping <span style="color: #002200;">&#40;</span>UIBackgroundFetchResult<span style="color: #002200;">&#41;</span> <span style="color: #002200;">-</span>&gt; <span style="color: #a61390;">Void</span><span style="color: #002200;">&#41;</span> <span style="color: #002200;">&#123;</span><br>  <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> tabBarController <span style="color: #002200;">=</span> window?.rootViewController <span style="color: #a61390;">as?</span> <span style="color: #400080;">UITabBarController</span>,<br>         <span style="color: #a61390;">let</span> viewControllers <span style="color: #002200;">=</span> tabBarController.viewControllers<br>  <span style="color: #002200;">&#123;</span><br>    <span style="color: #a61390;">for</span> viewController <span style="color: #a61390;">in</span> viewControllers <span style="color: #002200;">&#123;</span><br>      <span style="color: #a61390;">if</span> <span style="color: #a61390;">let</span> fetchViewController <span style="color: #002200;">=</span> viewController <span style="color: #a61390;">as?</span> FetchViewController <span style="color: #002200;">&#123;</span><br>        fetchViewController.fetch <span style="color: #002200;">&#123;</span><br>          fetchViewController.updateUI<span style="color: #002200;">&#40;</span><span style="color: #002200;">&#41;</span><br>          completionHandler<span style="color: #002200;">&#40;</span>.newData<span style="color: #002200;">&#41;</span><br>        <span style="color: #002200;">&#125;</span><br>      <span style="color: #002200;">&#125;</span><br>    <span style="color: #002200;">&#125;</span><br>  <span style="color: #002200;">&#125;</span><br><span style="color: #002200;">&#125;</span></em></pre></td></tr></table></div><br>First you need to get the FetchViewContoller. Next, optionally cast since the rootViewController is not necessarily a UITabBarController in every app, although it is in this app so it will never fail.<br>Next, you loop though all of the view controllers in the tab bar controller and find the one that successfully casts to FetchViewController. In this app you know it is the last view controller so you could hard-code it, but looping makes it a little more robust in case you decide to add or remove a tab later.<br>Finally you call fetch(:). When it completes, you update the UI and then call the completionHandler that was passed in as a parameter of the function. It is important that you call this completion handler at the end of the operation. You specify what happened during the fetch as the first parameter. Possible values are .newData, .noData, or .failed.<br>For simplicity, the tutorial always specifies .newData since getting the time will never fail and is always different than the last call. iOS can then use this value to better time the background fetches. The system knows at this point to take a snapshot of the app so it can present it in the card view of the app switcher. And that is all there is to it.<br><em>Update note:</em> Rather than passing the completion closure along, it can be tempting to save it away in a property variable and call that when your fetch completes. Don’t do this. If you get multiple calls to application(_:performFetchWithCompletionHandler:), the previous handler will get overwritten and never called. It is better to pass the handler through and call it as it will make this kind of programming error impossible.<br>Testing Background Fetch<br>One way to test background fetch is to sit around and wait for the system to decide to do it. That would require a lot of sitting. Fortunately, Xcode gives a way to simulate a background fetch. There are two scenarios that you need to test. One is when your app is in the background, and the other when your app is coming back from being suspended. The first way is the easiest and is just a menu selection.</p>
<p><ul></ul></p>
<p><li>Start the app on an actual device (not a simulator);</li></p>
<p><li>Go to the Fetch tab</li></p>
<p><li>Notice the message is &#8220;Not yet updated&#8221;</li></p>
<p><li>From the <em>Debug</em> menu in Xcode, select <em>Simulate Background Fetch</em>;<br></li></p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SimulateBGFetch.png" width="336" height="500"><br></div><br>The app will be sent to the background and Xcode’s debugger will trap. Instruct the debugger to continue</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ContinueDebugger.png" width="650" height="331"><br></div><br>Reopen the app<br>Notice that the time is updated!.<br>The other way you should test background fetch is to do it as a resume from suspension. There is a launch option that lets you launch your app directly into suspension. Since you might want to test this semi-often it is best to make a new Scheme with that option always set. Xcode makes this easy.<br>First select the Manage Schemes option.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ManageSchemes.png" width="401" height="168"><br></div><br>Next, select the only scheme in the list, and then click on the gear icon and select Duplicate.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DuplicateScheme.png" width="650" height="360"><br></div><br>Lastly, rename your scheme to something reasonable, like, “Background Fetch” and check the checkbox to Launch due to a background fetch event.</p>
<p><div style="text-align:center"><br><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ConfigureNewScheme.png" width="650" height="384"><br></div><br>Run your app with this scheme. You will notice that the app never actually opens but is launched into a suspended state. Now manually launch it and go to the Fetch tab. You should see that there is an updated time when you launched the app instead of “Not yet updated”.<br>Using background fetch effectively lets your users to seamlessly get the latest content.</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/12/22/苹果Background-Modes/" data-title="苹果Background Modes | 跳跳魔王的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/12/16/TestFlight-iOS-Beta测试/"  title="TestFlight:iOS Beta测试">
 <strong>下一篇：</strong><br/> 
 <span>TestFlight:iOS Beta测试
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/12/22/苹果Background-Modes/" data-title="苹果Background Modes" data-url="http://yoursite.com/2016/12/22/苹果Background-Modes/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开始"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#播放音频"><span class="toc-number">2.</span> <span class="toc-text">播放音频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取位置更新"><span class="toc-number">3.</span> <span class="toc-text">获取位置更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Executing-a-Finite-Length-Task-in-the-Background"><span class="toc-number">4.</span> <span class="toc-text">Executing a Finite-Length Task in the Background.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Background-Fetch"><span class="toc-number">5.</span> <span class="toc-text">Background Fetch</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mhealth365.cn/" target="_blank" title="一款温暖的心电监测设备">熙健-掌上心电</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m an iOS engineer <br/>
			Hala Madrid</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2779746325" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="跳跳魔王">跳跳魔王</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ecgbao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
